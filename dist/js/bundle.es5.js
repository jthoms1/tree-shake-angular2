(function () {
	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
	};

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var get = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = Object.getOwnPropertyDescriptor(object, property);

	  if (desc === undefined) {
	    var parent = Object.getPrototypeOf(object);

	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;

	    if (getter === undefined) {
	      return undefined;
	    }

	    return getter.call(receiver);
	  }
	};

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

	var toArray = function (arr) {
	  return Array.isArray(arr) ? arr : Array.from(arr);
	};

	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalScope;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope = self;
	    } else {
	        globalScope = global;
	    }
	} else {
	    globalScope = window;
	}
	function scheduleMicroTask(fn) {
	    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	}
	var IS_DART = false;
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var global$1 = globalScope;
	/**
	 * Runtime representation a type that a Component or other object is instances of.
	 *
	 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	 * the `MyCustomComponent` constructor function.
	 *
	 * @stable
	 */
	var Type = Function;
	function getTypeNameForDebugging(type) {
	    if (type['name']) {
	        return type['name'];
	    }
	    return typeof type === 'undefined' ? 'undefined' : _typeof(type);
	}
	var Math$1 = global$1.Math;
	var Date$1 = global$1.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	global$1.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent(obj) {
	    return obj !== undefined && obj !== null;
	}
	function isBlank(obj) {
	    return obj === undefined || obj === null;
	}
	function isString(obj) {
	    return typeof obj === 'string';
	}
	function isFunction(obj) {
	    return typeof obj === 'function';
	}
	function isType(obj) {
	    return isFunction(obj);
	}
	function isPromise(obj) {
	    return obj instanceof global$1.Promise;
	}
	function isArray(obj) {
	    return Array.isArray(obj);
	}
	function noop() {}
	function stringify(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token === undefined || token === null) {
	        return '' + token;
	    }
	    if (token.name) {
	        return token.name;
	    }
	    if (token.overriddenName) {
	        return token.overriddenName;
	    }
	    var res = token.toString();
	    var newLineIndex = res.indexOf('\n');
	    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	}
	var StringWrapper = function () {
	    function StringWrapper() {
	        classCallCheck(this, StringWrapper);
	    }

	    createClass(StringWrapper, null, [{
	        key: 'fromCharCode',
	        value: function fromCharCode(code) {
	            return String.fromCharCode(code);
	        }
	    }, {
	        key: 'charCodeAt',
	        value: function charCodeAt(s, index) {
	            return s.charCodeAt(index);
	        }
	    }, {
	        key: 'split',
	        value: function split(s, regExp) {
	            return s.split(regExp);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(s, s2) {
	            return s === s2;
	        }
	    }, {
	        key: 'stripLeft',
	        value: function stripLeft(s, charVal) {
	            if (s && s.length) {
	                var pos = 0;
	                for (var i = 0; i < s.length; i++) {
	                    if (s[i] != charVal) break;
	                    pos++;
	                }
	                s = s.substring(pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'stripRight',
	        value: function stripRight(s, charVal) {
	            if (s && s.length) {
	                var pos = s.length;
	                for (var i = s.length - 1; i >= 0; i--) {
	                    if (s[i] != charVal) break;
	                    pos--;
	                }
	                s = s.substring(0, pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'replace',
	        value: function replace(s, from, _replace) {
	            return s.replace(from, _replace);
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(s, from, replace) {
	            return s.replace(from, replace);
	        }
	    }, {
	        key: 'slice',
	        value: function slice(s) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return s.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'replaceAllMapped',
	        value: function replaceAllMapped(s, from, cb) {
	            return s.replace(from, function () {
	                for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
	                    matches[_key] = arguments[_key];
	                }

	                // Remove offset & string from the result array
	                matches.splice(-2, 2);
	                // The callback receives match, p1, ..., pn
	                return cb(matches);
	            });
	        }
	    }, {
	        key: 'contains',
	        value: function contains(s, substr) {
	            return s.indexOf(substr) != -1;
	        }
	    }, {
	        key: 'compare',
	        value: function compare(a, b) {
	            if (a < b) {
	                return -1;
	            } else if (a > b) {
	                return 1;
	            } else {
	                return 0;
	            }
	        }
	    }]);
	    return StringWrapper;
	}();

	var StringJoiner = function () {
	    function StringJoiner() {
	        var parts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, StringJoiner);

	        this.parts = parts;
	    }

	    createClass(StringJoiner, [{
	        key: 'add',
	        value: function add(part) {
	            this.parts.push(part);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.parts.join('');
	        }
	    }]);
	    return StringJoiner;
	}();
	var NumberParseError = function (_Error) {
	    inherits(NumberParseError, _Error);

	    function NumberParseError(message) {
	        classCallCheck(this, NumberParseError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NumberParseError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(NumberParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return NumberParseError;
	}(Error);
	var NumberWrapper = function () {
	    function NumberWrapper() {
	        classCallCheck(this, NumberWrapper);
	    }

	    createClass(NumberWrapper, null, [{
	        key: 'toFixed',
	        value: function toFixed(n, fractionDigits) {
	            return n.toFixed(fractionDigits);
	        }
	    }, {
	        key: 'equal',
	        value: function equal(a, b) {
	            return a === b;
	        }
	    }, {
	        key: 'parseIntAutoRadix',
	        value: function parseIntAutoRadix(text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new NumberParseError('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        }
	    }, {
	        key: 'parseInt',
	        value: function (_parseInt) {
	            function parseInt(_x4, _x5) {
	                return _parseInt.apply(this, arguments);
	            }

	            parseInt.toString = function () {
	                return _parseInt.toString();
	            };

	            return parseInt;
	        }(function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        })
	        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.

	    }, {
	        key: 'parseFloat',
	        value: function (_parseFloat) {
	            function parseFloat(_x6) {
	                return _parseFloat.apply(this, arguments);
	            }

	            parseFloat.toString = function () {
	                return _parseFloat.toString();
	            };

	            return parseFloat;
	        }(function (text) {
	            return parseFloat(text);
	        })
	    }, {
	        key: 'isNumeric',
	        value: function isNumeric(value) {
	            return !isNaN(value - parseFloat(value));
	        }
	    }, {
	        key: 'isNaN',
	        value: function (_isNaN) {
	            function isNaN(_x7) {
	                return _isNaN.apply(this, arguments);
	            }

	            isNaN.toString = function () {
	                return _isNaN.toString();
	            };

	            return isNaN;
	        }(function (value) {
	            return isNaN(value);
	        })
	    }, {
	        key: 'isInteger',
	        value: function isInteger(value) {
	            return Number.isInteger(value);
	        }
	    }, {
	        key: 'NaN',
	        get: function get() {
	            return NaN;
	        }
	    }]);
	    return NumberWrapper;
	}();
	var RegExpWrapper = function () {
	    function RegExpWrapper() {
	        classCallCheck(this, RegExpWrapper);
	    }

	    createClass(RegExpWrapper, null, [{
	        key: 'create',
	        value: function create(regExpStr) {
	            var flags = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            flags = flags.replace(/g/g, '');
	            return new global$1.RegExp(regExpStr, flags + 'g');
	        }
	    }, {
	        key: 'firstMatch',
	        value: function firstMatch(regExp, input) {
	            // Reset multimatch regex state
	            regExp.lastIndex = 0;
	            return regExp.exec(input);
	        }
	    }, {
	        key: 'test',
	        value: function test(regExp, input) {
	            regExp.lastIndex = 0;
	            return regExp.test(input);
	        }
	    }, {
	        key: 'matcher',
	        value: function matcher(regExp, input) {
	            // Reset regex state for the case
	            // someone did not loop over all matches
	            // last time.
	            regExp.lastIndex = 0;
	            return { re: regExp, input: input };
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(regExp, input, replace) {
	            var c = regExp.exec(input);
	            var res = '';
	            regExp.lastIndex = 0;
	            var prev = 0;
	            while (c) {
	                res += input.substring(prev, c.index);
	                res += replace(c);
	                prev = c.index + c[0].length;
	                regExp.lastIndex = prev;
	                c = regExp.exec(input);
	            }
	            res += input.substring(prev);
	            return res;
	        }
	    }]);
	    return RegExpWrapper;
	}();
	var RegExpMatcherWrapper = function () {
	    function RegExpMatcherWrapper() {
	        classCallCheck(this, RegExpMatcherWrapper);
	    }

	    createClass(RegExpMatcherWrapper, null, [{
	        key: 'next',
	        value: function next(matcher) {
	            return matcher.re.exec(matcher.input);
	        }
	    }]);
	    return RegExpMatcherWrapper;
	}();
	var FunctionWrapper = function () {
	    function FunctionWrapper() {
	        classCallCheck(this, FunctionWrapper);
	    }

	    createClass(FunctionWrapper, null, [{
	        key: 'apply',
	        value: function apply(fn, posArgs) {
	            return fn.apply(null, posArgs);
	        }
	    }, {
	        key: 'bind',
	        value: function bind(fn, scope) {
	            return fn.bind(scope);
	        }
	    }]);
	    return FunctionWrapper;
	}();
	// JS has NaN !== NaN
	function looseIdentical(a, b) {
	    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	}
	// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
	// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
	function getMapKey(value) {
	    return value;
	}
	function normalizeBool(obj) {
	    return isBlank(obj) ? false : obj;
	}
	function isJsObject(o) {
	    return o !== null && (typeof o === 'function' || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object');
	}
	function print(obj) {
	    console.log(obj);
	}
	function warn(obj) {
	    console.warn(obj);
	}
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json = function () {
	    function Json() {
	        classCallCheck(this, Json);
	    }

	    createClass(Json, null, [{
	        key: 'parse',
	        value: function parse(s) {
	            return global$1.JSON.parse(s);
	        }
	    }, {
	        key: 'stringify',
	        value: function stringify(data) {
	            // Dart doesn't take 3 arguments
	            return global$1.JSON.stringify(data, null, 2);
	        }
	    }]);
	    return Json;
	}();
	var DateWrapper = function () {
	    function DateWrapper() {
	        classCallCheck(this, DateWrapper);
	    }

	    createClass(DateWrapper, null, [{
	        key: 'create',
	        value: function create(year) {
	            var month = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var day = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	            var hour = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	            var minutes = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
	            var seconds = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
	            var milliseconds = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];

	            return new Date$1(year, month - 1, day, hour, minutes, seconds, milliseconds);
	        }
	    }, {
	        key: 'fromISOString',
	        value: function fromISOString(str) {
	            return new Date$1(str);
	        }
	    }, {
	        key: 'fromMillis',
	        value: function fromMillis(ms) {
	            return new Date$1(ms);
	        }
	    }, {
	        key: 'toMillis',
	        value: function toMillis(date) {
	            return date.getTime();
	        }
	    }, {
	        key: 'now',
	        value: function now() {
	            return new Date$1();
	        }
	    }, {
	        key: 'toJson',
	        value: function toJson(date) {
	            return date.toJSON();
	        }
	    }]);
	    return DateWrapper;
	}();
	var _symbolIterator = null;
	function getSymbolIterator() {
	    if (isBlank(_symbolIterator)) {
	        if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
	            _symbolIterator = Symbol.iterator;
	        } else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator;
	}
	function isPrimitive(obj) {
	    return !isJsObject(obj);
	}

	/**
	 * Allows to refer to references which are not yet defined.
	 *
	 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	 * DI is declared,
	 * but not yet defined. It is also used when the `token` which we use when creating a query is not
	 * yet defined.
	 *
	 * ### Example
	 * {@example core/di/ts/forward_ref/forward_ref.ts region='forward_ref'}
	 * @experimental
	 */
	function forwardRef(forwardRefFn) {
	    forwardRefFn.__forward_ref__ = forwardRef;
	    forwardRefFn.toString = function () {
	        return stringify(this());
	    };
	    return forwardRefFn;
	}
	/**
	 * Lazily retrieves the reference value from a forwardRef.
	 *
	 * Acts as the identity function when given a non-forward-ref value.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	 *
	 * ```typescript
	 * var ref = forwardRef(() => "refValue");
	 * expect(resolveForwardRef(ref)).toEqual("refValue");
	 * expect(resolveForwardRef("regularValue")).toEqual("regularValue");
	 * ```
	 *
	 * See: {@link forwardRef}
	 * @experimental
	 */
	function resolveForwardRef(type) {
	    if (isFunction(type) && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef) {
	        return type();
	    } else {
	        return type;
	    }
	}

	/**
	 * A parameter metadata that specifies a dependency.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/6uHYJK?p=preview))
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   engine;
	 *   constructor(@Inject("MyEngine") engine:Engine) {
	 *     this.engine = engine;
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([
	 *  {provide: "MyEngine", useClass: Engine},
	 *  Car
	 * ]);
	 *
	 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * When `@Inject()` is not present, {@link Injector} will use the type annotation of the parameter.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   constructor(public engine: Engine) {} //same as constructor(@Inject(Engine) engine:Engine)
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([Engine, Car]);
	 * expect(injector.get(Car).engine instanceof Engine).toBe(true);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var InjectMetadata = function () {
	  function InjectMetadata(token) {
	    classCallCheck(this, InjectMetadata);

	    this.token = token;
	  }

	  createClass(InjectMetadata, [{
	    key: 'toString',
	    value: function toString() {
	      return '@Inject(' + stringify(this.token) + ')';
	    }
	  }]);
	  return InjectMetadata;
	}();
	/**
	 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
	 * the dependency is not found.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/AsryOm?p=preview))
	 *
	 * ```typescript
	 * class Engine {}
	 *
	 * @Injectable()
	 * class Car {
	 *   engine;
	 *   constructor(@Optional() engine:Engine) {
	 *     this.engine = engine;
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([Car]);
	 * expect(injector.get(Car).engine).toBeNull();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var OptionalMetadata = function () {
	  function OptionalMetadata() {
	    classCallCheck(this, OptionalMetadata);
	  }

	  createClass(OptionalMetadata, [{
	    key: 'toString',
	    value: function toString() {
	      return '@Optional()';
	    }
	  }]);
	  return OptionalMetadata;
	}();
	/**
	 * `DependencyMetadata` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 * @ts2dart_const
	 * @stable
	 */
	var DependencyMetadata = function () {
	  function DependencyMetadata() {
	    classCallCheck(this, DependencyMetadata);
	  }

	  createClass(DependencyMetadata, [{
	    key: 'token',
	    get: function get() {
	      return null;
	    }
	  }]);
	  return DependencyMetadata;
	}();
	/**
	 * A marker metadata that marks a class as available to {@link Injector} for creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Wk4DMQ?p=preview))
	 *
	 * ```typescript
	 * @Injectable()
	 * class UsefulService {}
	 *
	 * @Injectable()
	 * class NeedsService {
	 *   constructor(public service:UsefulService) {}
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
	 * expect(injector.get(NeedsService).service instanceof UsefulService).toBe(true);
	 * ```
	 * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that
	 * does not have `@Injectable` marker, as shown in the example below.
	 *
	 * ```typescript
	 * class UsefulService {}
	 *
	 * class NeedsService {
	 *   constructor(public service:UsefulService) {}
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([NeedsService, UsefulService]);
	 * expect(() => injector.get(NeedsService)).toThrowError();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var InjectableMetadata = function InjectableMetadata() {
	  classCallCheck(this, InjectableMetadata);
	};
	/**
	 * Specifies that an {@link Injector} should retrieve a dependency only from itself.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/NeagAg?p=preview))
	 *
	 * ```typescript
	 * class Dependency {
	 * }
	 *
	 * @Injectable()
	 * class NeedsDependency {
	 *   dependency;
	 *   constructor(@Self() dependency:Dependency) {
	 *     this.dependency = dependency;
	 *   }
	 * }
	 *
	 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
	 * var nd = inj.get(NeedsDependency);
	 *
	 * expect(nd.dependency instanceof Dependency).toBe(true);
	 *
	 * var inj = Injector.resolveAndCreate([Dependency]);
	 * var child = inj.resolveAndCreateChild([NeedsDependency]);
	 * expect(() => child.get(NeedsDependency)).toThrowError();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var SelfMetadata = function () {
	  function SelfMetadata() {
	    classCallCheck(this, SelfMetadata);
	  }

	  createClass(SelfMetadata, [{
	    key: 'toString',
	    value: function toString() {
	      return '@Self()';
	    }
	  }]);
	  return SelfMetadata;
	}();
	/**
	 * Specifies that the dependency resolution should start from the parent injector.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Wchdzb?p=preview))
	 *
	 * ```typescript
	 * class Dependency {
	 * }
	 *
	 * @Injectable()
	 * class NeedsDependency {
	 *   dependency;
	 *   constructor(@SkipSelf() dependency:Dependency) {
	 *     this.dependency = dependency;
	 *   }
	 * }
	 *
	 * var parent = Injector.resolveAndCreate([Dependency]);
	 * var child = parent.resolveAndCreateChild([NeedsDependency]);
	 * expect(child.get(NeedsDependency).dependency instanceof Depedency).toBe(true);
	 *
	 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
	 * expect(() => inj.get(NeedsDependency)).toThrowError();
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var SkipSelfMetadata = function () {
	  function SkipSelfMetadata() {
	    classCallCheck(this, SkipSelfMetadata);
	  }

	  createClass(SkipSelfMetadata, [{
	    key: 'toString',
	    value: function toString() {
	      return '@SkipSelf()';
	    }
	  }]);
	  return SkipSelfMetadata;
	}();
	/**
	 * Specifies that an injector should retrieve a dependency from any injector until reaching the
	 * closest host.
	 *
	 * In Angular, a component element is automatically declared as a host for all the injectors in
	 * its view.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GX79pV?p=preview))
	 *
	 * In the following example `App` contains `ParentCmp`, which contains `ChildDirective`.
	 * So `ParentCmp` is the host of `ChildDirective`.
	 *
	 * `ChildDirective` depends on two services: `HostService` and `OtherService`.
	 * `HostService` is defined at `ParentCmp`, and `OtherService` is defined at `App`.
	 *
	 *```typescript
	 * class OtherService {}
	 * class HostService {}
	 *
	 * @Directive({
	 *   selector: 'child-directive'
	 * })
	 * class ChildDirective {
	 *   constructor(@Optional() @Host() os:OtherService, @Optional() @Host() hs:HostService){
	 *     console.log("os is null", os);
	 *     console.log("hs is NOT null", hs);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   providers: [HostService],
	 *   template: `
	 *     Dir: <child-directive></child-directive>
	 *   `,
	 *   directives: [ChildDirective]
	 * })
	 * class ParentCmp {
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   providers: [OtherService],
	 *   template: `
	 *     Parent: <parent-cmp></parent-cmp>
	 *   `,
	 *   directives: [ParentCmp]
	 * })
	 * class App {
	 * }
	 *
	 * bootstrap(App);
	 *```
	 * @ts2dart_const
	 * @stable
	 */
	var HostMetadata = function () {
	  function HostMetadata() {
	    classCallCheck(this, HostMetadata);
	  }

	  createClass(HostMetadata, [{
	    key: 'toString',
	    value: function toString() {
	      return '@Host()';
	    }
	  }]);
	  return HostMetadata;
	}();

	/**
	 * Specifies that a constant attribute value should be injected.
	 *
	 * The directive can inject constant string literals of host element attributes.
	 *
	 * ### Example
	 *
	 * Suppose we have an `<input>` element and want to know its `type`.
	 *
	 * ```html
	 * <input type="text">
	 * ```
	 *
	 * A decorator can inject string literal `text` like so:
	 *
	 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
	 * @ts2dart_const
	 * @stable
	 */
	var AttributeMetadata = function (_DependencyMetadata) {
	    inherits(AttributeMetadata, _DependencyMetadata);

	    function AttributeMetadata(attributeName) {
	        classCallCheck(this, AttributeMetadata);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AttributeMetadata).call(this));

	        _this.attributeName = attributeName;
	        return _this;
	    }

	    createClass(AttributeMetadata, [{
	        key: 'toString',
	        value: function toString() {
	            return '@Attribute(' + stringify(this.attributeName) + ')';
	        }
	    }, {
	        key: 'token',
	        get: function get() {
	            // Normally one would default a token to a type of an injected value but here
	            // the type of a variable is "string" and we can't use primitive type as a return value
	            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
	            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
	            // account.
	            return this;
	        }
	    }]);
	    return AttributeMetadata;
	}(DependencyMetadata);
	/**
	 * Declares an injectable parameter to be a live list of directives or variable
	 * bindings from the content children of a directive.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 *
	 * Assume that `<tabs>` component would like to get a list its children `<pane>`
	 * components as shown in this example:
	 *
	 * ```html
	 * <tabs>
	 *   <pane title="Overview">...</pane>
	 *   <pane *ngFor="let o of objects" [title]="o.title">{{o.text}}</pane>
	 * </tabs>
	 * ```
	 *
	 * The preferred solution is to query for `Pane` directives using this decorator.
	 *
	 * ```javascript
	 * @Component({
	 *   selector: 'pane',
	 *   inputs: ['title']
	 * })
	 * class Pane {
	 *   title:string;
	 * }
	 *
	 * @Component({
	 *  selector: 'tabs',
	 *  template: `
	 *    <ul>
	 *      <li *ngFor="let pane of panes">{{pane.title}}</li>
	 *    </ul>
	 *    <ng-content></ng-content>
	 *  `
	 * })
	 * class Tabs {
	 *   panes: QueryList<Pane>;
	 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
	  *    this.panes = panes;
	  *  }
	 * }
	 * ```
	 *
	 * A query can look for variable bindings by passing in a string with desired binding symbol.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/sT2j25cH1dURAyBRCKx1?p=preview))
	 * ```html
	 * <seeker>
	 *   <div #findme>...</div>
	 * </seeker>
	 *
	 * @Component({ selector: 'seeker' })
	 * class Seeker {
	 *   constructor(@Query('findme') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * In this case the object that is injected depend on the type of the variable
	 * binding. It can be an ElementRef, a directive or a component.
	 *
	 * Passing in a comma separated list of variable bindings will query for all of them.
	 *
	 * ```html
	 * <seeker>
	 *   <div #find-me>...</div>
	 *   <div #find-me-too>...</div>
	 * </seeker>
	 *
	 *  @Component({
	 *   selector: 'seeker'
	 * })
	 * class Seeker {
	 *   constructor(@Query('findMe, findMeToo') elList: QueryList<ElementRef>) {...}
	 * }
	 * ```
	 *
	 * Configure whether query looks for direct children or all descendants
	 * of the querying element, by using the `descendants` parameter.
	 * It is set to `false` by default.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wtGeB977bv7qvA5FTYl9?p=preview))
	 * ```html
	 * <container #first>
	 *   <item>a</item>
	 *   <item>b</item>
	 *   <container #second>
	 *     <item>c</item>
	 *   </container>
	 * </container>
	 * ```
	 *
	 * When querying for items, the first container will see only `a` and `b` by default,
	 * but with `Query(TextDirective, {descendants: true})` it will see `c` too.
	 *
	 * The queried directives are kept in a depth-first pre-order with respect to their
	 * positions in the DOM.
	 *
	 * Query does not look deep into any subcomponent views.
	 *
	 * Query is updated as part of the change-detection cycle. Since change detection
	 * happens after construction of a directive, QueryList will always be empty when observed in the
	 * constructor.
	 *
	 * The injected object is an unmodifiable live list.
	 * See {@link QueryList} for more details.
	 * @ts2dart_const
	 * @deprecated
	 */
	var QueryMetadata = function (_DependencyMetadata2) {
	    inherits(QueryMetadata, _DependencyMetadata2);

	    function QueryMetadata(_selector) {
	        var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var _ref$descendants = _ref.descendants;
	        var descendants = _ref$descendants === undefined ? false : _ref$descendants;
	        var _ref$first = _ref.first;
	        var first = _ref$first === undefined ? false : _ref$first;
	        var _ref$read = _ref.read;
	        var read = _ref$read === undefined ? null : _ref$read;
	        classCallCheck(this, QueryMetadata);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(QueryMetadata).call(this));

	        _this2._selector = _selector;
	        _this2.descendants = descendants;
	        _this2.first = first;
	        _this2.read = read;
	        return _this2;
	    }
	    /**
	     * always `false` to differentiate it with {@link ViewQueryMetadata}.
	     */


	    createClass(QueryMetadata, [{
	        key: 'toString',
	        value: function toString() {
	            return '@Query(' + stringify(this.selector) + ')';
	        }
	    }, {
	        key: 'isViewQuery',
	        get: function get() {
	            return false;
	        }
	        /**
	         * what this is querying for.
	         */

	    }, {
	        key: 'selector',
	        get: function get() {
	            return resolveForwardRef(this._selector);
	        }
	        /**
	         * whether this is querying for a variable binding or a directive.
	         */

	    }, {
	        key: 'isVarBindingQuery',
	        get: function get() {
	            return isString(this.selector);
	        }
	        /**
	         * returns a list of variable bindings this is querying for.
	         * Only applicable if this is a variable bindings query.
	         */

	    }, {
	        key: 'varBindings',
	        get: function get() {
	            return StringWrapper.split(this.selector, /\s*,\s*/g);
	        }
	    }]);
	    return QueryMetadata;
	}(DependencyMetadata);
	// TODO: add an example after ContentChildren and ViewChildren are in master
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChildren is set
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ContentChildrenMetadata = function (_QueryMetadata) {
	    inherits(ContentChildrenMetadata, _QueryMetadata);

	    function ContentChildrenMetadata(_selector) {
	        var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var _ref2$descendants = _ref2.descendants;
	        var descendants = _ref2$descendants === undefined ? false : _ref2$descendants;
	        var _ref2$read = _ref2.read;
	        var read = _ref2$read === undefined ? null : _ref2$read;
	        classCallCheck(this, ContentChildrenMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ContentChildrenMetadata).call(this, _selector, { descendants: descendants, read: read }));
	    }

	    return ContentChildrenMetadata;
	}(QueryMetadata);
	// TODO: add an example after ContentChild and ViewChild are in master
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChild(ChildDirective) contentChild;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is set
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ContentChildMetadata = function (_QueryMetadata2) {
	    inherits(ContentChildMetadata, _QueryMetadata2);

	    function ContentChildMetadata(_selector) {
	        var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var _ref3$read = _ref3.read;
	        var read = _ref3$read === undefined ? null : _ref3$read;
	        classCallCheck(this, ContentChildMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ContentChildMetadata).call(this, _selector, { descendants: true, first: true, read: read }));
	    }

	    return ContentChildMetadata;
	}(QueryMetadata);
	/**
	 * Similar to {@link QueryMetadata}, but querying the component view, instead of
	 * the content children.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/eNsFHDf7YjyM6IzKxM1j?p=preview))
	 *
	 * ```javascript
	 * @Component({
	 *   ...,
	 *   template: `
	 *     <item> a </item>
	 *     <item> b </item>
	 *     <item> c </item>
	 *   `
	 * })
	 * class MyComponent {
	 *   shown: boolean;
	 *
	 *   constructor(private @ViewQuery(Item) items:QueryList<Item>) {
	 *     items.changes.subscribe(() => console.log(items.length));
	 *   }
	 * }
	 * ```
	 *
	 * Supports the same querying parameters as {@link QueryMetadata}, except
	 * `descendants`. This always queries the whole view.
	 *
	 * As `shown` is flipped between true and false, items will contain zero of one
	 * items.
	 *
	 * Specifies that a {@link QueryList} should be injected.
	 *
	 * The injected object is an iterable and observable live list.
	 * See {@link QueryList} for more details.
	 * @ts2dart_const
	 * @deprecated
	 */
	var ViewQueryMetadata = function (_QueryMetadata3) {
	    inherits(ViewQueryMetadata, _QueryMetadata3);

	    function ViewQueryMetadata(_selector) {
	        var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var _ref4$descendants = _ref4.descendants;
	        var descendants = _ref4$descendants === undefined ? false : _ref4$descendants;
	        var _ref4$first = _ref4.first;
	        var first = _ref4$first === undefined ? false : _ref4$first;
	        var _ref4$read = _ref4.read;
	        var read = _ref4$read === undefined ? null : _ref4$read;
	        classCallCheck(this, ViewQueryMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ViewQueryMetadata).call(this, _selector, { descendants: descendants, first: first, read: read }));
	    }
	    /**
	     * always `true` to differentiate it with {@link QueryMetadata}.
	     */


	    createClass(ViewQueryMetadata, [{
	        key: 'toString',
	        value: function toString() {
	            return '@ViewQuery(' + stringify(this.selector) + ')';
	        }
	    }, {
	        key: 'isViewQuery',
	        get: function get() {
	            return true;
	        }
	    }]);
	    return ViewQueryMetadata;
	}(QueryMetadata);
	/**
	 * Declares a list of child element references.
	 *
	 * Angular automatically updates the list when the DOM is updated.
	 *
	 * `ViewChildren` takes an argument to select elements.
	 *
	 * - If the argument is a type, directives or components with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
	 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
	 * bound.
	 *
	 * View children are set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp #child1></child-cmp>
	 *     <child-cmp #child2></child-cmp>
	 *     <child-cmp #child3></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ViewChildrenMetadata = function (_ViewQueryMetadata) {
	    inherits(ViewChildrenMetadata, _ViewQueryMetadata);

	    function ViewChildrenMetadata(_selector) {
	        var _ref5 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var _ref5$read = _ref5.read;
	        var read = _ref5$read === undefined ? null : _ref5$read;
	        classCallCheck(this, ViewChildrenMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ViewChildrenMetadata).call(this, _selector, { descendants: true, read: read }));
	    }

	    return ViewChildrenMetadata;
	}(ViewQueryMetadata);
	/**
	 *
	 * Declares a reference of child element.
	 *
	 * `ViewChildren` takes an argument to select elements.
	 *
	 * - If the argument is a type, a directive or a component with the type will be bound.
	 *
	 If the argument is a string, the string is interpreted as a selector. An element containing the
	 matching template variable (e.g. `#child`) will be bound.
	 *
	 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
	 multiple matches.
	 *
	 * View child is set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild(ChildCmp) child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp #child></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild('child') child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var ViewChildMetadata = function (_ViewQueryMetadata2) {
	    inherits(ViewChildMetadata, _ViewQueryMetadata2);

	    function ViewChildMetadata(_selector) {
	        var _ref6 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var _ref6$read = _ref6.read;
	        var read = _ref6$read === undefined ? null : _ref6$read;
	        classCallCheck(this, ViewChildMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ViewChildMetadata).call(this, _selector, { descendants: true, first: true, read: read }));
	    }

	    return ViewChildMetadata;
	}(ViewQueryMetadata);

	/**
	 * Describes within the change detector which strategy will be used the next time change
	 * detection is triggered.
	 * @stable
	 */
	var ChangeDetectionStrategy;
	(function (ChangeDetectionStrategy) {
	  /**
	   * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
	   */
	  ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
	  /**
	   * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
	   */
	  ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
	})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
	/**
	 * Describes the status of the detector.
	 */
	var ChangeDetectorStatus;
	(function (ChangeDetectorStatus) {
	  /**
	   * `CheckedOnce` means that after calling detectChanges the mode of the change detector
	   * will become `Checked`.
	   */
	  ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
	  /**
	   * `Checked` means that the change detector should be skipped until its mode changes to
	   * `CheckOnce`.
	   */
	  ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
	  /**
	   * `CheckAlways` means that after calling detectChanges the mode of the change detector
	   * will remain `CheckAlways`.
	   */
	  ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
	  /**
	   * `Detached` means that the change detector sub tree is not a part of the main tree and
	   * should be skipped.
	   */
	  ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
	  /**
	   * `Errored` means that the change detector encountered an error checking a binding
	   * or calling a directive lifecycle method and is now in an inconsistent state. Change
	   * detectors in this state will no longer detect changes.
	   */
	  ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
	  /**
	   * `Destroyed` means that the change detector is destroyed.
	   */
	  ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
	})(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
	/**
	 * List of possible {@link ChangeDetectionStrategy} values.
	 */
	var CHANGE_DETECTION_STRATEGY_VALUES = [ChangeDetectionStrategy.OnPush, ChangeDetectionStrategy.Default];
	function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	  return isBlank(changeDetectionStrategy) || changeDetectionStrategy === ChangeDetectionStrategy.Default;
	}

	/**
	 * Directives allow you to attach behavior to elements in the DOM.
	 *
	 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
	 *
	 * A directive consists of a single directive annotation and a controller class. When the
	 * directive's `selector` matches
	 * elements in the DOM, the following steps occur:
	 *
	 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
	 * arguments.
	 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
	 * depth-first order,
	 *    as declared in the HTML.
	 *
	 * ## Understanding How Injection Works
	 *
	 * There are three stages of injection resolution.
	 * - *Pre-existing Injectors*:
	 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
	 * the dependency was
	 *     specified as `@Optional`, returns `null`.
	 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
	 * location, and others.
	 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
	 * the same parent-child hierarchy
	 *     as the component instances in the DOM.
	 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
	 * element has an `ElementInjector`
	 *     which follow the same parent-child hierarchy as the DOM elements themselves.
	 *
	 * When a template is instantiated, it also must instantiate the corresponding directives in a
	 * depth-first order. The
	 * current `ElementInjector` resolves the constructor dependencies for each directive.
	 *
	 * Angular then resolves dependencies as follows, according to the order in which they appear in the
	 * {@link ViewMetadata}:
	 *
	 * 1. Dependencies on the current element
	 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
	 * 3. Dependencies on component injectors and their parents until it encounters the root component
	 * 4. Dependencies on pre-existing injectors
	 *
	 *
	 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
	 * delegate to the parent
	 * injector.
	 *
	 * To inject other directives, declare the constructor parameter as:
	 * - `directive:DirectiveType`: a directive on the current element only
	 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
	 * element and the
	 *    Shadow DOM root.
	 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
	 * directives.
	 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
	 * child directives.
	 *
	 * To inject element-specific special objects, declare the constructor parameter as:
	 * - `element: ElementRef` to obtain a reference to logical element in the view.
	 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
	 * {@link DirectiveMetadata} directives only
	 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
	 *
	 * ### Example
	 *
	 * The following example demonstrates how dependency injection resolves constructor arguments in
	 * practice.
	 *
	 *
	 * Assume this HTML template:
	 *
	 * ```
	 * <div dependency="1">
	 *   <div dependency="2">
	 *     <div dependency="3" my-directive>
	 *       <div dependency="4">
	 *         <div dependency="5"></div>
	 *       </div>
	 *       <div dependency="6"></div>
	 *     </div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * With the following `dependency` decorator and `SomeService` injectable class.
	 *
	 * ```
	 * @Injectable()
	 * class SomeService {
	 * }
	 *
	 * @Directive({
	 *   selector: '[dependency]',
	 *   inputs: [
	 *     'id: dependency'
	 *   ]
	 * })
	 * class Dependency {
	 *   id:string;
	 * }
	 * ```
	 *
	 * Let's step through the different ways in which `MyDirective` could be declared...
	 *
	 *
	 * ### No injection
	 *
	 * Here the constructor is declared with no arguments, therefore nothing is injected into
	 * `MyDirective`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor() {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with no dependencies.
	 *
	 *
	 * ### Component-level injection
	 *
	 * Directives can inject any injectable instance from the closest component injector or any of its
	 * parents.
	 *
	 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
	 * from the parent
	 * component's injector.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(someService: SomeService) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a dependency on `SomeService`.
	 *
	 *
	 * ### Injecting a directive from the current element
	 *
	 * Directives can inject other directives declared on the current element.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(dependency: Dependency) {
	 *     expect(dependency.id).toEqual(3);
	 *   }
	 * }
	 * ```
	 * This directive would be instantiated with `Dependency` declared at the same element, in this case
	 * `dependency="3"`.
	 *
	 * ### Injecting a directive from any ancestor elements
	 *
	 * Directives can inject other directives declared on any ancestor element (in the current Shadow
	 * DOM), i.e. on the current element, the
	 * parent element, or its parents.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Host() dependency: Dependency) {
	 *     expect(dependency.id).toEqual(2);
	 *   }
	 * }
	 * ```
	 *
	 * `@Host` checks the current element, the parent, as well as its parents recursively. If
	 * `dependency="2"` didn't
	 * exist on the direct parent, this injection would
	 * have returned
	 * `dependency="1"`.
	 *
	 *
	 * ### Injecting a live collection of direct child directives
	 *
	 *
	 * A directive can also query for other child directives. Since parent directives are instantiated
	 * before child directives, a directive can't simply inject the list of child directives. Instead,
	 * the directive injects a {@link QueryList}, which updates its contents as children are added,
	 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
	 * `ngIf`, or an `ngSwitch`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
	 * `Dependency` 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
	 *
	 * ### Injecting a live collection of descendant directives
	 *
	 * By passing the descendant flag to `@Query` above, we can include the children of the child
	 * elements.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
	 *
	 * ### Optional injection
	 *
	 * The normal behavior of directives is to return an error when a specified dependency cannot be
	 * resolved. If you
	 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
	 * with `@Optional()`.
	 * This explicitly permits the author of a template to treat some of the surrounding directives as
	 * optional.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Optional() dependency:Dependency) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a `Dependency` directive found on the current element.
	 * If none can be
	 * found, the injector supplies `null` instead of throwing an error.
	 *
	 * ### Example
	 *
	 * Here we use a decorator directive to simply define basic tool-tip behavior.
	 *
	 * ```
	 * @Directive({
	 *   selector: '[tooltip]',
	 *   inputs: [
	 *     'text: tooltip'
	 *   ],
	 *   host: {
	 *     '(mouseenter)': 'onMouseEnter()',
	 *     '(mouseleave)': 'onMouseLeave()'
	 *   }
	 * })
	 * class Tooltip{
	 *   text:string;
	 *   overlay:Overlay; // NOT YET IMPLEMENTED
	 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
	 *
	 *   constructor(overlayManager:OverlayManager) {
	 *     this.overlay = overlay;
	 *   }
	 *
	 *   onMouseEnter() {
	 *     // exact signature to be determined
	 *     this.overlay = this.overlayManager.open(text, ...);
	 *   }
	 *
	 *   onMouseLeave() {
	 *     this.overlay.close();
	 *     this.overlay = null;
	 *   }
	 * }
	 * ```
	 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
	 * `tooltip` selector,
	 * like so:
	 *
	 * ```
	 * <div tooltip="some text here"></div>
	 * ```
	 *
	 * Directives can also control the instantiation, destruction, and positioning of inline template
	 * elements:
	 *
	 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
	 * runtime.
	 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
	 * location in the current view
	 * where these actions are performed.
	 *
	 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
	 * `<template>` element. Thus a
	 * directive in a child view cannot inject the directive that created it.
	 *
	 * Since directives that create views via ViewContainers are common in Angular, and using the full
	 * `<template>` element syntax is wordy, Angular
	 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
	 * equivalent.
	 *
	 * Thus,
	 *
	 * ```
	 * <ul>
	 *   <li *foo="bar" title="text"></li>
	 * </ul>
	 * ```
	 *
	 * Expands in use to:
	 *
	 * ```
	 * <ul>
	 *   <template [foo]="bar">
	 *     <li title="text"></li>
	 *   </template>
	 * </ul>
	 * ```
	 *
	 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
	 * the directive
	 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the directive class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the directive.
	 *
	 * ### Example
	 *
	 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
	 *
	 * Here is a simple directive that triggers on an `unless` selector:
	 *
	 * ```
	 * @Directive({
	 *   selector: '[unless]',
	 *   inputs: ['unless']
	 * })
	 * export class Unless {
	 *   viewContainer: ViewContainerRef;
	 *   templateRef: TemplateRef;
	 *   prevCondition: boolean;
	 *
	 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
	 *     this.viewContainer = viewContainer;
	 *     this.templateRef = templateRef;
	 *     this.prevCondition = null;
	 *   }
	 *
	 *   set unless(newCondition) {
	 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
	 *       this.prevCondition = true;
	 *       this.viewContainer.clear();
	 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
	 *       this.prevCondition = false;
	 *       this.viewContainer.create(this.templateRef);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * We can then use this `unless` selector in a template:
	 * ```
	 * <ul>
	 *   <li *unless="expr"></li>
	 * </ul>
	 * ```
	 *
	 * Once the directive instantiates the child view, the shorthand notation for the template expands
	 * and the result is:
	 *
	 * ```
	 * <ul>
	 *   <template [unless]="exp">
	 *     <li></li>
	 *   </template>
	 *   <li></li>
	 * </ul>
	 * ```
	 *
	 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
	 * the instantiated
	 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
	 * @ts2dart_const
	 * @stable
	 */
	var DirectiveMetadata = function (_InjectableMetadata) {
	    inherits(DirectiveMetadata, _InjectableMetadata);

	    function DirectiveMetadata() {
	        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var selector = _ref.selector;
	        var inputs = _ref.inputs;
	        var outputs = _ref.outputs;
	        var properties = _ref.properties;
	        var events = _ref.events;
	        var host = _ref.host;
	        var providers = _ref.providers;
	        var exportAs = _ref.exportAs;
	        var queries = _ref.queries;
	        classCallCheck(this, DirectiveMetadata);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DirectiveMetadata).call(this));

	        _this.selector = selector;
	        _this._inputs = inputs;
	        _this._properties = properties;
	        _this._outputs = outputs;
	        _this._events = events;
	        _this.host = host;
	        _this.exportAs = exportAs;
	        _this.queries = queries;
	        _this._providers = providers;
	        return _this;
	    }
	    /**
	     * Enumerates the set of data-bound input properties for a directive
	     *
	     * Angular automatically updates input properties during change detection.
	     *
	     * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
	     * configuration:
	     *
	     * - `directiveProperty` specifies the component property where the value is written.
	     * - `bindingProperty` specifies the DOM property where the value is read from.
	     *
	     * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
	     *
	     * The following example creates a component with two data-bound properties.
	     *
	     * ```typescript
	     * @Component({
	     *   selector: 'bank-account',
	     *   inputs: ['bankName', 'id: account-id'],
	     *   template: `
	     *     Bank Name: {{bankName}}
	     *     Account Id: {{id}}
	     *   `
	     * })
	     * class BankAccount {
	     *   bankName: string;
	     *   id: string;
	     *
	     *   // this property is not bound, and won't be automatically updated by Angular
	     *   normalizedBankName: string;
	     * }
	     *
	     * @Component({
	     *   selector: 'app',
	     *   template: `
	     *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	     *   `,
	     *   directives: [BankAccount]
	     * })
	     * class App {}
	     *
	     * bootstrap(App);
	     * ```
	     *
	     */


	    createClass(DirectiveMetadata, [{
	        key: 'inputs',
	        get: function get() {
	            return isPresent(this._properties) && this._properties.length > 0 ? this._properties : this._inputs;
	        }
	        /**
	         * Use `inputs` instead
	         *
	         * @deprecated
	         */

	    }, {
	        key: 'properties',
	        get: function get() {
	            return this.inputs;
	        }
	        /**
	         * Enumerates the set of event-bound output properties.
	         *
	         * When an output property emits an event, an event handler attached to that event
	         * the template is invoked.
	         *
	         * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
	         * configuration:
	         *
	         * - `directiveProperty` specifies the component property that emits events.
	         * - `bindingProperty` specifies the DOM property the event handler is attached to.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
	         *
	         * ```typescript
	         * @Directive({
	         *   selector: 'interval-dir',
	         *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
	         * })
	         * class IntervalDir {
	         *   everySecond = new EventEmitter();
	         *   five5Secs = new EventEmitter();
	         *
	         *   constructor() {
	         *     setInterval(() => this.everySecond.emit("event"), 1000);
	         *     setInterval(() => this.five5Secs.emit("event"), 5000);
	         *   }
	         * }
	         *
	         * @Component({
	         *   selector: 'app',
	         *   template: `
	         *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	         *     </interval-dir>
	         *   `,
	         *   directives: [IntervalDir]
	         * })
	         * class App {
	         *   everySecond() { console.log('second'); }
	         *   everyFiveSeconds() { console.log('five seconds'); }
	         * }
	         * bootstrap(App);
	         * ```
	         *
	         */

	    }, {
	        key: 'outputs',
	        get: function get() {
	            return isPresent(this._events) && this._events.length > 0 ? this._events : this._outputs;
	        }
	        /**
	         * Use `outputs` instead
	         *
	         * @deprecated
	         */

	    }, {
	        key: 'events',
	        get: function get() {
	            return this.outputs;
	        }
	        /**
	         * Defines the set of injectable objects that are visible to a Directive and its light DOM
	         * children.
	         *
	         * ## Simple Example
	         *
	         * Here is an example of a class that can be injected:
	         *
	         * ```
	         * class Greeter {
	         *    greet(name:string) {
	         *      return 'Hello ' + name + '!';
	         *    }
	         * }
	         *
	         * @Directive({
	         *   selector: 'greet',
	         *   providers: [
	         *     Greeter
	         *   ]
	         * })
	         * class HelloWorld {
	         *   greeter:Greeter;
	         *
	         *   constructor(greeter:Greeter) {
	         *     this.greeter = greeter;
	         *   }
	         * }
	         * ```
	         */

	    }, {
	        key: 'providers',
	        get: function get() {
	            return this._providers;
	        }
	    }]);
	    return DirectiveMetadata;
	}(InjectableMetadata);
	/**
	 * Declare reusable UI building blocks for an application.
	 *
	 * Each Angular component requires a single `@Component` annotation. The
	 * `@Component`
	 * annotation specifies when a component is instantiated, and which properties and hostListeners it
	 * binds to.
	 *
	 * When a component is instantiated, Angular
	 * - creates a shadow DOM for the component.
	 * - loads the selected template into the shadow DOM.
	 * - creates all the injectable objects configured with `providers` and `viewProviders`.
	 *
	 * All template expressions and statements are then evaluated against the component instance.
	 *
	 * For details on the `@View` annotation, see {@link ViewMetadata}.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the component class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the component.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='component'}
	 * @ts2dart_const
	 * @stable
	 */
	var ComponentMetadata = function (_DirectiveMetadata) {
	    inherits(ComponentMetadata, _DirectiveMetadata);

	    function ComponentMetadata() {
	        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var selector = _ref2.selector;
	        var inputs = _ref2.inputs;
	        var outputs = _ref2.outputs;
	        var properties = _ref2.properties;
	        var events = _ref2.events;
	        var host = _ref2.host;
	        var exportAs = _ref2.exportAs;
	        var moduleId = _ref2.moduleId;
	        var providers = _ref2.providers;
	        var viewProviders = _ref2.viewProviders;
	        var _ref2$changeDetection = _ref2.changeDetection;
	        var changeDetection = _ref2$changeDetection === undefined ? ChangeDetectionStrategy.Default : _ref2$changeDetection;
	        var queries = _ref2.queries;
	        var templateUrl = _ref2.templateUrl;
	        var template = _ref2.template;
	        var styleUrls = _ref2.styleUrls;
	        var styles = _ref2.styles;
	        var animations = _ref2.animations;
	        var directives = _ref2.directives;
	        var pipes = _ref2.pipes;
	        var encapsulation = _ref2.encapsulation;
	        var interpolation = _ref2.interpolation;
	        var precompile = _ref2.precompile;
	        classCallCheck(this, ComponentMetadata);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(ComponentMetadata).call(this, {
	            selector: selector,
	            inputs: inputs,
	            outputs: outputs,
	            properties: properties,
	            events: events,
	            host: host,
	            exportAs: exportAs,
	            providers: providers,
	            queries: queries
	        }));

	        _this2.changeDetection = changeDetection;
	        _this2._viewProviders = viewProviders;
	        _this2.templateUrl = templateUrl;
	        _this2.template = template;
	        _this2.styleUrls = styleUrls;
	        _this2.styles = styles;
	        _this2.directives = directives;
	        _this2.pipes = pipes;
	        _this2.encapsulation = encapsulation;
	        _this2.moduleId = moduleId;
	        _this2.animations = animations;
	        _this2.interpolation = interpolation;
	        _this2.precompile = precompile;
	        return _this2;
	    }
	    /**
	     * Defines the set of injectable objects that are visible to its view DOM children.
	     *
	     * ## Simple Example
	     *
	     * Here is an example of a class that can be injected:
	     *
	     * ```
	     * class Greeter {
	     *    greet(name:string) {
	     *      return 'Hello ' + name + '!';
	     *    }
	     * }
	     *
	     * @Directive({
	     *   selector: 'needs-greeter'
	     * })
	     * class NeedsGreeter {
	     *   greeter:Greeter;
	     *
	     *   constructor(greeter:Greeter) {
	     *     this.greeter = greeter;
	     *   }
	     * }
	     *
	     * @Component({
	     *   selector: 'greet',
	     *   viewProviders: [
	     *     Greeter
	     *   ],
	     *   template: `<needs-greeter></needs-greeter>`,
	     *   directives: [NeedsGreeter]
	     * })
	     * class HelloWorld {
	     * }
	     *
	     * ```
	     */


	    createClass(ComponentMetadata, [{
	        key: 'viewProviders',
	        get: function get() {
	            return this._viewProviders;
	        }
	    }]);
	    return ComponentMetadata;
	}(DirectiveMetadata);
	/**
	 * Declare reusable pipe function.
	 *
	 * A "pure" pipe is only re-evaluated when either the input or any of the arguments change.
	 *
	 * When not specified, pipes default to being pure.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='pipe'}
	 * @ts2dart_const
	 * @stable
	 */
	var PipeMetadata = function (_InjectableMetadata2) {
	    inherits(PipeMetadata, _InjectableMetadata2);

	    function PipeMetadata(_ref3) {
	        var name = _ref3.name;
	        var pure = _ref3.pure;
	        classCallCheck(this, PipeMetadata);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(PipeMetadata).call(this));

	        _this3.name = name;
	        _this3._pure = pure;
	        return _this3;
	    }

	    createClass(PipeMetadata, [{
	        key: 'pure',
	        get: function get() {
	            return isPresent(this._pure) ? this._pure : true;
	        }
	    }]);
	    return PipeMetadata;
	}(InjectableMetadata);
	/**
	 * Declares a data-bound input property.
	 *
	 * Angular automatically updates data-bound properties during change detection.
	 *
	 * `InputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * The following example creates a component with two input properties.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'bank-account',
	 *   template: `
	 *     Bank Name: {{bankName}}
	 *     Account Id: {{id}}
	 *   `
	 * })
	 * class BankAccount {
	 *   @Input() bankName: string;
	 *   @Input('account-id') id: string;
	 *
	 *   // this property is not bound, and won't be automatically updated by Angular
	 *   normalizedBankName: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	 *   `,
	 *   directives: [BankAccount]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var InputMetadata = function InputMetadata(
	/**
	 * Name used when instantiating a component in the template.
	 */
	bindingPropertyName) {
	    classCallCheck(this, InputMetadata);

	    this.bindingPropertyName = bindingPropertyName;
	};
	/**
	 * Declares an event-bound output property.
	 *
	 * When an output property emits an event, an event handler attached to that event
	 * the template is invoked.
	 *
	 * `OutputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Directive({
	 *   selector: 'interval-dir',
	 * })
	 * class IntervalDir {
	 *   @Output() everySecond = new EventEmitter();
	 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
	 *
	 *   constructor() {
	 *     setInterval(() => this.everySecond.emit("event"), 1000);
	 *     setInterval(() => this.five5Secs.emit("event"), 5000);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	 *     </interval-dir>
	 *   `,
	 *   directives: [IntervalDir]
	 * })
	 * class App {
	 *   everySecond() { console.log('second'); }
	 *   everyFiveSeconds() { console.log('five seconds'); }
	 * }
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var OutputMetadata = function OutputMetadata(bindingPropertyName) {
	    classCallCheck(this, OutputMetadata);

	    this.bindingPropertyName = bindingPropertyName;
	};
	/**
	 * Declares a host property binding.
	 *
	 * Angular automatically checks host property bindings during change detection.
	 * If a binding changes, it will update the host element of the directive.
	 *
	 * `HostBindingMetadata` takes an optional parameter that specifies the property
	 * name of the host element that will be updated. When not provided,
	 * the class property name is used.
	 *
	 * ### Example
	 *
	 * The following example creates a directive that sets the `valid` and `invalid` classes
	 * on the DOM element that has ngModel directive on it.
	 *
	 * ```typescript
	 * @Directive({selector: '[ngModel]'})
	 * class NgModelStatus {
	 *   constructor(public control:NgModel) {}
	 *   @HostBinding('class.valid') get valid { return this.control.valid; }
	 *   @HostBinding('class.invalid') get invalid { return this.control.invalid; }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<input [(ngModel)]="prop">`,
	 *   directives: [FORM_DIRECTIVES, NgModelStatus]
	 * })
	 * class App {
	 *   prop;
	 * }
	 *
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var HostBindingMetadata = function HostBindingMetadata(hostPropertyName) {
	    classCallCheck(this, HostBindingMetadata);

	    this.hostPropertyName = hostPropertyName;
	};
	/**
	 * Declares a host listener.
	 *
	 * Angular will invoke the decorated method when the host element emits the specified event.
	 *
	 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
	 * event.
	 *
	 * ### Example
	 *
	 * The following example declares a directive that attaches a click listener to the button and
	 * counts clicks.
	 *
	 * ```typescript
	 * @Directive({selector: 'button[counting]'})
	 * class CountClicks {
	 *   numberOfClicks = 0;
	 *
	 *   @HostListener('click', ['$event.target'])
	 *   onClick(btn) {
	 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<button counting>Increment</button>`,
	 *   directives: [CountClicks]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @ts2dart_const
	 * @stable
	 */
	var HostListenerMetadata = function HostListenerMetadata(eventName, args) {
	    classCallCheck(this, HostListenerMetadata);

	    this.eventName = eventName;
	    this.args = args;
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Defines template and style encapsulation options available for Component's {@link View}.
	 *
	 * See {@link ViewMetadata#encapsulation}.
	 * @stable
	 */
	var ViewEncapsulation;
	(function (ViewEncapsulation) {
	  /**
	   * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
	   * Element and pre-processing the style rules provided via
	   * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
	   * attribute to all selectors.
	   *
	   * This is the default option.
	   */
	  ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
	  /**
	   * Use the native encapsulation mechanism of the renderer.
	   *
	   * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
	   * creating a ShadowRoot for Component's Host Element.
	   */
	  ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
	  /**
	   * Don't provide any template or style encapsulation.
	   */
	  ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
	})(ViewEncapsulation || (ViewEncapsulation = {}));
	var VIEW_ENCAPSULATION_VALUES = [ViewEncapsulation.Emulated, ViewEncapsulation.Native, ViewEncapsulation.None];
	/**
	 * Metadata properties available for configuring Views.
	 *
	 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
	 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
	 * within the template.
	 *
	 * When a component is instantiated, the template is loaded into the component's shadow root, and
	 * the expressions and statements in the template are evaluated against the component.
	 *
	 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
	 *
	 * ### Example
	 *
	 * ```
	 * @Component({
	 *   selector: 'greet',
	 *   template: 'Hello {{name}}!',
	 *   directives: [GreetUser, Bold]
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 * @ts2dart_const
	 *
	 * @experimental You should most likely be using ComponentMetadata instead.
	 */
	var ViewMetadata = function ViewMetadata() {
	  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  var templateUrl = _ref.templateUrl;
	  var template = _ref.template;
	  var directives = _ref.directives;
	  var pipes = _ref.pipes;
	  var encapsulation = _ref.encapsulation;
	  var styles = _ref.styles;
	  var styleUrls = _ref.styleUrls;
	  var animations = _ref.animations;
	  var interpolation = _ref.interpolation;
	  classCallCheck(this, ViewMetadata);

	  this.templateUrl = templateUrl;
	  this.template = template;
	  this.styleUrls = styleUrls;
	  this.styles = styles;
	  this.directives = directives;
	  this.pipes = pipes;
	  this.encapsulation = encapsulation;
	  this.animations = animations;
	  this.interpolation = interpolation;
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @stable
	 */
	var LifecycleHooks;
	(function (LifecycleHooks) {
	  LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
	  LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
	  LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
	  LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
	  LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
	  LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
	  LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
	  LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
	})(LifecycleHooks || (LifecycleHooks = {}));
	var LIFECYCLE_HOOKS_VALUES = [LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges, LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit, LifecycleHooks.AfterViewChecked];
	/**
	 * Lifecycle hooks are guaranteed to be called in the following order:
	 * - `OnChanges` (if any bindings have changed),
	 * - `OnInit` (after the first check only),
	 * - `DoCheck`,
	 * - `AfterContentInit`,
	 * - `AfterContentChecked`,
	 * - `AfterViewInit`,
	 * - `AfterViewChecked`,
	 * - `OnDestroy` (at the very end before destruction)
	 */
	/**
	 * Implement this interface to get notified when any data-bound property of your directive changes.
	 *
	 * `ngOnChanges` is called right after the data-bound properties have been checked and before view
	 * and content children are checked if at least one of them has changed.
	 *
	 * The `changes` parameter contains an entry for each of the changed data-bound property. The key is
	 * the property name and the value is an instance of {@link SimpleChange}.
	 *
	 * ### Example ([live example](http://plnkr.co/edit/AHrB6opLqHDBPkt4KpdT?p=preview)):
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>myProp = {{myProp}}</p>`
	 * })
	 * class MyComponent implements OnChanges {
	 *   @Input() myProp: any;
	 *
	 *   ngOnChanges(changes: SimpleChanges) {
	 *     console.log('ngOnChanges - myProp = ' + changes['myProp'].currentValue);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="value = value + 1">Change MyComponent</button>
	 *     <my-cmp [my-prop]="value"></my-cmp>`,
	 *   directives: [MyComponent]
	 * })
	 * export class App {
	 *   value = 0;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var OnChanges = function OnChanges() {
	  classCallCheck(this, OnChanges);
	};
	/**
	 * Implement this interface to execute custom initialization logic after your directive's
	 * data-bound properties have been initialized.
	 *
	 * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
	 * first time, and before any of its children have been checked. It is invoked only once when the
	 * directive is instantiated.
	 *
	 * ### Example ([live example](http://plnkr.co/edit/1MBypRryXd64v4pV03Yn?p=preview))
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>my-component</p>`
	 * })
	 * class MyComponent implements OnInit, OnDestroy {
	 *   ngOnInit() {
	 *     console.log('ngOnInit');
	 *   }
	 *
	 *   ngOnDestroy() {
	 *     console.log('ngOnDestroy');
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="hasChild = !hasChild">
	 *       {{hasChild ? 'Destroy' : 'Create'}} MyComponent
	 *     </button>
	 *     <my-cmp *ngIf="hasChild"></my-cmp>`,
	 *   directives: [MyComponent, NgIf]
	 * })
	 * export class App {
	 *   hasChild = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 *  ```
	 * @stable
	 */
	var OnInit = function OnInit() {
	  classCallCheck(this, OnInit);
	};
	/**
	 * Implement this interface to supplement the default change detection algorithm in your directive.
	 *
	 * `ngDoCheck` gets called to check the changes in the directives in addition to the default
	 * algorithm.
	 *
	 * The default change detection algorithm looks for differences by comparing bound-property values
	 * by reference across change detection runs.
	 *
	 * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
	 * changes on the same input. `ngOnChanges` will continue to be called when the default change
	 * detector
	 * detects changes, so it is usually unnecessary to respond to changes on the same input in both
	 * hooks.
	 * Reaction to the changes have to be handled from within the `ngDoCheck` callback.
	 *
	 * You can use {@link KeyValueDiffers} and {@link IterableDiffers} to help add your custom check
	 * mechanisms.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/QpnIlF0CR2i5bcYbHEUJ?p=preview))
	 *
	 * In the following example `ngDoCheck` uses an {@link IterableDiffers} to detect the updates to the
	 * array `list`:
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'custom-check',
	 *   template: `
	 *     <p>Changes:</p>
	 *     <ul>
	 *       <li *ngFor="let line of logs">{{line}}</li>
	 *     </ul>`,
	 *   directives: [NgFor]
	 * })
	 * class CustomCheckComponent implements DoCheck {
	 *   @Input() list: any[];
	 *   differ: any;
	 *   logs = [];
	 *
	 *   constructor(differs: IterableDiffers) {
	 *     this.differ = differs.find([]).create(null);
	 *   }
	 *
	 *   ngDoCheck() {
	 *     var changes = this.differ.diff(this.list);
	 *
	 *     if (changes) {
	 *       changes.forEachAddedItem(r => this.logs.push('added ' + r.item));
	 *       changes.forEachRemovedItem(r => this.logs.push('removed ' + r.item))
	 *     }
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="list.push(list.length)">Push</button>
	 *     <button (click)="list.pop()">Pop</button>
	 *     <custom-check [list]="list"></custom-check>`,
	 *   directives: [CustomCheckComponent]
	 * })
	 * export class App {
	 *   list = [];
	 * }
	 * ```
	 * @stable
	 */
	var DoCheck = function DoCheck() {
	  classCallCheck(this, DoCheck);
	};
	/**
	 * Implement this interface to get notified when your directive is destroyed.
	 *
	 * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
	 * instance is destroyed
	 *
	 * ### Example ([live example](http://plnkr.co/edit/1MBypRryXd64v4pV03Yn?p=preview))
	 *
	 * ```typesript
	 * @Component({
	 *   selector: 'my-cmp',
	 *   template: `<p>my-component</p>`
	 * })
	 * class MyComponent implements OnInit, OnDestroy {
	 *   ngOnInit() {
	 *     console.log('ngOnInit');
	 *   }
	 *
	 *   ngOnDestroy() {
	 *     console.log('ngOnDestroy');
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <button (click)="hasChild = !hasChild">
	 *       {{hasChild ? 'Destroy' : 'Create'}} MyComponent
	 *     </button>
	 *     <my-cmp *ngIf="hasChild"></my-cmp>`,
	 *   directives: [MyComponent, NgIf]
	 * })
	 * export class App {
	 *   hasChild = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 *
	 *
	 * To create a stateful Pipe, you should implement this interface and set the `pure`
	 * parameter to `false` in the {@link PipeMetadata}.
	 *
	 * A stateful pipe may produce different output, given the same input. It is
	 * likely that a stateful pipe may contain state that should be cleaned up when
	 * a binding is destroyed. For example, a subscription to a stream of data may need to
	 * be disposed, or an interval may need to be cleared.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/i8pm5brO4sPaLxBx56MR?p=preview))
	 *
	 * In this example, a pipe is created to countdown its input value, updating it every
	 * 50ms. Because it maintains an internal interval, it automatically clears
	 * the interval when the binding is destroyed or the countdown completes.
	 *
	 * ```
	 * import {OnDestroy, Pipe, PipeTransform} from '@angular/core'
	 * @Pipe({name: 'countdown', pure: false})
	 * class CountDown implements PipeTransform, OnDestroy {
	 *   remainingTime:Number;
	 *   interval:SetInterval;
	 *   ngOnDestroy() {
	 *     if (this.interval) {
	 *       clearInterval(this.interval);
	 *     }
	 *   }
	 *   transform(value: any, args: any[] = []) {
	 *     if (!parseInt(value, 10)) return null;
	 *     if (typeof this.remainingTime !== 'number') {
	 *       this.remainingTime = parseInt(value, 10);
	 *     }
	 *     if (!this.interval) {
	 *       this.interval = setInterval(() => {
	 *         this.remainingTime-=50;
	 *         if (this.remainingTime <= 0) {
	 *           this.remainingTime = 0;
	 *           clearInterval(this.interval);
	 *           delete this.interval;
	 *         }
	 *       }, 50);
	 *     }
	 *     return this.remainingTime;
	 *   }
	 * }
	 * ```
	 *
	 * Invoking `{{ 10000 | countdown }}` would cause the value to be decremented by 50,
	 * every 50ms, until it reaches 0.
	 *
	 * @stable
	 */
	var OnDestroy = function OnDestroy() {
	  classCallCheck(this, OnDestroy);
	};
	/**
	 * Implement this interface to get notified when your directive's content has been fully
	 * initialized.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/plamXUpsLQbIXpViZhUO?p=preview))
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: `{{where}} child`
	 * })
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `<ng-content></ng-content>`
	 * })
	 * class ParentComponent implements AfterContentInit {
	 *   @ContentChild(ChildComponent) contentChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // contentChild is not initialized yet
	 *     console.log(this.getMessage(this.contentChild));
	 *   }
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is updated after the content has been checked
	 *     console.log('AfterContentInit: ' + this.getMessage(this.contentChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <parent-cmp>
	 *       <child-cmp where="content"></child-cmp>
	 *     </parent-cmp>`,
	 *   directives: [ParentComponent, ChildComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterContentInit = function AfterContentInit() {
	  classCallCheck(this, AfterContentInit);
	};
	/**
	 * Implement this interface to get notified after every check of your directive's content.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/tGdrytNEKQnecIPkD7NU?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({selector: 'parent-cmp', template: `<ng-content></ng-content>`})
	 * class ParentComponent implements AfterContentChecked {
	 *   @ContentChild(ChildComponent) contentChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // contentChild is not initialized yet
	 *     console.log(this.getMessage(this.contentChild));
	 *   }
	 *
	 *   ngAfterContentChecked() {
	 *     // contentChild is updated after the content has been checked
	 *     console.log('AfterContentChecked: ' + this.getMessage(this.contentChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <parent-cmp>
	 *       <button (click)="hasContent = !hasContent">Toggle content child</button>
	 *       <child-cmp *ngIf="hasContent" where="content"></child-cmp>
	 *     </parent-cmp>`,
	 *   directives: [NgIf, ParentComponent, ChildComponent]
	 * })
	 * export class App {
	 *   hasContent = true;
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterContentChecked = function AfterContentChecked() {
	  classCallCheck(this, AfterContentChecked);
	};
	/**
	 * Implement this interface to get notified when your component's view has been fully initialized.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/LhTKVMEM0fkJgyp4CI1W?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `<child-cmp where="view"></child-cmp>`,
	 *   directives: [ChildComponent]
	 * })
	 * class ParentComponent implements AfterViewInit {
	 *   @ViewChild(ChildComponent) viewChild: ChildComponent;
	 *
	 *   constructor() {
	 *     // viewChild is not initialized yet
	 *     console.log(this.getMessage(this.viewChild));
	 *   }
	 *
	 *   ngAfterViewInit() {
	 *     // viewChild is updated after the view has been initialized
	 *     console.log('ngAfterViewInit: ' + this.getMessage(this.viewChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<parent-cmp></parent-cmp>`,
	 *   directives: [ParentComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterViewInit = function AfterViewInit() {
	  classCallCheck(this, AfterViewInit);
	};
	/**
	 * Implement this interface to get notified after every check of your component's view.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/0qDGHcPQkc25CXhTNzKU?p=preview))
	 *
	 * ```typescript
	 * @Component({selector: 'child-cmp', template: `{{where}} child`})
	 * class ChildComponent {
	 *   @Input() where: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'parent-cmp',
	 *   template: `
	 *     <button (click)="showView = !showView">Toggle view child</button>
	 *     <child-cmp *ngIf="showView" where="view"></child-cmp>`,
	 *   directives: [NgIf, ChildComponent]
	 * })
	 * class ParentComponent implements AfterViewChecked {
	 *   @ViewChild(ChildComponent) viewChild: ChildComponent;
	 *   showView = true;
	 *
	 *   constructor() {
	 *     // viewChild is not initialized yet
	 *     console.log(this.getMessage(this.viewChild));
	 *   }
	 *
	 *   ngAfterViewChecked() {
	 *     // viewChild is updated after the view has been checked
	 *     console.log('AfterViewChecked: ' + this.getMessage(this.viewChild));
	 *   }
	 *
	 *   private getMessage(cmp: ChildComponent): string {
	 *     return cmp ? cmp.where + ' child' : 'no child';
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<parent-cmp></parent-cmp>`,
	 *   directives: [ParentComponent]
	 * })
	 * export class App {
	 * }
	 *
	 * bootstrap(App).catch(err => console.error(err));
	 * ```
	 * @stable
	 */
	var AfterViewChecked = function AfterViewChecked() {
	  classCallCheck(this, AfterViewChecked);
	};

	var _nextClassId = 0;
	function extractAnnotation(annotation) {
	    if (isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
	        // it is a decorator, extract annotation
	        annotation = annotation.annotation;
	    }
	    return annotation;
	}
	function applyParams(fnOrArray, key) {
	    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function || fnOrArray === Number || fnOrArray === Array) {
	        throw new Error('Can not use native ' + stringify(fnOrArray) + ' as constructor');
	    }
	    if (isFunction(fnOrArray)) {
	        return fnOrArray;
	    } else if (fnOrArray instanceof Array) {
	        var annotations = fnOrArray;
	        var fn = fnOrArray[fnOrArray.length - 1];
	        if (!isFunction(fn)) {
	            throw new Error('Last position of Class method array must be Function in key ' + key + ' was \'' + stringify(fn) + '\'');
	        }
	        var annoLength = annotations.length - 1;
	        if (annoLength != fn.length) {
	            throw new Error('Number of annotations (' + annoLength + ') does not match number of arguments (' + fn.length + ') in the function: ' + stringify(fn));
	        }
	        var paramsAnnotations = [];
	        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
	            var paramAnnotations = [];
	            paramsAnnotations.push(paramAnnotations);
	            var annotation = annotations[i];
	            if (annotation instanceof Array) {
	                for (var j = 0; j < annotation.length; j++) {
	                    paramAnnotations.push(extractAnnotation(annotation[j]));
	                }
	            } else if (isFunction(annotation)) {
	                paramAnnotations.push(extractAnnotation(annotation));
	            } else {
	                paramAnnotations.push(annotation);
	            }
	        }
	        Reflect$1.defineMetadata('parameters', paramsAnnotations, fn);
	        return fn;
	    } else {
	        throw new Error('Only Function or Array is supported in Class definition for key \'' + key + '\' is \'' + stringify(fnOrArray) + '\'');
	    }
	}
	/**
	 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	 *
	 * ## Basic Example
	 *
	 * ```
	 * var Greeter = ng.Class({
	 *   constructor: function(name) {
	 *     this.name = name;
	 *   },
	 *
	 *   greet: function() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class Greeter {
	 *   constructor(name) {
	 *     this.name = name;
	 *   }
	 *
	 *   greet() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * }
	 * ```
	 *
	 * or equivalent to ES5:
	 *
	 * ```
	 * var Greeter = function (name) {
	 *   this.name = name;
	 * }
	 *
	 * Greeter.prototype.greet = function () {
	 *   alert('Hello ' + this.name + '!');
	 * }
	 * ```
	 *
	 * ### Example with parameter annotations
	 *
	 * ```
	 * var MyService = ng.Class({
	 *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
	 *     ...
	 *   }]
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class MyService {
	 *   constructor(name: string, @Query() queryList: QueryList) {
	 *     ...
	 *   }
	 * }
	 * ```
	 *
	 * ### Example with inheritance
	 *
	 * ```
	 * var Shape = ng.Class({
	 *   constructor: (color) {
	 *     this.color = color;
	 *   }
	 * });
	 *
	 * var Square = ng.Class({
	 *   extends: Shape,
	 *   constructor: function(color, size) {
	 *     Shape.call(this, color);
	 *     this.size = size;
	 *   }
	 * });
	 * ```
	 * @stable
	 */
	function Class(clsDef) {
	    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	    var proto = constructor.prototype;
	    if (clsDef.hasOwnProperty('extends')) {
	        if (isFunction(clsDef.extends)) {
	            constructor.prototype = proto = Object.create(clsDef.extends.prototype);
	        } else {
	            throw new Error('Class definition \'extends\' property must be a constructor function was: ' + stringify(clsDef.extends));
	        }
	    }
	    for (var key in clsDef) {
	        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
	            proto[key] = applyParams(clsDef[key], key);
	        }
	    }
	    if (this && this.annotations instanceof Array) {
	        Reflect$1.defineMetadata('annotations', this.annotations, constructor);
	    }
	    if (!constructor['name']) {
	        constructor['overriddenName'] = 'class' + _nextClassId++;
	    }
	    return constructor;
	}
	var Reflect$1 = global$1.Reflect;
	function makeDecorator(annotationCls /* TODO #9100 */) {
	    var chainFn = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    function DecoratorFactory(objOrType /** TODO #9100 */) {
	        var annotationInstance = new annotationCls(objOrType);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        } else {
	            var chainAnnotation = isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
	            chainAnnotation.push(annotationInstance);
	            var TypeDecorator = function TypeDecorator(cls /** TODO #9100 */) {
	                var annotations = Reflect$1.getOwnMetadata('annotations', cls);
	                annotations = annotations || [];
	                annotations.push(annotationInstance);
	                Reflect$1.defineMetadata('annotations', annotations, cls);
	                return cls;
	            };
	            TypeDecorator.annotations = chainAnnotation;
	            TypeDecorator.Class = Class;
	            if (chainFn) chainFn(TypeDecorator);
	            return TypeDecorator;
	        }
	    }
	    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    DecoratorFactory.annotationCls = annotationCls;
	    return DecoratorFactory;
	}
	function makeParamDecorator(annotationCls /** TODO #9100 */) {
	    function ParamDecoratorFactory() /** TODO #9100 */{
	        var annotationInstance = Object.create(annotationCls.prototype);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        annotationCls.apply(annotationInstance, args);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        } else {
	            ParamDecorator.annotation = annotationInstance;
	            return ParamDecorator;
	        }
	        function ParamDecorator(cls /** TODO #9100 */, unusedKey /** TODO #9100 */, index /** TODO #9100 */) {
	            var parameters = Reflect$1.getMetadata('parameters', cls);
	            parameters = parameters || [];
	            // there might be gaps if some in between parameters do not have annotations.
	            // we pad with nulls.
	            while (parameters.length <= index) {
	                parameters.push(null);
	            }
	            parameters[index] = parameters[index] || [];
	            var annotationsForParam = parameters[index];
	            annotationsForParam.push(annotationInstance);
	            Reflect$1.defineMetadata('parameters', parameters, cls);
	            return cls;
	        }
	    }
	    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    ParamDecoratorFactory.annotationCls = annotationCls;
	    return ParamDecoratorFactory;
	}
	function makePropDecorator(annotationCls /** TODO #9100 */) {
	    function PropDecoratorFactory() /** TODO #9100 */{
	        var decoratorInstance = Object.create(annotationCls.prototype);

	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	        }

	        annotationCls.apply(decoratorInstance, args);
	        if (this instanceof annotationCls) {
	            return decoratorInstance;
	        } else {
	            return function PropDecorator(target, name) {
	                var meta = Reflect$1.getOwnMetadata('propMetadata', target.constructor);
	                meta = meta || {};
	                meta[name] = meta[name] || [];
	                meta[name].unshift(decoratorInstance);
	                Reflect$1.defineMetadata('propMetadata', meta, target.constructor);
	            };
	        }
	    }
	    PropDecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    PropDecoratorFactory.annotationCls = annotationCls;
	    return PropDecoratorFactory;
	}

	// TODO(alexeagle): remove the duplication of this doc. It is copied from ComponentMetadata.
	/**
	 * Declare reusable UI building blocks for an application.
	 *
	 * Each Angular component requires a single `@Component` annotation. The `@Component`
	 * annotation specifies when a component is instantiated, and which properties and hostListeners it
	 * binds to.
	 *
	 * When a component is instantiated, Angular
	 * - creates a shadow DOM for the component.
	 * - loads the selected template into the shadow DOM.
	 * - creates all the injectable objects configured with `providers` and `viewProviders`.
	 *
	 * All template expressions and statements are then evaluated against the component instance.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the component class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the component.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='component'}
	 * @stable
	 * @Annotation
	 */
	var Component = makeDecorator(ComponentMetadata, function (fn) {
	  return fn.View = View;
	});
	// TODO(alexeagle): remove the duplication of this doc. It is copied from DirectiveMetadata.
	/**
	 * Directives allow you to attach behavior to elements in the DOM.
	 *
	 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
	 *
	 * A directive consists of a single directive annotation and a controller class. When the
	 * directive's `selector` matches
	 * elements in the DOM, the following steps occur:
	 *
	 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
	 * arguments.
	 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
	 * depth-first order,
	 *    as declared in the HTML.
	 *
	 * ## Understanding How Injection Works
	 *
	 * There are three stages of injection resolution.
	 * - *Pre-existing Injectors*:
	 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
	 * the dependency was
	 *     specified as `@Optional`, returns `null`.
	 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
	 * location, and others.
	 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
	 * the same parent-child hierarchy
	 *     as the component instances in the DOM.
	 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
	 * element has an `ElementInjector`
	 *     which follow the same parent-child hierarchy as the DOM elements themselves.
	 *
	 * When a template is instantiated, it also must instantiate the corresponding directives in a
	 * depth-first order. The
	 * current `ElementInjector` resolves the constructor dependencies for each directive.
	 *
	 * Angular then resolves dependencies as follows, according to the order in which they appear in the
	 * {@link ViewMetadata}:
	 *
	 * 1. Dependencies on the current element
	 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
	 * 3. Dependencies on component injectors and their parents until it encounters the root component
	 * 4. Dependencies on pre-existing injectors
	 *
	 *
	 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
	 * delegate to the parent
	 * injector.
	 *
	 * To inject other directives, declare the constructor parameter as:
	 * - `directive:DirectiveType`: a directive on the current element only
	 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
	 * element and the
	 *    Shadow DOM root.
	 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
	 * directives.
	 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
	 * child directives.
	 *
	 * To inject element-specific special objects, declare the constructor parameter as:
	 * - `element: ElementRef` to obtain a reference to logical element in the view.
	 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
	 * {@link DirectiveMetadata} directives only
	 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
	 *
	 * ### Example
	 *
	 * The following example demonstrates how dependency injection resolves constructor arguments in
	 * practice.
	 *
	 *
	 * Assume this HTML template:
	 *
	 * ```
	 * <div dependency="1">
	 *   <div dependency="2">
	 *     <div dependency="3" my-directive>
	 *       <div dependency="4">
	 *         <div dependency="5"></div>
	 *       </div>
	 *       <div dependency="6"></div>
	 *     </div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * With the following `dependency` decorator and `SomeService` injectable class.
	 *
	 * ```
	 * @Injectable()
	 * class SomeService {
	 * }
	 *
	 * @Directive({
	 *   selector: '[dependency]',
	 *   inputs: [
	 *     'id: dependency'
	 *   ]
	 * })
	 * class Dependency {
	 *   id:string;
	 * }
	 * ```
	 *
	 * Let's step through the different ways in which `MyDirective` could be declared...
	 *
	 *
	 * ### No injection
	 *
	 * Here the constructor is declared with no arguments, therefore nothing is injected into
	 * `MyDirective`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor() {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with no dependencies.
	 *
	 *
	 * ### Component-level injection
	 *
	 * Directives can inject any injectable instance from the closest component injector or any of its
	 * parents.
	 *
	 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
	 * from the parent
	 * component's injector.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(someService: SomeService) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a dependency on `SomeService`.
	 *
	 *
	 * ### Injecting a directive from the current element
	 *
	 * Directives can inject other directives declared on the current element.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(dependency: Dependency) {
	 *     expect(dependency.id).toEqual(3);
	 *   }
	 * }
	 * ```
	 * This directive would be instantiated with `Dependency` declared at the same element, in this case
	 * `dependency="3"`.
	 *
	 * ### Injecting a directive from any ancestor elements
	 *
	 * Directives can inject other directives declared on any ancestor element (in the current Shadow
	 * DOM), i.e. on the current element, the
	 * parent element, or its parents.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Host() dependency: Dependency) {
	 *     expect(dependency.id).toEqual(2);
	 *   }
	 * }
	 * ```
	 *
	 * `@Host` checks the current element, the parent, as well as its parents recursively. If
	 * `dependency="2"` didn't
	 * exist on the direct parent, this injection would
	 * have returned
	 * `dependency="1"`.
	 *
	 *
	 * ### Injecting a live collection of direct child directives
	 *
	 *
	 * A directive can also query for other child directives. Since parent directives are instantiated
	 * before child directives, a directive can't simply inject the list of child directives. Instead,
	 * the directive injects a {@link QueryList}, which updates its contents as children are added,
	 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ngFor`, an
	 * `ngIf`, or an `ngSwitch`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
	 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
	 *
	 * ### Injecting a live collection of descendant directives
	 *
	 * By passing the descendant flag to `@Query` above, we can include the children of the child
	 * elements.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
	 *
	 * ### Optional injection
	 *
	 * The normal behavior of directives is to return an error when a specified dependency cannot be
	 * resolved. If you
	 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
	 * with `@Optional()`.
	 * This explicitly permits the author of a template to treat some of the surrounding directives as
	 * optional.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Optional() dependency:Dependency) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a `Dependency` directive found on the current element.
	 * If none can be
	 * found, the injector supplies `null` instead of throwing an error.
	 *
	 * ### Example
	 *
	 * Here we use a decorator directive to simply define basic tool-tip behavior.
	 *
	 * ```
	 * @Directive({
	 *   selector: '[tooltip]',
	 *   inputs: [
	 *     'text: tooltip'
	 *   ],
	 *   host: {
	 *     '(mouseenter)': 'onMouseEnter()',
	 *     '(mouseleave)': 'onMouseLeave()'
	 *   }
	 * })
	 * class Tooltip{
	 *   text:string;
	 *   overlay:Overlay; // NOT YET IMPLEMENTED
	 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
	 *
	 *   constructor(overlayManager:OverlayManager) {
	 *     this.overlayManager = overlayManager;
	 *   }
	 *
	 *   onMouseEnter() {
	 *     // exact signature to be determined
	 *     this.overlay = this.overlayManager.open(text, ...);
	 *   }
	 *
	 *   onMouseLeave() {
	 *     this.overlay.close();
	 *     this.overlay = null;
	 *   }
	 * }
	 * ```
	 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
	 * `tooltip` selector,
	 * like so:
	 *
	 * ```
	 * <div tooltip="some text here"></div>
	 * ```
	 *
	 * Directives can also control the instantiation, destruction, and positioning of inline template
	 * elements:
	 *
	 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
	 * runtime.
	 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
	 * location in the current view
	 * where these actions are performed.
	 *
	 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
	 * `<template>` element. Thus a
	 * directive in a child view cannot inject the directive that created it.
	 *
	 * Since directives that create views via ViewContainers are common in Angular, and using the full
	 * `<template>` element syntax is wordy, Angular
	 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
	 * equivalent.
	 *
	 * Thus,
	 *
	 * ```
	 * <ul>
	 *   <li *foo="bar" title="text"></li>
	 * </ul>
	 * ```
	 *
	 * Expands in use to:
	 *
	 * ```
	 * <ul>
	 *   <template [foo]="bar">
	 *     <li title="text"></li>
	 *   </template>
	 * </ul>
	 * ```
	 *
	 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
	 * the directive
	 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the directive class implements some {@link ../../guide/lifecycle-hooks.html} the callbacks
	 * are called by the change detection at defined points in time during the life of the directive.
	 *
	 * ### Example
	 *
	 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
	 *
	 * Here is a simple directive that triggers on an `unless` selector:
	 *
	 * ```
	 * @Directive({
	 *   selector: '[unless]',
	 *   inputs: ['unless']
	 * })
	 * export class Unless {
	 *   viewContainer: ViewContainerRef;
	 *   templateRef: TemplateRef;
	 *   prevCondition: boolean;
	 *
	 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
	 *     this.viewContainer = viewContainer;
	 *     this.templateRef = templateRef;
	 *     this.prevCondition = null;
	 *   }
	 *
	 *   set unless(newCondition) {
	 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
	 *       this.prevCondition = true;
	 *       this.viewContainer.clear();
	 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
	 *       this.prevCondition = false;
	 *       this.viewContainer.create(this.templateRef);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * We can then use this `unless` selector in a template:
	 * ```
	 * <ul>
	 *   <li *unless="expr"></li>
	 * </ul>
	 * ```
	 *
	 * Once the directive instantiates the child view, the shorthand notation for the template expands
	 * and the result is:
	 *
	 * ```
	 * <ul>
	 *   <template [unless]="exp">
	 *     <li></li>
	 *   </template>
	 *   <li></li>
	 * </ul>
	 * ```
	 *
	 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
	 * the instantiated
	 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
	 * @stable
	 * @Annotation
	 */
	var Directive = makeDecorator(DirectiveMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewMetadata.
	/**
	 * Metadata properties available for configuring Views.
	 *
	 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
	 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
	 * within the template.
	 *
	 * When a component is instantiated, the template is loaded into the component's shadow root, and
	 * the expressions and statements in the template are evaluated against the component.
	 *
	 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
	 *
	 * ### Example
	 *
	 * ```
	 * @Component({
	 *   selector: 'greet',
	 *   template: 'Hello {{name}}!',
	 *   directives: [GreetUser, Bold]
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 * @deprecated
	 * @Annotation
	 */
	var View = makeDecorator(ViewMetadata, function (fn) {
	  return fn.View = View;
	});
	/**
	 * Specifies that a constant attribute value should be injected.
	 *
	 * The directive can inject constant string literals of host element attributes.
	 *
	 * ### Example
	 *
	 * Suppose we have an `<input>` element and want to know its `type`.
	 *
	 * ```html
	 * <input type="text">
	 * ```
	 *
	 * A decorator can inject string literal `text` like so:
	 *
	 * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
	 * @stable
	 * @Annotation
	 */
	var Attribute = makeParamDecorator(AttributeMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildrenMetadata.
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChildren(ChildDirective) contentChildren: QueryList<ChildDirective>;
	 *
	 *   ngAfterContentInit() {
	 *     // contentChildren is set
	 *   }
	 * }
	 * ```
	 * @stable
	 * @Annotation
	 */
	var ContentChildren = makePropDecorator(ContentChildrenMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ContentChildMetadata.
	/**
	 * Configures a content query.
	 *
	 * Content queries are set before the `ngAfterContentInit` callback is called.
	 *
	 * ### Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'someDir'
	 * })
	 * class SomeDir {
	 *   @ContentChild(ChildDirective) contentChild;
	 *   @ContentChild('container_ref') containerChild
	 *
	 *   ngAfterContentInit() {
	 *     // contentChild is set
	 *     // containerChild is set
	 *   }
	 * }
	 * ```
	 *
	 * ```html
	 * <container #container_ref>
	 *   <item>a</item>
	 *   <item>b</item>
	 * </container>
	 * ```
	 * @stable
	 * @Annotation
	 */
	var ContentChild = makePropDecorator(ContentChildMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildrenMetadata.
	/**
	 * Declares a list of child element references.
	 *
	 * Angular automatically updates the list when the DOM is updated.
	 *
	 * `ViewChildren` takes a argument to select elements.
	 *
	 * - If the argument is a type, directives or components with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a list of comma-separated selectors.
	 * For each selector, an element containing the matching template variable (e.g. `#child`) will be
	 * bound.
	 *
	 * View children are set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *     <child-cmp></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren(ChildCmp) children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: `
	 *     <child-cmp #child1></child-cmp>
	 *     <child-cmp #child2></child-cmp>
	 *     <child-cmp #child3></child-cmp>
	 *   `,
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChildren('child1,child2,child3') children:QueryList<ChildCmp>;
	 *
	 *   ngAfterViewInit() {
	 *     // children are set
	 *     this.children.toArray().forEach((child)=>child.doSomething());
	 *   }
	 * }
	 * ```
	 *
	 * See also: [ViewChildrenMetadata]
	 * @stable
	 * @Annotation
	 */
	var ViewChildren = makePropDecorator(ViewChildrenMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from ViewChildMetadata.
	/**
	 * Declares a reference to a child element.
	 *
	 * `ViewChildren` takes a argument to select elements.
	 *
	 * - If the argument is a type, a directive or a component with the type will be bound.
	 *
	 * - If the argument is a string, the string is interpreted as a selector. An element containing the
	 * matching template variable (e.g. `#child`) will be bound.
	 *
	 * In either case, `@ViewChild()` assigns the first (looking from above) element if there are
	 * multiple matches.
	 *
	 * View child is set before the `ngAfterViewInit` callback is called.
	 *
	 * ### Example
	 *
	 * With type selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild(ChildCmp) child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 *
	 * With string selector:
	 *
	 * ```
	 * @Component({
	 *   selector: 'child-cmp',
	 *   template: '<p>child</p>'
	 * })
	 * class ChildCmp {
	 *   doSomething() {}
	 * }
	 *
	 * @Component({
	 *   selector: 'some-cmp',
	 *   template: '<child-cmp #child></child-cmp>',
	 *   directives: [ChildCmp]
	 * })
	 * class SomeCmp {
	 *   @ViewChild('child') child:ChildCmp;
	 *
	 *   ngAfterViewInit() {
	 *     // child is set
	 *     this.child.doSomething();
	 *   }
	 * }
	 * ```
	 * See also: [ViewChildMetadata]
	 * @stable
	 * @Annotation
	 */
	var ViewChild = makePropDecorator(ViewChildMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from PipeMetadata.
	/**
	 * Declare reusable pipe function.
	 *
	 * ### Example
	 *
	 * {@example core/ts/metadata/metadata.ts region='pipe'}
	 * @stable
	 * @Annotation
	 */
	var Pipe = makeDecorator(PipeMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from InputMetadata.
	/**
	 * Declares a data-bound input property.
	 *
	 * Angular automatically updates data-bound properties during change detection.
	 *
	 * `InputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * The following example creates a component with two input properties.
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'bank-account',
	 *   template: `
	 *     Bank Name: {{bankName}}
	 *     Account Id: {{id}}
	 *   `
	 * })
	 * class BankAccount {
	 *   @Input() bankName: string;
	 *   @Input('account-id') id: string;
	 *
	 *   // this property is not bound, and won't be automatically updated by Angular
	 *   normalizedBankName: string;
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
	 *   `,
	 *   directives: [BankAccount]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	var Input = makePropDecorator(InputMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from OutputMetadata.
	/**
	 * Declares an event-bound output property.
	 *
	 * When an output property emits an event, an event handler attached to that event
	 * the template is invoked.
	 *
	 * `OutputMetadata` takes an optional parameter that specifies the name
	 * used when instantiating a component in the template. When not provided,
	 * the name of the decorated property is used.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Directive({
	 *   selector: 'interval-dir',
	 * })
	 * class IntervalDir {
	 *   @Output() everySecond = new EventEmitter();
	 *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
	 *
	 *   constructor() {
	 *     setInterval(() => this.everySecond.emit("event"), 1000);
	 *     setInterval(() => this.five5Secs.emit("event"), 5000);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `
	 *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
	 *     </interval-dir>
	 *   `,
	 *   directives: [IntervalDir]
	 * })
	 * class App {
	 *   everySecond() { console.log('second'); }
	 *   everyFiveSeconds() { console.log('five seconds'); }
	 * }
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	var Output = makePropDecorator(OutputMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from HostBindingMetadata.
	/**
	 * Declares a host property binding.
	 *
	 * Angular automatically checks host property bindings during change detection.
	 * If a binding changes, it will update the host element of the directive.
	 *
	 * `HostBindingMetadata` takes an optional parameter that specifies the property
	 * name of the host element that will be updated. When not provided,
	 * the class property name is used.
	 *
	 * ### Example
	 *
	 * The following example creates a directive that sets the `valid` and `invalid` classes
	 * on the DOM element that has ngModel directive on it.
	 *
	 * ```typescript
	 * @Directive({selector: '[ngModel]'})
	 * class NgModelStatus {
	 *   constructor(public control:NgModel) {}
	 *   @HostBinding('class.valid') get valid() { return this.control.valid; }
	 *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<input [(ngModel)]="prop">`,
	 *   directives: [FORM_DIRECTIVES, NgModelStatus]
	 * })
	 * class App {
	 *   prop;
	 * }
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	var HostBinding = makePropDecorator(HostBindingMetadata);
	// TODO(alexeagle): remove the duplication of this doc. It is copied from HostListenerMetadata.
	/**
	 * Declares a host listener.
	 *
	 * Angular will invoke the decorated method when the host element emits the specified event.
	 *
	 * If the decorated method returns `false`, then `preventDefault` is applied on the DOM
	 * event.
	 *
	 * ### Example
	 *
	 * The following example declares a directive that attaches a click listener to the button and
	 * counts clicks.
	 *
	 * ```typescript
	 * @Directive({selector: 'button[counting]'})
	 * class CountClicks {
	 *   numberOfClicks = 0;
	 *
	 *   @HostListener('click', ['$event.target'])
	 *   onClick(btn) {
	 *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'app',
	 *   template: `<button counting>Increment</button>`,
	 *   directives: [CountClicks]
	 * })
	 * class App {}
	 *
	 * bootstrap(App);
	 * ```
	 * @stable
	 * @Annotation
	 */
	var HostListener = makePropDecorator(HostListenerMetadata);

	/**
	 * Factory for creating {@link InjectMetadata}.
	 * @stable
	 * @Annotation
	 */
	var Inject = makeParamDecorator(InjectMetadata);
	/**
	 * Factory for creating {@link OptionalMetadata}.
	 * @stable
	 * @Annotation
	 */
	var Optional = makeParamDecorator(OptionalMetadata);
	/**
	 * Factory for creating {@link InjectableMetadata}.
	 * @stable
	 * @Annotation
	 */
	var Injectable = makeDecorator(InjectableMetadata);
	/**
	 * Factory for creating {@link SelfMetadata}.
	 * @stable
	 * @Annotation
	 */
	var Self = makeParamDecorator(SelfMetadata);
	/**
	 * Factory for creating {@link HostMetadata}.
	 * @stable
	 * @Annotation
	 */
	var Host = makeParamDecorator(HostMetadata);
	/**
	 * Factory for creating {@link SkipSelfMetadata}.
	 * @stable
	 * @Annotation
	 */
	var SkipSelf = makeParamDecorator(SkipSelfMetadata);

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException = function (_Error) {
	  inherits(BaseWrappedException, _Error);

	  function BaseWrappedException(message) {
	    classCallCheck(this, BaseWrappedException);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(BaseWrappedException).call(this, message));
	  }

	  createClass(BaseWrappedException, [{
	    key: 'wrapperMessage',
	    get: function get() {
	      return '';
	    }
	  }, {
	    key: 'wrapperStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalException',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'message',
	    get: function get() {
	      return '';
	    }
	  }]);
	  return BaseWrappedException;
	}(Error);

	var Map$1 = global$1.Map;
	var Set$1 = global$1.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs = function () {
	    try {
	        if (new Map$1([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) {
	                return new Map$1(pairs);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new Map$1();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	}();
	var createMapFromMap = function () {
	    try {
	        if (new Map$1(new Map$1())) {
	            return function createMapFromMap(m) {
	                return new Map$1(m);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromMap(m) {
	        var map = new Map$1();
	        m.forEach(function (v, k) {
	            map.set(k, v);
	        });
	        return map;
	    };
	}();
	var _clearValues = function () {
	    if (new Map$1().keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!(k = keyIterator.next()).done) {
	                m.set(k.value, null);
	            }
	        };
	    } else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) {
	                m.set(k, null);
	            });
	        };
	    }
	}();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap = function () {
	    try {
	        if (new Map$1().values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    } catch (e) {}
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper.createFixedSize(m.size),
	            i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	}();
	var MapWrapper = function () {
	    function MapWrapper() {
	        classCallCheck(this, MapWrapper);
	    }

	    createClass(MapWrapper, null, [{
	        key: 'clone',
	        value: function clone(m) {
	            return createMapFromMap(m);
	        }
	    }, {
	        key: 'createFromStringMap',
	        value: function createFromStringMap(stringMap) {
	            var result = new Map$1();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        }
	    }, {
	        key: 'toStringMap',
	        value: function toStringMap(m) {
	            var r = {};
	            m.forEach(function (v, k) {
	                return r[k] = v;
	            });
	            return r;
	        }
	    }, {
	        key: 'createFromPairs',
	        value: function createFromPairs(pairs) {
	            return createMapFromPairs(pairs);
	        }
	    }, {
	        key: 'clearValues',
	        value: function clearValues(m) {
	            _clearValues(m);
	        }
	    }, {
	        key: 'iterable',
	        value: function iterable(m) {
	            return m;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(m) {
	            return _arrayFromMap(m, false);
	        }
	    }, {
	        key: 'values',
	        value: function values(m) {
	            return _arrayFromMap(m, true);
	        }
	    }]);
	    return MapWrapper;
	}();
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper = function () {
	    function StringMapWrapper() {
	        classCallCheck(this, StringMapWrapper);
	    }

	    createClass(StringMapWrapper, null, [{
	        key: 'create',
	        value: function create() {
	            // Note: We are not using Object.create(null) here due to
	            // performance!
	            // http://jsperf.com/ng2-object-create-null
	            return {};
	        }
	    }, {
	        key: 'contains',
	        value: function contains(map, key) {
	            return map.hasOwnProperty(key);
	        }
	    }, {
	        key: 'get',
	        value: function get(map, key) {
	            return map.hasOwnProperty(key) ? map[key] : undefined;
	        }
	    }, {
	        key: 'set',
	        value: function set(map, key, value) {
	            map[key] = value;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(map) {
	            return Object.keys(map);
	        }
	    }, {
	        key: 'values',
	        value: function values(map) {
	            return Object.keys(map).reduce(function (r, a) {
	                r.push(map[a]);
	                return r;
	            }, []);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(map) {
	            for (var prop in map) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(map, key) {
	            delete map[key];
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(map, callback) {
	            for (var prop in map) {
	                if (map.hasOwnProperty(prop)) {
	                    callback(map[prop], prop);
	                }
	            }
	        }
	    }, {
	        key: 'merge',
	        value: function merge(m1, m2) {
	            var m = {};
	            for (var attr in m1) {
	                if (m1.hasOwnProperty(attr)) {
	                    m[attr] = m1[attr];
	                }
	            }
	            for (var attr in m2) {
	                if (m2.hasOwnProperty(attr)) {
	                    m[attr] = m2[attr];
	                }
	            }
	            return m;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            var key;
	            for (var i = 0; i < k1.length; i++) {
	                key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }]);
	    return StringMapWrapper;
	}();
	var ListWrapper = function () {
	    function ListWrapper() {
	        classCallCheck(this, ListWrapper);
	    }

	    createClass(ListWrapper, null, [{
	        key: 'createFixedSize',

	        // JS has no way to express a statically fixed size list, but dart does so we
	        // keep both methods.
	        value: function createFixedSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'createGrowableSize',
	        value: function createGrowableSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'clone',
	        value: function clone(array) {
	            return array.slice(0);
	        }
	    }, {
	        key: 'forEachWithIndex',
	        value: function forEachWithIndex(array, fn) {
	            for (var i = 0; i < array.length; i++) {
	                fn(array[i], i);
	            }
	        }
	    }, {
	        key: 'first',
	        value: function first(array) {
	            if (!array) return null;
	            return array[0];
	        }
	    }, {
	        key: 'last',
	        value: function last(array) {
	            if (!array || array.length == 0) return null;
	            return array[array.length - 1];
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(array, value) {
	            var startIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	            return array.indexOf(value, startIndex);
	        }
	    }, {
	        key: 'contains',
	        value: function contains(list, el) {
	            return list.indexOf(el) !== -1;
	        }
	    }, {
	        key: 'reversed',
	        value: function reversed(array) {
	            var a = ListWrapper.clone(array);
	            return a.reverse();
	        }
	    }, {
	        key: 'concat',
	        value: function concat(a, b) {
	            return a.concat(b);
	        }
	    }, {
	        key: 'insert',
	        value: function insert(list, index, value) {
	            list.splice(index, 0, value);
	        }
	    }, {
	        key: 'removeAt',
	        value: function removeAt(list, index) {
	            var res = list[index];
	            list.splice(index, 1);
	            return res;
	        }
	    }, {
	        key: 'removeAll',
	        value: function removeAll(list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'clear',
	        value: function clear(list) {
	            list.length = 0;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(list) {
	            return list.length == 0;
	        }
	    }, {
	        key: 'fill',
	        value: function fill(list, value) {
	            var start = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	            var end = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            list.fill(value, start, end === null ? list.length : end);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(a, b) {
	            if (a.length != b.length) return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i]) return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'slice',
	        value: function slice(l) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return l.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'splice',
	        value: function splice(l, from, length) {
	            return l.splice(from, length);
	        }
	    }, {
	        key: 'sort',
	        value: function sort(l, compareFn) {
	            if (isPresent(compareFn)) {
	                l.sort(compareFn);
	            } else {
	                l.sort();
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString(l) {
	            return l.toString();
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON(l) {
	            return JSON.stringify(l);
	        }
	    }, {
	        key: 'maximum',
	        value: function maximum(list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (isBlank(candidate)) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        }
	    }, {
	        key: 'flatten',
	        value: function flatten(list) {
	            var target = [];
	            _flattenArray(list, target);
	            return target;
	        }
	    }, {
	        key: 'addAll',
	        value: function addAll(list, source) {
	            for (var i = 0; i < source.length; i++) {
	                list.push(source[i]);
	            }
	        }
	    }]);
	    return ListWrapper;
	}();
	function _flattenArray(source, target) {
	    if (isPresent(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (isArray(item)) {
	                _flattenArray(item, target);
	            } else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable(obj) {
	    if (!isJsObject(obj)) return false;
	    return isArray(obj) || !(obj instanceof Map$1) && getSymbolIterator() in obj; // JS Iterable have a Symbol.iterator prop
	}
	function areIterablesEqual(a, b, comparator) {
	    var iterator1 = a[getSymbolIterator()]();
	    var iterator2 = b[getSymbolIterator()]();
	    while (true) {
	        var item1 = iterator1.next();
	        var item2 = iterator2.next();
	        if (item1.done && item2.done) return true;
	        if (item1.done || item2.done) return false;
	        if (!comparator(item1.value, item2.value)) return false;
	    }
	}
	function iterateListLike(obj, fn) {
	    if (isArray(obj)) {
	        for (var i = 0; i < obj.length; i++) {
	            fn(obj[i]);
	        }
	    } else {
	        var iterator = obj[getSymbolIterator()]();
	        var item;
	        while (!(item = iterator.next()).done) {
	            fn(item.value);
	        }
	    }
	}
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList = function () {
	    var test = new Set$1([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) {
	            return new Set$1(lst);
	        };
	    } else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new Set$1(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	}();
	var SetWrapper = function () {
	    function SetWrapper() {
	        classCallCheck(this, SetWrapper);
	    }

	    createClass(SetWrapper, null, [{
	        key: 'createFromList',
	        value: function createFromList(lst) {
	            return createSetFromList(lst);
	        }
	    }, {
	        key: 'has',
	        value: function has(s, key) {
	            return s.has(key);
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(m, k) {
	            m.delete(k);
	        }
	    }]);
	    return SetWrapper;
	}();

	var _ArrayLogger = function () {
	    function _ArrayLogger() {
	        classCallCheck(this, _ArrayLogger);

	        this.res = [];
	    }

	    createClass(_ArrayLogger, [{
	        key: 'log',
	        value: function log(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logError',
	        value: function logError(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return _ArrayLogger;
	}();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */


	var ExceptionHandler = function () {
	    function ExceptionHandler(_logger) {
	        var _rethrowException = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        classCallCheck(this, ExceptionHandler);

	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }

	    createClass(ExceptionHandler, [{
	        key: 'call',
	        value: function call(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var originalException = this._findOriginalException(exception);
	            var originalStack = this._findOriginalStack(exception);
	            var context = this._findContext(exception);
	            this._logger.logGroup('EXCEPTION: ' + this._extractMessage(exception));
	            if (isPresent(stackTrace) && isBlank(originalStack)) {
	                this._logger.logError('STACKTRACE:');
	                this._logger.logError(this._longStackTrace(stackTrace));
	            }
	            if (isPresent(reason)) {
	                this._logger.logError('REASON: ' + reason);
	            }
	            if (isPresent(originalException)) {
	                this._logger.logError('ORIGINAL EXCEPTION: ' + this._extractMessage(originalException));
	            }
	            if (isPresent(originalStack)) {
	                this._logger.logError('ORIGINAL STACKTRACE:');
	                this._logger.logError(this._longStackTrace(originalStack));
	            }
	            if (isPresent(context)) {
	                this._logger.logError('ERROR CONTEXT:');
	                this._logger.logError(context);
	            }
	            this._logger.logGroupEnd();
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	            if (this._rethrowException) throw exception;
	        }
	        /** @internal */

	    }, {
	        key: '_extractMessage',
	        value: function _extractMessage(exception) {
	            return exception instanceof BaseWrappedException ? exception.wrapperMessage : exception.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_longStackTrace',
	        value: function _longStackTrace(stackTrace) {
	            return isListLikeIterable(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_findContext',
	        value: function _findContext(exception) {
	            try {
	                if (!(exception instanceof BaseWrappedException)) return null;
	                return isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
	            } catch (e) {
	                // exception.context can throw an exception. if it happens, we ignore the context.
	                return null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalException',
	        value: function _findOriginalException(exception) {
	            if (!(exception instanceof BaseWrappedException)) return null;
	            var e = exception.originalException;
	            while (e instanceof BaseWrappedException && isPresent(e.originalException)) {
	                e = e.originalException;
	            }
	            return e;
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalStack',
	        value: function _findOriginalStack(exception) {
	            if (!(exception instanceof BaseWrappedException)) return null;
	            var e = exception;
	            var stack = exception.originalStack;
	            while (e instanceof BaseWrappedException && isPresent(e.originalException)) {
	                e = e.originalException;
	                if (e instanceof BaseWrappedException && isPresent(e.originalException)) {
	                    stack = e.originalStack;
	                }
	            }
	            return stack;
	        }
	    }], [{
	        key: 'exceptionToString',
	        value: function exceptionToString(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var l = new _ArrayLogger();
	            var e = new ExceptionHandler(l, false);
	            e.call(exception, stackTrace, reason);
	            return l.res.join('\n');
	        }
	    }]);
	    return ExceptionHandler;
	}();

	/**
	 * @stable
	 */
	var BaseException = function (_Error) {
	    inherits(BaseException, _Error);

	    function BaseException() {
	        var message = arguments.length <= 0 || arguments[0] === undefined ? '--' : arguments[0];
	        classCallCheck(this, BaseException);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseException).call(this, message));

	        _this.message = message;
	        _this.stack = new Error(message).stack;
	        return _this;
	    }

	    createClass(BaseException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return BaseException;
	}(Error);
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException = function (_BaseWrappedException) {
	    inherits(WrappedException, _BaseWrappedException);

	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        classCallCheck(this, WrappedException);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(WrappedException).call(this, _wrapperMessage));

	        _this2._wrapperMessage = _wrapperMessage;
	        _this2._originalException = _originalException;
	        _this2._originalStack = _originalStack;
	        _this2._context = _context;
	        _this2._wrapperStack = new Error(_wrapperMessage).stack;
	        return _this2;
	    }

	    createClass(WrappedException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            return this._wrapperMessage;
	        }
	    }, {
	        key: 'wrapperStack',
	        get: function get() {
	            return this._wrapperStack;
	        }
	    }, {
	        key: 'originalException',
	        get: function get() {
	            return this._originalException;
	        }
	    }, {
	        key: 'originalStack',
	        get: function get() {
	            return this._originalStack;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._context;
	        }
	    }, {
	        key: 'message',
	        get: function get() {
	            return ExceptionHandler.exceptionToString(this);
	        }
	    }]);
	    return WrappedException;
	}(BaseWrappedException);
	function unimplemented() {
	    throw new BaseException('unimplemented');
	}

	var _THROW_IF_NOT_FOUND = new Object();
	var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	/**
	 * @stable
	 */
	var Injector = function () {
	  function Injector() {
	    classCallCheck(this, Injector);
	  }

	  createClass(Injector, [{
	    key: 'get',

	    /**
	     * Retrieves an instance from the injector based on the provided token.
	     * If not found:
	     * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
	     * Injector.THROW_IF_NOT_FOUND is given
	     * - Returns the `notFoundValue` otherwise
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/HeXSHg?p=preview))
	     *
	     * ```typescript
	     * var injector = ReflectiveInjector.resolveAndCreate([
	     *   {provide: "validToken", useValue: "Value"}
	     * ]);
	     * expect(injector.get("validToken")).toEqual("Value");
	     * expect(() => injector.get("invalidToken")).toThrowError();
	     * ```
	     *
	     * `Injector` returns itself when given `Injector` as a token.
	     *
	     * ```typescript
	     * var injector = ReflectiveInjector.resolveAndCreate([]);
	     * expect(injector.get(Injector)).toBe(injector);
	     * ```
	     */
	    value: function get(token, notFoundValue) {
	      return unimplemented();
	    }
	  }]);
	  return Injector;
	}();
	Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;

	function findFirstClosedCycle(keys) {
	    var res = [];
	    for (var i = 0; i < keys.length; ++i) {
	        if (ListWrapper.contains(res, keys[i])) {
	            res.push(keys[i]);
	            return res;
	        }
	        res.push(keys[i]);
	    }
	    return res;
	}
	function constructResolvingPath(keys) {
	    if (keys.length > 1) {
	        var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
	        var tokenStrs = reversed.map(function (k) {
	            return stringify(k.token);
	        });
	        return ' (' + tokenStrs.join(' -> ') + ')';
	    }
	    return '';
	}
	/**
	 * Base class for all errors arising from misconfigured providers.
	 * @stable
	 */
	var AbstractProviderError = function (_BaseException) {
	    inherits(AbstractProviderError, _BaseException);

	    function AbstractProviderError(injector, key, constructResolvingMessage) {
	        classCallCheck(this, AbstractProviderError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AbstractProviderError).call(this, 'DI Exception'));

	        _this.keys = [key];
	        _this.injectors = [injector];
	        _this.constructResolvingMessage = constructResolvingMessage;
	        _this.message = _this.constructResolvingMessage(_this.keys);
	        return _this;
	    }

	    createClass(AbstractProviderError, [{
	        key: 'addKey',
	        value: function addKey(injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	            this.message = this.constructResolvingMessage(this.keys);
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this.injectors[this.injectors.length - 1].debugContext();
	        }
	    }]);
	    return AbstractProviderError;
	}(BaseException);
	/**
	 * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
	 * {@link Injector} does not have a {@link Provider} for {@link Key}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b:B) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 * @stable
	 */
	var NoProviderError = function (_AbstractProviderErro) {
	    inherits(NoProviderError, _AbstractProviderErro);

	    function NoProviderError(injector, key) {
	        classCallCheck(this, NoProviderError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(NoProviderError).call(this, injector, key, function (keys) {
	            var first = stringify(ListWrapper.first(keys).token);
	            return 'No provider for ' + first + '!' + constructResolvingPath(keys);
	        }));
	    }

	    return NoProviderError;
	}(AbstractProviderError);
	/**
	 * Thrown when dependencies form a cycle.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	 *
	 * ```typescript
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	 *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	 * ]);
	 *
	 * expect(() => injector.get("one")).toThrowError();
	 * ```
	 *
	 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	 * @stable
	 */
	var CyclicDependencyError = function (_AbstractProviderErro2) {
	    inherits(CyclicDependencyError, _AbstractProviderErro2);

	    function CyclicDependencyError(injector, key) {
	        classCallCheck(this, CyclicDependencyError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(CyclicDependencyError).call(this, injector, key, function (keys) {
	            return 'Cannot instantiate cyclic dependency!' + constructResolvingPath(keys);
	        }));
	    }

	    return CyclicDependencyError;
	}(AbstractProviderError);
	/**
	 * Thrown when a constructing type returns with an Error.
	 *
	 * The `InstantiationError` class contains the original error plus the dependency graph which caused
	 * this object to be instantiated.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor() {
	 *     throw new Error('message');
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([A]);

	 * try {
	 *   injector.get(A);
	 * } catch (e) {
	 *   expect(e instanceof InstantiationError).toBe(true);
	 *   expect(e.originalException.message).toEqual("message");
	 *   expect(e.originalStack).toBeDefined();
	 * }
	 * ```
	 * @stable
	 */
	var InstantiationError = function (_WrappedException) {
	    inherits(InstantiationError, _WrappedException);

	    function InstantiationError(injector, originalException, originalStack, key) {
	        classCallCheck(this, InstantiationError);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(InstantiationError).call(this, 'DI Exception', originalException, originalStack, null));

	        _this4.keys = [key];
	        _this4.injectors = [injector];
	        return _this4;
	    }

	    createClass(InstantiationError, [{
	        key: 'addKey',
	        value: function addKey(injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            var first = stringify(ListWrapper.first(this.keys).token);
	            return 'Error during instantiation of ' + first + '!' + constructResolvingPath(this.keys) + '.';
	        }
	    }, {
	        key: 'causeKey',
	        get: function get() {
	            return this.keys[0];
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this.injectors[this.injectors.length - 1].debugContext();
	        }
	    }]);
	    return InstantiationError;
	}(WrappedException);
	/**
	 * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
	 * creation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	 * ```
	 * @stable
	 */
	var InvalidProviderError = function (_BaseException2) {
	    inherits(InvalidProviderError, _BaseException2);

	    function InvalidProviderError(provider) {
	        classCallCheck(this, InvalidProviderError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(InvalidProviderError).call(this, 'Invalid provider - only instances of Provider and Type are allowed, got: ' + provider));
	    }

	    return InvalidProviderError;
	}(BaseException);
	/**
	 * Thrown when the class has no annotation information.
	 *
	 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
	 * need to be injected into the constructor.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	 *
	 * ```typescript
	 * class A {
	 *   constructor(b) {}
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	 * ```
	 *
	 * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
	 *
	 * ```typescript
	 * class B {}
	 *
	 * class A {
	 *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	 * }
	 *
	 * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	 * ```
	 * @stable
	 */
	var NoAnnotationError = function (_BaseException3) {
	    inherits(NoAnnotationError, _BaseException3);

	    function NoAnnotationError(typeOrFunc, params) {
	        classCallCheck(this, NoAnnotationError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(NoAnnotationError).call(this, NoAnnotationError._genMessage(typeOrFunc, params)));
	    }

	    createClass(NoAnnotationError, null, [{
	        key: '_genMessage',
	        value: function _genMessage(typeOrFunc, params) {
	            var signature = [];
	            for (var i = 0, ii = params.length; i < ii; i++) {
	                var parameter = params[i];
	                if (isBlank(parameter) || parameter.length == 0) {
	                    signature.push('?');
	                } else {
	                    signature.push(parameter.map(stringify).join(' '));
	                }
	            }
	            return 'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' + signature.join(', ') + '). ' + 'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' + stringify(typeOrFunc) + '\' is decorated with Injectable.';
	        }
	    }]);
	    return NoAnnotationError;
	}(BaseException);
	/**
	 * Thrown when getting an object by index.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	 *
	 * ```typescript
	 * class A {}
	 *
	 * var injector = Injector.resolveAndCreate([A]);
	 *
	 * expect(() => injector.getAt(100)).toThrowError();
	 * ```
	 * @stable
	 */
	var OutOfBoundsError = function (_BaseException4) {
	    inherits(OutOfBoundsError, _BaseException4);

	    function OutOfBoundsError(index) {
	        classCallCheck(this, OutOfBoundsError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(OutOfBoundsError).call(this, 'Index ' + index + ' is out-of-bounds.'));
	    }

	    return OutOfBoundsError;
	}(BaseException);
	// TODO: add a working example after alpha38 is released
	/**
	 * Thrown when a multi provider and a regular provider are bound to the same token.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * expect(() => Injector.resolveAndCreate([
	 *   new Provider("Strings", {useValue: "string1", multi: true}),
	 *   new Provider("Strings", {useValue: "string2", multi: false})
	 * ])).toThrowError();
	 * ```
	 */
	var MixingMultiProvidersWithRegularProvidersError = function (_BaseException5) {
	    inherits(MixingMultiProvidersWithRegularProvidersError, _BaseException5);

	    function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	        classCallCheck(this, MixingMultiProvidersWithRegularProvidersError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(MixingMultiProvidersWithRegularProvidersError).call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' + provider2.toString()));
	    }

	    return MixingMultiProvidersWithRegularProvidersError;
	}(BaseException);

	/**
	 * A unique object used for retrieving items from the {@link ReflectiveInjector}.
	 *
	 * Keys have:
	 * - a system-wide unique `id`.
	 * - a `token`.
	 *
	 * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
	 * the
	 * injector to store created objects in a more efficient way.
	 *
	 * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
	 * resolving
	 * providers.
	 * @experimental
	 */
	var ReflectiveKey = function () {
	    /**
	     * Private
	     */

	    function ReflectiveKey(token, id) {
	        classCallCheck(this, ReflectiveKey);

	        this.token = token;
	        this.id = id;
	        if (isBlank(token)) {
	            throw new BaseException('Token must be defined!');
	        }
	    }
	    /**
	     * Returns a stringified token.
	     */


	    createClass(ReflectiveKey, [{
	        key: 'displayName',
	        get: function get() {
	            return stringify(this.token);
	        }
	        /**
	         * Retrieves a `Key` for a token.
	         */

	    }], [{
	        key: 'get',
	        value: function get(token) {
	            return _globalKeyRegistry.get(resolveForwardRef(token));
	        }
	        /**
	         * @returns the number of keys registered in the system.
	         */

	    }, {
	        key: 'numberOfKeys',
	        get: function get() {
	            return _globalKeyRegistry.numberOfKeys;
	        }
	    }]);
	    return ReflectiveKey;
	}();
	/**
	 * @internal
	 */
	var KeyRegistry = function () {
	    function KeyRegistry() {
	        classCallCheck(this, KeyRegistry);

	        this._allKeys = new Map();
	    }

	    createClass(KeyRegistry, [{
	        key: 'get',
	        value: function get(token) {
	            if (token instanceof ReflectiveKey) return token;
	            if (this._allKeys.has(token)) {
	                return this._allKeys.get(token);
	            }
	            var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	            this._allKeys.set(token, newKey);
	            return newKey;
	        }
	    }, {
	        key: 'numberOfKeys',
	        get: function get() {
	            return this._allKeys.size;
	        }
	    }]);
	    return KeyRegistry;
	}();
	var _globalKeyRegistry = new KeyRegistry();

	var ReflectionCapabilities = function () {
	    function ReflectionCapabilities(reflect) {
	        classCallCheck(this, ReflectionCapabilities);

	        this._reflect = isPresent(reflect) ? reflect : global$1.Reflect;
	    }

	    createClass(ReflectionCapabilities, [{
	        key: 'isReflectionEnabled',
	        value: function isReflectionEnabled() {
	            return true;
	        }
	    }, {
	        key: 'factory',
	        value: function factory(t) {
	            switch (t.length) {
	                case 0:
	                    return function () {
	                        return new t();
	                    };
	                case 1:
	                    return function (a1) {
	                        return new t(a1);
	                    };
	                case 2:
	                    return function (a1, a2) {
	                        return new t(a1, a2);
	                    };
	                case 3:
	                    return function (a1, a2, a3) {
	                        return new t(a1, a2, a3);
	                    };
	                case 4:
	                    return function (a1, a2, a3, a4) {
	                        return new t(a1, a2, a3, a4);
	                    };
	                case 5:
	                    return function (a1, a2, a3, a4, a5) {
	                        return new t(a1, a2, a3, a4, a5);
	                    };
	                case 6:
	                    return function (a1, a2, a3, a4, a5, a6) {
	                        return new t(a1, a2, a3, a4, a5, a6);
	                    };
	                case 7:
	                    return function (a1, a2, a3, a4, a5, a6, a7) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7);
	                    };
	                case 8:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8);
	                    };
	                case 9:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
	                    };
	                case 10:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	                    };
	                case 11:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	                    };
	                case 12:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	                    };
	                case 13:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	                    };
	                case 14:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	                    };
	                case 15:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	                    };
	                case 16:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
	                    };
	                case 17:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
	                    };
	                case 18:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
	                    };
	                case 19:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
	                    };
	                case 20:
	                    return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
	                        return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
	                    };
	            }
	            ;
	            throw new Error('Cannot create a factory for \'' + stringify(t) + '\' because its constructor has more than 20 arguments');
	        }
	        /** @internal */

	    }, {
	        key: '_zipTypesAndAnnotations',
	        value: function _zipTypesAndAnnotations(paramTypes /** TODO #9100 */, paramAnnotations /** TODO #9100 */) {
	            var result;
	            if (typeof paramTypes === 'undefined') {
	                result = new Array(paramAnnotations.length);
	            } else {
	                result = new Array(paramTypes.length);
	            }
	            for (var i = 0; i < result.length; i++) {
	                // TS outputs Object for parameters without types, while Traceur omits
	                // the annotations. For now we preserve the Traceur behavior to aid
	                // migration, but this can be revisited.
	                if (typeof paramTypes === 'undefined') {
	                    result[i] = [];
	                } else if (paramTypes[i] != Object) {
	                    result[i] = [paramTypes[i]];
	                } else {
	                    result[i] = [];
	                }
	                if (isPresent(paramAnnotations) && isPresent(paramAnnotations[i])) {
	                    result[i] = result[i].concat(paramAnnotations[i]);
	                }
	            }
	            return result;
	        }
	    }, {
	        key: 'parameters',
	        value: function parameters(typeOrFunc) {
	            // Prefer the direct API.
	            if (isPresent(typeOrFunc.parameters)) {
	                return typeOrFunc.parameters;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (isPresent(typeOrFunc.ctorParameters)) {
	                var ctorParameters = typeOrFunc.ctorParameters;
	                var _paramTypes = ctorParameters.map(function (ctorParam /** TODO #9100 */) {
	                    return ctorParam && ctorParam.type;
	                });
	                var _paramAnnotations = ctorParameters.map(function (ctorParam /** TODO #9100 */) {
	                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
	                });
	                return this._zipTypesAndAnnotations(_paramTypes, _paramAnnotations);
	            }
	            // API for metadata created by invoking the decorators.
	            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
	                var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
	                var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
	                if (isPresent(paramTypes) || isPresent(paramAnnotations)) {
	                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	                }
	            }
	            // The array has to be filled with `undefined` because holes would be skipped by `some`
	            var parameters = new Array(typeOrFunc.length);
	            parameters.fill(undefined);
	            return parameters;
	        }
	    }, {
	        key: 'annotations',
	        value: function annotations(typeOrFunc) {
	            // Prefer the direct API.
	            if (isPresent(typeOrFunc.annotations)) {
	                var annotations = typeOrFunc.annotations;
	                if (isFunction(annotations) && annotations.annotations) {
	                    annotations = annotations.annotations;
	                }
	                return annotations;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (isPresent(typeOrFunc.decorators)) {
	                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
	            }
	            // API for metadata created by invoking the decorators.
	            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
	                var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
	                if (isPresent(annotations)) return annotations;
	            }
	            return [];
	        }
	    }, {
	        key: 'propMetadata',
	        value: function propMetadata(typeOrFunc) {
	            // Prefer the direct API.
	            if (isPresent(typeOrFunc.propMetadata)) {
	                var propMetadata = typeOrFunc.propMetadata;
	                if (isFunction(propMetadata) && propMetadata.propMetadata) {
	                    propMetadata = propMetadata.propMetadata;
	                }
	                return propMetadata;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (isPresent(typeOrFunc.propDecorators)) {
	                var _ret = function () {
	                    var propDecorators = typeOrFunc.propDecorators;
	                    var propMetadata = {};
	                    Object.keys(propDecorators).forEach(function (prop) {
	                        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
	                    });
	                    return {
	                        v: propMetadata
	                    };
	                }();

	                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	            }
	            // API for metadata created by invoking the decorators.
	            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
	                var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
	                if (isPresent(propMetadata)) return propMetadata;
	            }
	            return {};
	        }
	        // Note: JavaScript does not support to query for interfaces during runtime.
	        // However, we can't throw here as the reflector will always call this method
	        // when asked for a lifecycle interface as this is what we check in Dart.

	    }, {
	        key: 'interfaces',
	        value: function interfaces(type) {
	            return [];
	        }
	    }, {
	        key: 'hasLifecycleHook',
	        value: function hasLifecycleHook(type, lcInterface, lcProperty) {
	            if (!(type instanceof Type)) return false;
	            var proto = type.prototype;
	            return !!proto[lcProperty];
	        }
	    }, {
	        key: 'getter',
	        value: function getter(name) {
	            return new Function('o', 'return o.' + name + ';');
	        }
	    }, {
	        key: 'setter',
	        value: function setter(name) {
	            return new Function('o', 'v', 'return o.' + name + ' = v;');
	        }
	    }, {
	        key: 'method',
	        value: function method(name) {
	            var functionBody = 'if (!o.' + name + ') throw new Error(\'"' + name + '" is undefined\');\n        return o.' + name + '.apply(o, args);';
	            return new Function('o', 'args', functionBody);
	        }
	        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.

	    }, {
	        key: 'importUri',
	        value: function importUri(type) {
	            // StaticSymbol
	            if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type['filePath']) {
	                return type['filePath'];
	            }
	            // Runtime type
	            return './' + stringify(type);
	        }
	    }]);
	    return ReflectionCapabilities;
	}();
	function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	    if (!decoratorInvocations) {
	        return [];
	    }
	    return decoratorInvocations.map(function (decoratorInvocation) {
	        var decoratorType = decoratorInvocation.type;
	        var annotationCls = decoratorType.annotationCls;
	        var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	        var annotation = Object.create(annotationCls.prototype);
	        annotationCls.apply(annotation, annotationArgs);
	        return annotation;
	    });
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Provides read-only access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var ReflectorReader = function ReflectorReader() {
	  classCallCheck(this, ReflectorReader);
	};

	/**
	 * Provides access to reflection data about symbols. Used internally by Angular
	 * to power dependency injection and compilation.
	 */
	var Reflector = function (_ReflectorReader) {
	    inherits(Reflector, _ReflectorReader);

	    function Reflector(reflectionCapabilities) {
	        classCallCheck(this, Reflector);

	        /** @internal */

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Reflector).call(this));

	        _this._injectableInfo = new Map$1();
	        /** @internal */
	        _this._getters = new Map$1();
	        /** @internal */
	        _this._setters = new Map$1();
	        /** @internal */
	        _this._methods = new Map$1();
	        _this._usedKeys = null;
	        _this.reflectionCapabilities = reflectionCapabilities;
	        return _this;
	    }

	    createClass(Reflector, [{
	        key: 'updateCapabilities',
	        value: function updateCapabilities(caps) {
	            this.reflectionCapabilities = caps;
	        }
	    }, {
	        key: 'isReflectionEnabled',
	        value: function isReflectionEnabled() {
	            return this.reflectionCapabilities.isReflectionEnabled();
	        }
	        /**
	         * Causes `this` reflector to track keys used to access
	         * {@link ReflectionInfo} objects.
	         */

	    }, {
	        key: 'trackUsage',
	        value: function trackUsage() {
	            this._usedKeys = new Set$1();
	        }
	        /**
	         * Lists types for which reflection information was not requested since
	         * {@link #trackUsage} was called. This list could later be audited as
	         * potential dead code.
	         */

	    }, {
	        key: 'listUnusedKeys',
	        value: function listUnusedKeys() {
	            var _this2 = this;

	            if (this._usedKeys == null) {
	                throw new BaseException('Usage tracking is disabled');
	            }
	            var allTypes = MapWrapper.keys(this._injectableInfo);
	            return allTypes.filter(function (key) {
	                return !SetWrapper.has(_this2._usedKeys, key);
	            });
	        }
	    }, {
	        key: 'registerFunction',
	        value: function registerFunction(func, funcInfo) {
	            this._injectableInfo.set(func, funcInfo);
	        }
	    }, {
	        key: 'registerType',
	        value: function registerType(type, typeInfo) {
	            this._injectableInfo.set(type, typeInfo);
	        }
	    }, {
	        key: 'registerGetters',
	        value: function registerGetters(getters) {
	            _mergeMaps(this._getters, getters);
	        }
	    }, {
	        key: 'registerSetters',
	        value: function registerSetters(setters) {
	            _mergeMaps(this._setters, setters);
	        }
	    }, {
	        key: 'registerMethods',
	        value: function registerMethods(methods) {
	            _mergeMaps(this._methods, methods);
	        }
	    }, {
	        key: 'factory',
	        value: function factory(type) {
	            if (this._containsReflectionInfo(type)) {
	                var res = this._getReflectionInfo(type).factory;
	                return isPresent(res) ? res : null;
	            } else {
	                return this.reflectionCapabilities.factory(type);
	            }
	        }
	    }, {
	        key: 'parameters',
	        value: function parameters(typeOrFunc) {
	            if (this._injectableInfo.has(typeOrFunc)) {
	                var res = this._getReflectionInfo(typeOrFunc).parameters;
	                return isPresent(res) ? res : [];
	            } else {
	                return this.reflectionCapabilities.parameters(typeOrFunc);
	            }
	        }
	    }, {
	        key: 'annotations',
	        value: function annotations(typeOrFunc) {
	            if (this._injectableInfo.has(typeOrFunc)) {
	                var res = this._getReflectionInfo(typeOrFunc).annotations;
	                return isPresent(res) ? res : [];
	            } else {
	                return this.reflectionCapabilities.annotations(typeOrFunc);
	            }
	        }
	    }, {
	        key: 'propMetadata',
	        value: function propMetadata(typeOrFunc) {
	            if (this._injectableInfo.has(typeOrFunc)) {
	                var res = this._getReflectionInfo(typeOrFunc).propMetadata;
	                return isPresent(res) ? res : {};
	            } else {
	                return this.reflectionCapabilities.propMetadata(typeOrFunc);
	            }
	        }
	    }, {
	        key: 'interfaces',
	        value: function interfaces(type) {
	            if (this._injectableInfo.has(type)) {
	                var res = this._getReflectionInfo(type).interfaces;
	                return isPresent(res) ? res : [];
	            } else {
	                return this.reflectionCapabilities.interfaces(type);
	            }
	        }
	    }, {
	        key: 'hasLifecycleHook',
	        value: function hasLifecycleHook(type, lcInterface, lcProperty) {
	            var interfaces = this.interfaces(type);
	            if (interfaces.indexOf(lcInterface) !== -1) {
	                return true;
	            } else {
	                return this.reflectionCapabilities.hasLifecycleHook(type, lcInterface, lcProperty);
	            }
	        }
	    }, {
	        key: 'getter',
	        value: function getter(name) {
	            if (this._getters.has(name)) {
	                return this._getters.get(name);
	            } else {
	                return this.reflectionCapabilities.getter(name);
	            }
	        }
	    }, {
	        key: 'setter',
	        value: function setter(name) {
	            if (this._setters.has(name)) {
	                return this._setters.get(name);
	            } else {
	                return this.reflectionCapabilities.setter(name);
	            }
	        }
	    }, {
	        key: 'method',
	        value: function method(name) {
	            if (this._methods.has(name)) {
	                return this._methods.get(name);
	            } else {
	                return this.reflectionCapabilities.method(name);
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_getReflectionInfo',
	        value: function _getReflectionInfo(typeOrFunc) {
	            if (isPresent(this._usedKeys)) {
	                this._usedKeys.add(typeOrFunc);
	            }
	            return this._injectableInfo.get(typeOrFunc);
	        }
	        /** @internal */

	    }, {
	        key: '_containsReflectionInfo',
	        value: function _containsReflectionInfo(typeOrFunc) {
	            return this._injectableInfo.has(typeOrFunc);
	        }
	    }, {
	        key: 'importUri',
	        value: function importUri(type) {
	            return this.reflectionCapabilities.importUri(type);
	        }
	    }]);
	    return Reflector;
	}(ReflectorReader);
	function _mergeMaps(target, config) {
	    StringMapWrapper.forEach(config, function (v, k) {
	        return target.set(k, v);
	    });
	}

	/**
	 * The {@link Reflector} used internally in Angular to access metadata
	 * about symbols.
	 */
	var reflector = new Reflector(new ReflectionCapabilities());

	/**
	 * Describes how the {@link Injector} should instantiate a given token.
	 *
	 * See {@link provide}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/GNAyj6K6PfYg2NBzgwZ5?p%3Dpreview&p=preview))
	 *
	 * ```javascript
	 * var injector = Injector.resolveAndCreate([
	 *   new Provider("message", { useValue: 'Hello' })
	 * ]);
	 *
	 * expect(injector.get("message")).toEqual('Hello');
	 * ```
	 * @ts2dart_const
	 * @deprecated
	 */
	var Provider = function () {
	    function Provider(token, _ref) {
	        var useClass = _ref.useClass;
	        var useValue = _ref.useValue;
	        var useExisting = _ref.useExisting;
	        var useFactory = _ref.useFactory;
	        var deps = _ref.deps;
	        var multi = _ref.multi;
	        classCallCheck(this, Provider);

	        this.token = token;
	        this.useClass = useClass;
	        this.useValue = useValue;
	        this.useExisting = useExisting;
	        this.useFactory = useFactory;
	        this.dependencies = deps;
	        this._multi = multi;
	    }
	    // TODO: Provide a full working example after alpha38 is released.
	    /**
	     * Creates multiple providers matching the same token (a multi-provider).
	     *
	     * Multi-providers are used for creating pluggable service, where the system comes
	     * with some default providers, and the user can register additional providers.
	     * The combination of the default providers and the additional providers will be
	     * used to drive the behavior of the system.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   new Provider("Strings", { useValue: "String1", multi: true}),
	     *   new Provider("Strings", { useValue: "String2", multi: true})
	     * ]);
	     *
	     * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
	     * ```
	     *
	     * Multi-providers and regular providers cannot be mixed. The following
	     * will throw an exception:
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   new Provider("Strings", { useValue: "String1", multi: true }),
	     *   new Provider("Strings", { useValue: "String2"})
	     * ]);
	     * ```
	     */


	    createClass(Provider, [{
	        key: 'multi',
	        get: function get() {
	            return normalizeBool(this._multi);
	        }
	    }]);
	    return Provider;
	}();
	/**
	 * See {@link Provider} instead.
	 *
	 * @deprecated
	 * @ts2dart_const
	 */
	var Binding = function (_Provider) {
	    inherits(Binding, _Provider);

	    function Binding(token, _ref2) {
	        var toClass = _ref2.toClass;
	        var toValue = _ref2.toValue;
	        var toAlias = _ref2.toAlias;
	        var toFactory = _ref2.toFactory;
	        var deps = _ref2.deps;
	        var multi = _ref2.multi;
	        classCallCheck(this, Binding);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(Binding).call(this, token, {
	            useClass: toClass,
	            useValue: toValue,
	            useExisting: toAlias,
	            useFactory: toFactory,
	            deps: deps,
	            multi: multi
	        }));
	    }
	    /**
	     * @deprecated
	     */


	    createClass(Binding, [{
	        key: 'toClass',
	        get: function get() {
	            return this.useClass;
	        }
	        /**
	         * @deprecated
	         */

	    }, {
	        key: 'toAlias',
	        get: function get() {
	            return this.useExisting;
	        }
	        /**
	         * @deprecated
	         */

	    }, {
	        key: 'toFactory',
	        get: function get() {
	            return this.useFactory;
	        }
	        /**
	         * @deprecated
	         */

	    }, {
	        key: 'toValue',
	        get: function get() {
	            return this.useValue;
	        }
	    }]);
	    return Binding;
	}(Provider);
	/**
	 * Helper class for the {@link bind} function.
	 * @deprecated
	 */
	var ProviderBuilder = function () {
	    function ProviderBuilder(token) {
	        classCallCheck(this, ProviderBuilder);

	        this.token = token;
	    }
	    /**
	     * Binds a DI token to a class.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/ZpBCSYqv6e2ud5KXLdxQ?p=preview))
	     *
	     * Because `toAlias` and `toClass` are often confused, the example contains
	     * both use cases for easy comparison.
	     *
	     * ```typescript
	     * class Vehicle {}
	     *
	     * class Car extends Vehicle {}
	     *
	     * var injectorClass = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useClass: Car}
	     * ]);
	     * var injectorAlias = Injector.resolveAndCreate([
	     *   Car,
	     *   {provide: Vehicle, useExisting: Car}
	     * ]);
	     *
	     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	     *
	     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	     * ```
	     */


	    createClass(ProviderBuilder, [{
	        key: 'toClass',
	        value: function toClass(type) {
	            if (!isType(type)) {
	                throw new BaseException('Trying to create a class provider but "' + stringify(type) + '" is not a class!');
	            }
	            return new Provider(this.token, { useClass: type });
	        }
	        /**
	         * Binds a DI token to a value.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/G024PFHmDL0cJFgfZK8O?p=preview))
	         *
	         * ```typescript
	         * var injector = Injector.resolveAndCreate([
	         *   {provide: 'message', useValue: 'Hello'}
	         * ]);
	         *
	         * expect(injector.get('message')).toEqual('Hello');
	         * ```
	         */

	    }, {
	        key: 'toValue',
	        value: function toValue(value) {
	            return new Provider(this.token, { useValue: value });
	        }
	        /**
	         * Binds a DI token to an existing token.
	         *
	         * Angular will return the same instance as if the provided token was used. (This is
	         * in contrast to `useClass` where a separate instance of `useClass` will be returned.)
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/uBaoF2pN5cfc5AfZapNw?p=preview))
	         *
	         * Because `toAlias` and `toClass` are often confused, the example contains
	         * both use cases for easy comparison.
	         *
	         * ```typescript
	         * class Vehicle {}
	         *
	         * class Car extends Vehicle {}
	         *
	         * var injectorAlias = Injector.resolveAndCreate([
	         *   Car,
	         *   {provide: Vehicle, useExisting: Car}
	         * ]);
	         * var injectorClass = Injector.resolveAndCreate([
	         *   Car,
	         *   {provide: Vehicle, useClass: Car})
	         * ]);
	         *
	         * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	         * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	         *
	         * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	         * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	         * ```
	         */

	    }, {
	        key: 'toAlias',
	        value: function toAlias(aliasToken) {
	            if (isBlank(aliasToken)) {
	                throw new BaseException('Can not alias ' + stringify(this.token) + ' to a blank value!');
	            }
	            return new Provider(this.token, { useExisting: aliasToken });
	        }
	        /**
	         * Binds a DI token to a function which computes the value.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/OejNIfTT3zb1iBxaIYOb?p=preview))
	         *
	         * ```typescript
	         * var injector = Injector.resolveAndCreate([
	         *   {provide: Number, useFactory: () => { return 1+2; }},
	         *   {provide: String, useFactory: (v) => { return "Value: " + v; }, deps: [Number]}
	         * ]);
	         *
	         * expect(injector.get(Number)).toEqual(3);
	         * expect(injector.get(String)).toEqual('Value: 3');
	         * ```
	         */

	    }, {
	        key: 'toFactory',
	        value: function toFactory(factory, dependencies) {
	            if (!isFunction(factory)) {
	                throw new BaseException('Trying to create a factory provider but "' + stringify(factory) + '" is not a function!');
	            }
	            return new Provider(this.token, { useFactory: factory, deps: dependencies });
	        }
	    }]);
	    return ProviderBuilder;
	}();
	/**
	 * Creates a {@link Provider}.
	 *
	 * See {@link Provider} for more details.
	 *
	 * <!-- TODO: improve the docs -->
	 * @deprecated
	 */
	function provide(token, _ref3) {
	    var useClass = _ref3.useClass;
	    var useValue = _ref3.useValue;
	    var useExisting = _ref3.useExisting;
	    var useFactory = _ref3.useFactory;
	    var deps = _ref3.deps;
	    var multi = _ref3.multi;

	    return new Provider(token, {
	        useClass: useClass,
	        useValue: useValue,
	        useExisting: useExisting,
	        useFactory: useFactory,
	        deps: deps,
	        multi: multi
	    });
	}

	function isProviderLiteral(obj) {
	    return obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' && obj.provide;
	}
	function createProvider(obj) {
	    return new Provider(obj.provide, obj);
	}

	/**
	 * `Dependency` is used by the framework to extend DI.
	 * This is internal to Angular and should not be used directly.
	 */
	var ReflectiveDependency = function () {
	    function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
	        classCallCheck(this, ReflectiveDependency);

	        this.key = key;
	        this.optional = optional;
	        this.lowerBoundVisibility = lowerBoundVisibility;
	        this.upperBoundVisibility = upperBoundVisibility;
	        this.properties = properties;
	    }

	    createClass(ReflectiveDependency, null, [{
	        key: 'fromKey',
	        value: function fromKey(key) {
	            return new ReflectiveDependency(key, false, null, null, []);
	        }
	    }]);
	    return ReflectiveDependency;
	}();
	var _EMPTY_LIST = [];
	var ResolvedReflectiveProvider_ = function () {
	    function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	        classCallCheck(this, ResolvedReflectiveProvider_);

	        this.key = key;
	        this.resolvedFactories = resolvedFactories;
	        this.multiProvider = multiProvider;
	    }

	    createClass(ResolvedReflectiveProvider_, [{
	        key: 'resolvedFactory',
	        get: function get() {
	            return this.resolvedFactories[0];
	        }
	    }]);
	    return ResolvedReflectiveProvider_;
	}();
	/**
	 * An internal resolved representation of a factory function created by resolving {@link Provider}.
	 * @experimental
	 */
	var ResolvedReflectiveFactory = function ResolvedReflectiveFactory(
	/**
	 * Factory function which can return an instance of an object represented by a key.
	 */
	factory,
	/**
	 * Arguments (dependencies) to the `factory` function.
	 */
	dependencies) {
	    classCallCheck(this, ResolvedReflectiveFactory);

	    this.factory = factory;
	    this.dependencies = dependencies;
	};
	/**
	 * Resolve a single provider.
	 */
	function resolveReflectiveFactory(provider) {
	    var factoryFn;
	    var resolvedDeps;
	    if (isPresent(provider.useClass)) {
	        var useClass = resolveForwardRef(provider.useClass);
	        factoryFn = reflector.factory(useClass);
	        resolvedDeps = _dependenciesFor(useClass);
	    } else if (isPresent(provider.useExisting)) {
	        factoryFn = function factoryFn(aliasInstance) {
	            return aliasInstance;
	        };
	        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
	    } else if (isPresent(provider.useFactory)) {
	        factoryFn = provider.useFactory;
	        resolvedDeps = constructDependencies(provider.useFactory, provider.dependencies);
	    } else {
	        factoryFn = function factoryFn() {
	            return provider.useValue;
	        };
	        resolvedDeps = _EMPTY_LIST;
	    }
	    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	}
	/**
	 * Converts the {@link Provider} into {@link ResolvedProvider}.
	 *
	 * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
	 * convenience provider syntax.
	 */
	function resolveReflectiveProvider(provider) {
	    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.token), [resolveReflectiveFactory(provider)], provider.multi);
	}
	/**
	 * Resolve a list of Providers.
	 */
	function resolveReflectiveProviders(providers) {
	    var normalized = _normalizeProviders(providers, []);
	    var resolved = normalized.map(resolveReflectiveProvider);
	    return MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
	}
	/**
	 * Merges a list of ResolvedProviders into a list where
	 * each key is contained exactly once and multi providers
	 * have been merged.
	 */
	function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	    for (var i = 0; i < providers.length; i++) {
	        var provider = providers[i];
	        var existing = normalizedProvidersMap.get(provider.key.id);
	        if (isPresent(existing)) {
	            if (provider.multiProvider !== existing.multiProvider) {
	                throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
	            }
	            if (provider.multiProvider) {
	                for (var j = 0; j < provider.resolvedFactories.length; j++) {
	                    existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                }
	            } else {
	                normalizedProvidersMap.set(provider.key.id, provider);
	            }
	        } else {
	            var resolvedProvider;
	            if (provider.multiProvider) {
	                resolvedProvider = new ResolvedReflectiveProvider_(provider.key, ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
	            } else {
	                resolvedProvider = provider;
	            }
	            normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	        }
	    }
	    return normalizedProvidersMap;
	}
	function _normalizeProviders(providers, res) {
	    providers.forEach(function (b) {
	        if (b instanceof Type) {
	            res.push(provide(b, { useClass: b }));
	        } else if (b instanceof Provider) {
	            res.push(b);
	        } else if (isProviderLiteral(b)) {
	            res.push(createProvider(b));
	        } else if (b instanceof Array) {
	            _normalizeProviders(b, res);
	        } else if (b instanceof ProviderBuilder) {
	            throw new InvalidProviderError(b.token);
	        } else {
	            throw new InvalidProviderError(b);
	        }
	    });
	    return res;
	}
	function constructDependencies(typeOrFunc, dependencies) {
	    if (isBlank(dependencies)) {
	        return _dependenciesFor(typeOrFunc);
	    } else {
	        var params = dependencies.map(function (t) {
	            return [t];
	        });
	        return dependencies.map(function (t) {
	            return _extractToken(typeOrFunc, t, params);
	        });
	    }
	}
	function _dependenciesFor(typeOrFunc) {
	    var params = reflector.parameters(typeOrFunc);
	    if (isBlank(params)) return [];
	    if (params.some(isBlank)) {
	        throw new NoAnnotationError(typeOrFunc, params);
	    }
	    return params.map(function (p) {
	        return _extractToken(typeOrFunc, p, params);
	    });
	}
	function _extractToken(typeOrFunc /** TODO #9100 */, metadata /** TODO #9100 */ /*any[] | any*/, params) {
	    var depProps = [];
	    var token = null;
	    var optional = false;
	    if (!isArray(metadata)) {
	        if (metadata instanceof InjectMetadata) {
	            return _createDependency(metadata.token, optional, null, null, depProps);
	        } else {
	            return _createDependency(metadata, optional, null, null, depProps);
	        }
	    }
	    var lowerBoundVisibility = null;
	    var upperBoundVisibility = null;
	    for (var i = 0; i < metadata.length; ++i) {
	        var paramMetadata = metadata[i];
	        if (paramMetadata instanceof Type) {
	            token = paramMetadata;
	        } else if (paramMetadata instanceof InjectMetadata) {
	            token = paramMetadata.token;
	        } else if (paramMetadata instanceof OptionalMetadata) {
	            optional = true;
	        } else if (paramMetadata instanceof SelfMetadata) {
	            upperBoundVisibility = paramMetadata;
	        } else if (paramMetadata instanceof HostMetadata) {
	            upperBoundVisibility = paramMetadata;
	        } else if (paramMetadata instanceof SkipSelfMetadata) {
	            lowerBoundVisibility = paramMetadata;
	        } else if (paramMetadata instanceof DependencyMetadata) {
	            if (isPresent(paramMetadata.token)) {
	                token = paramMetadata.token;
	            }
	            depProps.push(paramMetadata);
	        }
	    }
	    token = resolveForwardRef(token);
	    if (isPresent(token)) {
	        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	    } else {
	        throw new NoAnnotationError(typeOrFunc, params);
	    }
	}
	function _createDependency(token /** TODO #9100 */, optional /** TODO #9100 */, lowerBoundVisibility /** TODO #9100 */, upperBoundVisibility /** TODO #9100 */, depProps /** TODO #9100 */) {
	    return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	}

	// avoid unused import when Type union types are erased
	// Threshold for the dynamic version
	var _MAX_CONSTRUCTION_COUNTER = 10;
	var UNDEFINED = new Object();
	var ReflectiveProtoInjectorInlineStrategy = function () {
	    function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
	        classCallCheck(this, ReflectiveProtoInjectorInlineStrategy);

	        this.provider0 = null;
	        this.provider1 = null;
	        this.provider2 = null;
	        this.provider3 = null;
	        this.provider4 = null;
	        this.provider5 = null;
	        this.provider6 = null;
	        this.provider7 = null;
	        this.provider8 = null;
	        this.provider9 = null;
	        this.keyId0 = null;
	        this.keyId1 = null;
	        this.keyId2 = null;
	        this.keyId3 = null;
	        this.keyId4 = null;
	        this.keyId5 = null;
	        this.keyId6 = null;
	        this.keyId7 = null;
	        this.keyId8 = null;
	        this.keyId9 = null;
	        var length = providers.length;
	        if (length > 0) {
	            this.provider0 = providers[0];
	            this.keyId0 = providers[0].key.id;
	        }
	        if (length > 1) {
	            this.provider1 = providers[1];
	            this.keyId1 = providers[1].key.id;
	        }
	        if (length > 2) {
	            this.provider2 = providers[2];
	            this.keyId2 = providers[2].key.id;
	        }
	        if (length > 3) {
	            this.provider3 = providers[3];
	            this.keyId3 = providers[3].key.id;
	        }
	        if (length > 4) {
	            this.provider4 = providers[4];
	            this.keyId4 = providers[4].key.id;
	        }
	        if (length > 5) {
	            this.provider5 = providers[5];
	            this.keyId5 = providers[5].key.id;
	        }
	        if (length > 6) {
	            this.provider6 = providers[6];
	            this.keyId6 = providers[6].key.id;
	        }
	        if (length > 7) {
	            this.provider7 = providers[7];
	            this.keyId7 = providers[7].key.id;
	        }
	        if (length > 8) {
	            this.provider8 = providers[8];
	            this.keyId8 = providers[8].key.id;
	        }
	        if (length > 9) {
	            this.provider9 = providers[9];
	            this.keyId9 = providers[9].key.id;
	        }
	    }

	    createClass(ReflectiveProtoInjectorInlineStrategy, [{
	        key: 'getProviderAtIndex',
	        value: function getProviderAtIndex(index) {
	            if (index == 0) return this.provider0;
	            if (index == 1) return this.provider1;
	            if (index == 2) return this.provider2;
	            if (index == 3) return this.provider3;
	            if (index == 4) return this.provider4;
	            if (index == 5) return this.provider5;
	            if (index == 6) return this.provider6;
	            if (index == 7) return this.provider7;
	            if (index == 8) return this.provider8;
	            if (index == 9) return this.provider9;
	            throw new OutOfBoundsError(index);
	        }
	    }, {
	        key: 'createInjectorStrategy',
	        value: function createInjectorStrategy(injector) {
	            return new ReflectiveInjectorInlineStrategy(injector, this);
	        }
	    }]);
	    return ReflectiveProtoInjectorInlineStrategy;
	}();
	var ReflectiveProtoInjectorDynamicStrategy = function () {
	    function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
	        classCallCheck(this, ReflectiveProtoInjectorDynamicStrategy);

	        this.providers = providers;
	        var len = providers.length;
	        this.keyIds = ListWrapper.createFixedSize(len);
	        for (var i = 0; i < len; i++) {
	            this.keyIds[i] = providers[i].key.id;
	        }
	    }

	    createClass(ReflectiveProtoInjectorDynamicStrategy, [{
	        key: 'getProviderAtIndex',
	        value: function getProviderAtIndex(index) {
	            if (index < 0 || index >= this.providers.length) {
	                throw new OutOfBoundsError(index);
	            }
	            return this.providers[index];
	        }
	    }, {
	        key: 'createInjectorStrategy',
	        value: function createInjectorStrategy(ei) {
	            return new ReflectiveInjectorDynamicStrategy(this, ei);
	        }
	    }]);
	    return ReflectiveProtoInjectorDynamicStrategy;
	}();
	var ReflectiveProtoInjector = function () {
	    function ReflectiveProtoInjector(providers) {
	        classCallCheck(this, ReflectiveProtoInjector);

	        this.numberOfProviders = providers.length;
	        this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ? new ReflectiveProtoInjectorDynamicStrategy(this, providers) : new ReflectiveProtoInjectorInlineStrategy(this, providers);
	    }

	    createClass(ReflectiveProtoInjector, [{
	        key: 'getProviderAtIndex',
	        value: function getProviderAtIndex(index) {
	            return this._strategy.getProviderAtIndex(index);
	        }
	    }], [{
	        key: 'fromResolvedProviders',
	        value: function fromResolvedProviders(providers) {
	            return new ReflectiveProtoInjector(providers);
	        }
	    }]);
	    return ReflectiveProtoInjector;
	}();
	var ReflectiveInjectorInlineStrategy = function () {
	    function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
	        classCallCheck(this, ReflectiveInjectorInlineStrategy);

	        this.injector = injector;
	        this.protoStrategy = protoStrategy;
	        this.obj0 = UNDEFINED;
	        this.obj1 = UNDEFINED;
	        this.obj2 = UNDEFINED;
	        this.obj3 = UNDEFINED;
	        this.obj4 = UNDEFINED;
	        this.obj5 = UNDEFINED;
	        this.obj6 = UNDEFINED;
	        this.obj7 = UNDEFINED;
	        this.obj8 = UNDEFINED;
	        this.obj9 = UNDEFINED;
	    }

	    createClass(ReflectiveInjectorInlineStrategy, [{
	        key: 'resetConstructionCounter',
	        value: function resetConstructionCounter() {
	            this.injector._constructionCounter = 0;
	        }
	    }, {
	        key: 'instantiateProvider',
	        value: function instantiateProvider(provider) {
	            return this.injector._new(provider);
	        }
	    }, {
	        key: 'getObjByKeyId',
	        value: function getObjByKeyId(keyId) {
	            var p = this.protoStrategy;
	            var inj = this.injector;
	            if (p.keyId0 === keyId) {
	                if (this.obj0 === UNDEFINED) {
	                    this.obj0 = inj._new(p.provider0);
	                }
	                return this.obj0;
	            }
	            if (p.keyId1 === keyId) {
	                if (this.obj1 === UNDEFINED) {
	                    this.obj1 = inj._new(p.provider1);
	                }
	                return this.obj1;
	            }
	            if (p.keyId2 === keyId) {
	                if (this.obj2 === UNDEFINED) {
	                    this.obj2 = inj._new(p.provider2);
	                }
	                return this.obj2;
	            }
	            if (p.keyId3 === keyId) {
	                if (this.obj3 === UNDEFINED) {
	                    this.obj3 = inj._new(p.provider3);
	                }
	                return this.obj3;
	            }
	            if (p.keyId4 === keyId) {
	                if (this.obj4 === UNDEFINED) {
	                    this.obj4 = inj._new(p.provider4);
	                }
	                return this.obj4;
	            }
	            if (p.keyId5 === keyId) {
	                if (this.obj5 === UNDEFINED) {
	                    this.obj5 = inj._new(p.provider5);
	                }
	                return this.obj5;
	            }
	            if (p.keyId6 === keyId) {
	                if (this.obj6 === UNDEFINED) {
	                    this.obj6 = inj._new(p.provider6);
	                }
	                return this.obj6;
	            }
	            if (p.keyId7 === keyId) {
	                if (this.obj7 === UNDEFINED) {
	                    this.obj7 = inj._new(p.provider7);
	                }
	                return this.obj7;
	            }
	            if (p.keyId8 === keyId) {
	                if (this.obj8 === UNDEFINED) {
	                    this.obj8 = inj._new(p.provider8);
	                }
	                return this.obj8;
	            }
	            if (p.keyId9 === keyId) {
	                if (this.obj9 === UNDEFINED) {
	                    this.obj9 = inj._new(p.provider9);
	                }
	                return this.obj9;
	            }
	            return UNDEFINED;
	        }
	    }, {
	        key: 'getObjAtIndex',
	        value: function getObjAtIndex(index) {
	            if (index == 0) return this.obj0;
	            if (index == 1) return this.obj1;
	            if (index == 2) return this.obj2;
	            if (index == 3) return this.obj3;
	            if (index == 4) return this.obj4;
	            if (index == 5) return this.obj5;
	            if (index == 6) return this.obj6;
	            if (index == 7) return this.obj7;
	            if (index == 8) return this.obj8;
	            if (index == 9) return this.obj9;
	            throw new OutOfBoundsError(index);
	        }
	    }, {
	        key: 'getMaxNumberOfObjects',
	        value: function getMaxNumberOfObjects() {
	            return _MAX_CONSTRUCTION_COUNTER;
	        }
	    }]);
	    return ReflectiveInjectorInlineStrategy;
	}();
	var ReflectiveInjectorDynamicStrategy = function () {
	    function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
	        classCallCheck(this, ReflectiveInjectorDynamicStrategy);

	        this.protoStrategy = protoStrategy;
	        this.injector = injector;
	        this.objs = ListWrapper.createFixedSize(protoStrategy.providers.length);
	        ListWrapper.fill(this.objs, UNDEFINED);
	    }

	    createClass(ReflectiveInjectorDynamicStrategy, [{
	        key: 'resetConstructionCounter',
	        value: function resetConstructionCounter() {
	            this.injector._constructionCounter = 0;
	        }
	    }, {
	        key: 'instantiateProvider',
	        value: function instantiateProvider(provider) {
	            return this.injector._new(provider);
	        }
	    }, {
	        key: 'getObjByKeyId',
	        value: function getObjByKeyId(keyId) {
	            var p = this.protoStrategy;
	            for (var i = 0; i < p.keyIds.length; i++) {
	                if (p.keyIds[i] === keyId) {
	                    if (this.objs[i] === UNDEFINED) {
	                        this.objs[i] = this.injector._new(p.providers[i]);
	                    }
	                    return this.objs[i];
	                }
	            }
	            return UNDEFINED;
	        }
	    }, {
	        key: 'getObjAtIndex',
	        value: function getObjAtIndex(index) {
	            if (index < 0 || index >= this.objs.length) {
	                throw new OutOfBoundsError(index);
	            }
	            return this.objs[index];
	        }
	    }, {
	        key: 'getMaxNumberOfObjects',
	        value: function getMaxNumberOfObjects() {
	            return this.objs.length;
	        }
	    }]);
	    return ReflectiveInjectorDynamicStrategy;
	}();
	/**
	 * A ReflectiveDependency injection container used for instantiating objects and resolving
	 * dependencies.
	 *
	 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	 * constructor dependencies.
	 *
	 * In typical use, application code asks for the dependencies in the constructor and they are
	 * resolved by the `Injector`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	 *
	 * The following example creates an `Injector` configured to create `Engine` and `Car`.
	 *
	 * ```typescript
	 * @Injectable()
	 * class Engine {
	 * }
	 *
	 * @Injectable()
	 * class Car {
	 *   constructor(public engine:Engine) {}
	 * }
	 *
	 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	 * var car = injector.get(Car);
	 * expect(car instanceof Car).toBe(true);
	 * expect(car.engine instanceof Engine).toBe(true);
	 * ```
	 *
	 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	 * resolve all of the object's dependencies automatically.
	 *
	 * @stable
	 */
	var ReflectiveInjector = function () {
	    function ReflectiveInjector() {
	        classCallCheck(this, ReflectiveInjector);
	    }

	    createClass(ReflectiveInjector, [{
	        key: 'debugContext',

	        /**
	         * @internal
	         */
	        value: function debugContext() {
	            return null;
	        }
	        /**
	         * Resolves an array of providers and creates a child injector from those providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * The passed-in providers can be an array of `Type`, {@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	         * var child = parent.resolveAndCreateChild([ChildProvider]);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         *
	         * This function is slower than the corresponding `createChildFromResolved`
	         * because it needs to resolve the passed-in providers first.
	         * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
	         */

	    }, {
	        key: 'resolveAndCreateChild',
	        value: function resolveAndCreateChild(providers) {
	            return unimplemented();
	        }
	        /**
	         * Creates a child injector from previously resolved providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	         *
	         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	         * var child = parent.createChildFromResolved(childProviders);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         */

	    }, {
	        key: 'createChildFromResolved',
	        value: function createChildFromResolved(providers) {
	            return unimplemented();
	        }
	        /**
	         * Resolves a provider and instantiates an object in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         *
	         * var car = injector.resolveAndInstantiate(Car);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	         * ```
	         */

	    }, {
	        key: 'resolveAndInstantiate',
	        value: function resolveAndInstantiate(provider) {
	            return unimplemented();
	        }
	        /**
	         * Instantiates an object using a resolved provider in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         * var carProvider = ReflectiveInjector.resolve([Car])[0];
	         * var car = injector.instantiateResolved(carProvider);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	         * ```
	         */

	    }, {
	        key: 'instantiateResolved',
	        value: function instantiateResolved(provider) {
	            return unimplemented();
	        }
	    }, {
	        key: 'parent',

	        /**
	         * Parent of this injector.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	         *
	         * ```typescript
	         * var parent = ReflectiveInjector.resolveAndCreate([]);
	         * var child = parent.resolveAndCreateChild([]);
	         * expect(child.parent).toBe(parent);
	         * ```
	         */
	        get: function get() {
	            return unimplemented();
	        }
	    }], [{
	        key: 'resolve',

	        /**
	         * Turns an array of provider definitions into an array of resolved providers.
	         *
	         * A resolution is a process of flattening multiple nested arrays and converting individual
	         * providers into an array of {@link ResolvedReflectiveProvider}s.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	         *
	         * expect(providers.length).toEqual(2);
	         *
	         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	         * expect(providers[0].key.displayName).toBe("Car");
	         * expect(providers[0].dependencies.length).toEqual(1);
	         * expect(providers[0].factory).toBeDefined();
	         *
	         * expect(providers[1].key.displayName).toBe("Engine");
	         * });
	         * ```
	         *
	         * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
	         */
	        value: function resolve(providers) {
	            return resolveReflectiveProviders(providers);
	        }
	        /**
	         * Resolves an array of providers and creates an injector from those providers.
	         *
	         * The passed-in providers can be an array of `Type`, {@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         *
	         * This function is slower than the corresponding `fromResolvedProviders`
	         * because it needs to resolve the passed-in providers first.
	         * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
	         */

	    }, {
	        key: 'resolveAndCreate',
	        value: function resolveAndCreate(providers) {
	            var parent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	        }
	        /**
	         * Creates an injector from previously resolved providers.
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	         *
	         * ```typescript
	         * @Injectable()
	         * class Engine {
	         * }
	         *
	         * @Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, Engine]);
	         * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         * @experimental
	         */

	    }, {
	        key: 'fromResolvedProviders',
	        value: function fromResolvedProviders(providers) {
	            var parent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
	        }
	        /**
	         * @deprecated
	         */

	    }, {
	        key: 'fromResolvedBindings',
	        value: function fromResolvedBindings(providers) {
	            return ReflectiveInjector.fromResolvedProviders(providers);
	        }
	    }]);
	    return ReflectiveInjector;
	}();
	var ReflectiveInjector_ = function () {
	    /**
	     * Private
	     */

	    function ReflectiveInjector_(_proto /* ProtoInjector */) {
	        var _parent = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	        var _debugContext = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	        classCallCheck(this, ReflectiveInjector_);

	        this._debugContext = _debugContext;
	        /** @internal */
	        this._constructionCounter = 0;
	        this._proto = _proto;
	        this._parent = _parent;
	        this._strategy = _proto._strategy.createInjectorStrategy(this);
	    }
	    /**
	     * @internal
	     */


	    createClass(ReflectiveInjector_, [{
	        key: 'debugContext',
	        value: function debugContext() {
	            return this._debugContext();
	        }
	    }, {
	        key: 'get',
	        value: function get(token) {
	            var notFoundValue = arguments.length <= 1 || arguments[1] === undefined ? THROW_IF_NOT_FOUND : arguments[1];

	            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);
	        }
	    }, {
	        key: 'getAt',
	        value: function getAt(index) {
	            return this._strategy.getObjAtIndex(index);
	        }
	    }, {
	        key: 'resolveAndCreateChild',
	        value: function resolveAndCreateChild(providers) {
	            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return this.createChildFromResolved(ResolvedReflectiveProviders);
	        }
	    }, {
	        key: 'createChildFromResolved',
	        value: function createChildFromResolved(providers) {
	            var proto = new ReflectiveProtoInjector(providers);
	            var inj = new ReflectiveInjector_(proto);
	            inj._parent = this;
	            return inj;
	        }
	    }, {
	        key: 'resolveAndInstantiate',
	        value: function resolveAndInstantiate(provider) {
	            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	        }
	    }, {
	        key: 'instantiateResolved',
	        value: function instantiateResolved(provider) {
	            return this._instantiateProvider(provider);
	        }
	        /** @internal */

	    }, {
	        key: '_new',
	        value: function _new(provider) {
	            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
	                throw new CyclicDependencyError(this, provider.key);
	            }
	            return this._instantiateProvider(provider);
	        }
	    }, {
	        key: '_instantiateProvider',
	        value: function _instantiateProvider(provider) {
	            if (provider.multiProvider) {
	                var res = ListWrapper.createFixedSize(provider.resolvedFactories.length);
	                for (var i = 0; i < provider.resolvedFactories.length; ++i) {
	                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	                }
	                return res;
	            } else {
	                return this._instantiate(provider, provider.resolvedFactories[0]);
	            }
	        }
	    }, {
	        key: '_instantiate',
	        value: function _instantiate(provider, ResolvedReflectiveFactory) {
	            var factory = ResolvedReflectiveFactory.factory;
	            var deps = ResolvedReflectiveFactory.dependencies;
	            var length = deps.length;
	            var d0;
	            var d1;
	            var d2;
	            var d3;
	            var d4;
	            var d5;
	            var d6;
	            var d7;
	            var d8;
	            var d9;
	            var d10;
	            var d11;
	            var d12;
	            var d13;
	            var d14;
	            var d15;
	            var d16;
	            var d17;
	            var d18;
	            var d19;
	            try {
	                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
	                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
	                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
	                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
	                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
	                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
	                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
	                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
	                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
	                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
	                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
	                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
	                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
	                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
	                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
	                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
	                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
	                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
	                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
	                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
	            } catch (e) {
	                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
	                    e.addKey(this, provider.key);
	                }
	                throw e;
	            }
	            var obj;
	            try {
	                switch (length) {
	                    case 0:
	                        obj = factory();
	                        break;
	                    case 1:
	                        obj = factory(d0);
	                        break;
	                    case 2:
	                        obj = factory(d0, d1);
	                        break;
	                    case 3:
	                        obj = factory(d0, d1, d2);
	                        break;
	                    case 4:
	                        obj = factory(d0, d1, d2, d3);
	                        break;
	                    case 5:
	                        obj = factory(d0, d1, d2, d3, d4);
	                        break;
	                    case 6:
	                        obj = factory(d0, d1, d2, d3, d4, d5);
	                        break;
	                    case 7:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6);
	                        break;
	                    case 8:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
	                        break;
	                    case 9:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
	                        break;
	                    case 10:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
	                        break;
	                    case 11:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
	                        break;
	                    case 12:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
	                        break;
	                    case 13:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
	                        break;
	                    case 14:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
	                        break;
	                    case 15:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
	                        break;
	                    case 16:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
	                        break;
	                    case 17:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
	                        break;
	                    case 18:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
	                        break;
	                    case 19:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
	                        break;
	                    case 20:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
	                        break;
	                    default:
	                        throw new BaseException('Cannot instantiate \'' + provider.key.displayName + '\' because it has more than 20 dependencies');
	                }
	            } catch (e) {
	                throw new InstantiationError(this, e, e.stack, provider.key);
	            }
	            return obj;
	        }
	    }, {
	        key: '_getByReflectiveDependency',
	        value: function _getByReflectiveDependency(provider, dep) {
	            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);
	        }
	    }, {
	        key: '_getByKey',
	        value: function _getByKey(key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
	            if (key === INJECTOR_KEY) {
	                return this;
	            }
	            if (upperBoundVisibility instanceof SelfMetadata) {
	                return this._getByKeySelf(key, notFoundValue);
	            } else {
	                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_throwOrNull',
	        value: function _throwOrNull(key, notFoundValue) {
	            if (notFoundValue !== THROW_IF_NOT_FOUND) {
	                return notFoundValue;
	            } else {
	                throw new NoProviderError(this, key);
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_getByKeySelf',
	        value: function _getByKeySelf(key, notFoundValue) {
	            var obj = this._strategy.getObjByKeyId(key.id);
	            return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue);
	        }
	        /** @internal */

	    }, {
	        key: '_getByKeyDefault',
	        value: function _getByKeyDefault(key, notFoundValue, lowerBoundVisibility) {
	            var inj;
	            if (lowerBoundVisibility instanceof SkipSelfMetadata) {
	                inj = this._parent;
	            } else {
	                inj = this;
	            }
	            while (inj instanceof ReflectiveInjector_) {
	                var inj_ = inj;
	                var obj = inj_._strategy.getObjByKeyId(key.id);
	                if (obj !== UNDEFINED) return obj;
	                inj = inj_._parent;
	            }
	            if (inj !== null) {
	                return inj.get(key.token, notFoundValue);
	            } else {
	                return this._throwOrNull(key, notFoundValue);
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.displayName;
	        }
	    }, {
	        key: 'parent',
	        get: function get() {
	            return this._parent;
	        }
	        /**
	         * @internal
	         * Internal. Do not use.
	         * We return `any` not to export the InjectorStrategy type.
	         */

	    }, {
	        key: 'internalStrategy',
	        get: function get() {
	            return this._strategy;
	        }
	    }, {
	        key: 'displayName',
	        get: function get() {
	            var providers = _mapProviders(this, function (b) {
	                return ' "' + b.key.displayName + '" ';
	            }).join(', ');
	            return 'ReflectiveInjector(providers: [' + providers + '])';
	        }
	    }]);
	    return ReflectiveInjector_;
	}();
	var INJECTOR_KEY = ReflectiveKey.get(Injector);
	function _mapProviders(injector, fn) {
	    var res = new Array(injector._proto.numberOfProviders);
	    for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
	        res[i] = fn(injector._proto.getProviderAtIndex(i));
	    }
	    return res;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Creates a token that can be used in a DI Provider.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
	 *
	 * ```typescript
	 * var t = new OpaqueToken("value");
	 *
	 * var injector = Injector.resolveAndCreate([
	 *   {provide: t, useValue: "bindingValue"}
	 * ]);
	 *
	 * expect(injector.get(t)).toEqual("bindingValue");
	 * ```
	 *
	 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
	 * caused by multiple providers using the same string as two different tokens.
	 *
	 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
	 * error messages.
	 * @ts2dart_const
	 * @stable
	 */
	var OpaqueToken = function () {
	  function OpaqueToken(_desc) {
	    classCallCheck(this, OpaqueToken);

	    this._desc = _desc;
	  }

	  createClass(OpaqueToken, [{
	    key: "toString",
	    value: function toString() {
	      return "Token " + this._desc;
	    }
	  }]);
	  return OpaqueToken;
	}();

	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	var root = objectTypes[typeof self === 'undefined' ? 'undefined' : _typeof(self)] && self || objectTypes[typeof window === 'undefined' ? 'undefined' : _typeof(window)] && window;
	/* tslint:disable:no-unused-variable */
	var freeExports = objectTypes[typeof exports === 'undefined' ? 'undefined' : _typeof(exports)] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module === 'undefined' ? 'undefined' : _typeof(module)] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global === 'undefined' ? 'undefined' : _typeof(global)] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    root = freeGlobal;
	}

	function isFunction$1(x) {
	    return typeof x === 'function';
	}

	var isArray$1 = Array.isArray || function (x) {
	  return x && typeof x.length === 'number';
	};

	function isObject(x) {
	    return x != null && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object';
	}

	// typeof any so that it we don't have to cast when comparing a result to the error object
	var errorObject = { e: {} };

	var tryCatchTarget = void 0;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        errorObject.e = e;
	        return errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	;

	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = function (_Error) {
	    inherits(UnsubscriptionError, _Error);

	    function UnsubscriptionError(errors) {
	        classCallCheck(this, UnsubscriptionError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(UnsubscriptionError).call(this));

	        _this.errors = errors;
	        _this.name = 'UnsubscriptionError';
	        _this.message = errors ? errors.length + ' errors occurred during unsubscription:\n' + errors.map(function (err, i) {
	            return i + 1 + ') ' + err.toString();
	        }).join('\n') : '';
	        return _this;
	    }

	    return UnsubscriptionError;
	}(Error);

	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */

	    function Subscription(unsubscribe) {
	        classCallCheck(this, Subscription);

	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.isUnsubscribed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */


	    createClass(Subscription, [{
	        key: 'unsubscribe',
	        value: function unsubscribe() {
	            var hasErrors = false;
	            var errors = void 0;
	            if (this.isUnsubscribed) {
	                return;
	            }
	            this.isUnsubscribed = true;
	            var _unsubscribe = this._unsubscribe;
	            var _subscriptions = this._subscriptions;

	            this._subscriptions = null;
	            if (isFunction$1(_unsubscribe)) {
	                var trial = tryCatch(_unsubscribe).call(this);
	                if (trial === errorObject) {
	                    hasErrors = true;
	                    (errors = errors || []).push(errorObject.e);
	                }
	            }
	            if (isArray$1(_subscriptions)) {
	                var index = -1;
	                var len = _subscriptions.length;
	                while (++index < len) {
	                    var sub = _subscriptions[index];
	                    if (isObject(sub)) {
	                        var _trial = tryCatch(sub.unsubscribe).call(sub);
	                        if (_trial === errorObject) {
	                            hasErrors = true;
	                            errors = errors || [];
	                            var err = errorObject.e;
	                            if (err instanceof UnsubscriptionError) {
	                                errors = errors.concat(err.errors);
	                            } else {
	                                errors.push(err);
	                            }
	                        }
	                    }
	                }
	            }
	            if (hasErrors) {
	                throw new UnsubscriptionError(errors);
	            }
	        }
	        /**
	         * Adds a tear down to be called during the unsubscribe() of this
	         * Subscription.
	         *
	         * If the tear down being added is a subscription that is already
	         * unsubscribed, is the same reference `add` is being called on, or is
	         * `Subscription.EMPTY`, it will not be added.
	         *
	         * If this subscription is already in an `isUnsubscribed` state, the passed
	         * tear down logic will be executed immediately.
	         *
	         * @param {TeardownLogic} teardown The additional logic to execute on
	         * teardown.
	         * @return {Subscription} Returns the Subscription used or created to be
	         * added to the inner subscriptions list. This Subscription can be used with
	         * `remove()` to remove the passed teardown logic from the inner subscriptions
	         * list.
	         */

	    }, {
	        key: 'add',
	        value: function add(teardown) {
	            if (!teardown || teardown === this || teardown === Subscription.EMPTY) {
	                return;
	            }
	            var sub = teardown;
	            switch (typeof teardown === 'undefined' ? 'undefined' : _typeof(teardown)) {
	                case 'function':
	                    sub = new Subscription(teardown);
	                case 'object':
	                    if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
	                        break;
	                    } else if (this.isUnsubscribed) {
	                        sub.unsubscribe();
	                    } else {
	                        (this._subscriptions || (this._subscriptions = [])).push(sub);
	                    }
	                    break;
	                default:
	                    throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
	            }
	            return sub;
	        }
	        /**
	         * Removes a Subscription from the internal list of subscriptions that will
	         * unsubscribe during the unsubscribe process of this Subscription.
	         * @param {Subscription} subscription The subscription to remove.
	         * @return {void}
	         */

	    }, {
	        key: 'remove',
	        value: function remove(subscription) {
	            // HACK: This might be redundant because of the logic in `add()`
	            if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
	                return;
	            }
	            var subscriptions = this._subscriptions;
	            if (subscriptions) {
	                var subscriptionIndex = subscriptions.indexOf(subscription);
	                if (subscriptionIndex !== -1) {
	                    subscriptions.splice(subscriptionIndex, 1);
	                }
	            }
	        }
	    }]);
	    return Subscription;
	}();
	Subscription.EMPTY = function (empty) {
	    empty.isUnsubscribed = true;
	    return empty;
	}(new Subscription());

	var empty = {
	    isUnsubscribed: true,
	    next: function next(value) {},
	    error: function error(err) {
	        throw err;
	    },
	    complete: function complete() {}
	};

	var _Symbol = root.Symbol;
	var $$rxSubscriber = typeof _Symbol === 'function' && typeof _Symbol.for === 'function' ? _Symbol.for('rxSubscriber') : '@@rxSubscriber';

	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = function (_Subscription) {
	    inherits(Subscriber, _Subscription);

	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */

	    function Subscriber(destinationOrNext, error, complete) {
	        classCallCheck(this, Subscriber);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Subscriber).call(this));

	        _this.syncErrorValue = null;
	        _this.syncErrorThrown = false;
	        _this.syncErrorThrowable = false;
	        _this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                _this.destination = empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    _this.destination = empty;
	                    break;
	                }
	                if ((typeof destinationOrNext === 'undefined' ? 'undefined' : _typeof(destinationOrNext)) === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        _this.destination = destinationOrNext;
	                        _this.destination.add(_this);
	                    } else {
	                        _this.syncErrorThrowable = true;
	                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                _this.syncErrorThrowable = true;
	                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
	                break;
	        }
	        return _this;
	    }

	    createClass(Subscriber, [{
	        key: $$rxSubscriber,
	        value: function value() {
	            return this;
	        }
	        /**
	         * A static factory for a Subscriber, given a (potentially partial) definition
	         * of an Observer.
	         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	         * @param {function(e: ?any): void} [error] The `error` callback of an
	         * Observer.
	         * @param {function(): void} [complete] The `complete` callback of an
	         * Observer.
	         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	         * Observer represented by the given arguments.
	         */

	    }, {
	        key: 'next',

	        /**
	         * The {@link Observer} callback to receive notifications of type `next` from
	         * the Observable, with a value. The Observable may call this method 0 or more
	         * times.
	         * @param {T} [value] The `next` value.
	         * @return {void}
	         */
	        value: function next(value) {
	            if (!this.isStopped) {
	                this._next(value);
	            }
	        }
	        /**
	         * The {@link Observer} callback to receive notifications of type `error` from
	         * the Observable, with an attached {@link Error}. Notifies the Observer that
	         * the Observable has experienced an error condition.
	         * @param {any} [err] The `error` exception.
	         * @return {void}
	         */

	    }, {
	        key: 'error',
	        value: function error(err) {
	            if (!this.isStopped) {
	                this.isStopped = true;
	                this._error(err);
	            }
	        }
	        /**
	         * The {@link Observer} callback to receive a valueless notification of type
	         * `complete` from the Observable. Notifies the Observer that the Observable
	         * has finished sending push-based notifications.
	         * @return {void}
	         */

	    }, {
	        key: 'complete',
	        value: function complete() {
	            if (!this.isStopped) {
	                this.isStopped = true;
	                this._complete();
	            }
	        }
	    }, {
	        key: 'unsubscribe',
	        value: function unsubscribe() {
	            if (this.isUnsubscribed) {
	                return;
	            }
	            this.isStopped = true;
	            get(Object.getPrototypeOf(Subscriber.prototype), 'unsubscribe', this).call(this);
	        }
	    }, {
	        key: '_next',
	        value: function _next(value) {
	            this.destination.next(value);
	        }
	    }, {
	        key: '_error',
	        value: function _error(err) {
	            this.destination.error(err);
	            this.unsubscribe();
	        }
	    }, {
	        key: '_complete',
	        value: function _complete() {
	            this.destination.complete();
	            this.unsubscribe();
	        }
	    }], [{
	        key: 'create',
	        value: function create(next, error, complete) {
	            var subscriber = new Subscriber(next, error, complete);
	            subscriber.syncErrorThrowable = false;
	            return subscriber;
	        }
	    }]);
	    return Subscriber;
	}(Subscription);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */

	var SafeSubscriber = function (_Subscriber) {
	    inherits(SafeSubscriber, _Subscriber);

	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        classCallCheck(this, SafeSubscriber);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(SafeSubscriber).call(this));

	        _this2._parent = _parent;
	        var next = void 0;
	        var context = _this2;
	        if (isFunction$1(observerOrNext)) {
	            next = observerOrNext;
	        } else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction$1(context.unsubscribe)) {
	                _this2.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = _this2.unsubscribe.bind(_this2);
	        }
	        _this2._context = context;
	        _this2._next = next;
	        _this2._error = error;
	        _this2._complete = complete;
	        return _this2;
	    }

	    createClass(SafeSubscriber, [{
	        key: 'next',
	        value: function next(value) {
	            if (!this.isStopped && this._next) {
	                var _parent = this._parent;

	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._next, value);
	                } else if (this.__tryOrSetError(_parent, this._next, value)) {
	                    this.unsubscribe();
	                }
	            }
	        }
	    }, {
	        key: 'error',
	        value: function error(err) {
	            if (!this.isStopped) {
	                var _parent = this._parent;

	                if (this._error) {
	                    if (!_parent.syncErrorThrowable) {
	                        this.__tryOrUnsub(this._error, err);
	                        this.unsubscribe();
	                    } else {
	                        this.__tryOrSetError(_parent, this._error, err);
	                        this.unsubscribe();
	                    }
	                } else if (!_parent.syncErrorThrowable) {
	                    this.unsubscribe();
	                    throw err;
	                } else {
	                    _parent.syncErrorValue = err;
	                    _parent.syncErrorThrown = true;
	                    this.unsubscribe();
	                }
	            }
	        }
	    }, {
	        key: 'complete',
	        value: function complete() {
	            if (!this.isStopped) {
	                var _parent = this._parent;

	                if (this._complete) {
	                    if (!_parent.syncErrorThrowable) {
	                        this.__tryOrUnsub(this._complete);
	                        this.unsubscribe();
	                    } else {
	                        this.__tryOrSetError(_parent, this._complete);
	                        this.unsubscribe();
	                    }
	                } else {
	                    this.unsubscribe();
	                }
	            }
	        }
	    }, {
	        key: '__tryOrUnsub',
	        value: function __tryOrUnsub(fn, value) {
	            try {
	                fn.call(this._context, value);
	            } catch (err) {
	                this.unsubscribe();
	                throw err;
	            }
	        }
	    }, {
	        key: '__tryOrSetError',
	        value: function __tryOrSetError(parent, fn, value) {
	            try {
	                fn.call(this._context, value);
	            } catch (err) {
	                parent.syncErrorValue = err;
	                parent.syncErrorThrown = true;
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: '_unsubscribe',
	        value: function _unsubscribe() {
	            var _parent = this._parent;

	            this._context = null;
	            this._parent = null;
	            _parent.unsubscribe();
	        }
	    }]);
	    return SafeSubscriber;
	}(Subscriber);

	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[$$rxSubscriber]) {
	            return nextOrObserver[$$rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber();
	    }
	    return new Subscriber(nextOrObserver, error, complete);
	}

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var ponyfill = createCommonjsModule(function (module) {
		'use strict';

		module.exports = function symbolObservablePonyfill(root) {
			var result;
			var _Symbol = root.Symbol;

			if (typeof _Symbol === 'function') {
				if (_Symbol.observable) {
					result = _Symbol.observable;
				} else {
					result = _Symbol('observable');
					_Symbol.observable = result;
				}
			} else {
				result = '@@observable';
			}

			return result;
		};
	});

	var require$$0 = ponyfill && (typeof ponyfill === 'undefined' ? 'undefined' : _typeof(ponyfill)) === 'object' && 'default' in ponyfill ? ponyfill['default'] : ponyfill;

	var index = createCommonjsModule(function (module) {
	  /* global window */
	  'use strict';

	  module.exports = require$$0(commonjsGlobal || window || commonjsGlobal);
	});

	var index$1 = index && (typeof index === 'undefined' ? 'undefined' : _typeof(index)) === 'object' && 'default' in index ? index['default'] : index;



	var $$observable = Object.freeze({
	  default: index$1
	});

	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */

	    function Observable(subscribe) {
	        classCallCheck(this, Observable);

	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */


	    createClass(Observable, [{
	        key: 'lift',
	        value: function lift(operator) {
	            var observable = new Observable();
	            observable.source = this;
	            observable.operator = operator;
	            return observable;
	        }
	        /**
	         * Registers handlers for handling emitted values, error and completions from the observable, and
	         *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	         * @method subscribe
	         * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
	         *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	         * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	         *  the error will be thrown as unhandled
	         * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	         * @return {ISubscription} a subscription reference to the registered handlers
	         */

	    }, {
	        key: 'subscribe',
	        value: function subscribe(observerOrNext, error, complete) {
	            var operator = this.operator;

	            var sink = toSubscriber(observerOrNext, error, complete);
	            if (operator) {
	                operator.call(sink, this);
	            } else {
	                sink.add(this._subscribe(sink));
	            }
	            if (sink.syncErrorThrowable) {
	                sink.syncErrorThrowable = false;
	                if (sink.syncErrorThrown) {
	                    throw sink.syncErrorValue;
	                }
	            }
	            return sink;
	        }
	        /**
	         * @method forEach
	         * @param {Function} next a handler for each value emitted by the observable
	         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	         * @return {Promise} a promise that either resolves on observable completion or
	         *  rejects with the handled error
	         */

	    }, {
	        key: 'forEach',
	        value: function forEach(next, PromiseCtor) {
	            var _this = this;

	            if (!PromiseCtor) {
	                if (root.Rx && root.Rx.config && root.Rx.config.Promise) {
	                    PromiseCtor = root.Rx.config.Promise;
	                } else if (root.Promise) {
	                    PromiseCtor = root.Promise;
	                }
	            }
	            if (!PromiseCtor) {
	                throw new Error('no Promise impl found');
	            }
	            return new PromiseCtor(function (resolve, reject) {
	                var subscription = _this.subscribe(function (value) {
	                    if (subscription) {
	                        // if there is a subscription, then we can surmise
	                        // the next handling is asynchronous. Any errors thrown
	                        // need to be rejected explicitly and unsubscribe must be
	                        // called manually
	                        try {
	                            next(value);
	                        } catch (err) {
	                            reject(err);
	                            subscription.unsubscribe();
	                        }
	                    } else {
	                        // if there is NO subscription, then we're getting a nexted
	                        // value synchronously during subscription. We can just call it.
	                        // If it errors, Observable's `subscribe` imple will ensure the
	                        // unsubscription logic is called, then synchronously rethrow the error.
	                        // After that, Promise will trap the error and send it
	                        // down the rejection path.
	                        next(value);
	                    }
	                }, reject, resolve);
	            });
	        }
	    }, {
	        key: '_subscribe',
	        value: function _subscribe(subscriber) {
	            return this.source.subscribe(subscriber);
	        }
	        /**
	         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	         * @method Symbol.observable
	         * @return {Observable} this instance of the observable
	         */

	    }, {
	        key: $$observable,
	        value: function value() {
	            return this;
	        }
	    }]);
	    return Observable;
	}();
	// HACK: Since TypeScript inherits static properties too, we have to
	// fight against TypeScript here so Subject can have a different static create signature
	/**
	 * Creates a new cold Observable by calling the Observable constructor
	 * @static true
	 * @owner Observable
	 * @method create
	 * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	 * @return {Observable} a new cold observable
	 */
	Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	};

	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = function (_Error) {
	    inherits(ObjectUnsubscribedError, _Error);

	    function ObjectUnsubscribedError() {
	        classCallCheck(this, ObjectUnsubscribedError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ObjectUnsubscribedError).call(this, 'object unsubscribed'));

	        _this.name = 'ObjectUnsubscribedError';
	        return _this;
	    }

	    return ObjectUnsubscribedError;
	}(Error);

	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = function (_Subscription) {
	    inherits(SubjectSubscription, _Subscription);

	    function SubjectSubscription(subject, subscriber) {
	        classCallCheck(this, SubjectSubscription);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(SubjectSubscription).call(this));

	        _this.subject = subject;
	        _this.subscriber = subscriber;
	        _this.isUnsubscribed = false;
	        return _this;
	    }

	    createClass(SubjectSubscription, [{
	        key: 'unsubscribe',
	        value: function unsubscribe() {
	            if (this.isUnsubscribed) {
	                return;
	            }
	            this.isUnsubscribed = true;
	            var subject = this.subject;
	            var observers = subject.observers;
	            this.subject = null;
	            if (!observers || observers.length === 0 || subject.isStopped || subject.isUnsubscribed) {
	                return;
	            }
	            var subscriberIndex = observers.indexOf(this.subscriber);
	            if (subscriberIndex !== -1) {
	                observers.splice(subscriberIndex, 1);
	            }
	        }
	    }]);
	    return SubjectSubscription;
	}(Subscription);

	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = function (_Subscriber) {
	    inherits(SubjectSubscriber, _Subscriber);

	    function SubjectSubscriber(destination) {
	        classCallCheck(this, SubjectSubscriber);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(SubjectSubscriber).call(this, destination));

	        _this.destination = destination;
	        return _this;
	    }

	    return SubjectSubscriber;
	}(Subscriber);
	/**
	 * @class Subject<T>
	 */
	var Subject = function (_Observable) {
	    inherits(Subject, _Observable);

	    function Subject() {
	        classCallCheck(this, Subject);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(Subject).call(this));

	        _this2.observers = [];
	        _this2.isUnsubscribed = false;
	        _this2.isStopped = false;
	        _this2.hasError = false;
	        _this2.thrownError = null;
	        return _this2;
	    }

	    createClass(Subject, [{
	        key: $$rxSubscriber,
	        value: function value() {
	            return new SubjectSubscriber(this);
	        }
	    }, {
	        key: 'lift',
	        value: function lift(operator) {
	            var subject = new AnonymousSubject(this, this);
	            subject.operator = operator;
	            return subject;
	        }
	    }, {
	        key: 'next',
	        value: function next(value) {
	            if (this.isUnsubscribed) {
	                throw new ObjectUnsubscribedError();
	            }
	            if (!this.isStopped) {
	                var observers = this.observers;

	                var len = observers.length;
	                var copy = observers.slice();
	                for (var i = 0; i < len; i++) {
	                    copy[i].next(value);
	                }
	            }
	        }
	    }, {
	        key: 'error',
	        value: function error(err) {
	            if (this.isUnsubscribed) {
	                throw new ObjectUnsubscribedError();
	            }
	            this.hasError = true;
	            this.thrownError = err;
	            this.isStopped = true;
	            var observers = this.observers;

	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].error(err);
	            }
	            this.observers.length = 0;
	        }
	    }, {
	        key: 'complete',
	        value: function complete() {
	            if (this.isUnsubscribed) {
	                throw new ObjectUnsubscribedError();
	            }
	            this.isStopped = true;
	            var observers = this.observers;

	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].complete();
	            }
	            this.observers.length = 0;
	        }
	    }, {
	        key: 'unsubscribe',
	        value: function unsubscribe() {
	            this.isStopped = true;
	            this.isUnsubscribed = true;
	            this.observers = null;
	        }
	    }, {
	        key: '_subscribe',
	        value: function _subscribe(subscriber) {
	            if (this.isUnsubscribed) {
	                throw new ObjectUnsubscribedError();
	            } else if (this.hasError) {
	                subscriber.error(this.thrownError);
	                return Subscription.EMPTY;
	            } else if (this.isStopped) {
	                subscriber.complete();
	                return Subscription.EMPTY;
	            } else {
	                this.observers.push(subscriber);
	                return new SubjectSubscription(this, subscriber);
	            }
	        }
	    }, {
	        key: 'asObservable',
	        value: function asObservable() {
	            var observable = new Observable();
	            observable.source = this;
	            return observable;
	        }
	    }]);
	    return Subject;
	}(Observable);
	Subject.create = function (destination, source) {
	    return new AnonymousSubject(destination, source);
	};
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = function (_Subject) {
	    inherits(AnonymousSubject, _Subject);

	    function AnonymousSubject(destination, source) {
	        classCallCheck(this, AnonymousSubject);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(AnonymousSubject).call(this));

	        _this3.destination = destination;
	        _this3.source = source;
	        return _this3;
	    }

	    createClass(AnonymousSubject, [{
	        key: 'next',
	        value: function next(value) {
	            var destination = this.destination;

	            if (destination && destination.next) {
	                destination.next(value);
	            }
	        }
	    }, {
	        key: 'error',
	        value: function error(err) {
	            var destination = this.destination;

	            if (destination && destination.error) {
	                this.destination.error(err);
	            }
	        }
	    }, {
	        key: 'complete',
	        value: function complete() {
	            var destination = this.destination;

	            if (destination && destination.complete) {
	                this.destination.complete();
	            }
	        }
	    }, {
	        key: '_subscribe',
	        value: function _subscribe(subscriber) {
	            var source = this.source;

	            if (source) {
	                return this.source.subscribe(subscriber);
	            } else {
	                return Subscription.EMPTY;
	            }
	        }
	    }]);
	    return AnonymousSubject;
	}(Subject);

	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = function (_Observable) {
	    inherits(PromiseObservable, _Observable);

	    function PromiseObservable(promise) {
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, PromiseObservable);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(PromiseObservable).call(this));

	        _this.promise = promise;
	        _this.scheduler = scheduler;
	        return _this;
	    }
	    /**
	     * Converts a Promise to an Observable.
	     *
	     * <span class="informal">Returns an Observable that just emits the Promise's
	     * resolved value, then completes.</span>
	     *
	     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
	     * Observable. If the Promise resolves with a value, the output Observable
	     * emits that resolved value as a `next`, and then completes. If the Promise
	     * is rejected, then the output Observable emits the corresponding Error.
	     *
	     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
	     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     *
	     * @param {Promise<T>} promise The promise to be converted.
	     * @param {Scheduler} [scheduler] An optional Scheduler to use for scheduling
	     * the delivery of the resolved value (or the rejection).
	     * @return {Observable<T>} An Observable which wraps the Promise.
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */


	    createClass(PromiseObservable, [{
	        key: '_subscribe',
	        value: function _subscribe(subscriber) {
	            var _this2 = this;

	            var promise = this.promise;
	            var scheduler = this.scheduler;
	            if (scheduler == null) {
	                if (this._isScalar) {
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.next(this.value);
	                        subscriber.complete();
	                    }
	                } else {
	                    promise.then(function (value) {
	                        _this2.value = value;
	                        _this2._isScalar = true;
	                        if (!subscriber.isUnsubscribed) {
	                            subscriber.next(value);
	                            subscriber.complete();
	                        }
	                    }, function (err) {
	                        if (!subscriber.isUnsubscribed) {
	                            subscriber.error(err);
	                        }
	                    }).then(null, function (err) {
	                        // escape the promise trap, throw unhandled errors
	                        root.setTimeout(function () {
	                            throw err;
	                        });
	                    });
	                }
	            } else {
	                if (this._isScalar) {
	                    if (!subscriber.isUnsubscribed) {
	                        return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
	                    }
	                } else {
	                    promise.then(function (value) {
	                        _this2.value = value;
	                        _this2._isScalar = true;
	                        if (!subscriber.isUnsubscribed) {
	                            subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                        }
	                    }, function (err) {
	                        if (!subscriber.isUnsubscribed) {
	                            subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                        }
	                    }).then(null, function (err) {
	                        // escape the promise trap, throw unhandled errors
	                        root.setTimeout(function () {
	                            throw err;
	                        });
	                    });
	                }
	            }
	        }
	    }], [{
	        key: 'create',
	        value: function create(promise) {
	            var scheduler = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return new PromiseObservable(promise, scheduler);
	        }
	    }]);
	    return PromiseObservable;
	}(Observable);
	function dispatchNext(arg) {
	    var value = arg.value;
	    var subscriber = arg.subscriber;

	    if (!subscriber.isUnsubscribed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError(arg) {
	    var err = arg.err;
	    var subscriber = arg.subscriber;

	    if (!subscriber.isUnsubscribed) {
	        subscriber.error(err);
	    }
	}

	/**
	 * @param PromiseCtor
	 * @return {Promise<T>}
	 * @method toPromise
	 * @owner Observable
	 */
	function _toPromise(PromiseCtor) {
	    var _this = this;

	    if (!PromiseCtor) {
	        if (root.Rx && root.Rx.config && root.Rx.config.Promise) {
	            PromiseCtor = root.Rx.config.Promise;
	        } else if (root.Promise) {
	            PromiseCtor = root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value = void 0;
	        _this.subscribe(function (x) {
	            return value = x;
	        }, function (err) {
	            return reject(err);
	        }, function () {
	            return resolve(value);
	        });
	    });
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PromiseCompleter = function PromiseCompleter() {
	    var _this = this;

	    classCallCheck(this, PromiseCompleter);

	    this.promise = new Promise(function (res, rej) {
	        _this.resolve = res;
	        _this.reject = rej;
	    });
	};
	var PromiseWrapper = function () {
	    function PromiseWrapper() {
	        classCallCheck(this, PromiseWrapper);
	    }

	    createClass(PromiseWrapper, null, [{
	        key: "resolve",
	        value: function resolve(obj) {
	            return Promise.resolve(obj);
	        }
	    }, {
	        key: "reject",
	        value: function reject(obj, _) {
	            return Promise.reject(obj);
	        }
	        // Note: We can't rename this method into `catch`, as this is not a valid
	        // method name in Dart.

	    }, {
	        key: "catchError",
	        value: function catchError(promise, onError) {
	            return promise.catch(onError);
	        }
	    }, {
	        key: "all",
	        value: function all(promises) {
	            if (promises.length == 0) return Promise.resolve([]);
	            return Promise.all(promises);
	        }
	    }, {
	        key: "then",
	        value: function then(promise, success, rejection) {
	            return promise.then(success, rejection);
	        }
	    }, {
	        key: "wrap",
	        value: function wrap(computation) {
	            return new Promise(function (res, rej) {
	                try {
	                    res(computation());
	                } catch (e) {
	                    rej(e);
	                }
	            });
	        }
	    }, {
	        key: "scheduleMicrotask",
	        value: function scheduleMicrotask(computation) {
	            PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) {});
	        }
	    }, {
	        key: "completer",
	        value: function completer() {
	            return new PromiseCompleter();
	        }
	    }]);
	    return PromiseWrapper;
	}();

	var TimerWrapper = function () {
	    function TimerWrapper() {
	        classCallCheck(this, TimerWrapper);
	    }

	    createClass(TimerWrapper, null, [{
	        key: 'setTimeout',
	        value: function setTimeout(fn, millis) {
	            return global$1.setTimeout(fn, millis);
	        }
	    }, {
	        key: 'clearTimeout',
	        value: function clearTimeout(id) {
	            global$1.clearTimeout(id);
	        }
	    }, {
	        key: 'setInterval',
	        value: function setInterval(fn, millis) {
	            return global$1.setInterval(fn, millis);
	        }
	    }, {
	        key: 'clearInterval',
	        value: function clearInterval(id) {
	            global$1.clearInterval(id);
	        }
	    }]);
	    return TimerWrapper;
	}();
	var ObservableWrapper = function () {
	    function ObservableWrapper() {
	        classCallCheck(this, ObservableWrapper);
	    }

	    createClass(ObservableWrapper, null, [{
	        key: 'subscribe',

	        // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	        value: function subscribe(emitter, onNext, onError) {
	            var onComplete = arguments.length <= 3 || arguments[3] === undefined ? function () {} : arguments[3];

	            onError = typeof onError === 'function' && onError || noop;
	            onComplete = typeof onComplete === 'function' && onComplete || noop;
	            return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
	        }
	    }, {
	        key: 'isObservable',
	        value: function isObservable(obs) {
	            return !!obs.subscribe;
	        }
	        /**
	         * Returns whether `obs` has any subscribers listening to events.
	         */

	    }, {
	        key: 'hasSubscribers',
	        value: function hasSubscribers(obs) {
	            return obs.observers.length > 0;
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {
	            subscription.unsubscribe();
	        }
	        /**
	         * @deprecated - use callEmit() instead
	         */

	    }, {
	        key: 'callNext',
	        value: function callNext(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callEmit',
	        value: function callEmit(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callError',
	        value: function callError(emitter, error) {
	            emitter.error(error);
	        }
	    }, {
	        key: 'callComplete',
	        value: function callComplete(emitter) {
	            emitter.complete();
	        }
	    }, {
	        key: 'fromPromise',
	        value: function fromPromise(promise) {
	            return PromiseObservable.create(promise);
	        }
	    }, {
	        key: 'toPromise',
	        value: function toPromise(obj) {
	            return _toPromise.call(obj);
	        }
	    }]);
	    return ObservableWrapper;
	}();
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter = function (_Subject) {
	    inherits(EventEmitter, _Subject);

	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */

	    function EventEmitter() {
	        var isAsync = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	        classCallCheck(this, EventEmitter);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EventEmitter).call(this));

	        _this.__isAsync = isAsync;
	        return _this;
	    }

	    createClass(EventEmitter, [{
	        key: 'emit',
	        value: function emit(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	        /**
	         * @deprecated - use .emit(value) instead
	         */

	    }, {
	        key: 'next',
	        value: function next(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	    }, {
	        key: 'subscribe',
	        value: function subscribe(generatorOrNext, error, complete) {
	            var schedulerFn = void 0;
	            var errorFn = function errorFn(err) {
	                return null;
	            };
	            var completeFn = function completeFn() {
	                return null;
	            };
	            if (generatorOrNext && (typeof generatorOrNext === 'undefined' ? 'undefined' : _typeof(generatorOrNext)) === 'object') {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext.next(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext.next(value);
	                };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return generatorOrNext.error(err);
	                        });
	                    } : function (err) {
	                        generatorOrNext.error(err);
	                    };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return generatorOrNext.complete();
	                        });
	                    } : function () {
	                        generatorOrNext.complete();
	                    };
	                }
	            } else {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext(value);
	                };
	                if (error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return error(err);
	                        });
	                    } : function (err) {
	                        error(err);
	                    };
	                }
	                if (complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return complete();
	                        });
	                    } : function () {
	                        complete();
	                    };
	                }
	            }
	            return get(Object.getPrototypeOf(EventEmitter.prototype), 'subscribe', this).call(this, schedulerFn, errorFn, completeFn);
	        }
	    }]);
	    return EventEmitter;
	}(Subject);

	/**
	 * A DI Token representing a unique string id assigned to the application by Angular and used
	 * primarily for prefixing application attributes and CSS styles when
	 * {@link ViewEncapsulation#Emulated} is being used.
	 *
	 * If you need to avoid randomly generated value to be used as an application id, you can provide
	 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
	 * using this token.
	 * @experimental
	 */
	var APP_ID = new OpaqueToken('AppId');
	function _appIdRandomProviderFactory() {
	  return '' + _randomChar() + _randomChar() + _randomChar();
	}
	/**
	 * Providers that will generate a random APP_ID_TOKEN.
	 * @experimental
	 */
	var APP_ID_RANDOM_PROVIDER =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	  provide: APP_ID,
	  useFactory: _appIdRandomProviderFactory,
	  deps: []
	};
	function _randomChar() {
	  return StringWrapper.fromCharCode(97 + Math$1.floor(Math$1.random() * 25));
	}
	/**
	 * A function that will be executed when a platform is initialized.
	 * @experimental
	 */
	var PLATFORM_INITIALIZER =
	/*@ts2dart_const*/new OpaqueToken('Platform Initializer');
	/**
	 * A function that will be executed when an application is initialized.
	 * @experimental
	 */
	var APP_INITIALIZER =
	/*@ts2dart_const*/new OpaqueToken('Application Initializer');
	/**
	 * A token which indicates the root directory of the application
	 * @experimental
	 */
	var PACKAGE_ROOT_URL =
	/*@ts2dart_const*/new OpaqueToken('Application Packages Root URL');

	// Note: Need to rename warn as in Dart
	// class members and imports can't use the same name.
	var _warnImpl = warn;
	var Console = function () {
	    function Console() {
	        classCallCheck(this, Console);
	    }

	    createClass(Console, [{
	        key: 'log',
	        value: function log(message) {
	            print(message);
	        }
	        // Note: for reporting errors use `DOM.logError()` as it is platform specific

	    }, {
	        key: 'warn',
	        value: function warn(message) {
	            _warnImpl(message);
	        }
	    }]);
	    return Console;
	}();
	/** @nocollapse */
	Console.decorators = [{ type: Injectable }];

	/* @ts2dart_const */
	var DefaultIterableDifferFactory = function () {
	    function DefaultIterableDifferFactory() {
	        classCallCheck(this, DefaultIterableDifferFactory);
	    }

	    createClass(DefaultIterableDifferFactory, [{
	        key: 'supports',
	        value: function supports(obj) {
	            return isListLikeIterable(obj);
	        }
	    }, {
	        key: 'create',
	        value: function create(cdRef, trackByFn) {
	            return new DefaultIterableDiffer(trackByFn);
	        }
	    }]);
	    return DefaultIterableDifferFactory;
	}();
	var trackByIdentity = function trackByIdentity(index, item) {
	    return item;
	};
	/**
	 * @stable
	 */
	var DefaultIterableDiffer = function () {
	    function DefaultIterableDiffer(_trackByFn) {
	        classCallCheck(this, DefaultIterableDiffer);

	        this._trackByFn = _trackByFn;
	        this._length = null;
	        this._collection = null;
	        // Keeps track of the used records at any point in time (during & across `_check()` calls)
	        this._linkedRecords = null;
	        // Keeps track of the removed records at any point in time during `_check()` calls.
	        this._unlinkedRecords = null;
	        this._previousItHead = null;
	        this._itHead = null;
	        this._itTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._movesHead = null;
	        this._movesTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	        // Keeps track of records where custom track by is the same, but item identity has changed
	        this._identityChangesHead = null;
	        this._identityChangesTail = null;
	        this._trackByFn = isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;
	    }

	    createClass(DefaultIterableDiffer, [{
	        key: 'forEachItem',
	        value: function forEachItem(fn) {
	            var record;
	            for (record = this._itHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachPreviousItem',
	        value: function forEachPreviousItem(fn) {
	            var record;
	            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachAddedItem',
	        value: function forEachAddedItem(fn) {
	            var record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachMovedItem',
	        value: function forEachMovedItem(fn) {
	            var record;
	            for (record = this._movesHead; record !== null; record = record._nextMoved) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachRemovedItem',
	        value: function forEachRemovedItem(fn) {
	            var record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachIdentityChange',
	        value: function forEachIdentityChange(fn) {
	            var record;
	            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'diff',
	        value: function diff(collection) {
	            if (isBlank(collection)) collection = [];
	            if (!isListLikeIterable(collection)) {
	                throw new BaseException('Error trying to diff \'' + collection + '\'');
	            }
	            if (this.check(collection)) {
	                return this;
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'onDestroy',
	        value: function onDestroy() {}
	        // todo(vicb): optim for UnmodifiableListView (frozen arrays)

	    }, {
	        key: 'check',
	        value: function check(collection) {
	            var _this = this;

	            this._reset();
	            var record = this._itHead;
	            var mayBeDirty = false;
	            var index;
	            var item;
	            var itemTrackBy;
	            if (isArray(collection)) {
	                var list = collection;
	                this._length = collection.length;
	                for (index = 0; index < this._length; index++) {
	                    item = list[index];
	                    itemTrackBy = this._trackByFn(index, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = this._mismatch(record, item, itemTrackBy, index);
	                        mayBeDirty = true;
	                    } else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = this._verifyReinsertion(record, item, itemTrackBy, index);
	                        }
	                        if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                }
	            } else {
	                index = 0;
	                iterateListLike(collection, function (item /** TODO #9100 */) {
	                    itemTrackBy = _this._trackByFn(index, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = _this._mismatch(record, item, itemTrackBy, index);
	                        mayBeDirty = true;
	                    } else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                        }
	                        if (!looseIdentical(record.item, item)) _this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                    index++;
	                });
	                this._length = index;
	            }
	            this._truncate(record);
	            this._collection = collection;
	            return this.isDirty;
	        }
	        /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
	         * changes.
	         */

	    }, {
	        key: '_reset',

	        /**
	         * Reset the state of the change objects to show no changes. This means set previousKey to
	         * currentKey, and clear all of the queues (additions, moves, removals).
	         * Set the previousIndexes of moved and added items to their currentIndexes
	         * Reset the list of additions, moves and removals
	         *
	         * @internal
	         */
	        value: function _reset() {
	            if (this.isDirty) {
	                var record;
	                var nextRecord;
	                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                    record.previousIndex = record.currentIndex;
	                }
	                this._additionsHead = this._additionsTail = null;
	                for (record = this._movesHead; record !== null; record = nextRecord) {
	                    record.previousIndex = record.currentIndex;
	                    nextRecord = record._nextMoved;
	                }
	                this._movesHead = this._movesTail = null;
	                this._removalsHead = this._removalsTail = null;
	                this._identityChangesHead = this._identityChangesTail = null;
	            }
	        }
	        /**
	         * This is the core function which handles differences between collections.
	         *
	         * - `record` is the record which we saw at this position last time. If null then it is a new
	         *   item.
	         * - `item` is the current item in the collection
	         * - `index` is the position of the item in the collection
	         *
	         * @internal
	         */

	    }, {
	        key: '_mismatch',
	        value: function _mismatch(record, item, itemTrackBy, index) {
	            // The previous record after which we will append the current one.
	            var previousRecord;
	            if (record === null) {
	                previousRecord = this._itTail;
	            } else {
	                previousRecord = record._prev;
	                // Remove the record from the collection since we know it does not match the item.
	                this._remove(record);
	            }
	            // Attempt to see if we have seen the item before.
	            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	            if (record !== null) {
	                // We have seen this before, we need to move it forward in the collection.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);
	                this._moveAfter(record, previousRecord, index);
	            } else {
	                // Never seen it, check evicted list.
	                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	                if (record !== null) {
	                    // It is an item which we have evicted earlier: reinsert it back into the list.
	                    // But first we need to check if identity changed, so we can update in view if necessary
	                    if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);
	                    this._reinsertAfter(record, previousRecord, index);
	                } else {
	                    // It is a new item: add it.
	                    record = this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
	                }
	            }
	            return record;
	        }
	        /**
	         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	         *
	         * Use case: `[a, a]` => `[b, a, a]`
	         *
	         * If we did not have this check then the insertion of `b` would:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) leave `a` at index `1` as is. <-- this is wrong!
	         *   3) reinsert `a` at index 2. <-- this is wrong!
	         *
	         * The correct behavior is:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) reinsert `a` at index 1.
	         *   3) move `a` at from `1` to `2`.
	         *
	         *
	         * Double check that we have not evicted a duplicate item. We need to check if the item type may
	         * have already been removed:
	         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	         * at the end.
	         *
	         * @internal
	         */

	    }, {
	        key: '_verifyReinsertion',
	        value: function _verifyReinsertion(record, item, itemTrackBy, index) {
	            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	            if (reinsertRecord !== null) {
	                record = this._reinsertAfter(reinsertRecord, record._prev, index);
	            } else if (record.currentIndex != index) {
	                record.currentIndex = index;
	                this._addToMoves(record, index);
	            }
	            return record;
	        }
	        /**
	         * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
	         *
	         * - `record` The first excess {@link CollectionChangeRecord}.
	         *
	         * @internal
	         */

	    }, {
	        key: '_truncate',
	        value: function _truncate(record) {
	            // Anything after that needs to be removed;
	            while (record !== null) {
	                var nextRecord = record._next;
	                this._addToRemovals(this._unlink(record));
	                record = nextRecord;
	            }
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.clear();
	            }
	            if (this._additionsTail !== null) {
	                this._additionsTail._nextAdded = null;
	            }
	            if (this._movesTail !== null) {
	                this._movesTail._nextMoved = null;
	            }
	            if (this._itTail !== null) {
	                this._itTail._next = null;
	            }
	            if (this._removalsTail !== null) {
	                this._removalsTail._nextRemoved = null;
	            }
	            if (this._identityChangesTail !== null) {
	                this._identityChangesTail._nextIdentityChange = null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_reinsertAfter',
	        value: function _reinsertAfter(record, prevRecord, index) {
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.remove(record);
	            }
	            var prev = record._prevRemoved;
	            var next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            } else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            } else {
	                next._prevRemoved = prev;
	            }
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        }
	        /** @internal */

	    }, {
	        key: '_moveAfter',
	        value: function _moveAfter(record, prevRecord, index) {
	            this._unlink(record);
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        }
	        /** @internal */

	    }, {
	        key: '_addAfter',
	        value: function _addAfter(record, prevRecord, index) {
	            this._insertAfter(record, prevRecord, index);
	            if (this._additionsTail === null) {
	                // todo(vicb)
	                // assert(this._additionsHead === null);
	                this._additionsTail = this._additionsHead = record;
	            } else {
	                // todo(vicb)
	                // assert(_additionsTail._nextAdded === null);
	                // assert(record._nextAdded === null);
	                this._additionsTail = this._additionsTail._nextAdded = record;
	            }
	            return record;
	        }
	        /** @internal */

	    }, {
	        key: '_insertAfter',
	        value: function _insertAfter(record, prevRecord, index) {
	            // todo(vicb)
	            // assert(record != prevRecord);
	            // assert(record._next === null);
	            // assert(record._prev === null);
	            var next = prevRecord === null ? this._itHead : prevRecord._next;
	            // todo(vicb)
	            // assert(next != record);
	            // assert(prevRecord != record);
	            record._next = next;
	            record._prev = prevRecord;
	            if (next === null) {
	                this._itTail = record;
	            } else {
	                next._prev = record;
	            }
	            if (prevRecord === null) {
	                this._itHead = record;
	            } else {
	                prevRecord._next = record;
	            }
	            if (this._linkedRecords === null) {
	                this._linkedRecords = new _DuplicateMap();
	            }
	            this._linkedRecords.put(record);
	            record.currentIndex = index;
	            return record;
	        }
	        /** @internal */

	    }, {
	        key: '_remove',
	        value: function _remove(record) {
	            return this._addToRemovals(this._unlink(record));
	        }
	        /** @internal */

	    }, {
	        key: '_unlink',
	        value: function _unlink(record) {
	            if (this._linkedRecords !== null) {
	                this._linkedRecords.remove(record);
	            }
	            var prev = record._prev;
	            var next = record._next;
	            // todo(vicb)
	            // assert((record._prev = null) === null);
	            // assert((record._next = null) === null);
	            if (prev === null) {
	                this._itHead = next;
	            } else {
	                prev._next = next;
	            }
	            if (next === null) {
	                this._itTail = prev;
	            } else {
	                next._prev = prev;
	            }
	            return record;
	        }
	        /** @internal */

	    }, {
	        key: '_addToMoves',
	        value: function _addToMoves(record, toIndex) {
	            // todo(vicb)
	            // assert(record._nextMoved === null);
	            if (record.previousIndex === toIndex) {
	                return record;
	            }
	            if (this._movesTail === null) {
	                // todo(vicb)
	                // assert(_movesHead === null);
	                this._movesTail = this._movesHead = record;
	            } else {
	                // todo(vicb)
	                // assert(_movesTail._nextMoved === null);
	                this._movesTail = this._movesTail._nextMoved = record;
	            }
	            return record;
	        }
	        /** @internal */

	    }, {
	        key: '_addToRemovals',
	        value: function _addToRemovals(record) {
	            if (this._unlinkedRecords === null) {
	                this._unlinkedRecords = new _DuplicateMap();
	            }
	            this._unlinkedRecords.put(record);
	            record.currentIndex = null;
	            record._nextRemoved = null;
	            if (this._removalsTail === null) {
	                // todo(vicb)
	                // assert(_removalsHead === null);
	                this._removalsTail = this._removalsHead = record;
	                record._prevRemoved = null;
	            } else {
	                // todo(vicb)
	                // assert(_removalsTail._nextRemoved === null);
	                // assert(record._nextRemoved === null);
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = this._removalsTail._nextRemoved = record;
	            }
	            return record;
	        }
	        /** @internal */

	    }, {
	        key: '_addIdentityChange',
	        value: function _addIdentityChange(record, item) {
	            record.item = item;
	            if (this._identityChangesTail === null) {
	                this._identityChangesTail = this._identityChangesHead = record;
	            } else {
	                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	            }
	            return record;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var list = [];
	            this.forEachItem(function (record /** TODO #9100 */) {
	                return list.push(record);
	            });
	            var previous = [];
	            this.forEachPreviousItem(function (record /** TODO #9100 */) {
	                return previous.push(record);
	            });
	            var additions = [];
	            this.forEachAddedItem(function (record /** TODO #9100 */) {
	                return additions.push(record);
	            });
	            var moves = [];
	            this.forEachMovedItem(function (record /** TODO #9100 */) {
	                return moves.push(record);
	            });
	            var removals = [];
	            this.forEachRemovedItem(function (record /** TODO #9100 */) {
	                return removals.push(record);
	            });
	            var identityChanges = [];
	            this.forEachIdentityChange(function (record /** TODO #9100 */) {
	                return identityChanges.push(record);
	            });
	            return 'collection: ' + list.join(', ') + '\n' + 'previous: ' + previous.join(', ') + '\n' + 'additions: ' + additions.join(', ') + '\n' + 'moves: ' + moves.join(', ') + '\n' + 'removals: ' + removals.join(', ') + '\n' + 'identityChanges: ' + identityChanges.join(', ') + '\n';
	        }
	    }, {
	        key: 'collection',
	        get: function get() {
	            return this._collection;
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            return this._length;
	        }
	    }, {
	        key: 'isDirty',
	        get: function get() {
	            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
	        }
	    }]);
	    return DefaultIterableDiffer;
	}();
	/**
	 * @stable
	 */
	var CollectionChangeRecord = function () {
	    function CollectionChangeRecord(item, trackById) {
	        classCallCheck(this, CollectionChangeRecord);

	        this.item = item;
	        this.trackById = trackById;
	        this.currentIndex = null;
	        this.previousIndex = null;
	        /** @internal */
	        this._nextPrevious = null;
	        /** @internal */
	        this._prev = null;
	        /** @internal */
	        this._next = null;
	        /** @internal */
	        this._prevDup = null;
	        /** @internal */
	        this._nextDup = null;
	        /** @internal */
	        this._prevRemoved = null;
	        /** @internal */
	        this._nextRemoved = null;
	        /** @internal */
	        this._nextAdded = null;
	        /** @internal */
	        this._nextMoved = null;
	        /** @internal */
	        this._nextIdentityChange = null;
	    }

	    createClass(CollectionChangeRecord, [{
	        key: 'toString',
	        value: function toString() {
	            return this.previousIndex === this.currentIndex ? stringify(this.item) : stringify(this.item) + '[' + stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
	        }
	    }]);
	    return CollectionChangeRecord;
	}();
	// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item

	var _DuplicateItemRecordList = function () {
	    function _DuplicateItemRecordList() {
	        classCallCheck(this, _DuplicateItemRecordList);

	        /** @internal */
	        this._head = null;
	        /** @internal */
	        this._tail = null;
	    }
	    /**
	     * Append the record to the list of duplicates.
	     *
	     * Note: by design all records in the list of duplicates hold the same value in record.item.
	     */


	    createClass(_DuplicateItemRecordList, [{
	        key: 'add',
	        value: function add(record) {
	            if (this._head === null) {
	                this._head = this._tail = record;
	                record._nextDup = null;
	                record._prevDup = null;
	            } else {
	                // todo(vicb)
	                // assert(record.item ==  _head.item ||
	                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	                this._tail._nextDup = record;
	                record._prevDup = this._tail;
	                record._nextDup = null;
	                this._tail = record;
	            }
	        }
	        // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and
	        // CollectionChangeRecord.currentIndex >= afterIndex

	    }, {
	        key: 'get',
	        value: function get(trackById, afterIndex) {
	            var record;
	            for (record = this._head; record !== null; record = record._nextDup) {
	                if ((afterIndex === null || afterIndex < record.currentIndex) && looseIdentical(record.trackById, trackById)) {
	                    return record;
	                }
	            }
	            return null;
	        }
	        /**
	         * Remove one {@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * Returns whether the list of duplicates is empty.
	         */

	    }, {
	        key: 'remove',
	        value: function remove(record) {
	            // todo(vicb)
	            // assert(() {
	            //  // verify that the record being removed is in the list.
	            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
	            //    if (identical(cursor, record)) return true;
	            //  }
	            //  return false;
	            //});
	            var prev = record._prevDup;
	            var next = record._nextDup;
	            if (prev === null) {
	                this._head = next;
	            } else {
	                prev._nextDup = next;
	            }
	            if (next === null) {
	                this._tail = prev;
	            } else {
	                next._prevDup = prev;
	            }
	            return this._head === null;
	        }
	    }]);
	    return _DuplicateItemRecordList;
	}();

	var _DuplicateMap = function () {
	    function _DuplicateMap() {
	        classCallCheck(this, _DuplicateMap);

	        this.map = new Map();
	    }

	    createClass(_DuplicateMap, [{
	        key: 'put',
	        value: function put(record) {
	            // todo(vicb) handle corner cases
	            var key = getMapKey(record.trackById);
	            var duplicates = this.map.get(key);
	            if (!isPresent(duplicates)) {
	                duplicates = new _DuplicateItemRecordList();
	                this.map.set(key, duplicates);
	            }
	            duplicates.add(record);
	        }
	        /**
	         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
	         * have already iterated over, we use the afterIndex to pretend it is not there.
	         *
	         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	         * have any more `a`s needs to return the last `a` not the first or second.
	         */

	    }, {
	        key: 'get',
	        value: function get(trackById) {
	            var afterIndex = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var key = getMapKey(trackById);
	            var recordList = this.map.get(key);
	            return isBlank(recordList) ? null : recordList.get(trackById, afterIndex);
	        }
	        /**
	         * Removes a {@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * The list of duplicates also is removed from the map if it gets empty.
	         */

	    }, {
	        key: 'remove',
	        value: function remove(record) {
	            var key = getMapKey(record.trackById);
	            // todo(vicb)
	            // assert(this.map.containsKey(key));
	            var recordList = this.map.get(key);
	            // Remove the list of duplicates when it gets empty
	            if (recordList.remove(record)) {
	                this.map.delete(key);
	            }
	            return record;
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            this.map.clear();
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return '_DuplicateMap(' + stringify(this.map) + ')';
	        }
	    }, {
	        key: 'isEmpty',
	        get: function get() {
	            return this.map.size === 0;
	        }
	    }]);
	    return _DuplicateMap;
	}();

	/* @ts2dart_const */
	var DefaultKeyValueDifferFactory = function () {
	    function DefaultKeyValueDifferFactory() {
	        classCallCheck(this, DefaultKeyValueDifferFactory);
	    }

	    createClass(DefaultKeyValueDifferFactory, [{
	        key: 'supports',
	        value: function supports(obj) {
	            return obj instanceof Map || isJsObject(obj);
	        }
	    }, {
	        key: 'create',
	        value: function create(cdRef) {
	            return new DefaultKeyValueDiffer();
	        }
	    }]);
	    return DefaultKeyValueDifferFactory;
	}();
	var DefaultKeyValueDiffer = function () {
	    function DefaultKeyValueDiffer() {
	        classCallCheck(this, DefaultKeyValueDiffer);

	        this._records = new Map();
	        this._mapHead = null;
	        this._previousMapHead = null;
	        this._changesHead = null;
	        this._changesTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	    }

	    createClass(DefaultKeyValueDiffer, [{
	        key: 'forEachItem',
	        value: function forEachItem(fn) {
	            var record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachPreviousItem',
	        value: function forEachPreviousItem(fn) {
	            var record;
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachChangedItem',
	        value: function forEachChangedItem(fn) {
	            var record;
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachAddedItem',
	        value: function forEachAddedItem(fn) {
	            var record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'forEachRemovedItem',
	        value: function forEachRemovedItem(fn) {
	            var record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        }
	    }, {
	        key: 'diff',
	        value: function diff(map) {
	            if (isBlank(map)) map = MapWrapper.createFromPairs([]);
	            if (!(map instanceof Map || isJsObject(map))) {
	                throw new BaseException('Error trying to diff \'' + map + '\'');
	            }
	            if (this.check(map)) {
	                return this;
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'onDestroy',
	        value: function onDestroy() {}
	    }, {
	        key: 'check',
	        value: function check(map) {
	            var _this = this;

	            this._reset();
	            var records = this._records;
	            var oldSeqRecord = this._mapHead;
	            var lastOldSeqRecord = null;
	            var lastNewSeqRecord = null;
	            var seqChanged = false;
	            this._forEach(map, function (value /** TODO #9100 */, key /** TODO #9100 */) {
	                var newSeqRecord;
	                if (oldSeqRecord !== null && key === oldSeqRecord.key) {
	                    newSeqRecord = oldSeqRecord;
	                    if (!looseIdentical(value, oldSeqRecord.currentValue)) {
	                        oldSeqRecord.previousValue = oldSeqRecord.currentValue;
	                        oldSeqRecord.currentValue = value;
	                        _this._addToChanges(oldSeqRecord);
	                    }
	                } else {
	                    seqChanged = true;
	                    if (oldSeqRecord !== null) {
	                        oldSeqRecord._next = null;
	                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
	                        _this._addToRemovals(oldSeqRecord);
	                    }
	                    if (records.has(key)) {
	                        newSeqRecord = records.get(key);
	                    } else {
	                        newSeqRecord = new KeyValueChangeRecord(key);
	                        records.set(key, newSeqRecord);
	                        newSeqRecord.currentValue = value;
	                        _this._addToAdditions(newSeqRecord);
	                    }
	                }
	                if (seqChanged) {
	                    if (_this._isInRemovals(newSeqRecord)) {
	                        _this._removeFromRemovals(newSeqRecord);
	                    }
	                    if (lastNewSeqRecord == null) {
	                        _this._mapHead = newSeqRecord;
	                    } else {
	                        lastNewSeqRecord._next = newSeqRecord;
	                    }
	                }
	                lastOldSeqRecord = oldSeqRecord;
	                lastNewSeqRecord = newSeqRecord;
	                oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
	            });
	            this._truncate(lastOldSeqRecord, oldSeqRecord);
	            return this.isDirty;
	        }
	        /** @internal */

	    }, {
	        key: '_reset',
	        value: function _reset() {
	            if (this.isDirty) {
	                var record;
	                // Record the state of the mapping
	                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                    record.previousValue = record.currentValue;
	                }
	                for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                    record.previousValue = record.currentValue;
	                }
	                // todo(vicb) once assert is supported
	                // assert(() {
	                //  var r = _changesHead;
	                //  while (r != null) {
	                //    var nextRecord = r._nextChanged;
	                //    r._nextChanged = null;
	                //    r = nextRecord;
	                //  }
	                //
	                //  r = _additionsHead;
	                //  while (r != null) {
	                //    var nextRecord = r._nextAdded;
	                //    r._nextAdded = null;
	                //    r = nextRecord;
	                //  }
	                //
	                //  r = _removalsHead;
	                //  while (r != null) {
	                //    var nextRecord = r._nextRemoved;
	                //    r._nextRemoved = null;
	                //    r = nextRecord;
	                //  }
	                //
	                //  return true;
	                //});
	                this._changesHead = this._changesTail = null;
	                this._additionsHead = this._additionsTail = null;
	                this._removalsHead = this._removalsTail = null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_truncate',
	        value: function _truncate(lastRecord, record) {
	            while (record !== null) {
	                if (lastRecord === null) {
	                    this._mapHead = null;
	                } else {
	                    lastRecord._next = null;
	                }
	                var nextRecord = record._next;
	                // todo(vicb) assert
	                // assert((() {
	                //  record._next = null;
	                //  return true;
	                //}));
	                this._addToRemovals(record);
	                lastRecord = record;
	                record = nextRecord;
	            }
	            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
	                rec.previousValue = rec.currentValue;
	                rec.currentValue = null;
	                this._records.delete(rec.key);
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_isInRemovals',
	        value: function _isInRemovals(record) {
	            return record === this._removalsHead || record._nextRemoved !== null || record._prevRemoved !== null;
	        }
	        /** @internal */

	    }, {
	        key: '_addToRemovals',
	        value: function _addToRemovals(record) {
	            // todo(vicb) assert
	            // assert(record._next == null);
	            // assert(record._nextAdded == null);
	            // assert(record._nextChanged == null);
	            // assert(record._nextRemoved == null);
	            // assert(record._prevRemoved == null);
	            if (this._removalsHead === null) {
	                this._removalsHead = this._removalsTail = record;
	            } else {
	                this._removalsTail._nextRemoved = record;
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = record;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_removeFromSeq',
	        value: function _removeFromSeq(prev, record) {
	            var next = record._next;
	            if (prev === null) {
	                this._mapHead = next;
	            } else {
	                prev._next = next;
	            }
	            // todo(vicb) assert
	            // assert((() {
	            //  record._next = null;
	            //  return true;
	            //})());
	        }
	        /** @internal */

	    }, {
	        key: '_removeFromRemovals',
	        value: function _removeFromRemovals(record) {
	            // todo(vicb) assert
	            // assert(record._next == null);
	            // assert(record._nextAdded == null);
	            // assert(record._nextChanged == null);
	            var prev = record._prevRemoved;
	            var next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            } else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            } else {
	                next._prevRemoved = prev;
	            }
	            record._prevRemoved = record._nextRemoved = null;
	        }
	        /** @internal */

	    }, {
	        key: '_addToAdditions',
	        value: function _addToAdditions(record) {
	            // todo(vicb): assert
	            // assert(record._next == null);
	            // assert(record._nextAdded == null);
	            // assert(record._nextChanged == null);
	            // assert(record._nextRemoved == null);
	            // assert(record._prevRemoved == null);
	            if (this._additionsHead === null) {
	                this._additionsHead = this._additionsTail = record;
	            } else {
	                this._additionsTail._nextAdded = record;
	                this._additionsTail = record;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_addToChanges',
	        value: function _addToChanges(record) {
	            // todo(vicb) assert
	            // assert(record._nextAdded == null);
	            // assert(record._nextChanged == null);
	            // assert(record._nextRemoved == null);
	            // assert(record._prevRemoved == null);
	            if (this._changesHead === null) {
	                this._changesHead = this._changesTail = record;
	            } else {
	                this._changesTail._nextChanged = record;
	                this._changesTail = record;
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var items = [];
	            var previous = [];
	            var changes = [];
	            var additions = [];
	            var removals = [];
	            var record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                items.push(stringify(record));
	            }
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                previous.push(stringify(record));
	            }
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                changes.push(stringify(record));
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                additions.push(stringify(record));
	            }
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                removals.push(stringify(record));
	            }
	            return 'map: ' + items.join(', ') + '\n' + 'previous: ' + previous.join(', ') + '\n' + 'additions: ' + additions.join(', ') + '\n' + 'changes: ' + changes.join(', ') + '\n' + 'removals: ' + removals.join(', ') + '\n';
	        }
	        /** @internal */

	    }, {
	        key: '_forEach',
	        value: function _forEach(obj /** TODO #9100 */, fn) {
	            if (obj instanceof Map) {
	                obj.forEach(fn);
	            } else {
	                StringMapWrapper.forEach(obj, fn);
	            }
	        }
	    }, {
	        key: 'isDirty',
	        get: function get() {
	            return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
	        }
	    }]);
	    return DefaultKeyValueDiffer;
	}();
	/**
	 * @stable
	 */
	var KeyValueChangeRecord = function () {
	    function KeyValueChangeRecord(key) {
	        classCallCheck(this, KeyValueChangeRecord);

	        this.key = key;
	        this.previousValue = null;
	        this.currentValue = null;
	        /** @internal */
	        this._nextPrevious = null;
	        /** @internal */
	        this._next = null;
	        /** @internal */
	        this._nextAdded = null;
	        /** @internal */
	        this._nextRemoved = null;
	        /** @internal */
	        this._prevRemoved = null;
	        /** @internal */
	        this._nextChanged = null;
	    }

	    createClass(KeyValueChangeRecord, [{
	        key: 'toString',
	        value: function toString() {
	            return looseIdentical(this.previousValue, this.currentValue) ? stringify(this.key) : stringify(this.key) + '[' + stringify(this.previousValue) + '->' + stringify(this.currentValue) + ']';
	        }
	    }]);
	    return KeyValueChangeRecord;
	}();

	/**
	 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	 * @ts2dart_const
	 * @stable
	 */
	var IterableDiffers = function () {
	    /*@ts2dart_const*/

	    function IterableDiffers(factories) {
	        classCallCheck(this, IterableDiffers);

	        this.factories = factories;
	    }

	    createClass(IterableDiffers, [{
	        key: 'find',
	        value: function find(iterable) {
	            var factory = this.factories.find(function (f) {
	                return f.supports(iterable);
	            });
	            if (isPresent(factory)) {
	                return factory;
	            } else {
	                throw new BaseException('Cannot find a differ supporting object \'' + iterable + '\' of type \'' + getTypeNameForDebugging(iterable) + '\'');
	            }
	        }
	    }], [{
	        key: 'create',
	        value: function create(factories, parent) {
	            if (isPresent(parent)) {
	                var copied = ListWrapper.clone(parent.factories);
	                factories = factories.concat(copied);
	                return new IterableDiffers(factories);
	            } else {
	                return new IterableDiffers(factories);
	            }
	        }
	        /**
	         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
	         * inherited {@link IterableDiffers} instance with the provided factories and return a new
	         * {@link IterableDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	               * which will only be applied to the injector for this component and its children.
	               * This step is all that's required to make a new {@link IterableDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * @Component({
	         *   viewProviders: [
	         *     IterableDiffers.extend([new ImmutableListDiffer()])
	         *   ]
	         * })
	         * ```
	         */

	    }, {
	        key: 'extend',
	        value: function extend(factories) {
	            return new Provider(IterableDiffers, {
	                useFactory: function useFactory(parent) {
	                    if (isBlank(parent)) {
	                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new BaseException('Cannot extend IterableDiffers without a parent injector');
	                    }
	                    return IterableDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[IterableDiffers, new SkipSelfMetadata(), new OptionalMetadata()]]
	            });
	        }
	    }]);
	    return IterableDiffers;
	}();

	/**
	 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	 * @ts2dart_const
	 * @stable
	 */
	var KeyValueDiffers = function () {
	    /*@ts2dart_const*/

	    function KeyValueDiffers(factories) {
	        classCallCheck(this, KeyValueDiffers);

	        this.factories = factories;
	    }

	    createClass(KeyValueDiffers, [{
	        key: 'find',
	        value: function find(kv) {
	            var factory = this.factories.find(function (f) {
	                return f.supports(kv);
	            });
	            if (isPresent(factory)) {
	                return factory;
	            } else {
	                throw new BaseException('Cannot find a differ supporting object \'' + kv + '\'');
	            }
	        }
	    }], [{
	        key: 'create',
	        value: function create(factories, parent) {
	            if (isPresent(parent)) {
	                var copied = ListWrapper.clone(parent.factories);
	                factories = factories.concat(copied);
	                return new KeyValueDiffers(factories);
	            } else {
	                return new KeyValueDiffers(factories);
	            }
	        }
	        /**
	         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
	         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
	         * {@link KeyValueDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	               * which will only be applied to the injector for this component and its children.
	               * This step is all that's required to make a new {@link KeyValueDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * @Component({
	         *   viewProviders: [
	         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	         *   ]
	         * })
	         * ```
	         */

	    }, {
	        key: 'extend',
	        value: function extend(factories) {
	            return new Provider(KeyValueDiffers, {
	                useFactory: function useFactory(parent) {
	                    if (isBlank(parent)) {
	                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new BaseException('Cannot extend KeyValueDiffers without a parent injector');
	                    }
	                    return KeyValueDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[KeyValueDiffers, new SkipSelfMetadata(), new OptionalMetadata()]]
	            });
	        }
	    }]);
	    return KeyValueDiffers;
	}();

	var uninitialized = new Object();
	function devModeEqual(a, b) {
	    if (isListLikeIterable(a) && isListLikeIterable(b)) {
	        return areIterablesEqual(a, b, devModeEqual);
	    } else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
	        return true;
	    } else {
	        return looseIdentical(a, b);
	    }
	}
	/**
	 * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
	 * reference
	 * has not changed.
	 *
	 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	 *
	 * Example:
	 *
	 * ```
	 * if (this._latestValue === this._latestReturnedValue) {
	 *    return this._latestReturnedValue;
	 *  } else {
	 *    this._latestReturnedValue = this._latestValue;
	 *    return WrappedValue.wrap(this._latestValue); // this will force update
	 *  }
	 * ```
	 * @stable
	 */
	var WrappedValue = function () {
	    function WrappedValue(wrapped) {
	        classCallCheck(this, WrappedValue);

	        this.wrapped = wrapped;
	    }

	    createClass(WrappedValue, null, [{
	        key: 'wrap',
	        value: function wrap(value) {
	            return new WrappedValue(value);
	        }
	    }]);
	    return WrappedValue;
	}();
	/**
	 * Helper class for unwrapping WrappedValue s
	 */
	var ValueUnwrapper = function () {
	    function ValueUnwrapper() {
	        classCallCheck(this, ValueUnwrapper);

	        this.hasWrappedValue = false;
	    }

	    createClass(ValueUnwrapper, [{
	        key: 'unwrap',
	        value: function unwrap(value) {
	            if (value instanceof WrappedValue) {
	                this.hasWrappedValue = true;
	                return value.wrapped;
	            }
	            return value;
	        }
	    }, {
	        key: 'reset',
	        value: function reset() {
	            this.hasWrappedValue = false;
	        }
	    }]);
	    return ValueUnwrapper;
	}();
	/**
	 * Represents a basic change from a previous to a new value.
	 * @stable
	 */
	var SimpleChange = function () {
	    function SimpleChange(previousValue, currentValue) {
	        classCallCheck(this, SimpleChange);

	        this.previousValue = previousValue;
	        this.currentValue = currentValue;
	    }
	    /**
	     * Check whether the new value is the first value assigned.
	     */


	    createClass(SimpleChange, [{
	        key: 'isFirstChange',
	        value: function isFirstChange() {
	            return this.previousValue === uninitialized;
	        }
	    }]);
	    return SimpleChange;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @stable
	 */
	var ChangeDetectorRef = function ChangeDetectorRef() {
	  classCallCheck(this, ChangeDetectorRef);
	};

	/**
	 * Structural diffing for `Object`s and `Map`s.
	 */
	var keyValDiff =
	/*@ts2dart_const*/[new DefaultKeyValueDifferFactory()];
	/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */
	var iterableDiff =
	/*@ts2dart_const*/[new DefaultIterableDifferFactory()];
	var defaultIterableDiffers = new IterableDiffers(iterableDiff);
	var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

	/**
	 * @experimental
	 */
	var RenderComponentType = function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles) {
	  classCallCheck(this, RenderComponentType);

	  this.id = id;
	  this.templateUrl = templateUrl;
	  this.slotCount = slotCount;
	  this.encapsulation = encapsulation;
	  this.styles = styles;
	};
	var RenderDebugInfo = function () {
	  function RenderDebugInfo() {
	    classCallCheck(this, RenderDebugInfo);
	  }

	  createClass(RenderDebugInfo, [{
	    key: 'injector',
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'component',
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'providerTokens',
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'references',
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'source',
	    get: function get() {
	      return unimplemented();
	    }
	  }]);
	  return RenderDebugInfo;
	}();
	/**
	 * @experimental
	 */
	var Renderer = function Renderer() {
	  classCallCheck(this, Renderer);
	};
	/**
	 * Injectable service that provides a low-level interface for modifying the UI.
	 *
	 * Use this service to bypass Angular's templating and make custom UI changes that can't be
	 * expressed declaratively. For example if you need to set a property or an attribute whose name is
	 * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
	 * respectively.
	 *
	 * If you are implementing a custom renderer, you must implement this interface.
	 *
	 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	 * @experimental
	 */
	var RootRenderer = function RootRenderer() {
	  classCallCheck(this, RootRenderer);
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
	 * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
	 * handled.
	 *
	 * See DomSanitizationService for more details on security in Angular applications.
	 *
	 * @stable
	 */
	var SecurityContext;
	(function (SecurityContext) {
	  SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
	  SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
	  SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
	  SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
	  SecurityContext[SecurityContext["URL"] = 4] = "URL";
	  SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
	})(SecurityContext || (SecurityContext = {}));
	/**
	 * SanitizationService is used by the views to sanitize potentially dangerous values. This is a
	 * private API, use code should only refer to DomSanitizationService.
	 *
	 * @stable
	 */
	var SanitizationService = function SanitizationService() {
	  classCallCheck(this, SanitizationService);
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A wrapper around a native element inside of a View.
	 *
	 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
	 * element.
	 *
	 * @security Permitting direct access to the DOM can make your application more vulnerable to
	 * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
	 * [Security Guide](http://g.co/ng/security).
	 *
	 * @stable
	 */
	// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
	// i.e. users have to ask for what they need. With that, we can build better analysis tools
	// and could do better codegen in the future.
	var ElementRef = function ElementRef(nativeElement) {
	  classCallCheck(this, ElementRef);

	  this.nativeElement = nativeElement;
	};

	var trace;
	var events;
	function detectWTF() {
	    var wtf = global$1['wtf'];
	    if (wtf) {
	        trace = wtf['trace'];
	        if (trace) {
	            events = trace['events'];
	            return true;
	        }
	    }
	    return false;
	}
	function createScope(signature) {
	    var flags = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return events.createScope(signature, flags);
	}
	function leave(scope, returnValue) {
	    trace.leaveScope(scope, returnValue);
	    return returnValue;
	}

	// Change exports to const once https://github.com/angular/ts2dart/issues/150
	/**
	 * True if WTF is enabled.
	 */
	var wtfEnabled = detectWTF();
	function noopScope(arg0, arg1) {
	  return null;
	}
	/**
	 * Create trace scope.
	 *
	 * Scopes must be strictly nested and are analogous to stack frames, but
	 * do not have to follow the stack frames. Instead it is recommended that they follow logical
	 * nesting. You may want to use
	 * [Event
	 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	 * as they are defined in WTF.
	 *
	 * Used to mark scope entry. The return value is used to leave the scope.
	 *
	 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	 *
	 *     someMethod() {
	 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	 *        // DO SOME WORK HERE
	 *        return wtfLeave(s, 123); // Return value 123
	 *     }
	 *
	 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	 * negatively impact the performance of your application. For this reason we recommend that
	 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	 * exception, will produce incorrect trace, but presence of exception signifies logic error which
	 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	 * an exception is expected during normal execution while profiling.
	 *
	 * @experimental
	 */
	var wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) {
	  return noopScope;
	};
	/**
	 * Used to mark end of Scope.
	 *
	 * - `scope` to end.
	 * - `returnValue` (optional) to be passed to the WTF.
	 *
	 * Returns the `returnValue for easy chaining.
	 * @experimental
	 */
	var wtfLeave = wtfEnabled ? leave : function (s, r) {
	  return r;
	};

	/**
	 * Represents a container where one or more Views can be attached.
	 *
	 * The container can contain two kinds of Views. Host Views, created by instantiating a
	 * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
	 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
	 *
	 * The location of the View Container within the containing View is specified by the Anchor
	 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	 * have a single View Container.
	 *
	 * Root elements of Views attached to this container become siblings of the Anchor Element in
	 * the Rendered View.
	 *
	 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
	 * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
	 * @stable
	 */
	var ViewContainerRef = function () {
	    function ViewContainerRef() {
	        classCallCheck(this, ViewContainerRef);
	    }

	    createClass(ViewContainerRef, [{
	        key: 'element',

	        /**
	         * Anchor element that specifies the location of this container in the containing View.
	         * <!-- TODO: rename to anchorElement -->
	         */
	        get: function get() {
	            return unimplemented();
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return unimplemented();
	        }
	    }, {
	        key: 'parentInjector',
	        get: function get() {
	            return unimplemented();
	        }
	        /**
	         * Returns the number of Views currently attached to this container.
	         */

	    }, {
	        key: 'length',
	        get: function get() {
	            return unimplemented();
	        }
	    }]);
	    return ViewContainerRef;
	}();
	var ViewContainerRef_ = function () {
	    function ViewContainerRef_(_element) {
	        classCallCheck(this, ViewContainerRef_);

	        this._element = _element;
	        /** @internal */
	        this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
	        /** @internal */
	        this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
	        /** @internal */
	        this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
	        /** @internal */
	        this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
	    }

	    createClass(ViewContainerRef_, [{
	        key: 'get',
	        value: function get(index) {
	            return this._element.nestedViews[index].ref;
	        }
	    }, {
	        key: 'createEmbeddedView',

	        // TODO(rado): profile and decide whether bounds checks should be added
	        // to the methods below.
	        value: function createEmbeddedView(templateRef) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var index = arguments.length <= 2 || arguments[2] === undefined ? -1 : arguments[2];

	            var viewRef = templateRef.createEmbeddedView(context);
	            this.insert(viewRef, index);
	            return viewRef;
	        }
	    }, {
	        key: 'createComponent',
	        value: function createComponent(componentFactory) {
	            var index = arguments.length <= 1 || arguments[1] === undefined ? -1 : arguments[1];
	            var injector = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	            var projectableNodes = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            var s = this._createComponentInContainerScope();
	            var contextInjector = isPresent(injector) ? injector : this._element.parentInjector;
	            var componentRef = componentFactory.create(contextInjector, projectableNodes);
	            this.insert(componentRef.hostView, index);
	            return wtfLeave(s, componentRef);
	        }
	        // TODO(i): refactor insert+remove into move

	    }, {
	        key: 'insert',
	        value: function insert(viewRef) {
	            var index = arguments.length <= 1 || arguments[1] === undefined ? -1 : arguments[1];

	            var s = this._insertScope();
	            if (index == -1) index = this.length;
	            var viewRef_ = viewRef;
	            this._element.attachView(viewRef_.internalView, index);
	            return wtfLeave(s, viewRef_);
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(viewRef) {
	            return ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
	        }
	        // TODO(i): rename to destroy

	    }, {
	        key: 'remove',
	        value: function remove() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

	            var s = this._removeScope();
	            if (index == -1) index = this.length - 1;
	            var view = this._element.detachView(index);
	            view.destroy();
	            // view is intentionally not returned to the client.
	            wtfLeave(s);
	        }
	        // TODO(i): refactor insert+remove into move

	    }, {
	        key: 'detach',
	        value: function detach() {
	            var index = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

	            var s = this._detachScope();
	            if (index == -1) index = this.length - 1;
	            var view = this._element.detachView(index);
	            return wtfLeave(s, view.ref);
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            for (var i = this.length - 1; i >= 0; i--) {
	                this.remove(i);
	            }
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            var views = this._element.nestedViews;
	            return isPresent(views) ? views.length : 0;
	        }
	    }, {
	        key: 'element',
	        get: function get() {
	            return this._element.elementRef;
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return this._element.injector;
	        }
	    }, {
	        key: 'parentInjector',
	        get: function get() {
	            return this._element.parentInjector;
	        }
	    }]);
	    return ViewContainerRef_;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ViewType;
	(function (ViewType) {
	    // A view that contains the host element with bound component directive.
	    // Contains a COMPONENT view
	    ViewType[ViewType["HOST"] = 0] = "HOST";
	    // The view of the component
	    // Can contain 0 to n EMBEDDED views
	    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
	    // A view that is embedded into another View via a <template> element
	    // inside of a COMPONENT view
	    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
	})(ViewType || (ViewType = {}));

	/**
	 * An AppElement is created for elements that have a ViewContainerRef,
	 * a nested component or a <template> element to keep data around
	 * that is needed for later instantiations.
	 */
	var AppElement = function () {
	    function AppElement(index, parentIndex, parentView, nativeElement) {
	        classCallCheck(this, AppElement);

	        this.index = index;
	        this.parentIndex = parentIndex;
	        this.parentView = parentView;
	        this.nativeElement = nativeElement;
	        this.nestedViews = null;
	        this.componentView = null;
	    }

	    createClass(AppElement, [{
	        key: 'initComponent',
	        value: function initComponent(component, componentConstructorViewQueries, view) {
	            this.component = component;
	            this.componentConstructorViewQueries = componentConstructorViewQueries;
	            this.componentView = view;
	        }
	    }, {
	        key: 'mapNestedViews',
	        value: function mapNestedViews(nestedViewClass, callback) {
	            var result = [];
	            if (isPresent(this.nestedViews)) {
	                this.nestedViews.forEach(function (nestedView) {
	                    if (nestedView.clazz === nestedViewClass) {
	                        result.push(callback(nestedView));
	                    }
	                });
	            }
	            return result;
	        }
	    }, {
	        key: 'attachView',
	        value: function attachView(view, viewIndex) {
	            if (view.type === ViewType.COMPONENT) {
	                throw new BaseException('Component views can\'t be moved!');
	            }
	            var nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            ListWrapper.insert(nestedViews, viewIndex, view);
	            var refRenderNode;
	            if (viewIndex > 0) {
	                var prevView = nestedViews[viewIndex - 1];
	                refRenderNode = prevView.lastRootNode;
	            } else {
	                refRenderNode = this.nativeElement;
	            }
	            if (isPresent(refRenderNode)) {
	                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
	            }
	            view.addToContentChildren(this);
	        }
	    }, {
	        key: 'detachView',
	        value: function detachView(viewIndex) {
	            var view = ListWrapper.removeAt(this.nestedViews, viewIndex);
	            if (view.type === ViewType.COMPONENT) {
	                throw new BaseException('Component views can\'t be moved!');
	            }
	            view.detach();
	            view.removeFromContentChildren(this);
	            return view;
	        }
	    }, {
	        key: 'elementRef',
	        get: function get() {
	            return new ElementRef(this.nativeElement);
	        }
	    }, {
	        key: 'vcRef',
	        get: function get() {
	            return new ViewContainerRef_(this);
	        }
	    }, {
	        key: 'parentInjector',
	        get: function get() {
	            return this.parentView.injector(this.parentIndex);
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return this.parentView.injector(this.index);
	        }
	    }]);
	    return AppElement;
	}();

	/**
	 * An error thrown if application changes model breaking the top-down data flow.
	 *
	 * This exception is only thrown in dev mode.
	 *
	 * <!-- TODO: Add a link once the dev mode option is configurable -->
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'parent',
	 *   template: `
	 *     <child [prop]="parentProp"></child>
	 *   `,
	 *   directives: [forwardRef(() => Child)]
	 * })
	 * class Parent {
	 *   parentProp = "init";
	 * }
	 *
	 * @Directive({selector: 'child', inputs: ['prop']})
	 * class Child {
	 *   constructor(public parent: Parent) {}
	 *
	 *   set prop(v) {
	 *     // this updates the parent property, which is disallowed during change detection
	 *     // this will result in ExpressionChangedAfterItHasBeenCheckedException
	 *     this.parent.parentProp = "updated";
	 *   }
	 * }
	 * ```
	 * @stable
	 */
	var ExpressionChangedAfterItHasBeenCheckedException = function (_BaseException) {
	    inherits(ExpressionChangedAfterItHasBeenCheckedException, _BaseException);

	    function ExpressionChangedAfterItHasBeenCheckedException(oldValue, currValue, context) {
	        classCallCheck(this, ExpressionChangedAfterItHasBeenCheckedException);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ExpressionChangedAfterItHasBeenCheckedException).call(this, 'Expression has changed after it was checked. ' + ('Previous value: \'' + oldValue + '\'. Current value: \'' + currValue + '\'')));
	    }

	    return ExpressionChangedAfterItHasBeenCheckedException;
	}(BaseException);
	/**
	 * Thrown when an exception was raised during view creation, change detection or destruction.
	 *
	 * This error wraps the original exception to attach additional contextual information that can
	 * be useful for debugging.
	 * @stable
	 */
	var ViewWrappedException = function (_WrappedException) {
	    inherits(ViewWrappedException, _WrappedException);

	    function ViewWrappedException(originalException, originalStack, context) {
	        classCallCheck(this, ViewWrappedException);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ViewWrappedException).call(this, 'Error in ' + context.source, originalException, originalStack, context));
	    }

	    return ViewWrappedException;
	}(WrappedException);
	/**
	 * Thrown when a destroyed view is used.
	 *
	 * This error indicates a bug in the framework.
	 *
	 * This is an internal Angular error.
	 * @stable
	 */
	var ViewDestroyedException = function (_BaseException2) {
	    inherits(ViewDestroyedException, _BaseException2);

	    function ViewDestroyedException(details) {
	        classCallCheck(this, ViewDestroyedException);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ViewDestroyedException).call(this, 'Attempt to use a destroyed view: ' + details));
	    }

	    return ViewDestroyedException;
	}(BaseException);

	var ViewUtils = function () {
	    function ViewUtils(_renderer, _appId, sanitizer) {
	        classCallCheck(this, ViewUtils);

	        this._renderer = _renderer;
	        this._appId = _appId;
	        this._nextCompTypeId = 0;
	        this.sanitizer = sanitizer;
	    }
	    /**
	     * Used by the generated code
	     */


	    createClass(ViewUtils, [{
	        key: 'createRenderComponentType',
	        value: function createRenderComponentType(templateUrl, slotCount, encapsulation, styles) {
	            return new RenderComponentType(this._appId + '-' + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles);
	        }
	        /** @internal */

	    }, {
	        key: 'renderComponent',
	        value: function renderComponent(renderComponentType) {
	            return this._renderer.renderComponent(renderComponentType);
	        }
	    }]);
	    return ViewUtils;
	}();
	/** @nocollapse */
	ViewUtils.decorators = [{ type: Injectable }];
	/** @nocollapse */
	ViewUtils.ctorParameters = [{ type: RootRenderer }, { type: undefined, decorators: [{ type: Inject, args: [APP_ID] }] }, { type: SanitizationService }];
	function flattenNestedViewRenderNodes(nodes) {
	    return _flattenNestedViewRenderNodes(nodes, []);
	}
	function _flattenNestedViewRenderNodes(nodes, renderNodes) {
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node instanceof AppElement) {
	            var appEl = node;
	            renderNodes.push(appEl.nativeElement);
	            if (isPresent(appEl.nestedViews)) {
	                for (var k = 0; k < appEl.nestedViews.length; k++) {
	                    _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
	                }
	            }
	        } else {
	            renderNodes.push(node);
	        }
	    }
	    return renderNodes;
	}
	var EMPTY_ARR = [];
	function ensureSlotCount(projectableNodes, expectedSlotCount) {
	    var res;
	    if (isBlank(projectableNodes)) {
	        res = EMPTY_ARR;
	    } else if (projectableNodes.length < expectedSlotCount) {
	        var givenSlotCount = projectableNodes.length;
	        res = ListWrapper.createFixedSize(expectedSlotCount);
	        for (var i = 0; i < expectedSlotCount; i++) {
	            res[i] = i < givenSlotCount ? projectableNodes[i] : EMPTY_ARR;
	        }
	    } else {
	        res = projectableNodes;
	    }
	    return res;
	}
	var MAX_INTERPOLATION_VALUES = 9;
	function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	    switch (valueCount) {
	        case 1:
	            return c0 + _toStringWithNull(a1) + c1;
	        case 2:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	        case 3:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3;
	        case 4:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4;
	        case 5:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	        case 6:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	        case 7:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7;
	        case 8:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	        case 9:
	            return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	        default:
	            throw new BaseException('Does not support more than 9 expressions');
	    }
	}
	function _toStringWithNull(v) {
	    return v != null ? v.toString() : '';
	}
	function checkBinding(throwOnChange, oldValue, newValue) {
	    if (throwOnChange) {
	        if (!devModeEqual(oldValue, newValue)) {
	            throw new ExpressionChangedAfterItHasBeenCheckedException(oldValue, newValue, null);
	        }
	        return false;
	    } else {
	        return !looseIdentical(oldValue, newValue);
	    }
	}
	function castByValue(input, value) {
	    return input;
	}
	var EMPTY_ARRAY = [];
	var EMPTY_MAP = {};
	function pureProxy1(fn) {
	    var result;
	    var v0;
	    v0 = uninitialized;
	    return function (p0) {
	        if (!looseIdentical(v0, p0)) {
	            v0 = p0;
	            result = fn(p0);
	        }
	        return result;
	    };
	}
	function pureProxy2(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1;
	    v0 = v1 = uninitialized;
	    return function (p0, p1) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
	            v0 = p0;
	            v1 = p1;
	            result = fn(p0, p1);
	        }
	        return result;
	    };
	}
	function pureProxy3(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2;
	    v0 = v1 = v2 = uninitialized;
	    return function (p0, p1, p2) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            result = fn(p0, p1, p2);
	        }
	        return result;
	    };
	}
	function pureProxy4(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3;
	    v0 = v1 = v2 = v3 = uninitialized;
	    return function (p0, p1, p2, p3) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            result = fn(p0, p1, p2, p3);
	        }
	        return result;
	    };
	}
	function pureProxy5(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4;
	    v0 = v1 = v2 = v3 = v4 = uninitialized;
	    return function (p0, p1, p2, p3, p4) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            result = fn(p0, p1, p2, p3, p4);
	        }
	        return result;
	    };
	}
	function pureProxy6(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5;
	    v0 = v1 = v2 = v3 = v4 = v5 = uninitialized;
	    return function (p0, p1, p2, p3, p4, p5) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            result = fn(p0, p1, p2, p3, p4, p5);
	        }
	        return result;
	    };
	}
	function pureProxy7(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            result = fn(p0, p1, p2, p3, p4, p5, p6);
	        }
	        return result;
	    };
	}
	function pureProxy8(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6 /** TODO #9100 */, v7;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
	        }
	        return result;
	    };
	}
	function pureProxy9(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6 /** TODO #9100 */, v7 /** TODO #9100 */, v8;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            v8 = p8;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
	        }
	        return result;
	    };
	}
	function pureProxy10(fn) {
	    var result;
	    var v0 /** TODO #9100 */, v1 /** TODO #9100 */, v2 /** TODO #9100 */, v3 /** TODO #9100 */, v4 /** TODO #9100 */, v5 /** TODO #9100 */, v6 /** TODO #9100 */, v7 /** TODO #9100 */, v8 /** TODO #9100 */, v9;
	    v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = uninitialized;
	    return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
	        if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) || !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) || !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) || !looseIdentical(v9, p9)) {
	            v0 = p0;
	            v1 = p1;
	            v2 = p2;
	            v3 = p3;
	            v4 = p4;
	            v5 = p5;
	            v6 = p6;
	            v7 = p7;
	            v8 = p8;
	            v9 = p9;
	            result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	        }
	        return result;
	    };
	}

	/**
	 * Represents an instance of a Component created via a {@link ComponentFactory}.
	 *
	 * `ComponentRef` provides access to the Component Instance as well other objects related to this
	 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
	 * method.
	 * @stable
	 */
	var ComponentRef = function () {
	  function ComponentRef() {
	    classCallCheck(this, ComponentRef);
	  }

	  createClass(ComponentRef, [{
	    key: 'location',

	    /**
	     * Location of the Host Element of this Component Instance.
	     */
	    get: function get() {
	      return unimplemented();
	    }
	    /**
	     * The injector on which the component instance exists.
	     */

	  }, {
	    key: 'injector',
	    get: function get() {
	      return unimplemented();
	    }
	    /**
	     * The instance of the Component.
	     */

	  }, {
	    key: 'instance',
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'hostView',

	    /**
	     * The {@link ViewRef} of the Host View of this Component instance.
	     */
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'changeDetectorRef',

	    /**
	     * The {@link ChangeDetectorRef} of the Component instance.
	     */
	    get: function get() {
	      return unimplemented();
	    }
	    /**
	     * The component type.
	     */

	  }, {
	    key: 'componentType',
	    get: function get() {
	      return unimplemented();
	    }
	  }]);
	  return ComponentRef;
	}();
	var ComponentRef_ = function (_ComponentRef) {
	  inherits(ComponentRef_, _ComponentRef);

	  function ComponentRef_(_hostElement, _componentType) {
	    classCallCheck(this, ComponentRef_);

	    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ComponentRef_).call(this));

	    _this._hostElement = _hostElement;
	    _this._componentType = _componentType;
	    return _this;
	  }

	  createClass(ComponentRef_, [{
	    key: 'destroy',
	    value: function destroy() {
	      this._hostElement.parentView.destroy();
	    }
	  }, {
	    key: 'onDestroy',
	    value: function onDestroy(callback) {
	      this.hostView.onDestroy(callback);
	    }
	  }, {
	    key: 'location',
	    get: function get() {
	      return this._hostElement.elementRef;
	    }
	  }, {
	    key: 'injector',
	    get: function get() {
	      return this._hostElement.injector;
	    }
	  }, {
	    key: 'instance',
	    get: function get() {
	      return this._hostElement.component;
	    }
	  }, {
	    key: 'hostView',
	    get: function get() {
	      return this._hostElement.parentView.ref;
	    }
	  }, {
	    key: 'changeDetectorRef',
	    get: function get() {
	      return this._hostElement.parentView.ref;
	    }
	  }, {
	    key: 'componentType',
	    get: function get() {
	      return this._componentType;
	    }
	  }]);
	  return ComponentRef_;
	}(ComponentRef);
	/**
	 * @experimental
	 * @ts2dart_const
	 */
	var EMPTY_CONTEXT = new Object();
	/**
	 * @stable
	 */
	var ComponentFactory = function () {
	  function ComponentFactory(selector, _viewFactory, _componentType) {
	    classCallCheck(this, ComponentFactory);

	    this.selector = selector;
	    this._viewFactory = _viewFactory;
	    this._componentType = _componentType;
	  }

	  createClass(ComponentFactory, [{
	    key: 'create',

	    /**
	     * Creates a new component.
	     */
	    value: function create(injector) {
	      var projectableNodes = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      var rootSelectorOrNode = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	      var vu = injector.get(ViewUtils);
	      if (isBlank(projectableNodes)) {
	        projectableNodes = [];
	      }
	      // Note: Host views don't need a declarationAppElement!
	      var hostView = this._viewFactory(vu, injector, null);
	      var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
	      return new ComponentRef_(hostElement, this._componentType);
	    }
	  }, {
	    key: 'componentType',
	    get: function get() {
	      return this._componentType;
	    }
	  }]);
	  return ComponentFactory;
	}();

	/**
	 * Low-level service for loading {@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 * @experimental
	 */
	var ComponentResolver = function ComponentResolver() {
	    classCallCheck(this, ComponentResolver);
	};
	function _isComponentFactory(type) {
	    return type instanceof ComponentFactory;
	}
	var ReflectorComponentResolver = function (_ComponentResolver) {
	    inherits(ReflectorComponentResolver, _ComponentResolver);

	    function ReflectorComponentResolver() {
	        classCallCheck(this, ReflectorComponentResolver);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ReflectorComponentResolver).apply(this, arguments));
	    }

	    createClass(ReflectorComponentResolver, [{
	        key: 'resolveComponent',
	        value: function resolveComponent(component) {
	            if (isString(component)) {
	                return PromiseWrapper.reject(new BaseException('Cannot resolve component using \'' + component + '\'.'), null);
	            }
	            var metadatas = reflector.annotations(component);
	            var componentFactory = metadatas.find(_isComponentFactory);
	            if (isBlank(componentFactory)) {
	                throw new BaseException('No precompiled component ' + stringify(component) + ' found');
	            }
	            return PromiseWrapper.resolve(componentFactory);
	        }
	    }, {
	        key: 'clearCache',
	        value: function clearCache() {}
	    }]);
	    return ReflectorComponentResolver;
	}(ComponentResolver);
	/** @nocollapse */
	ReflectorComponentResolver.decorators = [{ type: Injectable }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Stores error information; delivered via [NgZone.onError] stream.
	 * @deprecated
	 */
	var NgZoneError = function NgZoneError(error, stackTrace) {
	    classCallCheck(this, NgZoneError);

	    this.error = error;
	    this.stackTrace = stackTrace;
	};
	var NgZoneImpl = function () {
	    function NgZoneImpl(_ref) {
	        var _this = this;

	        var trace = _ref.trace;
	        var onEnter = _ref.onEnter;
	        var onLeave = _ref.onLeave;
	        var setMicrotask = _ref.setMicrotask;
	        var setMacrotask = _ref.setMacrotask;
	        var onError = _ref.onError;
	        classCallCheck(this, NgZoneImpl);

	        this.onEnter = onEnter;
	        this.onLeave = onLeave;
	        this.setMicrotask = setMicrotask;
	        this.setMacrotask = setMacrotask;
	        this.onError = onError;
	        if (Zone) {
	            this.outer = this.inner = Zone.current;
	            if (Zone['wtfZoneSpec']) {
	                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
	            }
	            if (trace && Zone['longStackTraceZoneSpec']) {
	                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
	            }
	            this.inner = this.inner.fork({
	                name: 'angular',
	                properties: { 'isAngularZone': true },
	                onInvokeTask: function onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invokeTask(target, task, applyThis, applyArgs);
	                    } finally {
	                        _this.onLeave();
	                    }
	                },
	                onInvoke: function onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
	                    } finally {
	                        _this.onLeave();
	                    }
	                },
	                onHasTask: function onHasTask(delegate, current, target, hasTaskState) {
	                    delegate.hasTask(target, hasTaskState);
	                    if (current == target) {
	                        // We are only interested in hasTask events which originate from our zone
	                        // (A child hasTask event is not interesting to us)
	                        if (hasTaskState.change == 'microTask') {
	                            _this.setMicrotask(hasTaskState.microTask);
	                        } else if (hasTaskState.change == 'macroTask') {
	                            _this.setMacrotask(hasTaskState.macroTask);
	                        }
	                    }
	                },
	                onHandleError: function onHandleError(delegate, current, target, error) {
	                    delegate.handleError(target, error);
	                    _this.onError(new NgZoneError(error, error.stack));
	                    return false;
	                }
	            });
	        } else {
	            throw new Error('Angular requires Zone.js polyfill.');
	        }
	    }

	    createClass(NgZoneImpl, [{
	        key: 'runInner',
	        value: function runInner(fn) {
	            return this.inner.run(fn);
	        }
	    }, {
	        key: 'runInnerGuarded',
	        value: function runInnerGuarded(fn) {
	            return this.inner.runGuarded(fn);
	        }
	    }, {
	        key: 'runOuter',
	        value: function runOuter(fn) {
	            return this.outer.run(fn);
	        }
	    }], [{
	        key: 'isInAngularZone',
	        value: function isInAngularZone() {
	            return Zone.current.get('isAngularZone') === true;
	        }
	    }]);
	    return NgZoneImpl;
	}();

	/**
	 * An injectable service for executing work inside or outside of the Angular zone.
	 *
	 * The most common use of this service is to optimize performance when starting a work consisting of
	 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
	 * can reenter the Angular zone via {@link #run}.
	 *
	 * <!-- TODO: add/fix links to:
	 *   - docs explaining zones and the use of zones in Angular and change-detection
	 *   - link to runOutsideAngular/run (throughout this file!)
	 *   -->
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 * ```
	 * import {Component, View, NgZone} from '@angular/core';
	 * import {NgIf} from '@angular/common';
	 *
	 * @Component({
	 *   selector: 'ng-zone-demo'.
	 *   template: `
	 *     <h2>Demo: NgZone</h2>
	 *
	 *     <p>Progress: {{progress}}%</p>
	 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	 *
	 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	 *   `,
	 *   directives: [NgIf]
	 * })
	 * export class NgZoneDemo {
	 *   progress: number = 0;
	 *   label: string;
	 *
	 *   constructor(private _ngZone: NgZone) {}
	 *
	 *   // Loop inside the Angular zone
	 *   // so the UI DOES refresh after each setTimeout cycle
	 *   processWithinAngularZone() {
	 *     this.label = 'inside';
	 *     this.progress = 0;
	 *     this._increaseProgress(() => console.log('Inside Done!'));
	 *   }
	 *
	 *   // Loop outside of the Angular zone
	 *   // so the UI DOES NOT refresh after each setTimeout cycle
	 *   processOutsideOfAngularZone() {
	 *     this.label = 'outside';
	 *     this.progress = 0;
	 *     this._ngZone.runOutsideAngular(() => {
	 *       this._increaseProgress(() => {
	 *       // reenter the Angular zone and display done
	 *       this._ngZone.run(() => {console.log('Outside Done!') });
	 *     }}));
	 *   }
	 *
	 *
	 *   _increaseProgress(doneCallback: () => void) {
	 *     this.progress += 1;
	 *     console.log(`Current progress: ${this.progress}%`);
	 *
	 *     if (this.progress < 100) {
	 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	 *     } else {
	 *       doneCallback();
	 *     }
	 *   }
	 * }
	 * ```
	 * @experimental
	 */
	var NgZone = function () {
	    function NgZone(_ref) {
	        var _this = this;

	        var _ref$enableLongStackT = _ref.enableLongStackTrace;
	        var enableLongStackTrace = _ref$enableLongStackT === undefined ? false : _ref$enableLongStackT;
	        classCallCheck(this, NgZone);

	        this._hasPendingMicrotasks = false;
	        this._hasPendingMacrotasks = false;
	        /** @internal */
	        this._isStable = true;
	        /** @internal */
	        this._nesting = 0;
	        /** @internal */
	        this._onUnstable = new EventEmitter(false);
	        /** @internal */
	        this._onMicrotaskEmpty = new EventEmitter(false);
	        /** @internal */
	        this._onStable = new EventEmitter(false);
	        /** @internal */
	        this._onErrorEvents = new EventEmitter(false);
	        this._zoneImpl = new NgZoneImpl({
	            trace: enableLongStackTrace,
	            onEnter: function onEnter() {
	                // console.log('ZONE.enter', this._nesting, this._isStable);
	                _this._nesting++;
	                if (_this._isStable) {
	                    _this._isStable = false;
	                    _this._onUnstable.emit(null);
	                }
	            },
	            onLeave: function onLeave() {
	                _this._nesting--;
	                // console.log('ZONE.leave', this._nesting, this._isStable);
	                _this._checkStable();
	            },
	            setMicrotask: function setMicrotask(hasMicrotasks) {
	                _this._hasPendingMicrotasks = hasMicrotasks;
	                _this._checkStable();
	            },
	            setMacrotask: function setMacrotask(hasMacrotasks) {
	                _this._hasPendingMacrotasks = hasMacrotasks;
	            },
	            onError: function onError(error) {
	                return _this._onErrorEvents.emit(error);
	            }
	        });
	    }

	    createClass(NgZone, [{
	        key: '_checkStable',
	        value: function _checkStable() {
	            var _this2 = this;

	            if (this._nesting == 0) {
	                if (!this._hasPendingMicrotasks && !this._isStable) {
	                    try {
	                        // console.log('ZONE.microtaskEmpty');
	                        this._nesting++;
	                        this._onMicrotaskEmpty.emit(null);
	                    } finally {
	                        this._nesting--;
	                        if (!this._hasPendingMicrotasks) {
	                            try {
	                                // console.log('ZONE.stable', this._nesting, this._isStable);
	                                this.runOutsideAngular(function () {
	                                    return _this2._onStable.emit(null);
	                                });
	                            } finally {
	                                this._isStable = true;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'run',

	        /**
	         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * within the Angular zone.
	         *
	         * If a synchronous error happens it will be rethrown and not reported via `onError`.
	         */
	        value: function run(fn) {
	            return this._zoneImpl.runInner(fn);
	        }
	        /**
	         * Same as #run, except that synchronous errors are caught and forwarded
	         * via `onError` and not rethrown.
	         */

	    }, {
	        key: 'runGuarded',
	        value: function runGuarded(fn) {
	            return this._zoneImpl.runInnerGuarded(fn);
	        }
	        /**
	         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * outside of the Angular zone.
	         *
	         * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
	         */

	    }, {
	        key: 'runOutsideAngular',
	        value: function runOutsideAngular(fn) {
	            return this._zoneImpl.runOuter(fn);
	        }
	    }, {
	        key: 'onUnstable',

	        /**
	         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	         */
	        get: function get() {
	            return this._onUnstable;
	        }
	        /**
	         * Notifies when there is no more microtasks enqueue in the current VM Turn.
	         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	         * For this reason this event can fire multiple times per VM Turn.
	         */

	    }, {
	        key: 'onMicrotaskEmpty',
	        get: function get() {
	            return this._onMicrotaskEmpty;
	        }
	        /**
	         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	         * implies we are about to relinquish VM turn.
	         * This event gets called just once.
	         */

	    }, {
	        key: 'onStable',
	        get: function get() {
	            return this._onStable;
	        }
	        /**
	         * Notify that an error has been delivered.
	         */

	    }, {
	        key: 'onError',
	        get: function get() {
	            return this._onErrorEvents;
	        }
	        /**
	         * Whether there are no outstanding microtasks or microtasks.
	         */

	    }, {
	        key: 'isStable',
	        get: function get() {
	            return this._isStable;
	        }
	        /**
	         * Whether there are any outstanding microtasks.
	         */

	    }, {
	        key: 'hasPendingMicrotasks',
	        get: function get() {
	            return this._hasPendingMicrotasks;
	        }
	        /**
	         * Whether there are any outstanding microtasks.
	         */

	    }, {
	        key: 'hasPendingMacrotasks',
	        get: function get() {
	            return this._hasPendingMacrotasks;
	        }
	    }], [{
	        key: 'isInAngularZone',
	        value: function isInAngularZone() {
	            return NgZoneImpl.isInAngularZone();
	        }
	    }, {
	        key: 'assertInAngularZone',
	        value: function assertInAngularZone() {
	            if (!NgZoneImpl.isInAngularZone()) {
	                throw new BaseException('Expected to be in Angular Zone, but it is not!');
	            }
	        }
	    }, {
	        key: 'assertNotInAngularZone',
	        value: function assertNotInAngularZone() {
	            if (NgZoneImpl.isInAngularZone()) {
	                throw new BaseException('Expected to not be in Angular Zone, but it is!');
	            }
	        }
	    }]);
	    return NgZone;
	}();

	var Testability = function () {
	    function Testability(_ngZone) {
	        classCallCheck(this, Testability);

	        this._ngZone = _ngZone;
	        /** @internal */
	        this._pendingCount = 0;
	        /** @internal */
	        this._isZoneStable = true;
	        /**
	         * Whether any work was done since the last 'whenStable' callback. This is
	         * useful to detect if this could have potentially destabilized another
	         * component while it is stabilizing.
	         * @internal
	         */
	        this._didWork = false;
	        /** @internal */
	        this._callbacks = [];
	        this._watchAngularEvents();
	    }
	    /** @internal */


	    createClass(Testability, [{
	        key: '_watchAngularEvents',
	        value: function _watchAngularEvents() {
	            var _this = this;

	            ObservableWrapper.subscribe(this._ngZone.onUnstable, function (_) {
	                _this._didWork = true;
	                _this._isZoneStable = false;
	            });
	            this._ngZone.runOutsideAngular(function () {
	                ObservableWrapper.subscribe(_this._ngZone.onStable, function (_) {
	                    NgZone.assertNotInAngularZone();
	                    scheduleMicroTask(function () {
	                        _this._isZoneStable = true;
	                        _this._runCallbacksIfReady();
	                    });
	                });
	            });
	        }
	    }, {
	        key: 'increasePendingRequestCount',
	        value: function increasePendingRequestCount() {
	            this._pendingCount += 1;
	            this._didWork = true;
	            return this._pendingCount;
	        }
	    }, {
	        key: 'decreasePendingRequestCount',
	        value: function decreasePendingRequestCount() {
	            this._pendingCount -= 1;
	            if (this._pendingCount < 0) {
	                throw new BaseException('pending async requests below zero');
	            }
	            this._runCallbacksIfReady();
	            return this._pendingCount;
	        }
	    }, {
	        key: 'isStable',
	        value: function isStable() {
	            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	        }
	        /** @internal */

	    }, {
	        key: '_runCallbacksIfReady',
	        value: function _runCallbacksIfReady() {
	            var _this2 = this;

	            if (this.isStable()) {
	                // Schedules the call backs in a new frame so that it is always async.
	                scheduleMicroTask(function () {
	                    while (_this2._callbacks.length !== 0) {
	                        _this2._callbacks.pop()(_this2._didWork);
	                    }
	                    _this2._didWork = false;
	                });
	            } else {
	                // Not Ready
	                this._didWork = true;
	            }
	        }
	    }, {
	        key: 'whenStable',
	        value: function whenStable(callback) {
	            this._callbacks.push(callback);
	            this._runCallbacksIfReady();
	        }
	    }, {
	        key: 'getPendingRequestCount',
	        value: function getPendingRequestCount() {
	            return this._pendingCount;
	        }
	    }, {
	        key: 'findBindings',
	        value: function findBindings(using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        }
	    }, {
	        key: 'findProviders',
	        value: function findProviders(using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        }
	    }]);
	    return Testability;
	}();
	/** @nocollapse */
	Testability.decorators = [{ type: Injectable }];
	/** @nocollapse */
	Testability.ctorParameters = [{ type: NgZone }];
	var TestabilityRegistry = function () {
	    function TestabilityRegistry() {
	        classCallCheck(this, TestabilityRegistry);

	        /** @internal */
	        this._applications = new Map$1();
	        _testabilityGetter.addToWindow(this);
	    }

	    createClass(TestabilityRegistry, [{
	        key: 'registerApplication',
	        value: function registerApplication(token, testability) {
	            this._applications.set(token, testability);
	        }
	    }, {
	        key: 'getTestability',
	        value: function getTestability(elem) {
	            return this._applications.get(elem);
	        }
	    }, {
	        key: 'getAllTestabilities',
	        value: function getAllTestabilities() {
	            return MapWrapper.values(this._applications);
	        }
	    }, {
	        key: 'getAllRootElements',
	        value: function getAllRootElements() {
	            return MapWrapper.keys(this._applications);
	        }
	    }, {
	        key: 'findTestabilityInTree',
	        value: function findTestabilityInTree(elem) {
	            var findInAncestors = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	        }
	    }]);
	    return TestabilityRegistry;
	}();
	/** @nocollapse */
	TestabilityRegistry.decorators = [{ type: Injectable }];
	/** @nocollapse */
	TestabilityRegistry.ctorParameters = [];
	/* @ts2dart_const */

	var _NoopGetTestability = function () {
	    function _NoopGetTestability() {
	        classCallCheck(this, _NoopGetTestability);
	    }

	    createClass(_NoopGetTestability, [{
	        key: 'addToWindow',
	        value: function addToWindow(registry) {}
	    }, {
	        key: 'findTestabilityInTree',
	        value: function findTestabilityInTree(registry, elem, findInAncestors) {
	            return null;
	        }
	    }]);
	    return _NoopGetTestability;
	}();
	/**
	 * Set the {@link GetTestability} implementation used by the Angular testing framework.
	 * @experimental
	 */


	function setTestabilityGetter(getter) {
	    _testabilityGetter = getter;
	}
	var _testabilityGetter = new _NoopGetTestability();

	/**
	 * Create an Angular zone.
	 * @experimental
	 */
	function createNgZone() {
	    return new NgZone({ enableLongStackTrace: isDevMode() });
	}
	var _devMode = true;
	var _runModeLocked = false;
	var _platform;
	var _inPlatformCreate = false;
	/**
	 * Disable Angular's development mode, which turns off assertions and other
	 * checks within the framework.
	 *
	 * One important assertion this disables verifies that a change detection pass
	 * does not result in additional changes to any bindings (also known as
	 * unidirectional data flow).
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function enableProdMode() {
	    if (_runModeLocked) {
	        // Cannot use BaseException as that ends up importing from facade/lang.
	        throw new BaseException('Cannot enable prod mode after platform setup.');
	    }
	    _devMode = false;
	}
	/**
	 * Returns whether Angular is in development mode.
	 * This can only be read after `lockRunMode` has been called.
	 *
	 * By default, this is true, unless a user calls `enableProdMode`.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function isDevMode() {
	    if (!_runModeLocked) {
	        throw new BaseException('Dev mode can\'t be read before bootstrap!');
	    }
	    return _devMode;
	}
	/**
	 * Locks the run mode of Angular. After this has been called,
	 * it can't be changed any more. I.e. `isDevMode()` will always
	 * return the same value.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function lockRunMode() {
	    _runModeLocked = true;
	}
	/**
	 * Creates a platform.
	 * Platforms have to be eagerly created via this function.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function createPlatform(injector) {
	    if (_inPlatformCreate) {
	        throw new BaseException('Already creating a platform...');
	    }
	    if (isPresent(_platform) && !_platform.disposed) {
	        throw new BaseException('There can be only one platform. Destroy the previous one to create a new one.');
	    }
	    lockRunMode();
	    _inPlatformCreate = true;
	    try {
	        _platform = injector.get(PlatformRef);
	    } finally {
	        _inPlatformCreate = false;
	    }
	    return _platform;
	}
	/**
	 * Checks that there currently is a platform
	 * which contains the given token as a provider.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function assertPlatform(requiredToken) {
	    var platform = getPlatform();
	    if (isBlank(platform)) {
	        throw new BaseException('No platform exists!');
	    }
	    if (isPresent(platform) && isBlank(platform.injector.get(requiredToken, null))) {
	        throw new BaseException('A platform with a different configuration has been created. Please destroy it first.');
	    }
	    return platform;
	}
	/**
	 * Returns the current platform.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function getPlatform() {
	    return isPresent(_platform) && !_platform.disposed ? _platform : null;
	}
	/**
	 * Shortcut for ApplicationRef.bootstrap.
	 * Requires a platform to be created first.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	function coreBootstrap(componentFactory, injector) {
	    var appRef = injector.get(ApplicationRef);
	    return appRef.bootstrap(componentFactory);
	}
	/**
	 * The Angular platform is the entry point for Angular on a web page. Each page
	 * has exactly one platform, and services (such as reflection) which are common
	 * to every Angular application running on the page are bound in its scope.
	 *
	 * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
	 * explicitly by calling {@link createPlatform}().
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	var PlatformRef = function () {
	    function PlatformRef() {
	        classCallCheck(this, PlatformRef);
	    }

	    createClass(PlatformRef, [{
	        key: 'injector',

	        /**
	         * Retrieve the platform {@link Injector}, which is the parent injector for
	         * every Angular application on the page and provides singleton providers.
	         */
	        get: function get() {
	            throw unimplemented();
	        }
	    }, {
	        key: 'disposed',
	        get: function get() {
	            throw unimplemented();
	        }
	    }]);
	    return PlatformRef;
	}();
	var PlatformRef_ = function (_PlatformRef) {
	    inherits(PlatformRef_, _PlatformRef);

	    function PlatformRef_(_injector) {
	        classCallCheck(this, PlatformRef_);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(PlatformRef_).call(this));

	        _this._injector = _injector;
	        /** @internal */
	        _this._applications = [];
	        /** @internal */
	        _this._disposeListeners = [];
	        _this._disposed = false;
	        if (!_inPlatformCreate) {
	            throw new BaseException('Platforms have to be created via `createPlatform`!');
	        }
	        var inits = _injector.get(PLATFORM_INITIALIZER, null);
	        if (isPresent(inits)) inits.forEach(function (init) {
	            return init();
	        });
	        return _this;
	    }

	    createClass(PlatformRef_, [{
	        key: 'registerDisposeListener',
	        value: function registerDisposeListener(dispose) {
	            this._disposeListeners.push(dispose);
	        }
	    }, {
	        key: 'addApplication',
	        value: function addApplication(appRef) {
	            this._applications.push(appRef);
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose() {
	            ListWrapper.clone(this._applications).forEach(function (app) {
	                return app.dispose();
	            });
	            this._disposeListeners.forEach(function (dispose) {
	                return dispose();
	            });
	            this._disposed = true;
	        }
	        /** @internal */

	    }, {
	        key: '_applicationDisposed',
	        value: function _applicationDisposed(app) {
	            ListWrapper.remove(this._applications, app);
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return this._injector;
	        }
	    }, {
	        key: 'disposed',
	        get: function get() {
	            return this._disposed;
	        }
	    }]);
	    return PlatformRef_;
	}(PlatformRef);
	/** @nocollapse */
	PlatformRef_.decorators = [{ type: Injectable }];
	/** @nocollapse */
	PlatformRef_.ctorParameters = [{ type: Injector }];
	/**
	 * A reference to an Angular application running on a page.
	 *
	 * For more about Angular applications, see the documentation for {@link bootstrap}.
	 *
	 * @experimental APIs related to application bootstrap are currently under review.
	 */
	var ApplicationRef = function () {
	    function ApplicationRef() {
	        classCallCheck(this, ApplicationRef);
	    }

	    createClass(ApplicationRef, [{
	        key: 'injector',

	        /**
	         * Retrieve the application {@link Injector}.
	         */
	        get: function get() {
	            return unimplemented();
	        }
	    }, {
	        key: 'zone',

	        /**
	         * Retrieve the application {@link NgZone}.
	         */
	        get: function get() {
	            return unimplemented();
	        }
	    }, {
	        key: 'componentTypes',

	        /**
	         * Get a list of component types registered to this application.
	         */
	        get: function get() {
	            return unimplemented();
	        }
	    }]);
	    return ApplicationRef;
	}();
	var ApplicationRef_ = function (_ApplicationRef) {
	    inherits(ApplicationRef_, _ApplicationRef);

	    function ApplicationRef_(_platform, _zone, _injector) {
	        classCallCheck(this, ApplicationRef_);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(ApplicationRef_).call(this));

	        _this2._platform = _platform;
	        _this2._zone = _zone;
	        _this2._injector = _injector;
	        /** @internal */
	        _this2._bootstrapListeners = [];
	        /** @internal */
	        _this2._disposeListeners = [];
	        /** @internal */
	        _this2._rootComponents = [];
	        /** @internal */
	        _this2._rootComponentTypes = [];
	        /** @internal */
	        _this2._changeDetectorRefs = [];
	        /** @internal */
	        _this2._runningTick = false;
	        /** @internal */
	        _this2._enforceNoNewChanges = false;
	        var zone = _injector.get(NgZone);
	        _this2._enforceNoNewChanges = isDevMode();
	        zone.run(function () {
	            _this2._exceptionHandler = _injector.get(ExceptionHandler);
	        });
	        _this2._asyncInitDonePromise = _this2.run(function () {
	            var inits = _injector.get(APP_INITIALIZER, null);
	            var asyncInitResults = [];
	            var asyncInitDonePromise;
	            if (isPresent(inits)) {
	                for (var i = 0; i < inits.length; i++) {
	                    var initResult = inits[i]();
	                    if (isPromise(initResult)) {
	                        asyncInitResults.push(initResult);
	                    }
	                }
	            }
	            if (asyncInitResults.length > 0) {
	                asyncInitDonePromise = PromiseWrapper.all(asyncInitResults).then(function (_) {
	                    return _this2._asyncInitDone = true;
	                });
	                _this2._asyncInitDone = false;
	            } else {
	                _this2._asyncInitDone = true;
	                asyncInitDonePromise = PromiseWrapper.resolve(true);
	            }
	            return asyncInitDonePromise;
	        });
	        ObservableWrapper.subscribe(zone.onError, function (error) {
	            _this2._exceptionHandler.call(error.error, error.stackTrace);
	        });
	        ObservableWrapper.subscribe(_this2._zone.onMicrotaskEmpty, function (_) {
	            _this2._zone.run(function () {
	                _this2.tick();
	            });
	        });
	        return _this2;
	    }

	    createClass(ApplicationRef_, [{
	        key: 'registerBootstrapListener',
	        value: function registerBootstrapListener(listener) {
	            this._bootstrapListeners.push(listener);
	        }
	    }, {
	        key: 'registerDisposeListener',
	        value: function registerDisposeListener(dispose) {
	            this._disposeListeners.push(dispose);
	        }
	    }, {
	        key: 'registerChangeDetector',
	        value: function registerChangeDetector(changeDetector) {
	            this._changeDetectorRefs.push(changeDetector);
	        }
	    }, {
	        key: 'unregisterChangeDetector',
	        value: function unregisterChangeDetector(changeDetector) {
	            ListWrapper.remove(this._changeDetectorRefs, changeDetector);
	        }
	    }, {
	        key: 'waitForAsyncInitializers',
	        value: function waitForAsyncInitializers() {
	            return this._asyncInitDonePromise;
	        }
	    }, {
	        key: 'run',
	        value: function run(callback) {
	            var _this3 = this;

	            var zone = this.injector.get(NgZone);
	            var result;
	            // Note: Don't use zone.runGuarded as we want to know about
	            // the thrown exception!
	            // Note: the completer needs to be created outside
	            // of `zone.run` as Dart swallows rejected promises
	            // via the onError callback of the promise.
	            var completer = PromiseWrapper.completer();
	            zone.run(function () {
	                try {
	                    result = callback();
	                    if (isPromise(result)) {
	                        PromiseWrapper.then(result, function (ref) {
	                            completer.resolve(ref);
	                        }, function (err, stackTrace) {
	                            completer.reject(err, stackTrace);
	                            _this3._exceptionHandler.call(err, stackTrace);
	                        });
	                    }
	                } catch (e) {
	                    _this3._exceptionHandler.call(e, e.stack);
	                    throw e;
	                }
	            });
	            return isPromise(result) ? completer.promise : result;
	        }
	    }, {
	        key: 'bootstrap',
	        value: function bootstrap(componentFactory) {
	            var _this4 = this;

	            if (!this._asyncInitDone) {
	                throw new BaseException('Cannot bootstrap as there are still asynchronous initializers running. Wait for them using waitForAsyncInitializers().');
	            }
	            return this.run(function () {
	                _this4._rootComponentTypes.push(componentFactory.componentType);
	                var compRef = componentFactory.create(_this4._injector, [], componentFactory.selector);
	                compRef.onDestroy(function () {
	                    _this4._unloadComponent(compRef);
	                });
	                var testability = compRef.injector.get(Testability, null);
	                if (isPresent(testability)) {
	                    compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability);
	                }
	                _this4._loadComponent(compRef);
	                var c = _this4._injector.get(Console);
	                if (isDevMode()) {
	                    var prodDescription = IS_DART ? 'Production mode is disabled in Dart.' : 'Call enableProdMode() to enable the production mode.';
	                    c.log('Angular 2 is running in the development mode. ' + prodDescription);
	                }
	                return compRef;
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_loadComponent',
	        value: function _loadComponent(componentRef) {
	            this._changeDetectorRefs.push(componentRef.changeDetectorRef);
	            this.tick();
	            this._rootComponents.push(componentRef);
	            this._bootstrapListeners.forEach(function (listener) {
	                return listener(componentRef);
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_unloadComponent',
	        value: function _unloadComponent(componentRef) {
	            if (!ListWrapper.contains(this._rootComponents, componentRef)) {
	                return;
	            }
	            this.unregisterChangeDetector(componentRef.changeDetectorRef);
	            ListWrapper.remove(this._rootComponents, componentRef);
	        }
	    }, {
	        key: 'tick',
	        value: function tick() {
	            if (this._runningTick) {
	                throw new BaseException('ApplicationRef.tick is called recursively');
	            }
	            var s = ApplicationRef_._tickScope();
	            try {
	                this._runningTick = true;
	                this._changeDetectorRefs.forEach(function (detector) {
	                    return detector.detectChanges();
	                });
	                if (this._enforceNoNewChanges) {
	                    this._changeDetectorRefs.forEach(function (detector) {
	                        return detector.checkNoChanges();
	                    });
	                }
	            } finally {
	                this._runningTick = false;
	                wtfLeave(s);
	            }
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose() {
	            // TODO(alxhub): Dispose of the NgZone.
	            ListWrapper.clone(this._rootComponents).forEach(function (ref) {
	                return ref.destroy();
	            });
	            this._disposeListeners.forEach(function (dispose) {
	                return dispose();
	            });
	            this._platform._applicationDisposed(this);
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return this._injector;
	        }
	    }, {
	        key: 'zone',
	        get: function get() {
	            return this._zone;
	        }
	    }, {
	        key: 'componentTypes',
	        get: function get() {
	            return this._rootComponentTypes;
	        }
	    }]);
	    return ApplicationRef_;
	}(ApplicationRef);
	/** @internal */
	ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
	/** @nocollapse */
	ApplicationRef_.decorators = [{ type: Injectable }];
	/** @nocollapse */
	ApplicationRef_.ctorParameters = [{ type: PlatformRef_ }, { type: NgZone }, { type: Injector }];
	var PLATFORM_CORE_PROVIDERS =
	/*@ts2dart_const*/[PlatformRef_,
	/*@ts2dart_const*/
	/* @ts2dart_Provider */{ provide: PlatformRef, useExisting: PlatformRef_ }];
	var APPLICATION_CORE_PROVIDERS = [
	/* @ts2dart_Provider */{ provide: NgZone, useFactory: createNgZone, deps: [] }, ApplicationRef_,
	/* @ts2dart_Provider */{ provide: ApplicationRef, useExisting: ApplicationRef_ }];

	/**
	 * Low-level service for running the angular compiler duirng runtime
	 * to create {@link ComponentFactory}s, which
	 * can later be used to create and render a Component instance.
	 * @stable
	 */
	var Compiler = function () {
	  function Compiler() {
	    classCallCheck(this, Compiler);
	  }

	  createClass(Compiler, [{
	    key: 'compileComponentAsync',

	    /**
	     * Loads the template and styles of a component and returns the associated `ComponentFactory`.
	     */
	    value: function compileComponentAsync(component) {
	      throw new BaseException('Runtime compiler is not loaded. Tried to compile ' + stringify(component));
	    }
	    /**
	     * Compiles the given component. All templates have to be either inline or compiled via
	     * `compileComponentAsync` before.
	     */

	  }, {
	    key: 'compileComponentSync',
	    value: function compileComponentSync(component) {
	      throw new BaseException('Runtime compiler is not loaded. Tried to compile ' + stringify(component));
	    }
	    /**
	     * Clears all caches
	     */

	  }, {
	    key: 'clearCache',
	    value: function clearCache() {}
	    /**
	     * Clears the cache for the given component.
	     */

	  }, {
	    key: 'clearCacheFor',
	    value: function clearCacheFor(compType) {}
	  }]);
	  return Compiler;
	}();

	/**
	 * @stable
	 */
	var NoComponentFactoryError = function (_BaseException) {
	    inherits(NoComponentFactoryError, _BaseException);

	    function NoComponentFactoryError(component) {
	        classCallCheck(this, NoComponentFactoryError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NoComponentFactoryError).call(this, 'No component factory found for ' + stringify(component)));

	        _this.component = component;
	        return _this;
	    }

	    return NoComponentFactoryError;
	}(BaseException);

	var _NullComponentFactoryResolver = function () {
	    function _NullComponentFactoryResolver() {
	        classCallCheck(this, _NullComponentFactoryResolver);
	    }

	    createClass(_NullComponentFactoryResolver, [{
	        key: 'resolveComponentFactory',
	        value: function resolveComponentFactory(component) {
	            throw new NoComponentFactoryError(component);
	        }
	    }]);
	    return _NullComponentFactoryResolver;
	}();
	/**
	 * @stable
	 */


	var ComponentFactoryResolver = function ComponentFactoryResolver() {
	    classCallCheck(this, ComponentFactoryResolver);
	};
	ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	var CodegenComponentFactoryResolver = function () {
	    function CodegenComponentFactoryResolver(factories, _parent) {
	        classCallCheck(this, CodegenComponentFactoryResolver);

	        this._parent = _parent;
	        this._factories = new Map();
	        for (var i = 0; i < factories.length; i++) {
	            var factory = factories[i];
	            this._factories.set(factory.componentType, factory);
	        }
	    }

	    createClass(CodegenComponentFactoryResolver, [{
	        key: 'resolveComponentFactory',
	        value: function resolveComponentFactory(component) {
	            var result = this._factories.get(component);
	            if (!result) {
	                result = this._parent.resolveComponentFactory(component);
	            }
	            return result;
	        }
	    }]);
	    return CodegenComponentFactoryResolver;
	}();

	/**
	 * Use ComponentResolver and ViewContainerRef directly.
	 *
	 * @deprecated
	 */
	var DynamicComponentLoader = function DynamicComponentLoader() {
	    classCallCheck(this, DynamicComponentLoader);
	};
	var DynamicComponentLoader_ = function (_DynamicComponentLoad) {
	    inherits(DynamicComponentLoader_, _DynamicComponentLoad);

	    function DynamicComponentLoader_(_compiler) {
	        classCallCheck(this, DynamicComponentLoader_);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DynamicComponentLoader_).call(this));

	        _this._compiler = _compiler;
	        return _this;
	    }

	    createClass(DynamicComponentLoader_, [{
	        key: 'loadAsRoot',
	        value: function loadAsRoot(type, overrideSelectorOrNode, injector, onDispose, projectableNodes) {
	            return this._compiler.resolveComponent(type).then(function (componentFactory) {
	                var componentRef = componentFactory.create(injector, projectableNodes, isPresent(overrideSelectorOrNode) ? overrideSelectorOrNode : componentFactory.selector);
	                if (isPresent(onDispose)) {
	                    componentRef.onDestroy(onDispose);
	                }
	                return componentRef;
	            });
	        }
	    }, {
	        key: 'loadNextToLocation',
	        value: function loadNextToLocation(type, location) {
	            var providers = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	            var projectableNodes = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            return this._compiler.resolveComponent(type).then(function (componentFactory) {
	                var contextInjector = location.parentInjector;
	                var childInjector = isPresent(providers) && providers.length > 0 ? ReflectiveInjector.fromResolvedProviders(providers, contextInjector) : contextInjector;
	                return location.createComponent(componentFactory, location.length, childInjector, projectableNodes);
	            });
	        }
	    }]);
	    return DynamicComponentLoader_;
	}(DynamicComponentLoader);
	/** @nocollapse */
	DynamicComponentLoader_.decorators = [{ type: Injectable }];
	/** @nocollapse */
	DynamicComponentLoader_.ctorParameters = [{ type: ComponentResolver }];

	/**
	 * An unmodifiable list of items that Angular keeps up to date when the state
	 * of the application changes.
	 *
	 * The type of object that {@link QueryMetadata} and {@link ViewQueryMetadata} provide.
	 *
	 * Implements an iterable interface, therefore it can be used in both ES6
	 * javascript `for (var i of items)` loops as well as in Angular templates with
	 * `*ngFor="let i of myList"`.
	 *
	 * Changes can be observed by subscribing to the changes `Observable`.
	 *
	 * NOTE: In the future this class will implement an `Observable` interface.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	 * ```typescript
	 * @Component({...})
	 * class Container {
	 *   @ViewChildren(Item) items:QueryList<Item>;
	 * }
	 * ```
	 * @stable
	 */
	var QueryList = function () {
	  function QueryList() {
	    classCallCheck(this, QueryList);

	    this._dirty = true;
	    this._results = [];
	    this._emitter = new EventEmitter();
	  }

	  createClass(QueryList, [{
	    key: 'map',

	    /**
	     * See
	     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	     */
	    value: function map(fn) {
	      return this._results.map(fn);
	    }
	    /**
	     * See
	     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	     */

	  }, {
	    key: 'filter',
	    value: function filter(fn) {
	      return this._results.filter(fn);
	    }
	    /**
	     * See
	     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	     */

	  }, {
	    key: 'reduce',
	    value: function reduce(fn, init) {
	      return this._results.reduce(fn, init);
	    }
	    /**
	     * See
	     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	     */

	  }, {
	    key: 'forEach',
	    value: function forEach(fn) {
	      this._results.forEach(fn);
	    }
	    /**
	     * See
	     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	     */

	  }, {
	    key: 'some',
	    value: function some(fn) {
	      return this._results.some(fn);
	    }
	  }, {
	    key: 'toArray',
	    value: function toArray() {
	      return this._results.slice();
	    }
	  }, {
	    key: getSymbolIterator(),
	    value: function value() {
	      return this._results[getSymbolIterator()]();
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this._results.toString();
	    }
	  }, {
	    key: 'reset',
	    value: function reset(res) {
	      this._results = ListWrapper.flatten(res);
	      this._dirty = false;
	    }
	  }, {
	    key: 'notifyOnChanges',
	    value: function notifyOnChanges() {
	      this._emitter.emit(this);
	    }
	    /** internal */

	  }, {
	    key: 'setDirty',
	    value: function setDirty() {
	      this._dirty = true;
	    }
	    /** internal */

	  }, {
	    key: 'changes',
	    get: function get() {
	      return this._emitter;
	    }
	  }, {
	    key: 'length',
	    get: function get() {
	      return this._results.length;
	    }
	  }, {
	    key: 'first',
	    get: function get() {
	      return this._results[0];
	    }
	  }, {
	    key: 'last',
	    get: function get() {
	      return this._results[this.length - 1];
	    }
	  }, {
	    key: 'dirty',
	    get: function get() {
	      return this._dirty;
	    }
	  }]);
	  return QueryList;
	}();

	var _SEPARATOR = '#';
	/**
	 * Component resolver that can load components lazily
	 * @experimental
	 */
	var SystemJsComponentResolver = function () {
	    function SystemJsComponentResolver(_resolver) {
	        classCallCheck(this, SystemJsComponentResolver);

	        this._resolver = _resolver;
	    }

	    createClass(SystemJsComponentResolver, [{
	        key: 'resolveComponent',
	        value: function resolveComponent(componentType) {
	            var _this = this;

	            if (isString(componentType)) {
	                var _ret = function () {
	                    var _componentType$split = componentType.split(_SEPARATOR);

	                    var _componentType$split2 = slicedToArray(_componentType$split, 2);

	                    var module = _componentType$split2[0];
	                    var component = _componentType$split2[1];

	                    if (component === void 0) {
	                        // Use the default export when no component is specified
	                        component = 'default';
	                    }
	                    return {
	                        v: global$1.System.import(module).then(function (module) {
	                            return _this._resolver.resolveComponent(module[component]);
	                        })
	                    };
	                }();

	                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
	            }
	            return this._resolver.resolveComponent(componentType);
	        }
	    }, {
	        key: 'clearCache',
	        value: function clearCache() {}
	    }]);
	    return SystemJsComponentResolver;
	}();
	var FACTORY_MODULE_SUFFIX = '.ngfactory';
	var FACTORY_CLASS_SUFFIX = 'NgFactory';
	/**
	 * Component resolver that can load component factories lazily
	 * @experimental
	 */
	var SystemJsCmpFactoryResolver = function () {
	    function SystemJsCmpFactoryResolver() {
	        classCallCheck(this, SystemJsCmpFactoryResolver);
	    }

	    createClass(SystemJsCmpFactoryResolver, [{
	        key: 'resolveComponent',
	        value: function resolveComponent(componentType) {
	            if (isString(componentType)) {
	                var _ret2 = function () {
	                    var _componentType$split3 = componentType.split(_SEPARATOR);

	                    var _componentType$split4 = slicedToArray(_componentType$split3, 2);

	                    var module = _componentType$split4[0];
	                    var factory = _componentType$split4[1];

	                    return {
	                        v: global$1.System.import(module + FACTORY_MODULE_SUFFIX).then(function (module) {
	                            return module[factory + FACTORY_CLASS_SUFFIX];
	                        })
	                    };
	                }();

	                if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	            }
	            return Promise.resolve(null);
	        }
	    }, {
	        key: 'clearCache',
	        value: function clearCache() {}
	    }]);
	    return SystemJsCmpFactoryResolver;
	}();

	var EMPTY_CONTEXT$1 = new Object();
	/**
	 * Represents an Embedded Template that can be used to instantiate Embedded Views.
	 *
	 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
	 * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
	 * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
	 * `TemplateRef` from a Component or a Directive via {@link Query}.
	 *
	 * To instantiate Embedded Views based on a Template, use
	 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	 * View Container.
	 * @stable
	 */
	var TemplateRef = function () {
	    function TemplateRef() {
	        classCallCheck(this, TemplateRef);
	    }

	    createClass(TemplateRef, [{
	        key: 'elementRef',

	        /**
	         * The location in the View where the Embedded View logically belongs to.
	         *
	         * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
	         * inherit from the contexts of this location.
	         *
	         * Typically new Embedded Views are attached to the View Container of this location, but in
	         * advanced use-cases, the View can be attached to a different container while keeping the
	         * data-binding and injection context from the original location.
	         *
	         */
	        // TODO(i): rename to anchor or location
	        get: function get() {
	            return null;
	        }
	    }]);
	    return TemplateRef;
	}();
	var TemplateRef_ = function (_TemplateRef) {
	    inherits(TemplateRef_, _TemplateRef);

	    function TemplateRef_(_appElement, _viewFactory) {
	        classCallCheck(this, TemplateRef_);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(TemplateRef_).call(this));

	        _this._appElement = _appElement;
	        _this._viewFactory = _viewFactory;
	        return _this;
	    }

	    createClass(TemplateRef_, [{
	        key: 'createEmbeddedView',
	        value: function createEmbeddedView(context) {
	            var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
	            if (isBlank(context)) {
	                context = EMPTY_CONTEXT$1;
	            }
	            view.create(context, null, null);
	            return view.ref;
	        }
	    }, {
	        key: 'elementRef',
	        get: function get() {
	            return this._appElement.elementRef;
	        }
	    }]);
	    return TemplateRef_;
	}(TemplateRef);

	/**
	 * @stable
	 */
	var ViewRef = function () {
	    function ViewRef() {
	        classCallCheck(this, ViewRef);
	    }

	    createClass(ViewRef, [{
	        key: 'destroyed',
	        get: function get() {
	            return unimplemented();
	        }
	    }]);
	    return ViewRef;
	}();
	/**
	 * Represents an Angular View.
	 *
	 * <!-- TODO: move the next two paragraphs to the dev guide -->
	 * A View is a fundamental building block of the application UI. It is the smallest grouping of
	 * Elements which are created and destroyed together.
	 *
	 * Properties of elements in a View can change, but the structure (number and order) of elements in
	 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	 * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
	 * <!-- /TODO -->
	 *
	 * ### Example
	 *
	 * Given this template...
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ngFor="let  item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * We have two {@link TemplateRef}s:
	 *
	 * Outer {@link TemplateRef}:
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <template ngFor let-item [ngForOf]="items"></template>
	 * </ul>
	 * ```
	 *
	 * Inner {@link TemplateRef}:
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * Notice that the original template is broken down into two separate {@link TemplateRef}s.
	 *
	 * The outer/inner {@link TemplateRef}s are then assembled into views like so:
	 *
	 * ```
	 * <!-- ViewRef: outer-0 -->
	 * Count: 2
	 * <ul>
	 *   <template view-container-ref></template>
	 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	 * </ul>
	 * <!-- /ViewRef: outer-0 -->
	 * ```
	 * @experimental
	 */
	var EmbeddedViewRef = function (_ViewRef) {
	    inherits(EmbeddedViewRef, _ViewRef);

	    function EmbeddedViewRef() {
	        classCallCheck(this, EmbeddedViewRef);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(EmbeddedViewRef).apply(this, arguments));
	    }

	    createClass(EmbeddedViewRef, [{
	        key: 'context',
	        get: function get() {
	            return unimplemented();
	        }
	    }, {
	        key: 'rootNodes',
	        get: function get() {
	            return unimplemented();
	        }
	    }]);
	    return EmbeddedViewRef;
	}(ViewRef);
	var ViewRef_ = function () {
	    function ViewRef_(_view) {
	        classCallCheck(this, ViewRef_);

	        this._view = _view;
	        this._view = _view;
	        this._originalMode = this._view.cdMode;
	    }

	    createClass(ViewRef_, [{
	        key: 'markForCheck',
	        value: function markForCheck() {
	            this._view.markPathToRootAsCheckOnce();
	        }
	    }, {
	        key: 'detach',
	        value: function detach() {
	            this._view.cdMode = ChangeDetectorStatus.Detached;
	        }
	    }, {
	        key: 'detectChanges',
	        value: function detectChanges() {
	            this._view.detectChanges(false);
	        }
	    }, {
	        key: 'checkNoChanges',
	        value: function checkNoChanges() {
	            this._view.detectChanges(true);
	        }
	    }, {
	        key: 'reattach',
	        value: function reattach() {
	            this._view.cdMode = this._originalMode;
	            this.markForCheck();
	        }
	    }, {
	        key: 'onDestroy',
	        value: function onDestroy(callback) {
	            this._view.disposables.push(callback);
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this._view.destroy();
	        }
	    }, {
	        key: 'internalView',
	        get: function get() {
	            return this._view;
	        }
	    }, {
	        key: 'rootNodes',
	        get: function get() {
	            return this._view.flatRootNodes;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._view.context;
	        }
	    }, {
	        key: 'destroyed',
	        get: function get() {
	            return this._view.destroyed;
	        }
	    }]);
	    return ViewRef_;
	}();

	var EventListener = function EventListener(name, callback) {
	    classCallCheck(this, EventListener);

	    this.name = name;
	    this.callback = callback;
	};
	/**
	 * @experimental All debugging apis are currently experimental.
	 */
	var DebugNode = function () {
	    function DebugNode(nativeNode, parent, _debugInfo) {
	        classCallCheck(this, DebugNode);

	        this._debugInfo = _debugInfo;
	        this.nativeNode = nativeNode;
	        if (isPresent(parent) && parent instanceof DebugElement) {
	            parent.addChild(this);
	        } else {
	            this.parent = null;
	        }
	        this.listeners = [];
	    }

	    createClass(DebugNode, [{
	        key: 'inject',

	        /**
	         * Use injector.get(token) instead.
	         *
	         * @deprecated
	         */
	        value: function inject(token) {
	            return this.injector.get(token);
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return isPresent(this._debugInfo) ? this._debugInfo.injector : null;
	        }
	    }, {
	        key: 'componentInstance',
	        get: function get() {
	            return isPresent(this._debugInfo) ? this._debugInfo.component : null;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return isPresent(this._debugInfo) ? this._debugInfo.context : null;
	        }
	    }, {
	        key: 'references',
	        get: function get() {
	            return isPresent(this._debugInfo) ? this._debugInfo.references : null;
	        }
	    }, {
	        key: 'providerTokens',
	        get: function get() {
	            return isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
	        }
	    }, {
	        key: 'source',
	        get: function get() {
	            return isPresent(this._debugInfo) ? this._debugInfo.source : null;
	        }
	    }]);
	    return DebugNode;
	}();
	/**
	 * @experimental All debugging apis are currently experimental.
	 */
	var DebugElement = function (_DebugNode) {
	    inherits(DebugElement, _DebugNode);

	    function DebugElement(nativeNode, parent, _debugInfo) {
	        classCallCheck(this, DebugElement);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DebugElement).call(this, nativeNode, parent, _debugInfo));

	        _this.properties = {};
	        _this.attributes = {};
	        _this.classes = {};
	        _this.styles = {};
	        _this.childNodes = [];
	        _this.nativeElement = nativeNode;
	        return _this;
	    }

	    createClass(DebugElement, [{
	        key: 'addChild',
	        value: function addChild(child) {
	            if (isPresent(child)) {
	                this.childNodes.push(child);
	                child.parent = this;
	            }
	        }
	    }, {
	        key: 'removeChild',
	        value: function removeChild(child) {
	            var childIndex = this.childNodes.indexOf(child);
	            if (childIndex !== -1) {
	                child.parent = null;
	                this.childNodes.splice(childIndex, 1);
	            }
	        }
	    }, {
	        key: 'insertChildrenAfter',
	        value: function insertChildrenAfter(child, newChildren) {
	            var siblingIndex = this.childNodes.indexOf(child);
	            if (siblingIndex !== -1) {
	                var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
	                var nextChildren = this.childNodes.slice(siblingIndex + 1);
	                this.childNodes = ListWrapper.concat(ListWrapper.concat(previousChildren, newChildren), nextChildren);
	                for (var i = 0; i < newChildren.length; ++i) {
	                    var newChild = newChildren[i];
	                    if (isPresent(newChild.parent)) {
	                        newChild.parent.removeChild(newChild);
	                    }
	                    newChild.parent = this;
	                }
	            }
	        }
	    }, {
	        key: 'query',
	        value: function query(predicate) {
	            var results = this.queryAll(predicate);
	            return results.length > 0 ? results[0] : null;
	        }
	    }, {
	        key: 'queryAll',
	        value: function queryAll(predicate) {
	            var matches = [];
	            _queryElementChildren(this, predicate, matches);
	            return matches;
	        }
	    }, {
	        key: 'queryAllNodes',
	        value: function queryAllNodes(predicate) {
	            var matches = [];
	            _queryNodeChildren(this, predicate, matches);
	            return matches;
	        }
	    }, {
	        key: 'triggerEventHandler',
	        value: function triggerEventHandler(eventName, eventObj) {
	            this.listeners.forEach(function (listener) {
	                if (listener.name == eventName) {
	                    listener.callback(eventObj);
	                }
	            });
	        }
	    }, {
	        key: 'children',
	        get: function get() {
	            var children = [];
	            this.childNodes.forEach(function (node) {
	                if (node instanceof DebugElement) {
	                    children.push(node);
	                }
	            });
	            return children;
	        }
	    }]);
	    return DebugElement;
	}(DebugNode);
	function _queryElementChildren(element, predicate, matches) {
	    element.childNodes.forEach(function (node) {
	        if (node instanceof DebugElement) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            _queryElementChildren(node, predicate, matches);
	        }
	    });
	}
	function _queryNodeChildren(parentNode, predicate, matches) {
	    if (parentNode instanceof DebugElement) {
	        parentNode.childNodes.forEach(function (node) {
	            if (predicate(node)) {
	                matches.push(node);
	            }
	            if (node instanceof DebugElement) {
	                _queryNodeChildren(node, predicate, matches);
	            }
	        });
	    }
	}
	// Need to keep the nodes in a global Map so that multiple angular apps are supported.
	var _nativeNodeToDebugNode = new Map();
	/**
	 * @experimental
	 */
	function getDebugNode(nativeNode) {
	    return _nativeNodeToDebugNode.get(nativeNode);
	}
	function indexDebugNode(node) {
	    _nativeNodeToDebugNode.set(node.nativeNode, node);
	}
	function removeDebugNodeFromIndex(node) {
	    _nativeNodeToDebugNode.delete(node.nativeNode);
	}

	/**
	   A token that can be provided when bootstrapping an application to make an array of directives
	  * available in every component of the application.
	  *
	  * ### Example
	  *
	  * ```typescript
	  * import {PLATFORM_DIRECTIVES} from '@angular/core';
	  * import {OtherDirective} from './myDirectives';
	  *
	  * @Component({
	  *   selector: 'my-component',
	  *   template: `
	  *     <!-- can use other directive even though the component does not list it in `directives` -->
	  *     <other-directive></other-directive>
	  *   `
	  * })
	  * export class MyComponent {
	  *   ...
	  * }
	  *
	  * bootstrap(MyComponent, [{provide: PLATFORM_DIRECTIVES, useValue: [OtherDirective],
	  multi:true}]);
	  * ```
	  * @stable
	  */
	var PLATFORM_DIRECTIVES =
	/*@ts2dart_const*/new OpaqueToken('Platform Directives');
	/**
	  * A token that can be provided when bootstraping an application to make an array of pipes
	  * available in every component of the application.
	  *
	  * ### Example
	  *
	  * ```typescript
	  * import {PLATFORM_PIPES} from '@angular/core';
	  * import {OtherPipe} from './myPipe';
	  *
	  * @Component({
	  *   selector: 'my-component',
	  *   template: `
	  *     {{123 | other-pipe}}
	  *   `
	  * })
	  * export class MyComponent {
	  *   ...
	  * }
	  *
	  * bootstrap(MyComponent, [{provide: PLATFORM_PIPES, useValue: [OtherPipe], multi:true}]);
	  * ```
	  * @stable
	  */
	var PLATFORM_PIPES = new OpaqueToken('Platform Pipes');

	function _reflector() {
	  return reflector;
	}
	// prevent missing use Dart warning.
	/**
	 * A default set of providers which should be included in any Angular platform.
	 * @experimental
	 */
	var PLATFORM_COMMON_PROVIDERS = [PLATFORM_CORE_PROVIDERS,
	/*@ts2dart_Provider*/{ provide: Reflector, useFactory: _reflector, deps: [] },
	/*@ts2dart_Provider*/{ provide: ReflectorReader, useExisting: Reflector }, TestabilityRegistry, Console];

	// avoid unused import when Type union types are erased
	/**
	 * A default set of providers which should be included in any Angular
	 * application, regardless of the platform it runs onto.
	 * @stable
	 */
	var APPLICATION_COMMON_PROVIDERS =
	/*@ts2dart_const*/[APPLICATION_CORE_PROVIDERS,
	/* @ts2dart_Provider */{ provide: ComponentResolver, useClass: ReflectorComponentResolver }, { provide: ComponentFactoryResolver, useValue: ComponentFactoryResolver.NULL }, APP_ID_RANDOM_PROVIDER, ViewUtils,
	/* @ts2dart_Provider */{ provide: IterableDiffers, useValue: defaultIterableDiffers },
	/* @ts2dart_Provider */{ provide: KeyValueDiffers, useValue: defaultKeyValueDiffers },
	/* @ts2dart_Provider */{ provide: DynamicComponentLoader, useClass: DynamicComponentLoader_ }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
	var ANY_STATE = '*';
	var DEFAULT_STATE = '*';
	var EMPTY_STATE = 'void';

	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationPlayer = function () {
	    function AnimationPlayer() {
	        classCallCheck(this, AnimationPlayer);
	    }

	    createClass(AnimationPlayer, [{
	        key: 'parentPlayer',
	        get: function get() {
	            throw new BaseException('NOT IMPLEMENTED: Base Class');
	        },
	        set: function set(player) {
	            throw new BaseException('NOT IMPLEMENTED: Base Class');
	        }
	    }]);
	    return AnimationPlayer;
	}();
	var NoOpAnimationPlayer = function () {
	    function NoOpAnimationPlayer() {
	        var _this = this;

	        classCallCheck(this, NoOpAnimationPlayer);

	        this._subscriptions = [];
	        this.parentPlayer = null;
	        scheduleMicroTask(function () {
	            return _this._onFinish();
	        });
	    }
	    /** @internal */


	    createClass(NoOpAnimationPlayer, [{
	        key: '_onFinish',
	        value: function _onFinish() {
	            this._subscriptions.forEach(function (entry) {
	                entry();
	            });
	            this._subscriptions = [];
	        }
	    }, {
	        key: 'onDone',
	        value: function onDone(fn) {
	            this._subscriptions.push(fn);
	        }
	    }, {
	        key: 'play',
	        value: function play() {}
	    }, {
	        key: 'pause',
	        value: function pause() {}
	    }, {
	        key: 'restart',
	        value: function restart() {}
	    }, {
	        key: 'finish',
	        value: function finish() {
	            this._onFinish();
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {}
	    }, {
	        key: 'reset',
	        value: function reset() {}
	    }, {
	        key: 'setPosition',
	        value: function setPosition(p /** TODO #9100 */) {}
	    }, {
	        key: 'getPosition',
	        value: function getPosition() {
	            return 0;
	        }
	    }]);
	    return NoOpAnimationPlayer;
	}();

	var AnimationDriver = function AnimationDriver() {
	    classCallCheck(this, AnimationDriver);
	};
	var NoOpAnimationDriver = function (_AnimationDriver) {
	    inherits(NoOpAnimationDriver, _AnimationDriver);

	    function NoOpAnimationDriver() {
	        classCallCheck(this, NoOpAnimationDriver);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(NoOpAnimationDriver).apply(this, arguments));
	    }

	    createClass(NoOpAnimationDriver, [{
	        key: 'animate',
	        value: function animate(element, startingStyles, keyframes, duration, delay, easing) {
	            return new NoOpAnimationPlayer();
	        }
	    }]);
	    return NoOpAnimationDriver;
	}(AnimationDriver);

	var Math$2 = global$1.Math;
	var NaN$1 = typeof NaN$1 === 'undefined' ? 'undefined' : _typeof(NaN$1);

	var AnimationGroupPlayer = function () {
	    function AnimationGroupPlayer(_players) {
	        var _this = this;

	        classCallCheck(this, AnimationGroupPlayer);

	        this._players = _players;
	        this._subscriptions = [];
	        this._finished = false;
	        this.parentPlayer = null;
	        var count = 0;
	        var total = this._players.length;
	        if (total == 0) {
	            scheduleMicroTask(function () {
	                return _this._onFinish();
	            });
	        } else {
	            this._players.forEach(function (player) {
	                player.parentPlayer = _this;
	                player.onDone(function () {
	                    if (++count >= total) {
	                        _this._onFinish();
	                    }
	                });
	            });
	        }
	    }

	    createClass(AnimationGroupPlayer, [{
	        key: '_onFinish',
	        value: function _onFinish() {
	            if (!this._finished) {
	                this._finished = true;
	                if (!isPresent(this.parentPlayer)) {
	                    this.destroy();
	                }
	                this._subscriptions.forEach(function (subscription) {
	                    return subscription();
	                });
	                this._subscriptions = [];
	            }
	        }
	    }, {
	        key: 'onDone',
	        value: function onDone(fn) {
	            this._subscriptions.push(fn);
	        }
	    }, {
	        key: 'play',
	        value: function play() {
	            this._players.forEach(function (player) {
	                return player.play();
	            });
	        }
	    }, {
	        key: 'pause',
	        value: function pause() {
	            this._players.forEach(function (player) {
	                return player.pause();
	            });
	        }
	    }, {
	        key: 'restart',
	        value: function restart() {
	            this._players.forEach(function (player) {
	                return player.restart();
	            });
	        }
	    }, {
	        key: 'finish',
	        value: function finish() {
	            this._onFinish();
	            this._players.forEach(function (player) {
	                return player.finish();
	            });
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this._onFinish();
	            this._players.forEach(function (player) {
	                return player.destroy();
	            });
	        }
	    }, {
	        key: 'reset',
	        value: function reset() {
	            this._players.forEach(function (player) {
	                return player.reset();
	            });
	        }
	    }, {
	        key: 'setPosition',
	        value: function setPosition(p /** TODO #9100 */) {
	            this._players.forEach(function (player) {
	                player.setPosition(p);
	            });
	        }
	    }, {
	        key: 'getPosition',
	        value: function getPosition() {
	            var min = 0;
	            this._players.forEach(function (player) {
	                var p = player.getPosition();
	                min = Math$2.min(p, min);
	            });
	            return min;
	        }
	    }]);
	    return AnimationGroupPlayer;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var AnimationKeyframe = function AnimationKeyframe(offset, styles) {
	    classCallCheck(this, AnimationKeyframe);

	    this.offset = offset;
	    this.styles = styles;
	};

	var AnimationSequencePlayer = function () {
	    function AnimationSequencePlayer(_players) {
	        var _this = this;

	        classCallCheck(this, AnimationSequencePlayer);

	        this._players = _players;
	        this._currentIndex = 0;
	        this._subscriptions = [];
	        this._finished = false;
	        this.parentPlayer = null;
	        this._players.forEach(function (player) {
	            player.parentPlayer = _this;
	        });
	        this._onNext(false);
	    }

	    createClass(AnimationSequencePlayer, [{
	        key: '_onNext',
	        value: function _onNext(start) {
	            var _this2 = this;

	            if (this._finished) return;
	            if (this._players.length == 0) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                scheduleMicroTask(function () {
	                    return _this2._onFinish();
	                });
	            } else if (this._currentIndex >= this._players.length) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                this._onFinish();
	            } else {
	                var player = this._players[this._currentIndex++];
	                player.onDone(function () {
	                    return _this2._onNext(true);
	                });
	                this._activePlayer = player;
	                if (start) {
	                    player.play();
	                }
	            }
	        }
	    }, {
	        key: '_onFinish',
	        value: function _onFinish() {
	            if (!this._finished) {
	                this._finished = true;
	                if (!isPresent(this.parentPlayer)) {
	                    this.destroy();
	                }
	                this._subscriptions.forEach(function (subscription) {
	                    return subscription();
	                });
	                this._subscriptions = [];
	            }
	        }
	    }, {
	        key: 'onDone',
	        value: function onDone(fn) {
	            this._subscriptions.push(fn);
	        }
	    }, {
	        key: 'play',
	        value: function play() {
	            this._activePlayer.play();
	        }
	    }, {
	        key: 'pause',
	        value: function pause() {
	            this._activePlayer.pause();
	        }
	    }, {
	        key: 'restart',
	        value: function restart() {
	            if (this._players.length > 0) {
	                this.reset();
	                this._players[0].restart();
	            }
	        }
	    }, {
	        key: 'reset',
	        value: function reset() {
	            this._players.forEach(function (player) {
	                return player.reset();
	            });
	        }
	    }, {
	        key: 'finish',
	        value: function finish() {
	            this._onFinish();
	            this._players.forEach(function (player) {
	                return player.finish();
	            });
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this._onFinish();
	            this._players.forEach(function (player) {
	                return player.destroy();
	            });
	        }
	    }, {
	        key: 'setPosition',
	        value: function setPosition(p /** TODO #9100 */) {
	            this._players[0].setPosition(p);
	        }
	    }, {
	        key: 'getPosition',
	        value: function getPosition() {
	            return this._players[0].getPosition();
	        }
	    }]);
	    return AnimationSequencePlayer;
	}();

	/**
	 * @experimental Animation support is experimental.
	 */
	var AUTO_STYLE = '*';
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateMetadata = function AnimationStateMetadata() {
	    classCallCheck(this, AnimationStateMetadata);
	};
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link state state animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateDeclarationMetadata = function (_AnimationStateMetada) {
	    inherits(AnimationStateDeclarationMetadata, _AnimationStateMetada);

	    function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
	        classCallCheck(this, AnimationStateDeclarationMetadata);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStateDeclarationMetadata).call(this));

	        _this.stateNameExpr = stateNameExpr;
	        _this.styles = styles;
	        return _this;
	    }

	    return AnimationStateDeclarationMetadata;
	}(AnimationStateMetadata);
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the
	 * {@link transition transition animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStateTransitionMetadata = function (_AnimationStateMetada2) {
	    inherits(AnimationStateTransitionMetadata, _AnimationStateMetada2);

	    function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
	        classCallCheck(this, AnimationStateTransitionMetadata);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStateTransitionMetadata).call(this));

	        _this2.stateChangeExpr = stateChangeExpr;
	        _this2.steps = steps;
	        return _this2;
	    }

	    return AnimationStateTransitionMetadata;
	}(AnimationStateMetadata);
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationMetadata = function AnimationMetadata() {
	    classCallCheck(this, AnimationMetadata);
	};
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationKeyframesSequenceMetadata = function (_AnimationMetadata) {
	    inherits(AnimationKeyframesSequenceMetadata, _AnimationMetadata);

	    function AnimationKeyframesSequenceMetadata(steps) {
	        classCallCheck(this, AnimationKeyframesSequenceMetadata);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationKeyframesSequenceMetadata).call(this));

	        _this3.steps = steps;
	        return _this3;
	    }

	    return AnimationKeyframesSequenceMetadata;
	}(AnimationMetadata);
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link style style animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationStyleMetadata = function (_AnimationMetadata2) {
	    inherits(AnimationStyleMetadata, _AnimationMetadata2);

	    function AnimationStyleMetadata(styles) {
	        var offset = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, AnimationStyleMetadata);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStyleMetadata).call(this));

	        _this4.styles = styles;
	        _this4.offset = offset;
	        return _this4;
	    }

	    return AnimationStyleMetadata;
	}(AnimationMetadata);
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link animate animate
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationAnimateMetadata = function (_AnimationMetadata3) {
	    inherits(AnimationAnimateMetadata, _AnimationMetadata3);

	    function AnimationAnimateMetadata(timings, styles) {
	        classCallCheck(this, AnimationAnimateMetadata);

	        var _this5 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationAnimateMetadata).call(this));

	        _this5.timings = timings;
	        _this5.styles = styles;
	        return _this5;
	    }

	    return AnimationAnimateMetadata;
	}(AnimationMetadata);
	/**
	 * @experimental Animation support is experimental.
	 */
	var AnimationWithStepsMetadata = function (_AnimationMetadata4) {
	    inherits(AnimationWithStepsMetadata, _AnimationMetadata4);

	    function AnimationWithStepsMetadata() {
	        classCallCheck(this, AnimationWithStepsMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(AnimationWithStepsMetadata).call(this));
	    }

	    createClass(AnimationWithStepsMetadata, [{
	        key: 'steps',
	        get: function get() {
	            throw new BaseException('NOT IMPLEMENTED: Base Class');
	        }
	    }]);
	    return AnimationWithStepsMetadata;
	}(AnimationMetadata);
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link sequence sequence
	 * animation function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationSequenceMetadata = function (_AnimationWithStepsMe) {
	    inherits(AnimationSequenceMetadata, _AnimationWithStepsMe);

	    function AnimationSequenceMetadata(_steps) {
	        classCallCheck(this, AnimationSequenceMetadata);

	        var _this7 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationSequenceMetadata).call(this));

	        _this7._steps = _steps;
	        return _this7;
	    }

	    createClass(AnimationSequenceMetadata, [{
	        key: 'steps',
	        get: function get() {
	            return this._steps;
	        }
	    }]);
	    return AnimationSequenceMetadata;
	}(AnimationWithStepsMetadata);
	/**
	 * Metadata representing the entry of animations.
	 * Instances of this class are provided via the animation DSL when the {@link group group animation
	 * function} is called.
	 *
	 * @experimental Animation support is experimental.
	 */
	var AnimationGroupMetadata = function (_AnimationWithStepsMe2) {
	    inherits(AnimationGroupMetadata, _AnimationWithStepsMe2);

	    function AnimationGroupMetadata(_steps) {
	        classCallCheck(this, AnimationGroupMetadata);

	        var _this8 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationGroupMetadata).call(this));

	        _this8._steps = _steps;
	        return _this8;
	    }

	    createClass(AnimationGroupMetadata, [{
	        key: 'steps',
	        get: function get() {
	            return this._steps;
	        }
	    }]);
	    return AnimationGroupMetadata;
	}(AnimationWithStepsMetadata);

	function prepareFinalAnimationStyles(previousStyles, newStyles) {
	    var nullValue = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	    var finalStyles = {};
	    StringMapWrapper.forEach(newStyles, function (value, prop) {
	        finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();
	    });
	    StringMapWrapper.forEach(previousStyles, function (value, prop) {
	        if (!isPresent(finalStyles[prop])) {
	            finalStyles[prop] = nullValue;
	        }
	    });
	    return finalStyles;
	}
	function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
	    var limit = keyframes.length - 1;
	    var firstKeyframe = keyframes[0];
	    // phase 1: copy all the styles from the first keyframe into the lookup map
	    var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
	    var extraFirstKeyframeStyles = {};
	    var hasExtraFirstStyles = false;
	    StringMapWrapper.forEach(collectedStyles, function (value, prop) {
	        // if the style is already defined in the first keyframe then
	        // we do not replace it.
	        if (!flatenedFirstKeyframeStyles[prop]) {
	            flatenedFirstKeyframeStyles[prop] = value;
	            extraFirstKeyframeStyles[prop] = value;
	            hasExtraFirstStyles = true;
	        }
	    });
	    var keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
	    // phase 2: normalize the final keyframe
	    var finalKeyframe = keyframes[limit];
	    ListWrapper.insert(finalKeyframe.styles.styles, 0, finalStateStyles);
	    var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
	    var extraFinalKeyframeStyles = {};
	    var hasExtraFinalStyles = false;
	    StringMapWrapper.forEach(keyframeCollectedStyles, function (value, prop) {
	        if (!isPresent(flatenedFinalKeyframeStyles[prop])) {
	            extraFinalKeyframeStyles[prop] = AUTO_STYLE;
	            hasExtraFinalStyles = true;
	        }
	    });
	    if (hasExtraFinalStyles) {
	        finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
	    }
	    StringMapWrapper.forEach(flatenedFinalKeyframeStyles, function (value, prop) {
	        if (!isPresent(flatenedFirstKeyframeStyles[prop])) {
	            extraFirstKeyframeStyles[prop] = AUTO_STYLE;
	            hasExtraFirstStyles = true;
	        }
	    });
	    if (hasExtraFirstStyles) {
	        firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
	    }
	    return keyframes;
	}
	function clearStyles(styles) {
	    var finalStyles = {};
	    StringMapWrapper.keys(styles).forEach(function (key) {
	        finalStyles[key] = null;
	    });
	    return finalStyles;
	}
	function collectAndResolveStyles(collection, styles) {
	    return styles.map(function (entry) {
	        var stylesObj = {};
	        StringMapWrapper.forEach(entry, function (value, prop) {
	            if (value == FILL_STYLE_FLAG) {
	                value = collection[prop];
	                if (!isPresent(value)) {
	                    value = AUTO_STYLE;
	                }
	            }
	            collection[prop] = value;
	            stylesObj[prop] = value;
	        });
	        return stylesObj;
	    });
	}
	function renderStyles(element, renderer, styles) {
	    StringMapWrapper.forEach(styles, function (value, prop) {
	        renderer.setElementStyle(element, prop, value);
	    });
	}
	function flattenStyles(styles) {
	    var finalStyles = {};
	    styles.forEach(function (entry) {
	        StringMapWrapper.forEach(entry, function (value, prop) {
	            finalStyles[prop] = value;
	        });
	    });
	    return finalStyles;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var AnimationStyles = function AnimationStyles(styles) {
	    classCallCheck(this, AnimationStyles);

	    this.styles = styles;
	};

	var DebugDomRootRenderer = function () {
	    function DebugDomRootRenderer(_delegate) {
	        classCallCheck(this, DebugDomRootRenderer);

	        this._delegate = _delegate;
	    }

	    createClass(DebugDomRootRenderer, [{
	        key: 'renderComponent',
	        value: function renderComponent(componentProto) {
	            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
	        }
	    }]);
	    return DebugDomRootRenderer;
	}();
	var DebugDomRenderer = function () {
	    function DebugDomRenderer(_delegate) {
	        classCallCheck(this, DebugDomRenderer);

	        this._delegate = _delegate;
	    }

	    createClass(DebugDomRenderer, [{
	        key: 'selectRootElement',
	        value: function selectRootElement(selectorOrNode, debugInfo) {
	            var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
	            var debugEl = new DebugElement(nativeEl, null, debugInfo);
	            indexDebugNode(debugEl);
	            return nativeEl;
	        }
	    }, {
	        key: 'createElement',
	        value: function createElement(parentElement, name, debugInfo) {
	            var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
	            var debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
	            debugEl.name = name;
	            indexDebugNode(debugEl);
	            return nativeEl;
	        }
	    }, {
	        key: 'createViewRoot',
	        value: function createViewRoot(hostElement) {
	            return this._delegate.createViewRoot(hostElement);
	        }
	    }, {
	        key: 'createTemplateAnchor',
	        value: function createTemplateAnchor(parentElement, debugInfo) {
	            var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
	            var debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return comment;
	        }
	    }, {
	        key: 'createText',
	        value: function createText(parentElement, value, debugInfo) {
	            var text = this._delegate.createText(parentElement, value, debugInfo);
	            var debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return text;
	        }
	    }, {
	        key: 'projectNodes',
	        value: function projectNodes(parentElement, nodes) {
	            var debugParent = getDebugNode(parentElement);
	            if (isPresent(debugParent) && debugParent instanceof DebugElement) {
	                (function () {
	                    var debugElement = debugParent;
	                    nodes.forEach(function (node) {
	                        debugElement.addChild(getDebugNode(node));
	                    });
	                })();
	            }
	            this._delegate.projectNodes(parentElement, nodes);
	        }
	    }, {
	        key: 'attachViewAfter',
	        value: function attachViewAfter(node, viewRootNodes) {
	            var debugNode = getDebugNode(node);
	            if (isPresent(debugNode)) {
	                var debugParent = debugNode.parent;
	                if (viewRootNodes.length > 0 && isPresent(debugParent)) {
	                    var debugViewRootNodes = [];
	                    viewRootNodes.forEach(function (rootNode) {
	                        return debugViewRootNodes.push(getDebugNode(rootNode));
	                    });
	                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
	                }
	            }
	            this._delegate.attachViewAfter(node, viewRootNodes);
	        }
	    }, {
	        key: 'detachView',
	        value: function detachView(viewRootNodes) {
	            viewRootNodes.forEach(function (node) {
	                var debugNode = getDebugNode(node);
	                if (isPresent(debugNode) && isPresent(debugNode.parent)) {
	                    debugNode.parent.removeChild(debugNode);
	                }
	            });
	            this._delegate.detachView(viewRootNodes);
	        }
	    }, {
	        key: 'destroyView',
	        value: function destroyView(hostElement, viewAllNodes) {
	            viewAllNodes.forEach(function (node) {
	                removeDebugNodeFromIndex(getDebugNode(node));
	            });
	            this._delegate.destroyView(hostElement, viewAllNodes);
	        }
	    }, {
	        key: 'listen',
	        value: function listen(renderElement, name, callback) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl)) {
	                debugEl.listeners.push(new EventListener(name, callback));
	            }
	            return this._delegate.listen(renderElement, name, callback);
	        }
	    }, {
	        key: 'listenGlobal',
	        value: function listenGlobal(target, name, callback) {
	            return this._delegate.listenGlobal(target, name, callback);
	        }
	    }, {
	        key: 'setElementProperty',
	        value: function setElementProperty(renderElement, propertyName, propertyValue) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.properties[propertyName] = propertyValue;
	            }
	            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
	        }
	    }, {
	        key: 'setElementAttribute',
	        value: function setElementAttribute(renderElement, attributeName, attributeValue) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.attributes[attributeName] = attributeValue;
	            }
	            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
	        }
	    }, {
	        key: 'setBindingDebugInfo',
	        value: function setBindingDebugInfo(renderElement, propertyName, propertyValue) {
	            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	        }
	    }, {
	        key: 'setElementClass',
	        value: function setElementClass(renderElement, className, isAdd) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.classes[className] = isAdd;
	            }
	            this._delegate.setElementClass(renderElement, className, isAdd);
	        }
	    }, {
	        key: 'setElementStyle',
	        value: function setElementStyle(renderElement, styleName, styleValue) {
	            var debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.styles[styleName] = styleValue;
	            }
	            this._delegate.setElementStyle(renderElement, styleName, styleValue);
	        }
	    }, {
	        key: 'invokeElementMethod',
	        value: function invokeElementMethod(renderElement, methodName, args) {
	            this._delegate.invokeElementMethod(renderElement, methodName, args);
	        }
	    }, {
	        key: 'setText',
	        value: function setText(renderNode, text) {
	            this._delegate.setText(renderNode, text);
	        }
	    }, {
	        key: 'animate',
	        value: function animate(element, startingStyles, keyframes, duration, delay, easing) {
	            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);
	        }
	    }]);
	    return DebugDomRenderer;
	}();

	/* @ts2dart_const */
	var StaticNodeDebugInfo = function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
	    classCallCheck(this, StaticNodeDebugInfo);

	    this.providerTokens = providerTokens;
	    this.componentToken = componentToken;
	    this.refTokens = refTokens;
	};
	var DebugContext = function () {
	    function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
	        classCallCheck(this, DebugContext);

	        this._view = _view;
	        this._nodeIndex = _nodeIndex;
	        this._tplRow = _tplRow;
	        this._tplCol = _tplCol;
	    }

	    createClass(DebugContext, [{
	        key: '_staticNodeInfo',
	        get: function get() {
	            return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._view.context;
	        }
	    }, {
	        key: 'component',
	        get: function get() {
	            var staticNodeInfo = this._staticNodeInfo;
	            if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
	                return this.injector.get(staticNodeInfo.componentToken);
	            }
	            return null;
	        }
	    }, {
	        key: 'componentRenderElement',
	        get: function get() {
	            var componentView = this._view;
	            while (isPresent(componentView.declarationAppElement) && componentView.type !== ViewType.COMPONENT) {
	                componentView = componentView.declarationAppElement.parentView;
	            }
	            return isPresent(componentView.declarationAppElement) ? componentView.declarationAppElement.nativeElement : null;
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return this._view.injector(this._nodeIndex);
	        }
	    }, {
	        key: 'renderNode',
	        get: function get() {
	            if (isPresent(this._nodeIndex) && isPresent(this._view.allNodes)) {
	                return this._view.allNodes[this._nodeIndex];
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'providerTokens',
	        get: function get() {
	            var staticNodeInfo = this._staticNodeInfo;
	            return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
	        }
	    }, {
	        key: 'source',
	        get: function get() {
	            return this._view.componentType.templateUrl + ':' + this._tplRow + ':' + this._tplCol;
	        }
	    }, {
	        key: 'references',
	        get: function get() {
	            var _this = this;

	            var varValues = {};
	            var staticNodeInfo = this._staticNodeInfo;
	            if (isPresent(staticNodeInfo)) {
	                var refs = staticNodeInfo.refTokens;
	                StringMapWrapper.forEach(refs, function (refToken /** TODO #9100 */, refName /** TODO #9100 */) {
	                    var varValue;
	                    if (isBlank(refToken)) {
	                        varValue = isPresent(_this._view.allNodes) ? _this._view.allNodes[_this._nodeIndex] : null;
	                    } else {
	                        varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
	                    }
	                    varValues[refName] = varValue;
	                });
	            }
	            return varValues;
	        }
	    }]);
	    return DebugContext;
	}();

	var _UNDEFINED = new Object();
	var ElementInjector = function (_Injector) {
	    inherits(ElementInjector, _Injector);

	    function ElementInjector(_view, _nodeIndex) {
	        classCallCheck(this, ElementInjector);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ElementInjector).call(this));

	        _this._view = _view;
	        _this._nodeIndex = _nodeIndex;
	        return _this;
	    }

	    createClass(ElementInjector, [{
	        key: 'get',
	        value: function get(token) {
	            var notFoundValue = arguments.length <= 1 || arguments[1] === undefined ? THROW_IF_NOT_FOUND : arguments[1];

	            var result = _UNDEFINED;
	            if (result === _UNDEFINED) {
	                result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED);
	            }
	            if (result === _UNDEFINED) {
	                result = this._view.parentInjector.get(token, notFoundValue);
	            }
	            return result;
	        }
	    }]);
	    return ElementInjector;
	}(Injector);

	var ActiveAnimationPlayersMap = function () {
	    function ActiveAnimationPlayersMap() {
	        classCallCheck(this, ActiveAnimationPlayersMap);

	        this._map = new Map$1();
	        this._allPlayers = [];
	    }

	    createClass(ActiveAnimationPlayersMap, [{
	        key: 'find',
	        value: function find(element, animationName) {
	            var playersByAnimation = this._map.get(element);
	            if (isPresent(playersByAnimation)) {
	                return playersByAnimation[animationName];
	            }
	        }
	    }, {
	        key: 'findAllPlayersByElement',
	        value: function findAllPlayersByElement(element) {
	            var players = [];
	            StringMapWrapper.forEach(this._map.get(element), function (player /** TODO #9100 */) {
	                return players.push(player);
	            });
	            return players;
	        }
	    }, {
	        key: 'set',
	        value: function set(element, animationName, player) {
	            var playersByAnimation = this._map.get(element);
	            if (!isPresent(playersByAnimation)) {
	                playersByAnimation = {};
	            }
	            var existingEntry = playersByAnimation[animationName];
	            if (isPresent(existingEntry)) {
	                this.remove(element, animationName);
	            }
	            playersByAnimation[animationName] = player;
	            this._allPlayers.push(player);
	            this._map.set(element, playersByAnimation);
	        }
	    }, {
	        key: 'getAllPlayers',
	        value: function getAllPlayers() {
	            return this._allPlayers;
	        }
	    }, {
	        key: 'remove',
	        value: function remove(element, animationName) {
	            var playersByAnimation = this._map.get(element);
	            if (isPresent(playersByAnimation)) {
	                var player = playersByAnimation[animationName];
	                delete playersByAnimation[animationName];
	                var index = this._allPlayers.indexOf(player);
	                ListWrapper.removeAt(this._allPlayers, index);
	                if (StringMapWrapper.isEmpty(playersByAnimation)) {
	                    this._map.delete(element);
	                }
	            }
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            return this.getAllPlayers().length;
	        }
	    }]);
	    return ActiveAnimationPlayersMap;
	}();

	var _scope_check = wtfCreateScope('AppView#check(ascii id)');
	/**
	 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	 *
	 */
	var AppView = function () {
	    function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
	        classCallCheck(this, AppView);

	        this.clazz = clazz;
	        this.componentType = componentType;
	        this.type = type;
	        this.viewUtils = viewUtils;
	        this.parentInjector = parentInjector;
	        this.declarationAppElement = declarationAppElement;
	        this.cdMode = cdMode;
	        this.contentChildren = [];
	        this.viewChildren = [];
	        this.viewContainerElement = null;
	        this.numberOfChecks = 0;
	        this.activeAnimationPlayers = new ActiveAnimationPlayersMap();
	        this.ref = new ViewRef_(this);
	        if (type === ViewType.COMPONENT || type === ViewType.HOST) {
	            this.renderer = viewUtils.renderComponent(componentType);
	        } else {
	            this.renderer = declarationAppElement.parentView.renderer;
	        }
	    }

	    createClass(AppView, [{
	        key: 'cancelActiveAnimation',
	        value: function cancelActiveAnimation(element, animationName) {
	            var removeAllAnimations = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	            if (removeAllAnimations) {
	                this.activeAnimationPlayers.findAllPlayersByElement(element).forEach(function (player) {
	                    return player.destroy();
	                });
	            } else {
	                var player = this.activeAnimationPlayers.find(element, animationName);
	                if (isPresent(player)) {
	                    player.destroy();
	                }
	            }
	        }
	    }, {
	        key: 'registerAndStartAnimation',
	        value: function registerAndStartAnimation(element, animationName, player) {
	            var _this = this;

	            this.activeAnimationPlayers.set(element, animationName, player);
	            player.onDone(function () {
	                _this.activeAnimationPlayers.remove(element, animationName);
	            });
	            player.play();
	        }
	    }, {
	        key: 'create',
	        value: function create(context, givenProjectableNodes, rootSelectorOrNode) {
	            this.context = context;
	            var projectableNodes;
	            switch (this.type) {
	                case ViewType.COMPONENT:
	                    projectableNodes = ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
	                    break;
	                case ViewType.EMBEDDED:
	                    projectableNodes = this.declarationAppElement.parentView.projectableNodes;
	                    break;
	                case ViewType.HOST:
	                    // Note: Don't ensure the slot count for the projectableNodes as we store
	                    // them only for the contained component view (which will later check the slot count...)
	                    projectableNodes = givenProjectableNodes;
	                    break;
	            }
	            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
	            this.projectableNodes = projectableNodes;
	            return this.createInternal(rootSelectorOrNode);
	        }
	        /**
	         * Overwritten by implementations.
	         * Returns the AppElement for the host element for ViewType.HOST.
	         */

	    }, {
	        key: 'createInternal',
	        value: function createInternal(rootSelectorOrNode) {
	            return null;
	        }
	    }, {
	        key: 'init',
	        value: function init(rootNodesOrAppElements, allNodes, disposables, subscriptions) {
	            this.rootNodesOrAppElements = rootNodesOrAppElements;
	            this.allNodes = allNodes;
	            this.disposables = disposables;
	            this.subscriptions = subscriptions;
	            if (this.type === ViewType.COMPONENT) {
	                // Note: the render nodes have been attached to their host element
	                // in the ViewFactory already.
	                this.declarationAppElement.parentView.viewChildren.push(this);
	                this.dirtyParentQueriesInternal();
	            }
	        }
	    }, {
	        key: 'selectOrCreateHostElement',
	        value: function selectOrCreateHostElement(elementName, rootSelectorOrNode, debugInfo) {
	            var hostElement;
	            if (isPresent(rootSelectorOrNode)) {
	                hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
	            } else {
	                hostElement = this.renderer.createElement(null, elementName, debugInfo);
	            }
	            return hostElement;
	        }
	    }, {
	        key: 'injectorGet',
	        value: function injectorGet(token, nodeIndex, notFoundResult) {
	            return this.injectorGetInternal(token, nodeIndex, notFoundResult);
	        }
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'injectorGetInternal',
	        value: function injectorGetInternal(token, nodeIndex, notFoundResult) {
	            return notFoundResult;
	        }
	    }, {
	        key: 'injector',
	        value: function injector(nodeIndex) {
	            if (isPresent(nodeIndex)) {
	                return new ElementInjector(this, nodeIndex);
	            } else {
	                return this.parentInjector;
	            }
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this._hasExternalHostElement) {
	                this.renderer.detachView(this.flatRootNodes);
	            } else if (isPresent(this.viewContainerElement)) {
	                this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
	            }
	            this._destroyRecurse();
	        }
	    }, {
	        key: '_destroyRecurse',
	        value: function _destroyRecurse() {
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                return;
	            }
	            var children = this.contentChildren;
	            for (var i = 0; i < children.length; i++) {
	                children[i]._destroyRecurse();
	            }
	            children = this.viewChildren;
	            for (var i = 0; i < children.length; i++) {
	                children[i]._destroyRecurse();
	            }
	            this.destroyLocal();
	            this.cdMode = ChangeDetectorStatus.Destroyed;
	        }
	    }, {
	        key: 'destroyLocal',
	        value: function destroyLocal() {
	            var _this2 = this;

	            var hostElement = this.type === ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
	            for (var i = 0; i < this.disposables.length; i++) {
	                this.disposables[i]();
	            }
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                ObservableWrapper.dispose(this.subscriptions[i]);
	            }
	            this.destroyInternal();
	            this.dirtyParentQueriesInternal();
	            if (this.activeAnimationPlayers.length == 0) {
	                this.renderer.destroyView(hostElement, this.allNodes);
	            } else {
	                var player = new AnimationGroupPlayer(this.activeAnimationPlayers.getAllPlayers());
	                player.onDone(function () {
	                    _this2.renderer.destroyView(hostElement, _this2.allNodes);
	                });
	            }
	        }
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'destroyInternal',
	        value: function destroyInternal() {}
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'detachInternal',
	        value: function detachInternal() {}
	    }, {
	        key: 'detach',
	        value: function detach() {
	            var _this3 = this;

	            this.detachInternal();
	            if (this.activeAnimationPlayers.length == 0) {
	                this.renderer.detachView(this.flatRootNodes);
	            } else {
	                var player = new AnimationGroupPlayer(this.activeAnimationPlayers.getAllPlayers());
	                player.onDone(function () {
	                    _this3.renderer.detachView(_this3.flatRootNodes);
	                });
	            }
	        }
	    }, {
	        key: 'dirtyParentQueriesInternal',

	        /**
	         * Overwritten by implementations
	         */
	        value: function dirtyParentQueriesInternal() {}
	    }, {
	        key: 'detectChanges',
	        value: function detectChanges(throwOnChange) {
	            var s = _scope_check(this.clazz);
	            if (this.cdMode === ChangeDetectorStatus.Checked || this.cdMode === ChangeDetectorStatus.Errored) return;
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                this.throwDestroyedError('detectChanges');
	            }
	            this.detectChangesInternal(throwOnChange);
	            if (this.cdMode === ChangeDetectorStatus.CheckOnce) this.cdMode = ChangeDetectorStatus.Checked;
	            this.numberOfChecks++;
	            wtfLeave(s);
	        }
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'detectChangesInternal',
	        value: function detectChangesInternal(throwOnChange) {
	            this.detectContentChildrenChanges(throwOnChange);
	            this.detectViewChildrenChanges(throwOnChange);
	        }
	    }, {
	        key: 'detectContentChildrenChanges',
	        value: function detectContentChildrenChanges(throwOnChange) {
	            for (var i = 0; i < this.contentChildren.length; ++i) {
	                var child = this.contentChildren[i];
	                if (child.cdMode === ChangeDetectorStatus.Detached) continue;
	                child.detectChanges(throwOnChange);
	            }
	        }
	    }, {
	        key: 'detectViewChildrenChanges',
	        value: function detectViewChildrenChanges(throwOnChange) {
	            for (var i = 0; i < this.viewChildren.length; ++i) {
	                var child = this.viewChildren[i];
	                if (child.cdMode === ChangeDetectorStatus.Detached) continue;
	                child.detectChanges(throwOnChange);
	            }
	        }
	    }, {
	        key: 'addToContentChildren',
	        value: function addToContentChildren(renderAppElement) {
	            renderAppElement.parentView.contentChildren.push(this);
	            this.viewContainerElement = renderAppElement;
	            this.dirtyParentQueriesInternal();
	        }
	    }, {
	        key: 'removeFromContentChildren',
	        value: function removeFromContentChildren(renderAppElement) {
	            ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
	            this.dirtyParentQueriesInternal();
	            this.viewContainerElement = null;
	        }
	    }, {
	        key: 'markAsCheckOnce',
	        value: function markAsCheckOnce() {
	            this.cdMode = ChangeDetectorStatus.CheckOnce;
	        }
	    }, {
	        key: 'markPathToRootAsCheckOnce',
	        value: function markPathToRootAsCheckOnce() {
	            var c = this;
	            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
	                if (c.cdMode === ChangeDetectorStatus.Checked) {
	                    c.cdMode = ChangeDetectorStatus.CheckOnce;
	                }
	                var parentEl = c.type === ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
	                c = isPresent(parentEl) ? parentEl.parentView : null;
	            }
	        }
	    }, {
	        key: 'eventHandler',
	        value: function eventHandler(cb) {
	            return cb;
	        }
	    }, {
	        key: 'throwDestroyedError',
	        value: function throwDestroyedError(details) {
	            throw new ViewDestroyedException(details);
	        }
	    }, {
	        key: 'destroyed',
	        get: function get() {
	            return this.cdMode === ChangeDetectorStatus.Destroyed;
	        }
	    }, {
	        key: 'changeDetectorRef',
	        get: function get() {
	            return this.ref;
	        }
	    }, {
	        key: 'parent',
	        get: function get() {
	            return isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
	        }
	    }, {
	        key: 'flatRootNodes',
	        get: function get() {
	            return flattenNestedViewRenderNodes(this.rootNodesOrAppElements);
	        }
	    }, {
	        key: 'lastRootNode',
	        get: function get() {
	            var lastNode = this.rootNodesOrAppElements.length > 0 ? this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] : null;
	            return _findLastRenderNode(lastNode);
	        }
	    }]);
	    return AppView;
	}();
	var DebugAppView = function (_AppView) {
	    inherits(DebugAppView, _AppView);

	    function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
	        classCallCheck(this, DebugAppView);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(DebugAppView).call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode));

	        _this4.staticNodeDebugInfos = staticNodeDebugInfos;
	        _this4._currentDebugContext = null;
	        return _this4;
	    }

	    createClass(DebugAppView, [{
	        key: 'create',
	        value: function create(context, givenProjectableNodes, rootSelectorOrNode) {
	            this._resetDebug();
	            try {
	                return get(Object.getPrototypeOf(DebugAppView.prototype), 'create', this).call(this, context, givenProjectableNodes, rootSelectorOrNode);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'injectorGet',
	        value: function injectorGet(token, nodeIndex, notFoundResult) {
	            this._resetDebug();
	            try {
	                return get(Object.getPrototypeOf(DebugAppView.prototype), 'injectorGet', this).call(this, token, nodeIndex, notFoundResult);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'detach',
	        value: function detach() {
	            this._resetDebug();
	            try {
	                get(Object.getPrototypeOf(DebugAppView.prototype), 'detach', this).call(this);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'destroyLocal',
	        value: function destroyLocal() {
	            this._resetDebug();
	            try {
	                get(Object.getPrototypeOf(DebugAppView.prototype), 'destroyLocal', this).call(this);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'detectChanges',
	        value: function detectChanges(throwOnChange) {
	            this._resetDebug();
	            try {
	                get(Object.getPrototypeOf(DebugAppView.prototype), 'detectChanges', this).call(this, throwOnChange);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: '_resetDebug',
	        value: function _resetDebug() {
	            this._currentDebugContext = null;
	        }
	    }, {
	        key: 'debug',
	        value: function debug(nodeIndex, rowNum, colNum) {
	            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
	        }
	    }, {
	        key: '_rethrowWithContext',
	        value: function _rethrowWithContext(e, stack) {
	            if (!(e instanceof ViewWrappedException)) {
	                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedException)) {
	                    this.cdMode = ChangeDetectorStatus.Errored;
	                }
	                if (isPresent(this._currentDebugContext)) {
	                    throw new ViewWrappedException(e, stack, this._currentDebugContext);
	                }
	            }
	        }
	    }, {
	        key: 'eventHandler',
	        value: function eventHandler(cb) {
	            var _this5 = this;

	            var superHandler = get(Object.getPrototypeOf(DebugAppView.prototype), 'eventHandler', this).call(this, cb);
	            return function (event /** TODO #9100 */) {
	                _this5._resetDebug();
	                try {
	                    return superHandler(event);
	                } catch (e) {
	                    _this5._rethrowWithContext(e, e.stack);
	                    throw e;
	                }
	            };
	        }
	    }]);
	    return DebugAppView;
	}(AppView);
	function _findLastRenderNode(node) {
	    var lastNode;
	    if (node instanceof AppElement) {
	        var appEl = node;
	        lastNode = appEl.nativeElement;
	        if (isPresent(appEl.nestedViews)) {
	            // Note: Views might have no root nodes at all!
	            for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
	                var nestedView = appEl.nestedViews[i];
	                if (nestedView.rootNodesOrAppElements.length > 0) {
	                    lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
	                }
	            }
	        }
	    } else {
	        lastNode = node;
	    }
	    return lastNode;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * This is here because DART requires it. It is noop in JS.
	 */
	function wtfInit() {}

	var r = {
	    isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
	    ChangeDetectorStatus: ChangeDetectorStatus,
	    CHANGE_DETECTION_STRATEGY_VALUES: CHANGE_DETECTION_STRATEGY_VALUES,
	    constructDependencies: constructDependencies,
	    LifecycleHooks: LifecycleHooks,
	    LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
	    ReflectorReader: ReflectorReader,
	    ReflectorComponentResolver: ReflectorComponentResolver,
	    CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,
	    AppElement: AppElement,
	    AppView: AppView,
	    DebugAppView: DebugAppView,
	    ViewType: ViewType,
	    MAX_INTERPOLATION_VALUES: MAX_INTERPOLATION_VALUES,
	    checkBinding: checkBinding,
	    flattenNestedViewRenderNodes: flattenNestedViewRenderNodes,
	    interpolate: interpolate,
	    ViewUtils: ViewUtils,
	    VIEW_ENCAPSULATION_VALUES: VIEW_ENCAPSULATION_VALUES,
	    DebugContext: DebugContext,
	    StaticNodeDebugInfo: StaticNodeDebugInfo,
	    devModeEqual: devModeEqual,
	    uninitialized: uninitialized,
	    ValueUnwrapper: ValueUnwrapper,
	    RenderDebugInfo: RenderDebugInfo,
	    SecurityContext: SecurityContext,
	    SanitizationService: SanitizationService,
	    TemplateRef_: TemplateRef_,
	    wtfInit: wtfInit,
	    ReflectionCapabilities: ReflectionCapabilities,
	    makeDecorator: makeDecorator,
	    DebugDomRootRenderer: DebugDomRootRenderer,
	    createProvider: createProvider,
	    isProviderLiteral: isProviderLiteral,
	    EMPTY_ARRAY: EMPTY_ARRAY,
	    EMPTY_MAP: EMPTY_MAP,
	    pureProxy1: pureProxy1,
	    pureProxy2: pureProxy2,
	    pureProxy3: pureProxy3,
	    pureProxy4: pureProxy4,
	    pureProxy5: pureProxy5,
	    pureProxy6: pureProxy6,
	    pureProxy7: pureProxy7,
	    pureProxy8: pureProxy8,
	    pureProxy9: pureProxy9,
	    pureProxy10: pureProxy10,
	    castByValue: castByValue,
	    Console: Console,
	    reflector: reflector,
	    Reflector: Reflector,
	    NoOpAnimationPlayer: NoOpAnimationPlayer,
	    AnimationPlayer: AnimationPlayer,
	    NoOpAnimationDriver: NoOpAnimationDriver,
	    AnimationDriver: AnimationDriver,
	    AnimationSequencePlayer: AnimationSequencePlayer,
	    AnimationGroupPlayer: AnimationGroupPlayer,
	    AnimationKeyframe: AnimationKeyframe,
	    prepareFinalAnimationStyles: prepareFinalAnimationStyles,
	    balanceAnimationKeyframes: balanceAnimationKeyframes,
	    flattenStyles: flattenStyles,
	    clearStyles: clearStyles,
	    renderStyles: renderStyles,
	    collectAndResolveStyles: collectAndResolveStyles,
	    AnimationStyles: AnimationStyles,
	    ANY_STATE: ANY_STATE,
	    DEFAULT_STATE: DEFAULT_STATE,
	    EMPTY_STATE: EMPTY_STATE,
	    FILL_STYLE_FLAG: FILL_STYLE_FLAG
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalScope$1;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope$1 = self;
	    } else {
	        globalScope$1 = global;
	    }
	} else {
	    globalScope$1 = window;
	}
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var global$2 = globalScope$1;
	function getTypeNameForDebugging$1(type) {
	    if (type['name']) {
	        return type['name'];
	    }
	    return typeof type === 'undefined' ? 'undefined' : _typeof(type);
	}
	var Date$2 = global$2.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	global$2.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent$1(obj) {
	    return obj !== undefined && obj !== null;
	}
	function isBlank$1(obj) {
	    return obj === undefined || obj === null;
	}
	function isNumber$1(obj) {
	    return typeof obj === 'number';
	}
	function isString$1(obj) {
	    return typeof obj === 'string';
	}
	function isFunction$2(obj) {
	    return typeof obj === 'function';
	}
	function isStringMap$1(obj) {
	    return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null;
	}
	function isPromise$1(obj) {
	    return obj instanceof global$2.Promise;
	}
	function isArray$2(obj) {
	    return Array.isArray(obj);
	}
	function isDate$1(obj) {
	    return obj instanceof Date$2 && !isNaN(obj.valueOf());
	}
	function noop$1() {}
	function stringify$1(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token === undefined || token === null) {
	        return '' + token;
	    }
	    if (token.name) {
	        return token.name;
	    }
	    if (token.overriddenName) {
	        return token.overriddenName;
	    }
	    var res = token.toString();
	    var newLineIndex = res.indexOf('\n');
	    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	}
	var StringWrapper$1 = function () {
	    function StringWrapper() {
	        classCallCheck(this, StringWrapper);
	    }

	    createClass(StringWrapper, null, [{
	        key: 'fromCharCode',
	        value: function fromCharCode(code) {
	            return String.fromCharCode(code);
	        }
	    }, {
	        key: 'charCodeAt',
	        value: function charCodeAt(s, index) {
	            return s.charCodeAt(index);
	        }
	    }, {
	        key: 'split',
	        value: function split(s, regExp) {
	            return s.split(regExp);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(s, s2) {
	            return s === s2;
	        }
	    }, {
	        key: 'stripLeft',
	        value: function stripLeft(s, charVal) {
	            if (s && s.length) {
	                var pos = 0;
	                for (var i = 0; i < s.length; i++) {
	                    if (s[i] != charVal) break;
	                    pos++;
	                }
	                s = s.substring(pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'stripRight',
	        value: function stripRight(s, charVal) {
	            if (s && s.length) {
	                var pos = s.length;
	                for (var i = s.length - 1; i >= 0; i--) {
	                    if (s[i] != charVal) break;
	                    pos--;
	                }
	                s = s.substring(0, pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'replace',
	        value: function replace(s, from, _replace) {
	            return s.replace(from, _replace);
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(s, from, replace) {
	            return s.replace(from, replace);
	        }
	    }, {
	        key: 'slice',
	        value: function slice(s) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return s.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'replaceAllMapped',
	        value: function replaceAllMapped(s, from, cb) {
	            return s.replace(from, function () {
	                for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
	                    matches[_key] = arguments[_key];
	                }

	                // Remove offset & string from the result array
	                matches.splice(-2, 2);
	                // The callback receives match, p1, ..., pn
	                return cb(matches);
	            });
	        }
	    }, {
	        key: 'contains',
	        value: function contains(s, substr) {
	            return s.indexOf(substr) != -1;
	        }
	    }, {
	        key: 'compare',
	        value: function compare(a, b) {
	            if (a < b) {
	                return -1;
	            } else if (a > b) {
	                return 1;
	            } else {
	                return 0;
	            }
	        }
	    }]);
	    return StringWrapper;
	}();

	var StringJoiner$1 = function () {
	    function StringJoiner() {
	        var parts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, StringJoiner);

	        this.parts = parts;
	    }

	    createClass(StringJoiner, [{
	        key: 'add',
	        value: function add(part) {
	            this.parts.push(part);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.parts.join('');
	        }
	    }]);
	    return StringJoiner;
	}();
	var NumberParseError$1 = function (_Error) {
	    inherits(NumberParseError, _Error);

	    function NumberParseError(message) {
	        classCallCheck(this, NumberParseError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NumberParseError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(NumberParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return NumberParseError;
	}(Error);
	var NumberWrapper$1 = function () {
	    function NumberWrapper() {
	        classCallCheck(this, NumberWrapper);
	    }

	    createClass(NumberWrapper, null, [{
	        key: 'toFixed',
	        value: function toFixed(n, fractionDigits) {
	            return n.toFixed(fractionDigits);
	        }
	    }, {
	        key: 'equal',
	        value: function equal(a, b) {
	            return a === b;
	        }
	    }, {
	        key: 'parseIntAutoRadix',
	        value: function parseIntAutoRadix(text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new NumberParseError$1('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        }
	    }, {
	        key: 'parseInt',
	        value: function (_parseInt) {
	            function parseInt(_x4, _x5) {
	                return _parseInt.apply(this, arguments);
	            }

	            parseInt.toString = function () {
	                return _parseInt.toString();
	            };

	            return parseInt;
	        }(function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new NumberParseError$1('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        })
	        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.

	    }, {
	        key: 'parseFloat',
	        value: function (_parseFloat) {
	            function parseFloat(_x6) {
	                return _parseFloat.apply(this, arguments);
	            }

	            parseFloat.toString = function () {
	                return _parseFloat.toString();
	            };

	            return parseFloat;
	        }(function (text) {
	            return parseFloat(text);
	        })
	    }, {
	        key: 'isNumeric',
	        value: function isNumeric(value) {
	            return !isNaN(value - parseFloat(value));
	        }
	    }, {
	        key: 'isNaN',
	        value: function (_isNaN) {
	            function isNaN(_x7) {
	                return _isNaN.apply(this, arguments);
	            }

	            isNaN.toString = function () {
	                return _isNaN.toString();
	            };

	            return isNaN;
	        }(function (value) {
	            return isNaN(value);
	        })
	    }, {
	        key: 'isInteger',
	        value: function isInteger(value) {
	            return Number.isInteger(value);
	        }
	    }, {
	        key: 'NaN',
	        get: function get() {
	            return NaN;
	        }
	    }]);
	    return NumberWrapper;
	}();
	var RegExpWrapper$1 = function () {
	    function RegExpWrapper() {
	        classCallCheck(this, RegExpWrapper);
	    }

	    createClass(RegExpWrapper, null, [{
	        key: 'create',
	        value: function create(regExpStr) {
	            var flags = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            flags = flags.replace(/g/g, '');
	            return new global$2.RegExp(regExpStr, flags + 'g');
	        }
	    }, {
	        key: 'firstMatch',
	        value: function firstMatch(regExp, input) {
	            // Reset multimatch regex state
	            regExp.lastIndex = 0;
	            return regExp.exec(input);
	        }
	    }, {
	        key: 'test',
	        value: function test(regExp, input) {
	            regExp.lastIndex = 0;
	            return regExp.test(input);
	        }
	    }, {
	        key: 'matcher',
	        value: function matcher(regExp, input) {
	            // Reset regex state for the case
	            // someone did not loop over all matches
	            // last time.
	            regExp.lastIndex = 0;
	            return { re: regExp, input: input };
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(regExp, input, replace) {
	            var c = regExp.exec(input);
	            var res = '';
	            regExp.lastIndex = 0;
	            var prev = 0;
	            while (c) {
	                res += input.substring(prev, c.index);
	                res += replace(c);
	                prev = c.index + c[0].length;
	                regExp.lastIndex = prev;
	                c = regExp.exec(input);
	            }
	            res += input.substring(prev);
	            return res;
	        }
	    }]);
	    return RegExpWrapper;
	}();
	var RegExpMatcherWrapper$1 = function () {
	    function RegExpMatcherWrapper() {
	        classCallCheck(this, RegExpMatcherWrapper);
	    }

	    createClass(RegExpMatcherWrapper, null, [{
	        key: 'next',
	        value: function next(matcher) {
	            return matcher.re.exec(matcher.input);
	        }
	    }]);
	    return RegExpMatcherWrapper;
	}();
	var FunctionWrapper$1 = function () {
	    function FunctionWrapper() {
	        classCallCheck(this, FunctionWrapper);
	    }

	    createClass(FunctionWrapper, null, [{
	        key: 'apply',
	        value: function apply(fn, posArgs) {
	            return fn.apply(null, posArgs);
	        }
	    }, {
	        key: 'bind',
	        value: function bind(fn, scope) {
	            return fn.bind(scope);
	        }
	    }]);
	    return FunctionWrapper;
	}();
	// JS has NaN !== NaN
	function looseIdentical$1(a, b) {
	    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	}
	function normalizeBlank$1(obj) {
	    return isBlank$1(obj) ? null : obj;
	}
	function normalizeBool$1(obj) {
	    return isBlank$1(obj) ? false : obj;
	}
	function isJsObject$1(o) {
	    return o !== null && (typeof o === 'function' || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object');
	}
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json$1 = function () {
	    function Json() {
	        classCallCheck(this, Json);
	    }

	    createClass(Json, null, [{
	        key: 'parse',
	        value: function parse(s) {
	            return global$2.JSON.parse(s);
	        }
	    }, {
	        key: 'stringify',
	        value: function stringify(data) {
	            // Dart doesn't take 3 arguments
	            return global$2.JSON.stringify(data, null, 2);
	        }
	    }]);
	    return Json;
	}();
	var DateWrapper$1 = function () {
	    function DateWrapper() {
	        classCallCheck(this, DateWrapper);
	    }

	    createClass(DateWrapper, null, [{
	        key: 'create',
	        value: function create(year) {
	            var month = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var day = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	            var hour = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	            var minutes = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
	            var seconds = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
	            var milliseconds = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];

	            return new Date$2(year, month - 1, day, hour, minutes, seconds, milliseconds);
	        }
	    }, {
	        key: 'fromISOString',
	        value: function fromISOString(str) {
	            return new Date$2(str);
	        }
	    }, {
	        key: 'fromMillis',
	        value: function fromMillis(ms) {
	            return new Date$2(ms);
	        }
	    }, {
	        key: 'toMillis',
	        value: function toMillis(date) {
	            return date.getTime();
	        }
	    }, {
	        key: 'now',
	        value: function now() {
	            return new Date$2();
	        }
	    }, {
	        key: 'toJson',
	        value: function toJson(date) {
	            return date.toJSON();
	        }
	    }]);
	    return DateWrapper;
	}();
	var _symbolIterator$1 = null;
	function getSymbolIterator$1() {
	    if (isBlank$1(_symbolIterator$1)) {
	        if (isPresent$1(globalScope$1.Symbol) && isPresent$1(Symbol.iterator)) {
	            _symbolIterator$1 = Symbol.iterator;
	        } else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator$1 = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator$1;
	}
	function isPrimitive$1(obj) {
	    return !isJsObject$1(obj);
	}
	function hasConstructor$1(value, type) {
	    return value.constructor === type;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PromiseCompleter$1 = function PromiseCompleter() {
	    var _this = this;

	    classCallCheck(this, PromiseCompleter);

	    this.promise = new Promise(function (res, rej) {
	        _this.resolve = res;
	        _this.reject = rej;
	    });
	};
	var PromiseWrapper$1 = function () {
	    function PromiseWrapper() {
	        classCallCheck(this, PromiseWrapper);
	    }

	    createClass(PromiseWrapper, null, [{
	        key: "resolve",
	        value: function resolve(obj) {
	            return Promise.resolve(obj);
	        }
	    }, {
	        key: "reject",
	        value: function reject(obj, _) {
	            return Promise.reject(obj);
	        }
	        // Note: We can't rename this method into `catch`, as this is not a valid
	        // method name in Dart.

	    }, {
	        key: "catchError",
	        value: function catchError(promise, onError) {
	            return promise.catch(onError);
	        }
	    }, {
	        key: "all",
	        value: function all(promises) {
	            if (promises.length == 0) return Promise.resolve([]);
	            return Promise.all(promises);
	        }
	    }, {
	        key: "then",
	        value: function then(promise, success, rejection) {
	            return promise.then(success, rejection);
	        }
	    }, {
	        key: "wrap",
	        value: function wrap(computation) {
	            return new Promise(function (res, rej) {
	                try {
	                    res(computation());
	                } catch (e) {
	                    rej(e);
	                }
	            });
	        }
	    }, {
	        key: "scheduleMicrotask",
	        value: function scheduleMicrotask(computation) {
	            PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) {});
	        }
	    }, {
	        key: "completer",
	        value: function completer() {
	            return new PromiseCompleter$1();
	        }
	    }]);
	    return PromiseWrapper;
	}();

	var TimerWrapper$1 = function () {
	    function TimerWrapper() {
	        classCallCheck(this, TimerWrapper);
	    }

	    createClass(TimerWrapper, null, [{
	        key: 'setTimeout',
	        value: function setTimeout(fn, millis) {
	            return global$2.setTimeout(fn, millis);
	        }
	    }, {
	        key: 'clearTimeout',
	        value: function clearTimeout(id) {
	            global$2.clearTimeout(id);
	        }
	    }, {
	        key: 'setInterval',
	        value: function setInterval(fn, millis) {
	            return global$2.setInterval(fn, millis);
	        }
	    }, {
	        key: 'clearInterval',
	        value: function clearInterval(id) {
	            global$2.clearInterval(id);
	        }
	    }]);
	    return TimerWrapper;
	}();
	var ObservableWrapper$1 = function () {
	    function ObservableWrapper() {
	        classCallCheck(this, ObservableWrapper);
	    }

	    createClass(ObservableWrapper, null, [{
	        key: 'subscribe',

	        // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	        value: function subscribe(emitter, onNext, onError) {
	            var onComplete = arguments.length <= 3 || arguments[3] === undefined ? function () {} : arguments[3];

	            onError = typeof onError === 'function' && onError || noop$1;
	            onComplete = typeof onComplete === 'function' && onComplete || noop$1;
	            return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
	        }
	    }, {
	        key: 'isObservable',
	        value: function isObservable(obs) {
	            return !!obs.subscribe;
	        }
	        /**
	         * Returns whether `obs` has any subscribers listening to events.
	         */

	    }, {
	        key: 'hasSubscribers',
	        value: function hasSubscribers(obs) {
	            return obs.observers.length > 0;
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {
	            subscription.unsubscribe();
	        }
	        /**
	         * @deprecated - use callEmit() instead
	         */

	    }, {
	        key: 'callNext',
	        value: function callNext(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callEmit',
	        value: function callEmit(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callError',
	        value: function callError(emitter, error) {
	            emitter.error(error);
	        }
	    }, {
	        key: 'callComplete',
	        value: function callComplete(emitter) {
	            emitter.complete();
	        }
	    }, {
	        key: 'fromPromise',
	        value: function fromPromise(promise) {
	            return PromiseObservable.create(promise);
	        }
	    }, {
	        key: 'toPromise',
	        value: function toPromise(obj) {
	            return _toPromise.call(obj);
	        }
	    }]);
	    return ObservableWrapper;
	}();
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter$1 = function (_Subject) {
	    inherits(EventEmitter, _Subject);

	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */

	    function EventEmitter() {
	        var isAsync = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	        classCallCheck(this, EventEmitter);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EventEmitter).call(this));

	        _this.__isAsync = isAsync;
	        return _this;
	    }

	    createClass(EventEmitter, [{
	        key: 'emit',
	        value: function emit(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	        /**
	         * @deprecated - use .emit(value) instead
	         */

	    }, {
	        key: 'next',
	        value: function next(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	    }, {
	        key: 'subscribe',
	        value: function subscribe(generatorOrNext, error, complete) {
	            var schedulerFn = void 0;
	            var errorFn = function errorFn(err) {
	                return null;
	            };
	            var completeFn = function completeFn() {
	                return null;
	            };
	            if (generatorOrNext && (typeof generatorOrNext === 'undefined' ? 'undefined' : _typeof(generatorOrNext)) === 'object') {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext.next(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext.next(value);
	                };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return generatorOrNext.error(err);
	                        });
	                    } : function (err) {
	                        generatorOrNext.error(err);
	                    };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return generatorOrNext.complete();
	                        });
	                    } : function () {
	                        generatorOrNext.complete();
	                    };
	                }
	            } else {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext(value);
	                };
	                if (error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return error(err);
	                        });
	                    } : function (err) {
	                        error(err);
	                    };
	                }
	                if (complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return complete();
	                        });
	                    } : function () {
	                        complete();
	                    };
	                }
	            }
	            return get(Object.getPrototypeOf(EventEmitter.prototype), 'subscribe', this).call(this, schedulerFn, errorFn, completeFn);
	        }
	    }]);
	    return EventEmitter;
	}(Subject);

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException$1 = function (_Error) {
	  inherits(BaseWrappedException, _Error);

	  function BaseWrappedException(message) {
	    classCallCheck(this, BaseWrappedException);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(BaseWrappedException).call(this, message));
	  }

	  createClass(BaseWrappedException, [{
	    key: 'wrapperMessage',
	    get: function get() {
	      return '';
	    }
	  }, {
	    key: 'wrapperStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalException',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'message',
	    get: function get() {
	      return '';
	    }
	  }]);
	  return BaseWrappedException;
	}(Error);

	var Map$2 = global$2.Map;
	var Set$2 = global$2.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs$1 = function () {
	    try {
	        if (new Map$2([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) {
	                return new Map$2(pairs);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new Map$2();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	}();
	var createMapFromMap$1 = function () {
	    try {
	        if (new Map$2(new Map$2())) {
	            return function createMapFromMap(m) {
	                return new Map$2(m);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromMap(m) {
	        var map = new Map$2();
	        m.forEach(function (v, k) {
	            map.set(k, v);
	        });
	        return map;
	    };
	}();
	var _clearValues$1 = function () {
	    if (new Map$2().keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!(k = keyIterator.next()).done) {
	                m.set(k.value, null);
	            }
	        };
	    } else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) {
	                m.set(k, null);
	            });
	        };
	    }
	}();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap$1 = function () {
	    try {
	        if (new Map$2().values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    } catch (e) {}
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper$1.createFixedSize(m.size),
	            i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	}();
	var MapWrapper$1 = function () {
	    function MapWrapper() {
	        classCallCheck(this, MapWrapper);
	    }

	    createClass(MapWrapper, null, [{
	        key: 'clone',
	        value: function clone(m) {
	            return createMapFromMap$1(m);
	        }
	    }, {
	        key: 'createFromStringMap',
	        value: function createFromStringMap(stringMap) {
	            var result = new Map$2();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        }
	    }, {
	        key: 'toStringMap',
	        value: function toStringMap(m) {
	            var r = {};
	            m.forEach(function (v, k) {
	                return r[k] = v;
	            });
	            return r;
	        }
	    }, {
	        key: 'createFromPairs',
	        value: function createFromPairs(pairs) {
	            return createMapFromPairs$1(pairs);
	        }
	    }, {
	        key: 'clearValues',
	        value: function clearValues(m) {
	            _clearValues$1(m);
	        }
	    }, {
	        key: 'iterable',
	        value: function iterable(m) {
	            return m;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(m) {
	            return _arrayFromMap$1(m, false);
	        }
	    }, {
	        key: 'values',
	        value: function values(m) {
	            return _arrayFromMap$1(m, true);
	        }
	    }]);
	    return MapWrapper;
	}();
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper$1 = function () {
	    function StringMapWrapper() {
	        classCallCheck(this, StringMapWrapper);
	    }

	    createClass(StringMapWrapper, null, [{
	        key: 'create',
	        value: function create() {
	            // Note: We are not using Object.create(null) here due to
	            // performance!
	            // http://jsperf.com/ng2-object-create-null
	            return {};
	        }
	    }, {
	        key: 'contains',
	        value: function contains(map, key) {
	            return map.hasOwnProperty(key);
	        }
	    }, {
	        key: 'get',
	        value: function get(map, key) {
	            return map.hasOwnProperty(key) ? map[key] : undefined;
	        }
	    }, {
	        key: 'set',
	        value: function set(map, key, value) {
	            map[key] = value;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(map) {
	            return Object.keys(map);
	        }
	    }, {
	        key: 'values',
	        value: function values(map) {
	            return Object.keys(map).reduce(function (r, a) {
	                r.push(map[a]);
	                return r;
	            }, []);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(map) {
	            for (var prop in map) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(map, key) {
	            delete map[key];
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(map, callback) {
	            for (var prop in map) {
	                if (map.hasOwnProperty(prop)) {
	                    callback(map[prop], prop);
	                }
	            }
	        }
	    }, {
	        key: 'merge',
	        value: function merge(m1, m2) {
	            var m = {};
	            for (var attr in m1) {
	                if (m1.hasOwnProperty(attr)) {
	                    m[attr] = m1[attr];
	                }
	            }
	            for (var attr in m2) {
	                if (m2.hasOwnProperty(attr)) {
	                    m[attr] = m2[attr];
	                }
	            }
	            return m;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            var key;
	            for (var i = 0; i < k1.length; i++) {
	                key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }]);
	    return StringMapWrapper;
	}();
	var ListWrapper$1 = function () {
	    function ListWrapper() {
	        classCallCheck(this, ListWrapper);
	    }

	    createClass(ListWrapper, null, [{
	        key: 'createFixedSize',

	        // JS has no way to express a statically fixed size list, but dart does so we
	        // keep both methods.
	        value: function createFixedSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'createGrowableSize',
	        value: function createGrowableSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'clone',
	        value: function clone(array) {
	            return array.slice(0);
	        }
	    }, {
	        key: 'forEachWithIndex',
	        value: function forEachWithIndex(array, fn) {
	            for (var i = 0; i < array.length; i++) {
	                fn(array[i], i);
	            }
	        }
	    }, {
	        key: 'first',
	        value: function first(array) {
	            if (!array) return null;
	            return array[0];
	        }
	    }, {
	        key: 'last',
	        value: function last(array) {
	            if (!array || array.length == 0) return null;
	            return array[array.length - 1];
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(array, value) {
	            var startIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	            return array.indexOf(value, startIndex);
	        }
	    }, {
	        key: 'contains',
	        value: function contains(list, el) {
	            return list.indexOf(el) !== -1;
	        }
	    }, {
	        key: 'reversed',
	        value: function reversed(array) {
	            var a = ListWrapper.clone(array);
	            return a.reverse();
	        }
	    }, {
	        key: 'concat',
	        value: function concat(a, b) {
	            return a.concat(b);
	        }
	    }, {
	        key: 'insert',
	        value: function insert(list, index, value) {
	            list.splice(index, 0, value);
	        }
	    }, {
	        key: 'removeAt',
	        value: function removeAt(list, index) {
	            var res = list[index];
	            list.splice(index, 1);
	            return res;
	        }
	    }, {
	        key: 'removeAll',
	        value: function removeAll(list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'clear',
	        value: function clear(list) {
	            list.length = 0;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(list) {
	            return list.length == 0;
	        }
	    }, {
	        key: 'fill',
	        value: function fill(list, value) {
	            var start = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	            var end = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            list.fill(value, start, end === null ? list.length : end);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(a, b) {
	            if (a.length != b.length) return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i]) return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'slice',
	        value: function slice(l) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return l.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'splice',
	        value: function splice(l, from, length) {
	            return l.splice(from, length);
	        }
	    }, {
	        key: 'sort',
	        value: function sort(l, compareFn) {
	            if (isPresent$1(compareFn)) {
	                l.sort(compareFn);
	            } else {
	                l.sort();
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString(l) {
	            return l.toString();
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON(l) {
	            return JSON.stringify(l);
	        }
	    }, {
	        key: 'maximum',
	        value: function maximum(list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (isBlank$1(candidate)) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        }
	    }, {
	        key: 'flatten',
	        value: function flatten(list) {
	            var target = [];
	            _flattenArray$1(list, target);
	            return target;
	        }
	    }, {
	        key: 'addAll',
	        value: function addAll(list, source) {
	            for (var i = 0; i < source.length; i++) {
	                list.push(source[i]);
	            }
	        }
	    }]);
	    return ListWrapper;
	}();
	function _flattenArray$1(source, target) {
	    if (isPresent$1(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (isArray$2(item)) {
	                _flattenArray$1(item, target);
	            } else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable$1(obj) {
	    if (!isJsObject$1(obj)) return false;
	    return isArray$2(obj) || !(obj instanceof Map$2) && getSymbolIterator$1() in obj; // JS Iterable have a Symbol.iterator prop
	}
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList$1 = function () {
	    var test = new Set$2([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) {
	            return new Set$2(lst);
	        };
	    } else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new Set$2(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	}();
	var SetWrapper$1 = function () {
	    function SetWrapper() {
	        classCallCheck(this, SetWrapper);
	    }

	    createClass(SetWrapper, null, [{
	        key: 'createFromList',
	        value: function createFromList(lst) {
	            return createSetFromList$1(lst);
	        }
	    }, {
	        key: 'has',
	        value: function has(s, key) {
	            return s.has(key);
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(m, k) {
	            m.delete(k);
	        }
	    }]);
	    return SetWrapper;
	}();

	var _ArrayLogger$1 = function () {
	    function _ArrayLogger() {
	        classCallCheck(this, _ArrayLogger);

	        this.res = [];
	    }

	    createClass(_ArrayLogger, [{
	        key: 'log',
	        value: function log(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logError',
	        value: function logError(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return _ArrayLogger;
	}();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */


	var ExceptionHandler$1 = function () {
	    function ExceptionHandler(_logger) {
	        var _rethrowException = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        classCallCheck(this, ExceptionHandler);

	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }

	    createClass(ExceptionHandler, [{
	        key: 'call',
	        value: function call(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var originalException = this._findOriginalException(exception);
	            var originalStack = this._findOriginalStack(exception);
	            var context = this._findContext(exception);
	            this._logger.logGroup('EXCEPTION: ' + this._extractMessage(exception));
	            if (isPresent$1(stackTrace) && isBlank$1(originalStack)) {
	                this._logger.logError('STACKTRACE:');
	                this._logger.logError(this._longStackTrace(stackTrace));
	            }
	            if (isPresent$1(reason)) {
	                this._logger.logError('REASON: ' + reason);
	            }
	            if (isPresent$1(originalException)) {
	                this._logger.logError('ORIGINAL EXCEPTION: ' + this._extractMessage(originalException));
	            }
	            if (isPresent$1(originalStack)) {
	                this._logger.logError('ORIGINAL STACKTRACE:');
	                this._logger.logError(this._longStackTrace(originalStack));
	            }
	            if (isPresent$1(context)) {
	                this._logger.logError('ERROR CONTEXT:');
	                this._logger.logError(context);
	            }
	            this._logger.logGroupEnd();
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	            if (this._rethrowException) throw exception;
	        }
	        /** @internal */

	    }, {
	        key: '_extractMessage',
	        value: function _extractMessage(exception) {
	            return exception instanceof BaseWrappedException$1 ? exception.wrapperMessage : exception.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_longStackTrace',
	        value: function _longStackTrace(stackTrace) {
	            return isListLikeIterable$1(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_findContext',
	        value: function _findContext(exception) {
	            try {
	                if (!(exception instanceof BaseWrappedException$1)) return null;
	                return isPresent$1(exception.context) ? exception.context : this._findContext(exception.originalException);
	            } catch (e) {
	                // exception.context can throw an exception. if it happens, we ignore the context.
	                return null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalException',
	        value: function _findOriginalException(exception) {
	            if (!(exception instanceof BaseWrappedException$1)) return null;
	            var e = exception.originalException;
	            while (e instanceof BaseWrappedException$1 && isPresent$1(e.originalException)) {
	                e = e.originalException;
	            }
	            return e;
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalStack',
	        value: function _findOriginalStack(exception) {
	            if (!(exception instanceof BaseWrappedException$1)) return null;
	            var e = exception;
	            var stack = exception.originalStack;
	            while (e instanceof BaseWrappedException$1 && isPresent$1(e.originalException)) {
	                e = e.originalException;
	                if (e instanceof BaseWrappedException$1 && isPresent$1(e.originalException)) {
	                    stack = e.originalStack;
	                }
	            }
	            return stack;
	        }
	    }], [{
	        key: 'exceptionToString',
	        value: function exceptionToString(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var l = new _ArrayLogger$1();
	            var e = new ExceptionHandler(l, false);
	            e.call(exception, stackTrace, reason);
	            return l.res.join('\n');
	        }
	    }]);
	    return ExceptionHandler;
	}();

	/**
	 * @stable
	 */
	var BaseException$1 = function (_Error) {
	    inherits(BaseException, _Error);

	    function BaseException() {
	        var message = arguments.length <= 0 || arguments[0] === undefined ? '--' : arguments[0];
	        classCallCheck(this, BaseException);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseException).call(this, message));

	        _this.message = message;
	        _this.stack = new Error(message).stack;
	        return _this;
	    }

	    createClass(BaseException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return BaseException;
	}(Error);
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException$1 = function (_BaseWrappedException) {
	    inherits(WrappedException, _BaseWrappedException);

	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        classCallCheck(this, WrappedException);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(WrappedException).call(this, _wrapperMessage));

	        _this2._wrapperMessage = _wrapperMessage;
	        _this2._originalException = _originalException;
	        _this2._originalStack = _originalStack;
	        _this2._context = _context;
	        _this2._wrapperStack = new Error(_wrapperMessage).stack;
	        return _this2;
	    }

	    createClass(WrappedException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            return this._wrapperMessage;
	        }
	    }, {
	        key: 'wrapperStack',
	        get: function get() {
	            return this._wrapperStack;
	        }
	    }, {
	        key: 'originalException',
	        get: function get() {
	            return this._originalException;
	        }
	    }, {
	        key: 'originalStack',
	        get: function get() {
	            return this._originalStack;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._context;
	        }
	    }, {
	        key: 'message',
	        get: function get() {
	            return ExceptionHandler$1.exceptionToString(this);
	        }
	    }]);
	    return WrappedException;
	}(BaseWrappedException$1);
	function unimplemented$1() {
	    throw new BaseException$1('unimplemented');
	}

	var InvalidPipeArgumentException = function (_BaseException) {
	    inherits(InvalidPipeArgumentException, _BaseException);

	    function InvalidPipeArgumentException(type, value) {
	        classCallCheck(this, InvalidPipeArgumentException);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(InvalidPipeArgumentException).call(this, 'Invalid argument \'' + value + '\' for pipe \'' + stringify$1(type) + '\''));
	    }

	    return InvalidPipeArgumentException;
	}(BaseException$1);

	var ObservableStrategy = function () {
	    function ObservableStrategy() {
	        classCallCheck(this, ObservableStrategy);
	    }

	    createClass(ObservableStrategy, [{
	        key: 'createSubscription',
	        value: function createSubscription(async, updateLatestValue) {
	            return ObservableWrapper$1.subscribe(async, updateLatestValue, function (e) {
	                throw e;
	            });
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {
	            ObservableWrapper$1.dispose(subscription);
	        }
	    }, {
	        key: 'onDestroy',
	        value: function onDestroy(subscription) {
	            ObservableWrapper$1.dispose(subscription);
	        }
	    }]);
	    return ObservableStrategy;
	}();

	var PromiseStrategy = function () {
	    function PromiseStrategy() {
	        classCallCheck(this, PromiseStrategy);
	    }

	    createClass(PromiseStrategy, [{
	        key: 'createSubscription',
	        value: function createSubscription(async, updateLatestValue) {
	            return async.then(updateLatestValue, function (e) {
	                throw e;
	            });
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {}
	    }, {
	        key: 'onDestroy',
	        value: function onDestroy(subscription) {}
	    }]);
	    return PromiseStrategy;
	}();

	var _promiseStrategy = new PromiseStrategy();
	var _observableStrategy = new ObservableStrategy();
	var AsyncPipe = function () {
	    function AsyncPipe(_ref) {
	        classCallCheck(this, AsyncPipe);

	        /** @internal */
	        this._latestValue = null;
	        /** @internal */
	        this._latestReturnedValue = null;
	        /** @internal */
	        this._subscription = null;
	        /** @internal */
	        this._obj = null;
	        this._strategy = null;
	        this._ref = _ref;
	    }

	    createClass(AsyncPipe, [{
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            if (isPresent$1(this._subscription)) {
	                this._dispose();
	            }
	        }
	    }, {
	        key: 'transform',
	        value: function transform(obj) {
	            if (isBlank$1(this._obj)) {
	                if (isPresent$1(obj)) {
	                    this._subscribe(obj);
	                }
	                this._latestReturnedValue = this._latestValue;
	                return this._latestValue;
	            }
	            if (obj !== this._obj) {
	                this._dispose();
	                return this.transform(obj);
	            }
	            if (this._latestValue === this._latestReturnedValue) {
	                return this._latestReturnedValue;
	            } else {
	                this._latestReturnedValue = this._latestValue;
	                return WrappedValue.wrap(this._latestValue);
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_subscribe',
	        value: function _subscribe(obj) {
	            var _this = this;

	            this._obj = obj;
	            this._strategy = this._selectStrategy(obj);
	            this._subscription = this._strategy.createSubscription(obj, function (value) {
	                return _this._updateLatestValue(obj, value);
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_selectStrategy',
	        value: function _selectStrategy(obj) {
	            if (isPromise$1(obj)) {
	                return _promiseStrategy;
	            } else if (ObservableWrapper$1.isObservable(obj)) {
	                return _observableStrategy;
	            } else {
	                throw new InvalidPipeArgumentException(AsyncPipe, obj);
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_dispose',
	        value: function _dispose() {
	            this._strategy.dispose(this._subscription);
	            this._latestValue = null;
	            this._latestReturnedValue = null;
	            this._subscription = null;
	            this._obj = null;
	        }
	        /** @internal */

	    }, {
	        key: '_updateLatestValue',
	        value: function _updateLatestValue(async, value) {
	            if (async === this._obj) {
	                this._latestValue = value;
	                this._ref.markForCheck();
	            }
	        }
	    }]);
	    return AsyncPipe;
	}();
	/** @nocollapse */
	AsyncPipe.decorators = [{ type: Pipe, args: [{ name: 'async', pure: false }] }];
	/** @nocollapse */
	AsyncPipe.ctorParameters = [{ type: ChangeDetectorRef }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var NumberFormatStyle;
	(function (NumberFormatStyle) {
	    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
	    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
	    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
	})(NumberFormatStyle || (NumberFormatStyle = {}));
	var NumberFormatter = function () {
	    function NumberFormatter() {
	        classCallCheck(this, NumberFormatter);
	    }

	    createClass(NumberFormatter, null, [{
	        key: "format",
	        value: function format(num, locale, style) {
	            var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

	            var _ref$minimumIntegerDi = _ref.minimumIntegerDigits;
	            var minimumIntegerDigits = _ref$minimumIntegerDi === undefined ? 1 : _ref$minimumIntegerDi;
	            var _ref$minimumFractionD = _ref.minimumFractionDigits;
	            var minimumFractionDigits = _ref$minimumFractionD === undefined ? 0 : _ref$minimumFractionD;
	            var _ref$maximumFractionD = _ref.maximumFractionDigits;
	            var maximumFractionDigits = _ref$maximumFractionD === undefined ? 3 : _ref$maximumFractionD;
	            var currency = _ref.currency;
	            var _ref$currencyAsSymbol = _ref.currencyAsSymbol;
	            var currencyAsSymbol = _ref$currencyAsSymbol === undefined ? false : _ref$currencyAsSymbol;

	            var intlOptions = {
	                minimumIntegerDigits: minimumIntegerDigits,
	                minimumFractionDigits: minimumFractionDigits,
	                maximumFractionDigits: maximumFractionDigits
	            };
	            intlOptions.style = NumberFormatStyle[style].toLowerCase();
	            if (style == NumberFormatStyle.Currency) {
	                intlOptions.currency = currency;
	                intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
	            }
	            return new Intl.NumberFormat(locale, intlOptions).format(num);
	        }
	    }]);
	    return NumberFormatter;
	}();
	var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|Z|G+|w+))(.*)/;
	var PATTERN_ALIASES = {
	    yMMMdjms: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1), digitCondition('hour', 1), digitCondition('minute', 1), digitCondition('second', 1)])),
	    yMdjm: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1), digitCondition('hour', 1), digitCondition('minute', 1)])),
	    yMMMMEEEEd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4), digitCondition('day', 1)])),
	    yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
	    yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
	    yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
	    jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
	    jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
	};
	var DATE_FORMATS = {
	    yyyy: datePartGetterFactory(digitCondition('year', 4)),
	    yy: datePartGetterFactory(digitCondition('year', 2)),
	    y: datePartGetterFactory(digitCondition('year', 1)),
	    MMMM: datePartGetterFactory(nameCondition('month', 4)),
	    MMM: datePartGetterFactory(nameCondition('month', 3)),
	    MM: datePartGetterFactory(digitCondition('month', 2)),
	    M: datePartGetterFactory(digitCondition('month', 1)),
	    LLLL: datePartGetterFactory(nameCondition('month', 4)),
	    dd: datePartGetterFactory(digitCondition('day', 2)),
	    d: datePartGetterFactory(digitCondition('day', 1)),
	    HH: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false))),
	    H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
	    hh: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true))),
	    h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	    jj: datePartGetterFactory(digitCondition('hour', 2)),
	    j: datePartGetterFactory(digitCondition('hour', 1)),
	    mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
	    m: datePartGetterFactory(digitCondition('minute', 1)),
	    ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),
	    s: datePartGetterFactory(digitCondition('second', 1)),
	    // while ISO 8601 requires fractions to be prefixed with `.` or `,`
	    // we can be just safely rely on using `sss` since we currently don't support single or two digit
	    // fractions
	    sss: datePartGetterFactory(digitCondition('second', 3)),
	    EEEE: datePartGetterFactory(nameCondition('weekday', 4)),
	    EEE: datePartGetterFactory(nameCondition('weekday', 3)),
	    EE: datePartGetterFactory(nameCondition('weekday', 2)),
	    E: datePartGetterFactory(nameCondition('weekday', 1)),
	    a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	    Z: datePartGetterFactory({ timeZoneName: 'long' }),
	    z: datePartGetterFactory({ timeZoneName: 'short' }),
	    ww: datePartGetterFactory({}),
	    // first Thursday of the year. not support ?
	    w: datePartGetterFactory({}),
	    // of the year not support ?
	    G: datePartGetterFactory(nameCondition('era', 1)),
	    GG: datePartGetterFactory(nameCondition('era', 2)),
	    GGG: datePartGetterFactory(nameCondition('era', 3)),
	    GGGG: datePartGetterFactory(nameCondition('era', 4))
	};
	function digitModifier(inner) {
	    return function (date, locale) {
	        var result = inner(date, locale);
	        return result.length == 1 ? '0' + result : result;
	    };
	}
	function hourClockExtracter(inner) {
	    return function (date, locale) {
	        var result = inner(date, locale);
	        return result.split(' ')[1];
	    };
	}
	function hourExtracter(inner) {
	    return function (date, locale) {
	        var result = inner(date, locale);
	        return result.split(' ')[0];
	    };
	}
	function hour12Modify(options, value) {
	    options.hour12 = value;
	    return options;
	}
	function digitCondition(prop, len) {
	    var result = {};
	    result[prop] = len == 2 ? '2-digit' : 'numeric';
	    return result;
	}
	function nameCondition(prop, len) {
	    var result = {};
	    result[prop] = len < 4 ? 'short' : 'long';
	    return result;
	}
	function combine(options) {
	    var result = {};
	    options.forEach(function (option) {
	        Object.assign(result, option);
	    });
	    return result;
	}
	function datePartGetterFactory(ret) {
	    return function (date, locale) {
	        return new Intl.DateTimeFormat(locale, ret).format(date);
	    };
	}
	var datePartsFormatterCache = new Map();
	function dateFormatter(format, date, locale) {
	    var text = '';
	    var match;
	    var fn;
	    var parts = [];
	    if (PATTERN_ALIASES[format]) {
	        return PATTERN_ALIASES[format](date, locale);
	    }
	    if (datePartsFormatterCache.has(format)) {
	        parts = datePartsFormatterCache.get(format);
	    } else {
	        var matchs = DATE_FORMATS_SPLIT.exec(format);
	        while (format) {
	            match = DATE_FORMATS_SPLIT.exec(format);
	            if (match) {
	                parts = concat(parts, match, 1);
	                format = parts.pop();
	            } else {
	                parts.push(format);
	                format = null;
	            }
	        }
	        datePartsFormatterCache.set(format, parts);
	    }
	    parts.forEach(function (part) {
	        fn = DATE_FORMATS[part];
	        text += fn ? fn(date, locale) : part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
	    });
	    return text;
	}
	var slice = [].slice;
	function concat(array1 /** TODO #9100 */, array2 /** TODO #9100 */, index /** TODO #9100 */) {
	    return array1.concat(slice.call(array2, index));
	}
	var DateFormatter = function () {
	    function DateFormatter() {
	        classCallCheck(this, DateFormatter);
	    }

	    createClass(DateFormatter, null, [{
	        key: "format",
	        value: function format(date, locale, pattern) {
	            return dateFormatter(pattern, date, locale);
	        }
	    }]);
	    return DateFormatter;
	}();

	// TODO: move to a global configurable location along with other i18n components.
	var defaultLocale = 'en-US';
	var DatePipe = function () {
	    function DatePipe() {
	        classCallCheck(this, DatePipe);
	    }

	    createClass(DatePipe, [{
	        key: 'transform',
	        value: function transform(value) {
	            var pattern = arguments.length <= 1 || arguments[1] === undefined ? 'mediumDate' : arguments[1];

	            if (isBlank$1(value)) return null;
	            if (!this.supports(value)) {
	                throw new InvalidPipeArgumentException(DatePipe, value);
	            }
	            if (NumberWrapper$1.isNumeric(value)) {
	                value = DateWrapper$1.fromMillis(NumberWrapper$1.parseInt(value, 10));
	            } else if (isString$1(value)) {
	                value = DateWrapper$1.fromISOString(value);
	            }
	            if (StringMapWrapper$1.contains(DatePipe._ALIASES, pattern)) {
	                pattern = StringMapWrapper$1.get(DatePipe._ALIASES, pattern);
	            }
	            return DateFormatter.format(value, defaultLocale, pattern);
	        }
	    }, {
	        key: 'supports',
	        value: function supports(obj) {
	            if (isDate$1(obj) || NumberWrapper$1.isNumeric(obj)) {
	                return true;
	            }
	            if (isString$1(obj) && isDate$1(DateWrapper$1.fromISOString(obj))) {
	                return true;
	            }
	            return false;
	        }
	    }]);
	    return DatePipe;
	}();
	/** @internal */
	DatePipe._ALIASES = {
	    'medium': 'yMMMdjms',
	    'short': 'yMdjm',
	    'fullDate': 'yMMMMEEEEd',
	    'longDate': 'yMMMMd',
	    'mediumDate': 'yMMMd',
	    'shortDate': 'yMd',
	    'mediumTime': 'jms',
	    'shortTime': 'jm'
	};
	/** @nocollapse */
	DatePipe.decorators = [{ type: Pipe, args: [{ name: 'date', pure: true }] }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * @experimental
	 */
	var NgLocalization = function NgLocalization() {
	  classCallCheck(this, NgLocalization);
	};
	/**
	 * Returns the plural category for a given value.
	 * - "=value" when the case exists,
	 * - the plural category otherwise
	 *
	 * @internal
	 */
	function getPluralCategory(value, cases, ngLocalization) {
	  var nbCase = "=" + value;
	  return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);
	}

	var _INTERPOLATION_REGEXP = /#/g;
	var I18nPluralPipe = function () {
	    function I18nPluralPipe(_localization) {
	        classCallCheck(this, I18nPluralPipe);

	        this._localization = _localization;
	    }

	    createClass(I18nPluralPipe, [{
	        key: 'transform',
	        value: function transform(value, pluralMap) {
	            if (isBlank$1(value)) return '';
	            if (!isStringMap$1(pluralMap)) {
	                throw new InvalidPipeArgumentException(I18nPluralPipe, pluralMap);
	            }
	            var key = getPluralCategory(value, Object.getOwnPropertyNames(pluralMap), this._localization);
	            return StringWrapper$1.replaceAll(pluralMap[key], _INTERPOLATION_REGEXP, value.toString());
	        }
	    }]);
	    return I18nPluralPipe;
	}();
	/** @nocollapse */
	I18nPluralPipe.decorators = [{ type: Pipe, args: [{ name: 'i18nPlural', pure: true }] }];
	/** @nocollapse */
	I18nPluralPipe.ctorParameters = [{ type: NgLocalization }];

	var I18nSelectPipe = function () {
	    function I18nSelectPipe() {
	        classCallCheck(this, I18nSelectPipe);
	    }

	    createClass(I18nSelectPipe, [{
	        key: 'transform',
	        value: function transform(value, mapping) {
	            if (isBlank$1(value)) return '';
	            if (!isStringMap$1(mapping)) {
	                throw new InvalidPipeArgumentException(I18nSelectPipe, mapping);
	            }
	            return mapping.hasOwnProperty(value) ? mapping[value] : '';
	        }
	    }]);
	    return I18nSelectPipe;
	}();
	/** @nocollapse */
	I18nSelectPipe.decorators = [{ type: Pipe, args: [{ name: 'i18nSelect', pure: true }] }];

	var JsonPipe = function () {
	    function JsonPipe() {
	        classCallCheck(this, JsonPipe);
	    }

	    createClass(JsonPipe, [{
	        key: 'transform',
	        value: function transform(value) {
	            return Json$1.stringify(value);
	        }
	    }]);
	    return JsonPipe;
	}();
	/** @nocollapse */
	JsonPipe.decorators = [{ type: Pipe, args: [{ name: 'json', pure: false }] }];

	var LowerCasePipe = function () {
	    function LowerCasePipe() {
	        classCallCheck(this, LowerCasePipe);
	    }

	    createClass(LowerCasePipe, [{
	        key: 'transform',
	        value: function transform(value) {
	            if (isBlank$1(value)) return value;
	            if (!isString$1(value)) {
	                throw new InvalidPipeArgumentException(LowerCasePipe, value);
	            }
	            return value.toLowerCase();
	        }
	    }]);
	    return LowerCasePipe;
	}();
	/** @nocollapse */
	LowerCasePipe.decorators = [{ type: Pipe, args: [{ name: 'lowercase' }] }];

	var defaultLocale$1 = 'en-US';
	var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/g;
	/**
	 * Internal function to format numbers used by Decimal, Percent and Date pipes.
	 */
	function formatNumber(pipe, value, style, digits) {
	    var currency = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
	    var currencyAsSymbol = arguments.length <= 5 || arguments[5] === undefined ? false : arguments[5];

	    if (isBlank$1(value)) return null;
	    if (!isNumber$1(value)) {
	        throw new InvalidPipeArgumentException(pipe, value);
	    }
	    var minInt = 1,
	        minFraction = 0,
	        maxFraction = 3;
	    if (isPresent$1(digits)) {
	        var parts = RegExpWrapper$1.firstMatch(_NUMBER_FORMAT_REGEXP, digits);
	        if (isBlank$1(parts)) {
	            throw new BaseException$1(digits + ' is not a valid digit info for number pipes');
	        }
	        if (isPresent$1(parts[1])) {
	            minInt = NumberWrapper$1.parseIntAutoRadix(parts[1]);
	        }
	        if (isPresent$1(parts[3])) {
	            minFraction = NumberWrapper$1.parseIntAutoRadix(parts[3]);
	        }
	        if (isPresent$1(parts[5])) {
	            maxFraction = NumberWrapper$1.parseIntAutoRadix(parts[5]);
	        }
	    }
	    return NumberFormatter.format(value, defaultLocale$1, style, {
	        minimumIntegerDigits: minInt,
	        minimumFractionDigits: minFraction,
	        maximumFractionDigits: maxFraction,
	        currency: currency,
	        currencyAsSymbol: currencyAsSymbol
	    });
	}
	var DecimalPipe = function () {
	    function DecimalPipe() {
	        classCallCheck(this, DecimalPipe);
	    }

	    createClass(DecimalPipe, [{
	        key: 'transform',
	        value: function transform(value) {
	            var digits = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return formatNumber(DecimalPipe, value, NumberFormatStyle.Decimal, digits);
	        }
	    }]);
	    return DecimalPipe;
	}();
	/** @nocollapse */
	DecimalPipe.decorators = [{ type: Pipe, args: [{ name: 'number' }] }];
	var PercentPipe = function () {
	    function PercentPipe() {
	        classCallCheck(this, PercentPipe);
	    }

	    createClass(PercentPipe, [{
	        key: 'transform',
	        value: function transform(value) {
	            var digits = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return formatNumber(PercentPipe, value, NumberFormatStyle.Percent, digits);
	        }
	    }]);
	    return PercentPipe;
	}();
	/** @nocollapse */
	PercentPipe.decorators = [{ type: Pipe, args: [{ name: 'percent' }] }];
	var CurrencyPipe = function () {
	    function CurrencyPipe() {
	        classCallCheck(this, CurrencyPipe);
	    }

	    createClass(CurrencyPipe, [{
	        key: 'transform',
	        value: function transform(value) {
	            var currencyCode = arguments.length <= 1 || arguments[1] === undefined ? 'USD' : arguments[1];
	            var symbolDisplay = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	            var digits = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            return formatNumber(CurrencyPipe, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
	        }
	    }]);
	    return CurrencyPipe;
	}();
	/** @nocollapse */
	CurrencyPipe.decorators = [{ type: Pipe, args: [{ name: 'currency' }] }];

	var ReplacePipe = function () {
	    function ReplacePipe() {
	        classCallCheck(this, ReplacePipe);
	    }

	    createClass(ReplacePipe, [{
	        key: 'transform',
	        value: function transform(value, pattern, replacement) {
	            if (isBlank$1(value)) {
	                return value;
	            }
	            if (!this._supportedInput(value)) {
	                throw new InvalidPipeArgumentException(ReplacePipe, value);
	            }
	            var input = value.toString();
	            if (!this._supportedPattern(pattern)) {
	                throw new InvalidPipeArgumentException(ReplacePipe, pattern);
	            }
	            if (!this._supportedReplacement(replacement)) {
	                throw new InvalidPipeArgumentException(ReplacePipe, replacement);
	            }
	            if (isFunction$2(replacement)) {
	                var rgxPattern = isString$1(pattern) ? RegExpWrapper$1.create(pattern) : pattern;
	                return StringWrapper$1.replaceAllMapped(input, rgxPattern, replacement);
	            }
	            if (pattern instanceof RegExp) {
	                // use the replaceAll variant
	                return StringWrapper$1.replaceAll(input, pattern, replacement);
	            }
	            return StringWrapper$1.replace(input, pattern, replacement);
	        }
	    }, {
	        key: '_supportedInput',
	        value: function _supportedInput(input) {
	            return isString$1(input) || isNumber$1(input);
	        }
	    }, {
	        key: '_supportedPattern',
	        value: function _supportedPattern(pattern) {
	            return isString$1(pattern) || pattern instanceof RegExp;
	        }
	    }, {
	        key: '_supportedReplacement',
	        value: function _supportedReplacement(replacement) {
	            return isString$1(replacement) || isFunction$2(replacement);
	        }
	    }]);
	    return ReplacePipe;
	}();
	/** @nocollapse */
	ReplacePipe.decorators = [{ type: Pipe, args: [{ name: 'replace' }] }];

	var SlicePipe = function () {
	    function SlicePipe() {
	        classCallCheck(this, SlicePipe);
	    }

	    createClass(SlicePipe, [{
	        key: 'transform',
	        value: function transform(value, start) {
	            var end = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            if (isBlank$1(value)) return value;
	            if (!this.supports(value)) {
	                throw new InvalidPipeArgumentException(SlicePipe, value);
	            }
	            if (isString$1(value)) {
	                return StringWrapper$1.slice(value, start, end);
	            }
	            return ListWrapper$1.slice(value, start, end);
	        }
	    }, {
	        key: 'supports',
	        value: function supports(obj) {
	            return isString$1(obj) || isArray$2(obj);
	        }
	    }]);
	    return SlicePipe;
	}();
	/** @nocollapse */
	SlicePipe.decorators = [{ type: Pipe, args: [{ name: 'slice', pure: false }] }];

	var UpperCasePipe = function () {
	    function UpperCasePipe() {
	        classCallCheck(this, UpperCasePipe);
	    }

	    createClass(UpperCasePipe, [{
	        key: 'transform',
	        value: function transform(value) {
	            if (isBlank$1(value)) return value;
	            if (!isString$1(value)) {
	                throw new InvalidPipeArgumentException(UpperCasePipe, value);
	            }
	            return value.toUpperCase();
	        }
	    }]);
	    return UpperCasePipe;
	}();
	/** @nocollapse */
	UpperCasePipe.decorators = [{ type: Pipe, args: [{ name: 'uppercase' }] }];

	/**
	 * A collection of Angular core pipes that are likely to be used in each and every
	 * application.
	 *
	 * This collection can be used to quickly enumerate all the built-in pipes in the `pipes`
	 * property of the `@Component` decorator.
	 *
	 * @experimental Contains i18n pipes which are experimental
	 */
	var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, CurrencyPipe, DatePipe, ReplacePipe, I18nPluralPipe, I18nSelectPipe];

	var NgClass = function () {
	    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	        classCallCheck(this, NgClass);

	        this._iterableDiffers = _iterableDiffers;
	        this._keyValueDiffers = _keyValueDiffers;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	        this._initialClasses = [];
	    }

	    createClass(NgClass, [{
	        key: 'ngDoCheck',
	        value: function ngDoCheck() {
	            if (isPresent$1(this._iterableDiffer)) {
	                var changes = this._iterableDiffer.diff(this._rawClass);
	                if (isPresent$1(changes)) {
	                    this._applyIterableChanges(changes);
	                }
	            }
	            if (isPresent$1(this._keyValueDiffer)) {
	                var changes = this._keyValueDiffer.diff(this._rawClass);
	                if (isPresent$1(changes)) {
	                    this._applyKeyValueChanges(changes);
	                }
	            }
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this._cleanupClasses(this._rawClass);
	        }
	    }, {
	        key: '_cleanupClasses',
	        value: function _cleanupClasses(rawClassVal) {
	            this._applyClasses(rawClassVal, true);
	            this._applyInitialClasses(false);
	        }
	    }, {
	        key: '_applyKeyValueChanges',
	        value: function _applyKeyValueChanges(changes) {
	            var _this = this;

	            changes.forEachAddedItem(function (record) {
	                _this._toggleClass(record.key, record.currentValue);
	            });
	            changes.forEachChangedItem(function (record) {
	                _this._toggleClass(record.key, record.currentValue);
	            });
	            changes.forEachRemovedItem(function (record) {
	                if (record.previousValue) {
	                    _this._toggleClass(record.key, false);
	                }
	            });
	        }
	    }, {
	        key: '_applyIterableChanges',
	        value: function _applyIterableChanges(changes) {
	            var _this2 = this;

	            changes.forEachAddedItem(function (record) {
	                _this2._toggleClass(record.item, true);
	            });
	            changes.forEachRemovedItem(function (record) {
	                _this2._toggleClass(record.item, false);
	            });
	        }
	    }, {
	        key: '_applyInitialClasses',
	        value: function _applyInitialClasses(isCleanup) {
	            var _this3 = this;

	            this._initialClasses.forEach(function (className) {
	                return _this3._toggleClass(className, !isCleanup);
	            });
	        }
	    }, {
	        key: '_applyClasses',
	        value: function _applyClasses(rawClassVal, isCleanup) {
	            var _this4 = this;

	            if (isPresent$1(rawClassVal)) {
	                if (isArray$2(rawClassVal)) {
	                    rawClassVal.forEach(function (className) {
	                        return _this4._toggleClass(className, !isCleanup);
	                    });
	                } else if (rawClassVal instanceof Set) {
	                    rawClassVal.forEach(function (className) {
	                        return _this4._toggleClass(className, !isCleanup);
	                    });
	                } else {
	                    StringMapWrapper$1.forEach(rawClassVal, function (expVal, className) {
	                        if (isPresent$1(expVal)) _this4._toggleClass(className, !isCleanup);
	                    });
	                }
	            }
	        }
	    }, {
	        key: '_toggleClass',
	        value: function _toggleClass(className, enabled) {
	            className = className.trim();
	            if (className.length > 0) {
	                if (className.indexOf(' ') > -1) {
	                    var classes = className.split(/\s+/g);
	                    for (var i = 0, len = classes.length; i < len; i++) {
	                        this._renderer.setElementClass(this._ngEl.nativeElement, classes[i], enabled);
	                    }
	                } else {
	                    this._renderer.setElementClass(this._ngEl.nativeElement, className, enabled);
	                }
	            }
	        }
	    }, {
	        key: 'initialClasses',
	        set: function set(v) {
	            this._applyInitialClasses(true);
	            this._initialClasses = isPresent$1(v) && isString$1(v) ? v.split(' ') : [];
	            this._applyInitialClasses(false);
	            this._applyClasses(this._rawClass, false);
	        }
	    }, {
	        key: 'rawClass',
	        set: function set(v) {
	            this._cleanupClasses(this._rawClass);
	            if (isString$1(v)) {
	                v = v.split(' ');
	            }
	            this._rawClass = v;
	            this._iterableDiffer = null;
	            this._keyValueDiffer = null;
	            if (isPresent$1(v)) {
	                if (isListLikeIterable$1(v)) {
	                    this._iterableDiffer = this._iterableDiffers.find(v).create(null);
	                } else {
	                    this._keyValueDiffer = this._keyValueDiffers.find(v).create(null);
	                }
	            }
	        }
	    }]);
	    return NgClass;
	}();
	/** @nocollapse */
	NgClass.decorators = [{ type: Directive, args: [{ selector: '[ngClass]', inputs: ['rawClass: ngClass', 'initialClasses: class'] }] }];
	/** @nocollapse */
	NgClass.ctorParameters = [{ type: IterableDiffers }, { type: KeyValueDiffers }, { type: ElementRef }, { type: Renderer }];

	var NgForRow = function () {
	    function NgForRow($implicit, index, count) {
	        classCallCheck(this, NgForRow);

	        this.$implicit = $implicit;
	        this.index = index;
	        this.count = count;
	    }

	    createClass(NgForRow, [{
	        key: 'first',
	        get: function get() {
	            return this.index === 0;
	        }
	    }, {
	        key: 'last',
	        get: function get() {
	            return this.index === this.count - 1;
	        }
	    }, {
	        key: 'even',
	        get: function get() {
	            return this.index % 2 === 0;
	        }
	    }, {
	        key: 'odd',
	        get: function get() {
	            return !this.even;
	        }
	    }]);
	    return NgForRow;
	}();
	var NgFor = function () {
	    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
	        classCallCheck(this, NgFor);

	        this._viewContainer = _viewContainer;
	        this._templateRef = _templateRef;
	        this._iterableDiffers = _iterableDiffers;
	        this._cdr = _cdr;
	    }

	    createClass(NgFor, [{
	        key: 'ngDoCheck',
	        value: function ngDoCheck() {
	            if (isPresent$1(this._differ)) {
	                var changes = this._differ.diff(this._ngForOf);
	                if (isPresent$1(changes)) this._applyChanges(changes);
	            }
	        }
	    }, {
	        key: '_applyChanges',
	        value: function _applyChanges(changes) {
	            var _this = this;

	            // TODO(rado): check if change detection can produce a change record that is
	            // easier to consume than current.
	            var recordViewTuples = [];
	            changes.forEachRemovedItem(function (removedRecord) {
	                return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
	            });
	            changes.forEachMovedItem(function (movedRecord) {
	                return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
	            });
	            var insertTuples = this._bulkRemove(recordViewTuples);
	            changes.forEachAddedItem(function (addedRecord) {
	                return insertTuples.push(new RecordViewTuple(addedRecord, null));
	            });
	            this._bulkInsert(insertTuples);
	            for (var i = 0; i < insertTuples.length; i++) {
	                this._perViewChange(insertTuples[i].view, insertTuples[i].record);
	            }
	            for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
	                var viewRef = this._viewContainer.get(i);
	                viewRef.context.index = i;
	                viewRef.context.count = ilen;
	            }
	            changes.forEachIdentityChange(function (record /** TODO #9100 */) {
	                var viewRef = _this._viewContainer.get(record.currentIndex);
	                viewRef.context.$implicit = record.item;
	            });
	        }
	    }, {
	        key: '_perViewChange',
	        value: function _perViewChange(view, record) {
	            view.context.$implicit = record.item;
	        }
	    }, {
	        key: '_bulkRemove',
	        value: function _bulkRemove(tuples) {
	            tuples.sort(function (a, b) {
	                return a.record.previousIndex - b.record.previousIndex;
	            });
	            var movedTuples = [];
	            for (var i = tuples.length - 1; i >= 0; i--) {
	                var tuple = tuples[i];
	                // separate moved views from removed views.
	                if (isPresent$1(tuple.record.currentIndex)) {
	                    tuple.view = this._viewContainer.detach(tuple.record.previousIndex);
	                    movedTuples.push(tuple);
	                } else {
	                    this._viewContainer.remove(tuple.record.previousIndex);
	                }
	            }
	            return movedTuples;
	        }
	    }, {
	        key: '_bulkInsert',
	        value: function _bulkInsert(tuples) {
	            tuples.sort(function (a, b) {
	                return a.record.currentIndex - b.record.currentIndex;
	            });
	            for (var i = 0; i < tuples.length; i++) {
	                var tuple = tuples[i];
	                if (isPresent$1(tuple.view)) {
	                    this._viewContainer.insert(tuple.view, tuple.record.currentIndex);
	                } else {
	                    tuple.view = this._viewContainer.createEmbeddedView(this._templateRef, new NgForRow(null, null, null), tuple.record.currentIndex);
	                }
	            }
	            return tuples;
	        }
	    }, {
	        key: 'ngForOf',
	        set: function set(value) {
	            this._ngForOf = value;
	            if (isBlank$1(this._differ) && isPresent$1(value)) {
	                try {
	                    this._differ = this._iterableDiffers.find(value).create(this._cdr, this._ngForTrackBy);
	                } catch (e) {
	                    throw new BaseException$1('Cannot find a differ supporting object \'' + value + '\' of type \'' + getTypeNameForDebugging$1(value) + '\'. NgFor only supports binding to Iterables such as Arrays.');
	                }
	            }
	        }
	    }, {
	        key: 'ngForTemplate',
	        set: function set(value) {
	            if (isPresent$1(value)) {
	                this._templateRef = value;
	            }
	        }
	    }, {
	        key: 'ngForTrackBy',
	        set: function set(value) {
	            this._ngForTrackBy = value;
	        }
	    }]);
	    return NgFor;
	}();
	/** @nocollapse */
	NgFor.decorators = [{ type: Directive, args: [{ selector: '[ngFor][ngForOf]', inputs: ['ngForTrackBy', 'ngForOf', 'ngForTemplate'] }] }];
	/** @nocollapse */
	NgFor.ctorParameters = [{ type: ViewContainerRef }, { type: TemplateRef }, { type: IterableDiffers }, { type: ChangeDetectorRef }];

	var RecordViewTuple = function RecordViewTuple(record, view) {
	    classCallCheck(this, RecordViewTuple);

	    this.record = record;
	    this.view = view;
	};

	var NgIf = function () {
	    function NgIf(_viewContainer, _templateRef) {
	        classCallCheck(this, NgIf);

	        this._viewContainer = _viewContainer;
	        this._templateRef = _templateRef;
	        this._prevCondition = null;
	    }

	    createClass(NgIf, [{
	        key: 'ngIf',
	        set: function set(newCondition /* boolean */) {
	            if (newCondition && (isBlank$1(this._prevCondition) || !this._prevCondition)) {
	                this._prevCondition = true;
	                this._viewContainer.createEmbeddedView(this._templateRef);
	            } else if (!newCondition && (isBlank$1(this._prevCondition) || this._prevCondition)) {
	                this._prevCondition = false;
	                this._viewContainer.clear();
	            }
	        }
	    }]);
	    return NgIf;
	}();
	/** @nocollapse */
	NgIf.decorators = [{ type: Directive, args: [{ selector: '[ngIf]', inputs: ['ngIf'] }] }];
	/** @nocollapse */
	NgIf.ctorParameters = [{ type: ViewContainerRef }, { type: TemplateRef }];

	var _CASE_DEFAULT = new Object();
	// TODO: remove when fully deprecated
	var _warned = false;
	var SwitchView = function () {
	    function SwitchView(_viewContainerRef, _templateRef) {
	        classCallCheck(this, SwitchView);

	        this._viewContainerRef = _viewContainerRef;
	        this._templateRef = _templateRef;
	    }

	    createClass(SwitchView, [{
	        key: 'create',
	        value: function create() {
	            this._viewContainerRef.createEmbeddedView(this._templateRef);
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this._viewContainerRef.clear();
	        }
	    }]);
	    return SwitchView;
	}();
	var NgSwitch = function () {
	    function NgSwitch() {
	        classCallCheck(this, NgSwitch);

	        this._useDefault = false;
	        this._valueViews = new Map$2();
	        this._activeViews = [];
	    }

	    createClass(NgSwitch, [{
	        key: '_onCaseValueChanged',

	        /** @internal */
	        value: function _onCaseValueChanged(oldCase, newCase, view) {
	            this._deregisterView(oldCase, view);
	            this._registerView(newCase, view);
	            if (oldCase === this._switchValue) {
	                view.destroy();
	                ListWrapper$1.remove(this._activeViews, view);
	            } else if (newCase === this._switchValue) {
	                if (this._useDefault) {
	                    this._useDefault = false;
	                    this._emptyAllActiveViews();
	                }
	                view.create();
	                this._activeViews.push(view);
	            }
	            // Switch to default when there is no more active ViewContainers
	            if (this._activeViews.length === 0 && !this._useDefault) {
	                this._useDefault = true;
	                this._activateViews(this._valueViews.get(_CASE_DEFAULT));
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_emptyAllActiveViews',
	        value: function _emptyAllActiveViews() {
	            var activeContainers = this._activeViews;
	            for (var i = 0; i < activeContainers.length; i++) {
	                activeContainers[i].destroy();
	            }
	            this._activeViews = [];
	        }
	        /** @internal */

	    }, {
	        key: '_activateViews',
	        value: function _activateViews(views) {
	            // TODO(vicb): assert(this._activeViews.length === 0);
	            if (isPresent$1(views)) {
	                for (var i = 0; i < views.length; i++) {
	                    views[i].create();
	                }
	                this._activeViews = views;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_registerView',
	        value: function _registerView(value, view) {
	            var views = this._valueViews.get(value);
	            if (isBlank$1(views)) {
	                views = [];
	                this._valueViews.set(value, views);
	            }
	            views.push(view);
	        }
	        /** @internal */

	    }, {
	        key: '_deregisterView',
	        value: function _deregisterView(value, view) {
	            // `_CASE_DEFAULT` is used a marker for non-registered cases
	            if (value === _CASE_DEFAULT) return;
	            var views = this._valueViews.get(value);
	            if (views.length == 1) {
	                this._valueViews.delete(value);
	            } else {
	                ListWrapper$1.remove(views, view);
	            }
	        }
	    }, {
	        key: 'ngSwitch',
	        set: function set(value) {
	            // Empty the currently active ViewContainers
	            this._emptyAllActiveViews();
	            // Add the ViewContainers matching the value (with a fallback to default)
	            this._useDefault = false;
	            var views = this._valueViews.get(value);
	            if (isBlank$1(views)) {
	                this._useDefault = true;
	                views = normalizeBlank$1(this._valueViews.get(_CASE_DEFAULT));
	            }
	            this._activateViews(views);
	            this._switchValue = value;
	        }
	    }]);
	    return NgSwitch;
	}();
	/** @nocollapse */
	NgSwitch.decorators = [{ type: Directive, args: [{ selector: '[ngSwitch]', inputs: ['ngSwitch'] }] }];
	var NgSwitchCase = function () {
	    function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
	        classCallCheck(this, NgSwitchCase);

	        // `_CASE_DEFAULT` is used as a marker for a not yet initialized value
	        /** @internal */
	        this._value = _CASE_DEFAULT;
	        this._switch = ngSwitch;
	        this._view = new SwitchView(viewContainer, templateRef);
	    }

	    createClass(NgSwitchCase, [{
	        key: 'ngSwitchCase',
	        set: function set(value) {
	            this._switch._onCaseValueChanged(this._value, value, this._view);
	            this._value = value;
	        }
	    }, {
	        key: 'ngSwitchWhen',
	        set: function set(value) {
	            if (!_warned) {
	                _warned = true;
	                console.warn('*ngSwitchWhen is deprecated and will be removed. Use *ngSwitchCase instead');
	            }
	            this._switch._onCaseValueChanged(this._value, value, this._view);
	            this._value = value;
	        }
	    }]);
	    return NgSwitchCase;
	}();
	/** @nocollapse */
	NgSwitchCase.decorators = [{ type: Directive, args: [{ selector: '[ngSwitchCase],[ngSwitchWhen]', inputs: ['ngSwitchCase', 'ngSwitchWhen'] }] }];
	/** @nocollapse */
	NgSwitchCase.ctorParameters = [{ type: ViewContainerRef }, { type: TemplateRef }, { type: NgSwitch, decorators: [{ type: Host }] }];
	var NgSwitchDefault = function NgSwitchDefault(viewContainer, templateRef, sswitch) {
	    classCallCheck(this, NgSwitchDefault);

	    sswitch._registerView(_CASE_DEFAULT, new SwitchView(viewContainer, templateRef));
	};
	/** @nocollapse */
	NgSwitchDefault.decorators = [{ type: Directive, args: [{ selector: '[ngSwitchDefault]' }] }];
	/** @nocollapse */
	NgSwitchDefault.ctorParameters = [{ type: ViewContainerRef }, { type: TemplateRef }, { type: NgSwitch, decorators: [{ type: Host }] }];

	var NgPluralCase = function NgPluralCase(value, template, viewContainer) {
	    classCallCheck(this, NgPluralCase);

	    this.value = value;
	    this._view = new SwitchView(viewContainer, template);
	};
	/** @nocollapse */
	NgPluralCase.decorators = [{ type: Directive, args: [{ selector: '[ngPluralCase]' }] }];
	/** @nocollapse */
	NgPluralCase.ctorParameters = [{ type: undefined, decorators: [{ type: Attribute, args: ['ngPluralCase'] }] }, { type: TemplateRef }, { type: ViewContainerRef }];
	var NgPlural = function () {
	    function NgPlural(_localization) {
	        classCallCheck(this, NgPlural);

	        this._localization = _localization;
	        this._caseViews = {};
	        this.cases = null;
	    }

	    createClass(NgPlural, [{
	        key: 'ngAfterContentInit',
	        value: function ngAfterContentInit() {
	            var _this = this;

	            this.cases.forEach(function (pluralCase) {
	                _this._caseViews[pluralCase.value] = pluralCase._view;
	            });
	            this._updateView();
	        }
	        /** @internal */

	    }, {
	        key: '_updateView',
	        value: function _updateView() {
	            this._clearViews();
	            var key = getPluralCategory(this._switchValue, Object.getOwnPropertyNames(this._caseViews), this._localization);
	            this._activateView(this._caseViews[key]);
	        }
	        /** @internal */

	    }, {
	        key: '_clearViews',
	        value: function _clearViews() {
	            if (isPresent$1(this._activeView)) this._activeView.destroy();
	        }
	        /** @internal */

	    }, {
	        key: '_activateView',
	        value: function _activateView(view) {
	            if (!isPresent$1(view)) return;
	            this._activeView = view;
	            this._activeView.create();
	        }
	    }, {
	        key: 'ngPlural',
	        set: function set(value) {
	            this._switchValue = value;
	            this._updateView();
	        }
	    }]);
	    return NgPlural;
	}();
	/** @nocollapse */
	NgPlural.decorators = [{ type: Directive, args: [{ selector: '[ngPlural]' }] }];
	/** @nocollapse */
	NgPlural.ctorParameters = [{ type: NgLocalization }];
	/** @nocollapse */
	NgPlural.propDecorators = {
	    'cases': [{ type: ContentChildren, args: [NgPluralCase] }],
	    'ngPlural': [{ type: Input }]
	};

	var NgStyle = function () {
	    function NgStyle(_differs, _ngEl, _renderer) {
	        classCallCheck(this, NgStyle);

	        this._differs = _differs;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	    }

	    createClass(NgStyle, [{
	        key: 'ngDoCheck',
	        value: function ngDoCheck() {
	            if (isPresent$1(this._differ)) {
	                var changes = this._differ.diff(this._rawStyle);
	                if (isPresent$1(changes)) {
	                    this._applyChanges(changes);
	                }
	            }
	        }
	    }, {
	        key: '_applyChanges',
	        value: function _applyChanges(changes) {
	            var _this = this;

	            changes.forEachAddedItem(function (record) {
	                _this._setStyle(record.key, record.currentValue);
	            });
	            changes.forEachChangedItem(function (record) {
	                _this._setStyle(record.key, record.currentValue);
	            });
	            changes.forEachRemovedItem(function (record) {
	                _this._setStyle(record.key, null);
	            });
	        }
	    }, {
	        key: '_setStyle',
	        value: function _setStyle(name, val) {
	            this._renderer.setElementStyle(this._ngEl.nativeElement, name, val);
	        }
	    }, {
	        key: 'rawStyle',
	        set: function set(v) {
	            this._rawStyle = v;
	            if (isBlank$1(this._differ) && isPresent$1(v)) {
	                this._differ = this._differs.find(this._rawStyle).create(null);
	            }
	        }
	    }]);
	    return NgStyle;
	}();
	/** @nocollapse */
	NgStyle.decorators = [{ type: Directive, args: [{ selector: '[ngStyle]', inputs: ['rawStyle: ngStyle'] }] }];
	/** @nocollapse */
	NgStyle.ctorParameters = [{ type: KeyValueDiffers }, { type: ElementRef }, { type: Renderer }];

	var NgTemplateOutlet = function () {
	    function NgTemplateOutlet(_viewContainerRef) {
	        classCallCheck(this, NgTemplateOutlet);

	        this._viewContainerRef = _viewContainerRef;
	    }

	    createClass(NgTemplateOutlet, [{
	        key: 'createView',
	        value: function createView() {
	            if (isPresent$1(this._viewRef)) {
	                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
	            }
	            if (isPresent$1(this._templateRef)) {
	                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
	            }
	        }
	    }, {
	        key: 'ngOutletContext',
	        set: function set(context) {
	            if (this._context !== context) {
	                this._context = context;
	                if (isPresent$1(this._viewRef)) {
	                    this.createView();
	                }
	            }
	        }
	    }, {
	        key: 'ngTemplateOutlet',
	        set: function set(templateRef) {
	            if (this._templateRef !== templateRef) {
	                this._templateRef = templateRef;
	                this.createView();
	            }
	        }
	    }]);
	    return NgTemplateOutlet;
	}();
	/** @nocollapse */
	NgTemplateOutlet.decorators = [{ type: Directive, args: [{ selector: '[ngTemplateOutlet]' }] }];
	/** @nocollapse */
	NgTemplateOutlet.ctorParameters = [{ type: ViewContainerRef }];
	/** @nocollapse */
	NgTemplateOutlet.propDecorators = {
	    'ngOutletContext': [{ type: Input }],
	    'ngTemplateOutlet': [{ type: Input }]
	};

	/**
	 * A collection of Angular core directives that are likely to be used in each and every Angular
	 * application.
	 *
	 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
	 * property of the `@Component` annotation.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/yakGwpCdUkg0qfzX5m8g?p=preview))
	 *
	 * Instead of writing:
	 *
	 * ```typescript
	 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 * one could import all the core directives at once:
	 *
	 * ```typescript
	 * import {CORE_DIRECTIVES} from '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [CORE_DIRECTIVES, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 *
	 * @stable
	 */
	var CORE_DIRECTIVES = [NgClass, NgFor, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];

	/**
	 * Used to provide a {@link ControlValueAccessor} for form controls.
	 *
	 * See {@link DefaultValueAccessor} for how to implement one.
	 * @experimental
	 */
	var NG_VALUE_ACCESSOR =
	/*@ts2dart_const*/new OpaqueToken('NgValueAccessor');

	/**
	 * Base class for control directives.
	 *
	 * Only used internally in the forms module.
	 *
	 * @experimental
	 */
	var AbstractControlDirective = function () {
	  function AbstractControlDirective() {
	    classCallCheck(this, AbstractControlDirective);
	  }

	  createClass(AbstractControlDirective, [{
	    key: 'control',
	    get: function get() {
	      return unimplemented$1();
	    }
	  }, {
	    key: 'value',
	    get: function get() {
	      return isPresent$1(this.control) ? this.control.value : null;
	    }
	  }, {
	    key: 'valid',
	    get: function get() {
	      return isPresent$1(this.control) ? this.control.valid : null;
	    }
	  }, {
	    key: 'errors',
	    get: function get() {
	      return isPresent$1(this.control) ? this.control.errors : null;
	    }
	  }, {
	    key: 'pristine',
	    get: function get() {
	      return isPresent$1(this.control) ? this.control.pristine : null;
	    }
	  }, {
	    key: 'dirty',
	    get: function get() {
	      return isPresent$1(this.control) ? this.control.dirty : null;
	    }
	  }, {
	    key: 'touched',
	    get: function get() {
	      return isPresent$1(this.control) ? this.control.touched : null;
	    }
	  }, {
	    key: 'untouched',
	    get: function get() {
	      return isPresent$1(this.control) ? this.control.untouched : null;
	    }
	  }, {
	    key: 'path',
	    get: function get() {
	      return null;
	    }
	  }]);
	  return AbstractControlDirective;
	}();

	/**
	 * A base class that all control directive extend.
	 * It binds a {@link Control} object to a DOM element.
	 *
	 * Used internally by Angular forms.
	 *
	 * @experimental
	 */
	var NgControl = function (_AbstractControlDirec) {
	  inherits(NgControl, _AbstractControlDirec);

	  function NgControl() {
	    var _Object$getPrototypeO;

	    classCallCheck(this, NgControl);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var _this = possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(NgControl)).call.apply(_Object$getPrototypeO, [this].concat(args)));

	    _this.name = null;
	    _this.valueAccessor = null;
	    return _this;
	  }

	  createClass(NgControl, [{
	    key: 'validator',
	    get: function get() {
	      return unimplemented$1();
	    }
	  }, {
	    key: 'asyncValidator',
	    get: function get() {
	      return unimplemented$1();
	    }
	  }]);
	  return NgControl;
	}(AbstractControlDirective);

	var RADIO_VALUE_ACCESSOR = {
	    provide: NG_VALUE_ACCESSOR,
	    useExisting: forwardRef(function () {
	        return RadioControlValueAccessor;
	    }),
	    multi: true
	};
	var RadioControlRegistry = function () {
	    function RadioControlRegistry() {
	        classCallCheck(this, RadioControlRegistry);

	        this._accessors = [];
	    }

	    createClass(RadioControlRegistry, [{
	        key: 'add',
	        value: function add(control, accessor) {
	            this._accessors.push([control, accessor]);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(accessor) {
	            var indexToRemove = -1;
	            for (var i = 0; i < this._accessors.length; ++i) {
	                if (this._accessors[i][1] === accessor) {
	                    indexToRemove = i;
	                }
	            }
	            ListWrapper$1.removeAt(this._accessors, indexToRemove);
	        }
	    }, {
	        key: 'select',
	        value: function select(accessor) {
	            var _this = this;

	            this._accessors.forEach(function (c) {
	                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                    c[1].fireUncheck();
	                }
	            });
	        }
	    }, {
	        key: '_isSameGroup',
	        value: function _isSameGroup(controlPair, accessor) {
	            return controlPair[0].control.root === accessor._control.control.root && controlPair[1].name === accessor.name;
	        }
	    }]);
	    return RadioControlRegistry;
	}();
	/** @nocollapse */
	RadioControlRegistry.decorators = [{ type: Injectable }];
	/**
	 * The value provided by the forms API for radio buttons.
	 *
	 * @experimental
	 */
	var RadioButtonState = function RadioButtonState(checked, value) {
	    classCallCheck(this, RadioButtonState);

	    this.checked = checked;
	    this.value = value;
	};
	var RadioControlValueAccessor = function () {
	    function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	        classCallCheck(this, RadioControlValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._registry = _registry;
	        this._injector = _injector;
	        this.onChange = function () {};
	        this.onTouched = function () {};
	    }

	    createClass(RadioControlValueAccessor, [{
	        key: 'ngOnInit',
	        value: function ngOnInit() {
	            this._control = this._injector.get(NgControl);
	            this._registry.add(this._control, this);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this._registry.remove(this);
	        }
	    }, {
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this._state = value;
	            if (isPresent$1(value) && value.checked) {
	                this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', true);
	            }
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            var _this2 = this;

	            this._fn = fn;
	            this.onChange = function () {
	                fn(new RadioButtonState(true, _this2._state.value));
	                _this2._registry.select(_this2);
	            };
	        }
	    }, {
	        key: 'fireUncheck',
	        value: function fireUncheck() {
	            this._fn(new RadioButtonState(false, this._state.value));
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }]);
	    return RadioControlValueAccessor;
	}();
	/** @nocollapse */
	RadioControlValueAccessor.decorators = [{ type: Directive, args: [{
	        selector: 'input[type=radio][ngControl],input[type=radio][ngFormControl],input[type=radio][ngModel]',
	        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	        providers: [RADIO_VALUE_ACCESSOR]
	    }] }];
	/** @nocollapse */
	RadioControlValueAccessor.ctorParameters = [{ type: Renderer }, { type: ElementRef }, { type: RadioControlRegistry }, { type: Injector }];
	/** @nocollapse */
	RadioControlValueAccessor.propDecorators = {
	    'name': [{ type: Input }]
	};

	/**
	 * Indicates that a Control is valid, i.e. that no errors exist in the input value.
	 */
	var VALID = 'VALID';
	/**
	 * Indicates that a Control is invalid, i.e. that an error exists in the input value.
	 */
	var INVALID = 'INVALID';
	/**
	 * Indicates that a Control is pending, i.e. that async validation is occurring and
	 * errors are not yet available for the input value.
	 */
	var PENDING = 'PENDING';
	function _find(control, path) {
	    if (isBlank$1(path)) return null;
	    if (!(path instanceof Array)) {
	        path = path.split('/');
	    }
	    if (path instanceof Array && ListWrapper$1.isEmpty(path)) return null;
	    return path.reduce(function (v, name) {
	        if (v instanceof ControlGroup) {
	            return isPresent$1(v.controls[name]) ? v.controls[name] : null;
	        } else if (v instanceof ControlArray) {
	            var index = name;
	            return isPresent$1(v.at(index)) ? v.at(index) : null;
	        } else {
	            return null;
	        }
	    }, control);
	}
	function toObservable(r) {
	    return isPromise$1(r) ? ObservableWrapper$1.fromPromise(r) : r;
	}
	/**
	 * @experimental
	 */
	var AbstractControl = function () {
	    function AbstractControl(validator, asyncValidator) {
	        classCallCheck(this, AbstractControl);

	        this.validator = validator;
	        this.asyncValidator = asyncValidator;
	        this._pristine = true;
	        this._touched = false;
	    }

	    createClass(AbstractControl, [{
	        key: 'markAsTouched',
	        value: function markAsTouched() {
	            this._touched = true;
	        }
	    }, {
	        key: 'markAsDirty',
	        value: function markAsDirty() {
	            var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var onlySelf = _ref.onlySelf;

	            onlySelf = normalizeBool$1(onlySelf);
	            this._pristine = false;
	            if (isPresent$1(this._parent) && !onlySelf) {
	                this._parent.markAsDirty({ onlySelf: onlySelf });
	            }
	        }
	    }, {
	        key: 'markAsPending',
	        value: function markAsPending() {
	            var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var onlySelf = _ref2.onlySelf;

	            onlySelf = normalizeBool$1(onlySelf);
	            this._status = PENDING;
	            if (isPresent$1(this._parent) && !onlySelf) {
	                this._parent.markAsPending({ onlySelf: onlySelf });
	            }
	        }
	    }, {
	        key: 'setParent',
	        value: function setParent(parent) {
	            this._parent = parent;
	        }
	    }, {
	        key: 'updateValueAndValidity',
	        value: function updateValueAndValidity() {
	            var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var onlySelf = _ref3.onlySelf;
	            var emitEvent = _ref3.emitEvent;

	            onlySelf = normalizeBool$1(onlySelf);
	            emitEvent = isPresent$1(emitEvent) ? emitEvent : true;
	            this._updateValue();
	            this._errors = this._runValidator();
	            this._status = this._calculateStatus();
	            if (this._status == VALID || this._status == PENDING) {
	                this._runAsyncValidator(emitEvent);
	            }
	            if (emitEvent) {
	                ObservableWrapper$1.callEmit(this._valueChanges, this._value);
	                ObservableWrapper$1.callEmit(this._statusChanges, this._status);
	            }
	            if (isPresent$1(this._parent) && !onlySelf) {
	                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            }
	        }
	    }, {
	        key: '_runValidator',
	        value: function _runValidator() {
	            return isPresent$1(this.validator) ? this.validator(this) : null;
	        }
	    }, {
	        key: '_runAsyncValidator',
	        value: function _runAsyncValidator(emitEvent) {
	            var _this = this;

	            if (isPresent$1(this.asyncValidator)) {
	                this._status = PENDING;
	                this._cancelExistingSubscription();
	                var obs = toObservable(this.asyncValidator(this));
	                this._asyncValidationSubscription = ObservableWrapper$1.subscribe(obs, function (res) {
	                    return _this.setErrors(res, { emitEvent: emitEvent });
	                });
	            }
	        }
	    }, {
	        key: '_cancelExistingSubscription',
	        value: function _cancelExistingSubscription() {
	            if (isPresent$1(this._asyncValidationSubscription)) {
	                ObservableWrapper$1.dispose(this._asyncValidationSubscription);
	            }
	        }
	        /**
	         * Sets errors on a control.
	         *
	         * This is used when validations are run not automatically, but manually by the user.
	         *
	         * Calling `setErrors` will also update the validity of the parent control.
	         *
	         * ## Usage
	         *
	         * ```
	         * var login = new Control("someLogin");
	         * login.setErrors({
	         *   "notUnique": true
	         * });
	         *
	         * expect(login.valid).toEqual(false);
	         * expect(login.errors).toEqual({"notUnique": true});
	         *
	         * login.updateValue("someOtherLogin");
	         *
	         * expect(login.valid).toEqual(true);
	         * ```
	         */

	    }, {
	        key: 'setErrors',
	        value: function setErrors(errors) {
	            var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	            var emitEvent = _ref4.emitEvent;

	            emitEvent = isPresent$1(emitEvent) ? emitEvent : true;
	            this._errors = errors;
	            this._status = this._calculateStatus();
	            if (emitEvent) {
	                ObservableWrapper$1.callEmit(this._statusChanges, this._status);
	            }
	            if (isPresent$1(this._parent)) {
	                this._parent._updateControlsErrors();
	            }
	        }
	    }, {
	        key: 'find',
	        value: function find(path) {
	            return _find(this, path);
	        }
	    }, {
	        key: 'getError',
	        value: function getError(errorCode) {
	            var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var control = isPresent$1(path) && !ListWrapper$1.isEmpty(path) ? this.find(path) : this;
	            if (isPresent$1(control) && isPresent$1(control._errors)) {
	                return StringMapWrapper$1.get(control._errors, errorCode);
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'hasError',
	        value: function hasError(errorCode) {
	            var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return isPresent$1(this.getError(errorCode, path));
	        }
	    }, {
	        key: '_updateControlsErrors',

	        /** @internal */
	        value: function _updateControlsErrors() {
	            this._status = this._calculateStatus();
	            if (isPresent$1(this._parent)) {
	                this._parent._updateControlsErrors();
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_initObservables',
	        value: function _initObservables() {
	            this._valueChanges = new EventEmitter$1();
	            this._statusChanges = new EventEmitter$1();
	        }
	    }, {
	        key: '_calculateStatus',
	        value: function _calculateStatus() {
	            if (isPresent$1(this._errors)) return INVALID;
	            if (this._anyControlsHaveStatus(PENDING)) return PENDING;
	            if (this._anyControlsHaveStatus(INVALID)) return INVALID;
	            return VALID;
	        }
	    }, {
	        key: 'value',
	        get: function get() {
	            return this._value;
	        }
	    }, {
	        key: 'status',
	        get: function get() {
	            return this._status;
	        }
	    }, {
	        key: 'valid',
	        get: function get() {
	            return this._status === VALID;
	        }
	        /**
	         * Returns the errors of this control.
	         */

	    }, {
	        key: 'errors',
	        get: function get() {
	            return this._errors;
	        }
	    }, {
	        key: 'pristine',
	        get: function get() {
	            return this._pristine;
	        }
	    }, {
	        key: 'dirty',
	        get: function get() {
	            return !this.pristine;
	        }
	    }, {
	        key: 'touched',
	        get: function get() {
	            return this._touched;
	        }
	    }, {
	        key: 'untouched',
	        get: function get() {
	            return !this._touched;
	        }
	    }, {
	        key: 'valueChanges',
	        get: function get() {
	            return this._valueChanges;
	        }
	    }, {
	        key: 'statusChanges',
	        get: function get() {
	            return this._statusChanges;
	        }
	    }, {
	        key: 'pending',
	        get: function get() {
	            return this._status == PENDING;
	        }
	    }, {
	        key: 'root',
	        get: function get() {
	            var x = this;
	            while (isPresent$1(x._parent)) {
	                x = x._parent;
	            }
	            return x;
	        }
	    }]);
	    return AbstractControl;
	}();
	/**
	 * Defines a part of a form that cannot be divided into other controls. `Control`s have values and
	 * validation state, which is determined by an optional validation function.
	 *
	 * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
	 * with {@link ControlGroup} and {@link ControlArray}.
	 *
	 * ## Usage
	 *
	 * By default, a `Control` is created for every `<input>` or other form component.
	 * With {@link NgFormControl} or {@link NgFormModel} an existing {@link Control} can be
	 * bound to a DOM element instead. This `Control` can be configured with a custom
	 * validation function.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var Control = function (_AbstractControl) {
	    inherits(Control, _AbstractControl);

	    function Control() {
	        var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, Control);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(Control).call(this, validator, asyncValidator));

	        _this2._value = value;
	        _this2.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        _this2._initObservables();
	        return _this2;
	    }
	    /**
	     * Set the value of the control to `value`.
	     *
	     * If `onlySelf` is `true`, this change will only affect the validation of this `Control`
	     * and not its parent component. If `emitEvent` is `true`, this change will cause a
	     * `valueChanges` event on the `Control` to be emitted. Both of these options default to
	     * `false`.
	     *
	     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	     * specified.
	     */


	    createClass(Control, [{
	        key: 'updateValue',
	        value: function updateValue(value) {
	            var _ref5 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	            var onlySelf = _ref5.onlySelf;
	            var emitEvent = _ref5.emitEvent;
	            var emitModelToViewChange = _ref5.emitModelToViewChange;

	            emitModelToViewChange = isPresent$1(emitModelToViewChange) ? emitModelToViewChange : true;
	            this._value = value;
	            if (isPresent$1(this._onChange) && emitModelToViewChange) this._onChange(this._value);
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        }
	        /**
	         * @internal
	         */

	    }, {
	        key: '_updateValue',
	        value: function _updateValue() {}
	        /**
	         * @internal
	         */

	    }, {
	        key: '_anyControlsHaveStatus',
	        value: function _anyControlsHaveStatus(status) {
	            return false;
	        }
	        /**
	         * Register a listener for change events.
	         */

	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this._onChange = fn;
	        }
	    }]);
	    return Control;
	}(AbstractControl);
	/**
	 * Defines a part of a form, of fixed length, that can contain other controls.
	 *
	 * A `ControlGroup` aggregates the values of each {@link Control} in the group.
	 * The status of a `ControlGroup` depends on the status of its children.
	 * If one of the controls in a group is invalid, the entire group is invalid.
	 * Similarly, if a control changes its value, the entire group changes as well.
	 *
	 * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other
	 * controls, but is of variable length.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var ControlGroup = function (_AbstractControl2) {
	    inherits(ControlGroup, _AbstractControl2);

	    function ControlGroup(controls) {
	        var optionals = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var validator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        var asyncValidator = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, ControlGroup);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(ControlGroup).call(this, validator, asyncValidator));

	        _this3.controls = controls;
	        _this3._optionals = isPresent$1(optionals) ? optionals : {};
	        _this3._initObservables();
	        _this3._setParentForControls();
	        _this3.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        return _this3;
	    }
	    /**
	     * Register a control with the group's list of controls.
	     */


	    createClass(ControlGroup, [{
	        key: 'registerControl',
	        value: function registerControl(name, control) {
	            this.controls[name] = control;
	            control.setParent(this);
	        }
	        /**
	         * Add a control to this group.
	         */

	    }, {
	        key: 'addControl',
	        value: function addControl(name, control) {
	            this.registerControl(name, control);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Remove a control from this group.
	         */

	    }, {
	        key: 'removeControl',
	        value: function removeControl(name) {
	            StringMapWrapper$1.delete(this.controls, name);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Mark the named control as non-optional.
	         */

	    }, {
	        key: 'include',
	        value: function include(controlName) {
	            StringMapWrapper$1.set(this._optionals, controlName, true);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Mark the named control as optional.
	         */

	    }, {
	        key: 'exclude',
	        value: function exclude(controlName) {
	            StringMapWrapper$1.set(this._optionals, controlName, false);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Check whether there is a control with the given name in the group.
	         */

	    }, {
	        key: 'contains',
	        value: function contains(controlName) {
	            var c = StringMapWrapper$1.contains(this.controls, controlName);
	            return c && this._included(controlName);
	        }
	        /** @internal */

	    }, {
	        key: '_setParentForControls',
	        value: function _setParentForControls() {
	            var _this4 = this;

	            StringMapWrapper$1.forEach(this.controls, function (control, name) {
	                control.setParent(_this4);
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_updateValue',
	        value: function _updateValue() {
	            this._value = this._reduceValue();
	        }
	        /** @internal */

	    }, {
	        key: '_anyControlsHaveStatus',
	        value: function _anyControlsHaveStatus(status) {
	            var _this5 = this;

	            var res = false;
	            StringMapWrapper$1.forEach(this.controls, function (control, name) {
	                res = res || _this5.contains(name) && control.status == status;
	            });
	            return res;
	        }
	        /** @internal */

	    }, {
	        key: '_reduceValue',
	        value: function _reduceValue() {
	            return this._reduceChildren({}, function (acc, control, name) {
	                acc[name] = control.value;
	                return acc;
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_reduceChildren',
	        value: function _reduceChildren(initValue, fn) {
	            var _this6 = this;

	            var res = initValue;
	            StringMapWrapper$1.forEach(this.controls, function (control, name) {
	                if (_this6._included(name)) {
	                    res = fn(res, control, name);
	                }
	            });
	            return res;
	        }
	        /** @internal */

	    }, {
	        key: '_included',
	        value: function _included(controlName) {
	            var isOptional = StringMapWrapper$1.contains(this._optionals, controlName);
	            return !isOptional || StringMapWrapper$1.get(this._optionals, controlName);
	        }
	    }]);
	    return ControlGroup;
	}(AbstractControl);
	/**
	 * Defines a part of a form, of variable length, that can contain other controls.
	 *
	 * A `ControlArray` aggregates the values of each {@link Control} in the group.
	 * The status of a `ControlArray` depends on the status of its children.
	 * If one of the controls in a group is invalid, the entire array is invalid.
	 * Similarly, if a control changes its value, the entire array changes as well.
	 *
	 * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
	 * other controls, but is of fixed length.
	 *
	 * ## Adding or removing controls
	 *
	 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	 * in `ControlArray` itself. These methods ensure the controls are properly tracked in the
	 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	 * the `ControlArray` directly, as that will result in strange and unexpected behavior such
	 * as broken change detection.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var ControlArray = function (_AbstractControl3) {
	    inherits(ControlArray, _AbstractControl3);

	    function ControlArray(controls) {
	        var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, ControlArray);

	        var _this7 = possibleConstructorReturn(this, Object.getPrototypeOf(ControlArray).call(this, validator, asyncValidator));

	        _this7.controls = controls;
	        _this7._initObservables();
	        _this7._setParentForControls();
	        _this7.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        return _this7;
	    }
	    /**
	     * Get the {@link AbstractControl} at the given `index` in the array.
	     */


	    createClass(ControlArray, [{
	        key: 'at',
	        value: function at(index) {
	            return this.controls[index];
	        }
	        /**
	         * Insert a new {@link AbstractControl} at the end of the array.
	         */

	    }, {
	        key: 'push',
	        value: function push(control) {
	            this.controls.push(control);
	            control.setParent(this);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Insert a new {@link AbstractControl} at the given `index` in the array.
	         */

	    }, {
	        key: 'insert',
	        value: function insert(index, control) {
	            ListWrapper$1.insert(this.controls, index, control);
	            control.setParent(this);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Remove the control at the given `index` in the array.
	         */

	    }, {
	        key: 'removeAt',
	        value: function removeAt(index) {
	            ListWrapper$1.removeAt(this.controls, index);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Length of the control array.
	         */

	    }, {
	        key: '_updateValue',

	        /** @internal */
	        value: function _updateValue() {
	            this._value = this.controls.map(function (control) {
	                return control.value;
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_anyControlsHaveStatus',
	        value: function _anyControlsHaveStatus(status) {
	            return this.controls.some(function (c) {
	                return c.status == status;
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_setParentForControls',
	        value: function _setParentForControls() {
	            var _this8 = this;

	            this.controls.forEach(function (control) {
	                control.setParent(_this8);
	            });
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            return this.controls.length;
	        }
	    }]);
	    return ControlArray;
	}(AbstractControl);

	var FormBuilder = function () {
	    function FormBuilder() {
	        classCallCheck(this, FormBuilder);
	    }

	    createClass(FormBuilder, [{
	        key: 'group',

	        /**
	         * Construct a new {@link ControlGroup} with the given map of configuration.
	         * Valid keys for the `extra` parameter map are `optionals` and `validator`.
	         *
	         * See the {@link ControlGroup} constructor for more details.
	         */
	        value: function group(controlsConfig) {
	            var extra = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var controls = this._reduceControls(controlsConfig);
	            var optionals = isPresent$1(extra) ? StringMapWrapper$1.get(extra, 'optionals') : null;
	            var validator = isPresent$1(extra) ? StringMapWrapper$1.get(extra, 'validator') : null;
	            var asyncValidator = isPresent$1(extra) ? StringMapWrapper$1.get(extra, 'asyncValidator') : null;
	            return new ControlGroup(controls, optionals, validator, asyncValidator);
	        }
	        /**
	         * Construct a new {@link Control} with the given `value`,`validator`, and `asyncValidator`.
	         */

	    }, {
	        key: 'control',
	        value: function control(value) {
	            var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return new Control(value, validator, asyncValidator);
	        }
	        /**
	         * Construct an array of {@link Control}s from the given `controlsConfig` array of
	         * configuration, with the given optional `validator` and `asyncValidator`.
	         */

	    }, {
	        key: 'array',
	        value: function array(controlsConfig) {
	            var _this = this;

	            var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var controls = controlsConfig.map(function (c) {
	                return _this._createControl(c);
	            });
	            return new ControlArray(controls, validator, asyncValidator);
	        }
	        /** @internal */

	    }, {
	        key: '_reduceControls',
	        value: function _reduceControls(controlsConfig) {
	            var _this2 = this;

	            var controls = {};
	            StringMapWrapper$1.forEach(controlsConfig, function (controlConfig, controlName) {
	                controls[controlName] = _this2._createControl(controlConfig);
	            });
	            return controls;
	        }
	        /** @internal */

	    }, {
	        key: '_createControl',
	        value: function _createControl(controlConfig) {
	            if (controlConfig instanceof Control || controlConfig instanceof ControlGroup || controlConfig instanceof ControlArray) {
	                return controlConfig;
	            } else if (isArray$2(controlConfig)) {
	                var value = controlConfig[0];
	                var validator = controlConfig.length > 1 ? controlConfig[1] : null;
	                var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	                return this.control(value, validator, asyncValidator);
	            } else {
	                return this.control(controlConfig);
	            }
	        }
	    }]);
	    return FormBuilder;
	}();
	/** @nocollapse */
	FormBuilder.decorators = [{ type: Injectable }];

	var CHECKBOX_VALUE_ACCESSOR = {
	    provide: NG_VALUE_ACCESSOR,
	    useExisting: forwardRef(function () {
	        return CheckboxControlValueAccessor;
	    }),
	    multi: true
	};
	var CheckboxControlValueAccessor = function () {
	    function CheckboxControlValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, CheckboxControlValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(CheckboxControlValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this.onChange = fn;
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }]);
	    return CheckboxControlValueAccessor;
	}();
	/** @nocollapse */
	CheckboxControlValueAccessor.decorators = [{ type: Directive, args: [{
	        selector: 'input[type=checkbox][ngControl],input[type=checkbox][ngFormControl],input[type=checkbox][ngModel]',
	        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	        providers: [CHECKBOX_VALUE_ACCESSOR]
	    }] }];
	/** @nocollapse */
	CheckboxControlValueAccessor.ctorParameters = [{ type: Renderer }, { type: ElementRef }];

	var DEFAULT_VALUE_ACCESSOR =
	/* @ts2dart_Provider */{
	    provide: NG_VALUE_ACCESSOR,
	    useExisting: forwardRef(function () {
	        return DefaultValueAccessor;
	    }),
	    multi: true
	};
	var DefaultValueAccessor = function () {
	    function DefaultValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, DefaultValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(DefaultValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            var normalizedValue = isBlank$1(value) ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this.onChange = fn;
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }]);
	    return DefaultValueAccessor;
	}();
	/** @nocollapse */
	DefaultValueAccessor.decorators = [{ type: Directive, args: [{
	        selector: 'input:not([type=checkbox])[ngControl],textarea[ngControl],input:not([type=checkbox])[ngFormControl],textarea[ngFormControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	        // TODO: vsavkin replace the above selector with the one below it once
	        // https://github.com/angular/angular/issues/3011 is implemented
	        // selector: '[ngControl],[ngModel],[ngFormControl]',
	        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	        providers: [DEFAULT_VALUE_ACCESSOR]
	    }] }];
	/** @nocollapse */
	DefaultValueAccessor.ctorParameters = [{ type: Renderer }, { type: ElementRef }];

	/**
	 * Providers for validators to be used for {@link Control}s in a form.
	 *
	 * Provide this using `multi: true` to add validators.
	 *
	 * ### Example
	 *
	 * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	 * @experimental
	 */
	var NG_VALIDATORS = new OpaqueToken('NgValidators');
	/**
	 * Providers for asynchronous validators to be used for {@link Control}s
	 * in a form.
	 *
	 * Provide this using `multi: true` to add validators.
	 *
	 * See {@link NG_VALIDATORS} for more details.
	 *
	 * @experimental
	 */
	var NG_ASYNC_VALIDATORS =
	/*@ts2dart_const*/new OpaqueToken('NgAsyncValidators');
	/**
	 * Provides a set of validators used by form controls.
	 *
	 * A validator is a function that processes a {@link Control} or collection of
	 * controls and returns a map of errors. A null map means that validation has passed.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * var loginControl = new Control("", Validators.required)
	 * ```
	 *
	 * @experimental
	 */

	var Validators = function () {
	    function Validators() {
	        classCallCheck(this, Validators);
	    }

	    createClass(Validators, null, [{
	        key: 'required',

	        /**
	         * Validator that requires controls to have a non-empty value.
	         */
	        value: function required(control) {
	            return isBlank$1(control.value) || isString$1(control.value) && control.value == '' ? { 'required': true } : null;
	        }
	        /**
	         * Validator that requires controls to have a value of a minimum length.
	         */

	    }, {
	        key: 'minLength',
	        value: function minLength(_minLength) {
	            return function (control) {
	                if (isPresent$1(Validators.required(control))) return null;
	                var v = control.value;
	                return v.length < _minLength ? { 'minlength': { 'requiredLength': _minLength, 'actualLength': v.length } } : null;
	            };
	        }
	        /**
	         * Validator that requires controls to have a value of a maximum length.
	         */

	    }, {
	        key: 'maxLength',
	        value: function maxLength(_maxLength) {
	            return function (control) {
	                if (isPresent$1(Validators.required(control))) return null;
	                var v = control.value;
	                return v.length > _maxLength ? { 'maxlength': { 'requiredLength': _maxLength, 'actualLength': v.length } } : null;
	            };
	        }
	        /**
	         * Validator that requires a control to match a regex to its value.
	         */

	    }, {
	        key: 'pattern',
	        value: function pattern(_pattern) {
	            return function (control) {
	                if (isPresent$1(Validators.required(control))) return null;
	                var regex = new RegExp('^' + _pattern + '$');
	                var v = control.value;
	                return regex.test(v) ? null : { 'pattern': { 'requiredPattern': '^' + _pattern + '$', 'actualValue': v } };
	            };
	        }
	        /**
	         * No-op validator.
	         */

	    }, {
	        key: 'nullValidator',
	        value: function nullValidator(c) {
	            return null;
	        }
	        /**
	         * Compose multiple validators into a single function that returns the union
	         * of the individual error maps.
	         */

	    }, {
	        key: 'compose',
	        value: function compose(validators) {
	            if (isBlank$1(validators)) return null;
	            var presentValidators = validators.filter(isPresent$1);
	            if (presentValidators.length == 0) return null;
	            return function (control) {
	                return _mergeErrors(_executeValidators(control, presentValidators));
	            };
	        }
	    }, {
	        key: 'composeAsync',
	        value: function composeAsync(validators) {
	            if (isBlank$1(validators)) return null;
	            var presentValidators = validators.filter(isPresent$1);
	            if (presentValidators.length == 0) return null;
	            return function (control) {
	                var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);
	                return PromiseWrapper$1.all(promises).then(_mergeErrors);
	            };
	        }
	    }]);
	    return Validators;
	}();

	function _convertToPromise(obj) {
	    return isPromise$1(obj) ? obj : ObservableWrapper$1.toPromise(obj);
	}
	function _executeValidators(control, validators) {
	    return validators.map(function (v) {
	        return v(control);
	    });
	}
	function _executeAsyncValidators(control, validators) {
	    return validators.map(function (v) {
	        return v(control);
	    });
	}
	function _mergeErrors(arrayOfErrors) {
	    var res = arrayOfErrors.reduce(function (res, errors) {
	        return isPresent$1(errors) ? StringMapWrapper$1.merge(res, errors) : res;
	    }, {});
	    return StringMapWrapper$1.isEmpty(res) ? null : res;
	}

	/**
	 * A directive that contains multiple {@link NgControl}s.
	 *
	 * Only used by the forms module.
	 *
	 * @experimental
	 */
	var ControlContainer = function (_AbstractControlDirec) {
	  inherits(ControlContainer, _AbstractControlDirec);

	  function ControlContainer() {
	    classCallCheck(this, ControlContainer);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(ControlContainer).apply(this, arguments));
	  }

	  createClass(ControlContainer, [{
	    key: 'formDirective',

	    /**
	     * Get the form to which this container belongs.
	     */
	    get: function get() {
	      return null;
	    }
	    /**
	     * Get the path to this container.
	     */

	  }, {
	    key: 'path',
	    get: function get() {
	      return null;
	    }
	  }]);
	  return ControlContainer;
	}(AbstractControlDirective);

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	function normalizeValidator(validator) {
	    if (validator.validate !== undefined) {
	        return function (c) {
	            return validator.validate(c);
	        };
	    } else {
	        return validator;
	    }
	}
	function normalizeAsyncValidator(validator) {
	    if (validator.validate !== undefined) {
	        return function (c) {
	            return validator.validate(c);
	        };
	    } else {
	        return validator;
	    }
	}

	var NUMBER_VALUE_ACCESSOR = {
	    provide: NG_VALUE_ACCESSOR,
	    useExisting: forwardRef(function () {
	        return NumberValueAccessor;
	    }),
	    multi: true
	};
	var NumberValueAccessor = function () {
	    function NumberValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, NumberValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(NumberValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this.onChange = function (value) {
	                fn(value == '' ? null : NumberWrapper$1.parseFloat(value));
	            };
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }]);
	    return NumberValueAccessor;
	}();
	/** @nocollapse */
	NumberValueAccessor.decorators = [{ type: Directive, args: [{
	        selector: 'input[type=number][ngControl],input[type=number][ngFormControl],input[type=number][ngModel]',
	        host: {
	            '(change)': 'onChange($event.target.value)',
	            '(input)': 'onChange($event.target.value)',
	            '(blur)': 'onTouched()'
	        },
	        providers: [NUMBER_VALUE_ACCESSOR]
	    }] }];
	/** @nocollapse */
	NumberValueAccessor.ctorParameters = [{ type: Renderer }, { type: ElementRef }];

	var SELECT_VALUE_ACCESSOR = {
	    provide: NG_VALUE_ACCESSOR,
	    useExisting: forwardRef(function () {
	        return SelectControlValueAccessor;
	    }),
	    multi: true
	};
	function _buildValueString(id, value) {
	    if (isBlank$1(id)) return '' + value;
	    if (!isPrimitive$1(value)) value = 'Object';
	    return StringWrapper$1.slice(id + ': ' + value, 0, 50);
	}
	function _extractId(valueString) {
	    return valueString.split(':')[0];
	}
	var SelectControlValueAccessor = function () {
	    function SelectControlValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, SelectControlValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        /** @internal */
	        this._optionMap = new Map();
	        /** @internal */
	        this._idCounter = 0;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(SelectControlValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this.value = value;
	            var valueString = _buildValueString(this._getOptionId(value), value);
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            var _this = this;

	            this.onChange = function (valueString) {
	                _this.value = valueString;
	                fn(_this._getOptionValue(valueString));
	            };
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	        /** @internal */

	    }, {
	        key: '_registerOption',
	        value: function _registerOption() {
	            return (this._idCounter++).toString();
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionId',
	        value: function _getOptionId(value) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = MapWrapper$1.keys(this._optionMap)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var id = _step.value;

	                    if (looseIdentical$1(this._optionMap.get(id), value)) return id;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }

	            return null;
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionValue',
	        value: function _getOptionValue(valueString) {
	            var value = this._optionMap.get(_extractId(valueString));
	            return isPresent$1(value) ? value : valueString;
	        }
	    }]);
	    return SelectControlValueAccessor;
	}();
	/** @nocollapse */
	SelectControlValueAccessor.decorators = [{ type: Directive, args: [{
	        selector: 'select:not([multiple])[ngControl],select:not([multiple])[ngFormControl],select:not([multiple])[ngModel]',
	        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	        providers: [SELECT_VALUE_ACCESSOR]
	    }] }];
	/** @nocollapse */
	SelectControlValueAccessor.ctorParameters = [{ type: Renderer }, { type: ElementRef }];
	var NgSelectOption = function () {
	    function NgSelectOption(_element, _renderer, _select) {
	        classCallCheck(this, NgSelectOption);

	        this._element = _element;
	        this._renderer = _renderer;
	        this._select = _select;
	        if (isPresent$1(this._select)) this.id = this._select._registerOption();
	    }

	    createClass(NgSelectOption, [{
	        key: '_setElementValue',

	        /** @internal */
	        value: function _setElementValue(value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            if (isPresent$1(this._select)) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        }
	    }, {
	        key: 'ngValue',
	        set: function set(value) {
	            if (this._select == null) return;
	            this._select._optionMap.set(this.id, value);
	            this._setElementValue(_buildValueString(this.id, value));
	            this._select.writeValue(this._select.value);
	        }
	    }, {
	        key: 'value',
	        set: function set(value) {
	            this._setElementValue(value);
	            if (isPresent$1(this._select)) this._select.writeValue(this._select.value);
	        }
	    }]);
	    return NgSelectOption;
	}();
	/** @nocollapse */
	NgSelectOption.decorators = [{ type: Directive, args: [{ selector: 'option' }] }];
	/** @nocollapse */
	NgSelectOption.ctorParameters = [{ type: ElementRef }, { type: Renderer }, { type: SelectControlValueAccessor, decorators: [{ type: Optional }, { type: Host }] }];
	/** @nocollapse */
	NgSelectOption.propDecorators = {
	    'ngValue': [{ type: Input, args: ['ngValue'] }],
	    'value': [{ type: Input, args: ['value'] }]
	};

	var SELECT_MULTIPLE_VALUE_ACCESSOR = {
	    provide: NG_VALUE_ACCESSOR,
	    useExisting: forwardRef(function () {
	        return SelectMultipleControlValueAccessor;
	    }),
	    multi: true
	};
	function _buildValueString$1(id, value) {
	    if (isBlank$1(id)) return '' + value;
	    if (isString$1(value)) value = '\'' + value + '\'';
	    if (!isPrimitive$1(value)) value = 'Object';
	    return StringWrapper$1.slice(id + ': ' + value, 0, 50);
	}
	function _extractId$1(valueString) {
	    return valueString.split(':')[0];
	}
	var SelectMultipleControlValueAccessor = function () {
	    function SelectMultipleControlValueAccessor() {
	        classCallCheck(this, SelectMultipleControlValueAccessor);

	        /** @internal */
	        this._optionMap = new Map();
	        /** @internal */
	        this._idCounter = 0;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(SelectMultipleControlValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            var _this = this;

	            this.value = value;
	            if (value == null) return;
	            var values = value;
	            // convert values to ids
	            var ids = values.map(function (v) {
	                return _this._getOptionId(v);
	            });
	            this._optionMap.forEach(function (opt, o) {
	                opt._setSelected(ids.indexOf(o.toString()) > -1);
	            });
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            var _this2 = this;

	            this.onChange = function (_) {
	                var selected = [];
	                if (_.hasOwnProperty('selectedOptions')) {
	                    var options = _.selectedOptions;
	                    for (var i = 0; i < options.length; i++) {
	                        var opt = options.item(i);
	                        var val = _this2._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                } else {
	                    var _options = _.options;
	                    for (var i = 0; i < _options.length; i++) {
	                        var _opt = _options.item(i);
	                        if (_opt.selected) {
	                            var _val = _this2._getOptionValue(_opt.value);
	                            selected.push(_val);
	                        }
	                    }
	                }
	                fn(selected);
	            };
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	        /** @internal */

	    }, {
	        key: '_registerOption',
	        value: function _registerOption(value) {
	            var id = (this._idCounter++).toString();
	            this._optionMap.set(id, value);
	            return id;
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionId',
	        value: function _getOptionId(value) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = MapWrapper$1.keys(this._optionMap)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var id = _step.value;

	                    if (looseIdentical$1(this._optionMap.get(id)._value, value)) return id;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }

	            return null;
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionValue',
	        value: function _getOptionValue(valueString) {
	            var opt = this._optionMap.get(_extractId$1(valueString));
	            return isPresent$1(opt) ? opt._value : valueString;
	        }
	    }]);
	    return SelectMultipleControlValueAccessor;
	}();
	/** @nocollapse */
	SelectMultipleControlValueAccessor.decorators = [{ type: Directive, args: [{
	        selector: 'select[multiple][ngControl],select[multiple][ngFormControl],select[multiple][ngModel]',
	        host: { '(input)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
	    }] }];
	/** @nocollapse */
	SelectMultipleControlValueAccessor.ctorParameters = [];
	var NgSelectMultipleOption = function () {
	    function NgSelectMultipleOption(_element, _renderer, _select) {
	        classCallCheck(this, NgSelectMultipleOption);

	        this._element = _element;
	        this._renderer = _renderer;
	        this._select = _select;
	        if (isPresent$1(this._select)) {
	            this.id = this._select._registerOption(this);
	        }
	    }

	    createClass(NgSelectMultipleOption, [{
	        key: '_setElementValue',

	        /** @internal */
	        value: function _setElementValue(value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        }
	        /** @internal */

	    }, {
	        key: '_setSelected',
	        value: function _setSelected(selected) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            if (isPresent$1(this._select)) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        }
	    }, {
	        key: 'ngValue',
	        set: function set(value) {
	            if (this._select == null) return;
	            this._value = value;
	            this._setElementValue(_buildValueString$1(this.id, value));
	            this._select.writeValue(this._select.value);
	        }
	    }, {
	        key: 'value',
	        set: function set(value) {
	            if (isPresent$1(this._select)) {
	                this._value = value;
	                this._setElementValue(_buildValueString$1(this.id, value));
	                this._select.writeValue(this._select.value);
	            } else {
	                this._setElementValue(value);
	            }
	        }
	    }]);
	    return NgSelectMultipleOption;
	}();
	/** @nocollapse */
	NgSelectMultipleOption.decorators = [{ type: Directive, args: [{ selector: 'option' }] }];
	/** @nocollapse */
	NgSelectMultipleOption.ctorParameters = [{ type: ElementRef }, { type: Renderer }, { type: SelectMultipleControlValueAccessor, decorators: [{ type: Optional }, { type: Host }] }];
	/** @nocollapse */
	NgSelectMultipleOption.propDecorators = {
	    'ngValue': [{ type: Input, args: ['ngValue'] }],
	    'value': [{ type: Input, args: ['value'] }]
	};

	function controlPath(name, parent) {
	    var p = ListWrapper$1.clone(parent.path);
	    p.push(name);
	    return p;
	}
	function setUpControl(control, dir) {
	    if (isBlank$1(control)) _throwError(dir, 'Cannot find control');
	    if (isBlank$1(dir.valueAccessor)) _throwError(dir, 'No value accessor for');
	    control.validator = Validators.compose([control.validator, dir.validator]);
	    control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    dir.valueAccessor.writeValue(control.value);
	    // view -> model
	    dir.valueAccessor.registerOnChange(function (newValue) {
	        dir.viewToModelUpdate(newValue);
	        control.updateValue(newValue, { emitModelToViewChange: false });
	        control.markAsDirty();
	    });
	    // model -> view
	    control.registerOnChange(function (newValue) {
	        return dir.valueAccessor.writeValue(newValue);
	    });
	    // touched
	    dir.valueAccessor.registerOnTouched(function () {
	        return control.markAsTouched();
	    });
	}
	function setUpControlGroup(control, dir) {
	    if (isBlank$1(control)) _throwError(dir, 'Cannot find control');
	    control.validator = Validators.compose([control.validator, dir.validator]);
	    control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);
	}
	function _throwError(dir, message) {
	    var path = dir.path.join(' -> ');
	    throw new BaseException$1(message + ' \'' + path + '\'');
	}
	function composeValidators(validators) {
	    return isPresent$1(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;
	}
	function composeAsyncValidators(validators) {
	    return isPresent$1(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) : null;
	}
	function isPropertyUpdated(changes, viewModel) {
	    if (!StringMapWrapper$1.contains(changes, 'model')) return false;
	    var change = changes['model'];
	    if (change.isFirstChange()) return true;
	    return !looseIdentical$1(viewModel, change.currentValue);
	}
	// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
	function selectValueAccessor(dir, valueAccessors) {
	    if (isBlank$1(valueAccessors)) return null;
	    var defaultAccessor;
	    var builtinAccessor;
	    var customAccessor;
	    valueAccessors.forEach(function (v) {
	        if (hasConstructor$1(v, DefaultValueAccessor)) {
	            defaultAccessor = v;
	        } else if (hasConstructor$1(v, CheckboxControlValueAccessor) || hasConstructor$1(v, NumberValueAccessor) || hasConstructor$1(v, SelectControlValueAccessor) || hasConstructor$1(v, SelectMultipleControlValueAccessor) || hasConstructor$1(v, RadioControlValueAccessor)) {
	            if (isPresent$1(builtinAccessor)) _throwError(dir, 'More than one built-in value accessor matches');
	            builtinAccessor = v;
	        } else {
	            if (isPresent$1(customAccessor)) _throwError(dir, 'More than one custom value accessor matches');
	            customAccessor = v;
	        }
	    });
	    if (isPresent$1(customAccessor)) return customAccessor;
	    if (isPresent$1(builtinAccessor)) return builtinAccessor;
	    if (isPresent$1(defaultAccessor)) return defaultAccessor;
	    _throwError(dir, 'No valid value accessor for');
	    return null;
	}

	var controlGroupProvider =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: ControlContainer,
	    useExisting: forwardRef(function () {
	        return NgControlGroup;
	    })
	};
	var NgControlGroup = function (_ControlContainer) {
	    inherits(NgControlGroup, _ControlContainer);

	    function NgControlGroup(parent, _validators, _asyncValidators) {
	        classCallCheck(this, NgControlGroup);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgControlGroup).call(this));

	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        _this._parent = parent;
	        return _this;
	    }

	    createClass(NgControlGroup, [{
	        key: 'ngOnInit',
	        value: function ngOnInit() {
	            this.formDirective.addControlGroup(this);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this.formDirective.removeControlGroup(this);
	        }
	        /**
	         * Get the {@link ControlGroup} backing this binding.
	         */

	    }, {
	        key: 'control',
	        get: function get() {
	            return this.formDirective.getControlGroup(this);
	        }
	        /**
	         * Get the path to this control group.
	         */

	    }, {
	        key: 'path',
	        get: function get() {
	            return controlPath(this.name, this._parent);
	        }
	        /**
	         * Get the {@link Form} to which this group belongs.
	         */

	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this._parent.formDirective;
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators(this._asyncValidators);
	        }
	    }]);
	    return NgControlGroup;
	}(ControlContainer);
	/** @nocollapse */
	NgControlGroup.decorators = [{ type: Directive, args: [{
	        selector: '[ngControlGroup]',
	        providers: [controlGroupProvider],
	        inputs: ['name: ngControlGroup'],
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	NgControlGroup.ctorParameters = [{ type: ControlContainer, decorators: [{ type: Host }, { type: SkipSelf }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS] }] }];

	var controlNameBinding =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: NgControl,
	    useExisting: forwardRef(function () {
	        return NgControlName;
	    })
	};
	var NgControlName = function (_NgControl) {
	    inherits(NgControlName, _NgControl);

	    function NgControlName(_parent, _validators, _asyncValidators, valueAccessors) {
	        classCallCheck(this, NgControlName);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgControlName).call(this));

	        _this._parent = _parent;
	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        /** @internal */
	        _this.update = new EventEmitter$1();
	        _this._added = false;
	        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);
	        return _this;
	    }

	    createClass(NgControlName, [{
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            if (!this._added) {
	                this.formDirective.addControl(this);
	                this._added = true;
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.viewModel = this.model;
	                this.formDirective.updateModel(this, this.model);
	            }
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this.formDirective.removeControl(this);
	        }
	    }, {
	        key: 'viewToModelUpdate',
	        value: function viewToModelUpdate(newValue) {
	            this.viewModel = newValue;
	            ObservableWrapper$1.callEmit(this.update, newValue);
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return controlPath(this.name, this._parent);
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this._parent.formDirective;
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators(this._asyncValidators);
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.formDirective.getControl(this);
	        }
	    }]);
	    return NgControlName;
	}(NgControl);
	/** @nocollapse */
	NgControlName.decorators = [{ type: Directive, args: [{
	        selector: '[ngControl]',
	        providers: [controlNameBinding],
	        inputs: ['name: ngControl', 'model: ngModel'],
	        outputs: ['update: ngModelChange'],
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	NgControlName.ctorParameters = [{ type: ControlContainer, decorators: [{ type: Host }, { type: SkipSelf }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR] }] }];

	var NgControlStatus = function () {
	    function NgControlStatus(cd) {
	        classCallCheck(this, NgControlStatus);

	        this._cd = cd;
	    }

	    createClass(NgControlStatus, [{
	        key: 'ngClassUntouched',
	        get: function get() {
	            return isPresent$1(this._cd.control) ? this._cd.control.untouched : false;
	        }
	    }, {
	        key: 'ngClassTouched',
	        get: function get() {
	            return isPresent$1(this._cd.control) ? this._cd.control.touched : false;
	        }
	    }, {
	        key: 'ngClassPristine',
	        get: function get() {
	            return isPresent$1(this._cd.control) ? this._cd.control.pristine : false;
	        }
	    }, {
	        key: 'ngClassDirty',
	        get: function get() {
	            return isPresent$1(this._cd.control) ? this._cd.control.dirty : false;
	        }
	    }, {
	        key: 'ngClassValid',
	        get: function get() {
	            return isPresent$1(this._cd.control) ? this._cd.control.valid : false;
	        }
	    }, {
	        key: 'ngClassInvalid',
	        get: function get() {
	            return isPresent$1(this._cd.control) ? !this._cd.control.valid : false;
	        }
	    }]);
	    return NgControlStatus;
	}();
	/** @nocollapse */
	NgControlStatus.decorators = [{ type: Directive, args: [{
	        selector: '[ngControl],[ngModel],[ngFormControl]',
	        host: {
	            '[class.ng-untouched]': 'ngClassUntouched',
	            '[class.ng-touched]': 'ngClassTouched',
	            '[class.ng-pristine]': 'ngClassPristine',
	            '[class.ng-dirty]': 'ngClassDirty',
	            '[class.ng-valid]': 'ngClassValid',
	            '[class.ng-invalid]': 'ngClassInvalid'
	        }
	    }] }];
	/** @nocollapse */
	NgControlStatus.ctorParameters = [{ type: NgControl, decorators: [{ type: Self }] }];

	var formDirectiveProvider =
	/*@ts2dart_const*/{ provide: ControlContainer, useExisting: forwardRef(function () {
	        return NgForm;
	    }) };
	var _formWarningDisplayed = false;
	var NgForm = function (_ControlContainer) {
	    inherits(NgForm, _ControlContainer);

	    function NgForm(validators, asyncValidators) {
	        classCallCheck(this, NgForm);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgForm).call(this));

	        _this._submitted = false;
	        _this.ngSubmit = new EventEmitter$1();
	        _this._displayWarning();
	        _this.form = new ControlGroup({}, null, composeValidators(validators), composeAsyncValidators(asyncValidators));
	        return _this;
	    }

	    createClass(NgForm, [{
	        key: '_displayWarning',
	        value: function _displayWarning() {
	            // TODO(kara): Update this when the new forms module becomes the default
	            if (!_formWarningDisplayed) {
	                _formWarningDisplayed = true;
	                console.warn('\n      *It looks like you\'re using the old forms module. This will be opt-in in the next RC, and\n      will eventually be removed in favor of the new forms module. For more information, see:\n      https://docs.google.com/document/u/1/d/1RIezQqE4aEhBRmArIAS1mRIZtWFf6JxN_7B4meyWK0Y/pub\n    ');
	            }
	        }
	    }, {
	        key: 'addControl',
	        value: function addControl(dir) {
	            var _this2 = this;

	            PromiseWrapper$1.scheduleMicrotask(function () {
	                var container = _this2._findContainer(dir.path);
	                var ctrl = new Control();
	                setUpControl(ctrl, dir);
	                container.registerControl(dir.name, ctrl);
	                ctrl.updateValueAndValidity({ emitEvent: false });
	            });
	        }
	    }, {
	        key: 'getControl',
	        value: function getControl(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'removeControl',
	        value: function removeControl(dir) {
	            var _this3 = this;

	            PromiseWrapper$1.scheduleMicrotask(function () {
	                var container = _this3._findContainer(dir.path);
	                if (isPresent$1(container)) {
	                    container.removeControl(dir.name);
	                }
	            });
	        }
	    }, {
	        key: 'addControlGroup',
	        value: function addControlGroup(dir) {
	            var _this4 = this;

	            PromiseWrapper$1.scheduleMicrotask(function () {
	                var container = _this4._findContainer(dir.path);
	                var group = new ControlGroup({});
	                setUpControlGroup(group, dir);
	                container.registerControl(dir.name, group);
	                group.updateValueAndValidity({ emitEvent: false });
	            });
	        }
	    }, {
	        key: 'removeControlGroup',
	        value: function removeControlGroup(dir) {
	            var _this5 = this;

	            PromiseWrapper$1.scheduleMicrotask(function () {
	                var container = _this5._findContainer(dir.path);
	                if (isPresent$1(container)) {
	                    container.removeControl(dir.name);
	                }
	            });
	        }
	    }, {
	        key: 'getControlGroup',
	        value: function getControlGroup(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'updateModel',
	        value: function updateModel(dir, value) {
	            var _this6 = this;

	            PromiseWrapper$1.scheduleMicrotask(function () {
	                var ctrl = _this6.form.find(dir.path);
	                ctrl.updateValue(value);
	            });
	        }
	    }, {
	        key: 'onSubmit',
	        value: function onSubmit() {
	            this._submitted = true;
	            ObservableWrapper$1.callEmit(this.ngSubmit, null);
	            return false;
	        }
	        /** @internal */

	    }, {
	        key: '_findContainer',
	        value: function _findContainer(path) {
	            path.pop();
	            return ListWrapper$1.isEmpty(path) ? this.form : this.form.find(path);
	        }
	    }, {
	        key: 'submitted',
	        get: function get() {
	            return this._submitted;
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this;
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.form;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return [];
	        }
	    }, {
	        key: 'controls',
	        get: function get() {
	            return this.form.controls;
	        }
	    }]);
	    return NgForm;
	}(ControlContainer);
	/** @nocollapse */
	NgForm.decorators = [{ type: Directive, args: [{
	        selector: 'form:not([ngNoForm]):not([ngFormModel]),ngForm,[ngForm]',
	        providers: [formDirectiveProvider],
	        host: {
	            '(submit)': 'onSubmit()'
	        },
	        outputs: ['ngSubmit'],
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	NgForm.ctorParameters = [{ type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS] }] }];

	var formControlBinding =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: NgControl,
	    useExisting: forwardRef(function () {
	        return NgFormControl;
	    })
	};
	var NgFormControl = function (_NgControl) {
	    inherits(NgFormControl, _NgControl);

	    function NgFormControl(_validators, _asyncValidators, valueAccessors) {
	        classCallCheck(this, NgFormControl);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgFormControl).call(this));

	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        _this.update = new EventEmitter$1();
	        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);
	        return _this;
	    }

	    createClass(NgFormControl, [{
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            if (this._isControlChanged(changes)) {
	                setUpControl(this.form, this);
	                this.form.updateValueAndValidity({ emitEvent: false });
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this.form.updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        }
	    }, {
	        key: 'viewToModelUpdate',
	        value: function viewToModelUpdate(newValue) {
	            this.viewModel = newValue;
	            ObservableWrapper$1.callEmit(this.update, newValue);
	        }
	    }, {
	        key: '_isControlChanged',
	        value: function _isControlChanged(changes) {
	            return StringMapWrapper$1.contains(changes, 'form');
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return [];
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators(this._asyncValidators);
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.form;
	        }
	    }]);
	    return NgFormControl;
	}(NgControl);
	/** @nocollapse */
	NgFormControl.decorators = [{ type: Directive, args: [{
	        selector: '[ngFormControl]',
	        providers: [formControlBinding],
	        inputs: ['form: ngFormControl', 'model: ngModel'],
	        outputs: ['update: ngModelChange'],
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	NgFormControl.ctorParameters = [{ type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR] }] }];

	var formDirectiveProvider$1 =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: ControlContainer,
	    useExisting: forwardRef(function () {
	        return NgFormModel;
	    })
	};
	var _formModelWarningDisplayed = false;
	var NgFormModel = function (_ControlContainer) {
	    inherits(NgFormModel, _ControlContainer);

	    function NgFormModel(_validators, _asyncValidators) {
	        classCallCheck(this, NgFormModel);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgFormModel).call(this));

	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        _this._submitted = false;
	        _this.form = null;
	        _this.directives = [];
	        _this.ngSubmit = new EventEmitter$1();
	        _this._displayWarning();
	        return _this;
	    }

	    createClass(NgFormModel, [{
	        key: '_displayWarning',
	        value: function _displayWarning() {
	            // TODO(kara): Update this when the new forms module becomes the default
	            if (!_formModelWarningDisplayed) {
	                _formModelWarningDisplayed = true;
	                console.warn('\n      *It looks like you\'re using the old forms module. This will be opt-in in the next RC, and\n      will eventually be removed in favor of the new forms module. For more information, see:\n      https://docs.google.com/document/u/1/d/1RIezQqE4aEhBRmArIAS1mRIZtWFf6JxN_7B4meyWK0Y/pub\n    ');
	            }
	        }
	    }, {
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            this._checkFormPresent();
	            if (StringMapWrapper$1.contains(changes, 'form')) {
	                var sync = composeValidators(this._validators);
	                this.form.validator = Validators.compose([this.form.validator, sync]);
	                var async = composeAsyncValidators(this._asyncValidators);
	                this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);
	                this.form.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	            }
	            this._updateDomValue();
	        }
	    }, {
	        key: 'addControl',
	        value: function addControl(dir) {
	            var ctrl = this.form.find(dir.path);
	            setUpControl(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	            this.directives.push(dir);
	        }
	    }, {
	        key: 'getControl',
	        value: function getControl(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'removeControl',
	        value: function removeControl(dir) {
	            ListWrapper$1.remove(this.directives, dir);
	        }
	    }, {
	        key: 'addControlGroup',
	        value: function addControlGroup(dir) {
	            var ctrl = this.form.find(dir.path);
	            setUpControlGroup(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        }
	    }, {
	        key: 'removeControlGroup',
	        value: function removeControlGroup(dir) {}
	    }, {
	        key: 'getControlGroup',
	        value: function getControlGroup(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'updateModel',
	        value: function updateModel(dir, value) {
	            var ctrl = this.form.find(dir.path);
	            ctrl.updateValue(value);
	        }
	    }, {
	        key: 'onSubmit',
	        value: function onSubmit() {
	            this._submitted = true;
	            ObservableWrapper$1.callEmit(this.ngSubmit, null);
	            return false;
	        }
	        /** @internal */

	    }, {
	        key: '_updateDomValue',
	        value: function _updateDomValue() {
	            var _this2 = this;

	            this.directives.forEach(function (dir) {
	                var ctrl = _this2.form.find(dir.path);
	                dir.valueAccessor.writeValue(ctrl.value);
	            });
	        }
	    }, {
	        key: '_checkFormPresent',
	        value: function _checkFormPresent() {
	            if (isBlank$1(this.form)) {
	                throw new BaseException$1('ngFormModel expects a form. Please pass one in. Example: <form [ngFormModel]="myCoolForm">');
	            }
	        }
	    }, {
	        key: 'submitted',
	        get: function get() {
	            return this._submitted;
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this;
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.form;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return [];
	        }
	    }]);
	    return NgFormModel;
	}(ControlContainer);
	/** @nocollapse */
	NgFormModel.decorators = [{ type: Directive, args: [{
	        selector: '[ngFormModel]',
	        providers: [formDirectiveProvider$1],
	        inputs: ['form: ngFormModel'],
	        host: { '(submit)': 'onSubmit()' },
	        outputs: ['ngSubmit'],
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	NgFormModel.ctorParameters = [{ type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS] }] }];

	var formControlBinding$1 =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: NgControl,
	    useExisting: forwardRef(function () {
	        return NgModel;
	    })
	};
	var NgModel = function (_NgControl) {
	    inherits(NgModel, _NgControl);

	    function NgModel(_validators, _asyncValidators, valueAccessors) {
	        classCallCheck(this, NgModel);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgModel).call(this));

	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        /** @internal */
	        _this._control = new Control();
	        /** @internal */
	        _this._added = false;
	        _this.update = new EventEmitter$1();
	        _this.valueAccessor = selectValueAccessor(_this, valueAccessors);
	        return _this;
	    }

	    createClass(NgModel, [{
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            if (!this._added) {
	                setUpControl(this._control, this);
	                this._control.updateValueAndValidity({ emitEvent: false });
	                this._added = true;
	            }
	            if (isPropertyUpdated(changes, this.viewModel)) {
	                this._control.updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        }
	    }, {
	        key: 'viewToModelUpdate',
	        value: function viewToModelUpdate(newValue) {
	            this.viewModel = newValue;
	            ObservableWrapper$1.callEmit(this.update, newValue);
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this._control;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return [];
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators(this._asyncValidators);
	        }
	    }]);
	    return NgModel;
	}(NgControl);
	/** @nocollapse */
	NgModel.decorators = [{ type: Directive, args: [{
	        selector: '[ngModel]:not([ngControl]):not([ngFormControl])',
	        providers: [formControlBinding$1],
	        inputs: ['model: ngModel'],
	        outputs: ['update: ngModelChange'],
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	NgModel.ctorParameters = [{ type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR] }] }];

	var REQUIRED = Validators.required;
	var REQUIRED_VALIDATOR = {
	    provide: NG_VALIDATORS,
	    useValue: REQUIRED,
	    multi: true
	};
	var RequiredValidator = function RequiredValidator() {
	    classCallCheck(this, RequiredValidator);
	};
	/** @nocollapse */
	RequiredValidator.decorators = [{ type: Directive, args: [{
	        selector: '[required][ngControl],[required][ngFormControl],[required][ngModel]',
	        providers: [REQUIRED_VALIDATOR]
	    }] }];
	/**
	 * Provivder which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	 *
	 * ## Example:
	 *
	 * {@example common/forms/ts/validators/validators.ts region='min'}
	 */
	var MIN_LENGTH_VALIDATOR = {
	    provide: NG_VALIDATORS,
	    useExisting: forwardRef(function () {
	        return MinLengthValidator;
	    }),
	    multi: true
	};
	var MinLengthValidator = function () {
	    function MinLengthValidator(minLength) {
	        classCallCheck(this, MinLengthValidator);

	        this._validator = Validators.minLength(NumberWrapper$1.parseInt(minLength, 10));
	    }

	    createClass(MinLengthValidator, [{
	        key: 'validate',
	        value: function validate(c) {
	            return this._validator(c);
	        }
	    }]);
	    return MinLengthValidator;
	}();
	/** @nocollapse */
	MinLengthValidator.decorators = [{ type: Directive, args: [{
	        selector: '[minlength][ngControl],[minlength][ngFormControl],[minlength][ngModel]',
	        providers: [MIN_LENGTH_VALIDATOR]
	    }] }];
	/** @nocollapse */
	MinLengthValidator.ctorParameters = [{ type: undefined, decorators: [{ type: Attribute, args: ['minlength'] }] }];
	/**
	 * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	 *
	 * ## Example:
	 *
	 * {@example common/forms/ts/validators/validators.ts region='max'}
	 */
	var MAX_LENGTH_VALIDATOR = {
	    provide: NG_VALIDATORS,
	    useExisting: forwardRef(function () {
	        return MaxLengthValidator;
	    }),
	    multi: true
	};
	var MaxLengthValidator = function () {
	    function MaxLengthValidator(maxLength) {
	        classCallCheck(this, MaxLengthValidator);

	        this._validator = Validators.maxLength(NumberWrapper$1.parseInt(maxLength, 10));
	    }

	    createClass(MaxLengthValidator, [{
	        key: 'validate',
	        value: function validate(c) {
	            return this._validator(c);
	        }
	    }]);
	    return MaxLengthValidator;
	}();
	/** @nocollapse */
	MaxLengthValidator.decorators = [{ type: Directive, args: [{
	        selector: '[maxlength][ngControl],[maxlength][ngFormControl],[maxlength][ngModel]',
	        providers: [MAX_LENGTH_VALIDATOR]
	    }] }];
	/** @nocollapse */
	MaxLengthValidator.ctorParameters = [{ type: undefined, decorators: [{ type: Attribute, args: ['maxlength'] }] }];
	var PATTERN_VALIDATOR = {
	    provide: NG_VALIDATORS,
	    useExisting: forwardRef(function () {
	        return PatternValidator;
	    }),
	    multi: true
	};
	var PatternValidator = function () {
	    function PatternValidator(pattern) {
	        classCallCheck(this, PatternValidator);

	        this._validator = Validators.pattern(pattern);
	    }

	    createClass(PatternValidator, [{
	        key: 'validate',
	        value: function validate(c) {
	            return this._validator(c);
	        }
	    }]);
	    return PatternValidator;
	}();
	/** @nocollapse */
	PatternValidator.decorators = [{ type: Directive, args: [{
	        selector: '[pattern][ngControl],[pattern][ngFormControl],[pattern][ngModel]',
	        providers: [PATTERN_VALIDATOR]
	    }] }];
	/** @nocollapse */
	PatternValidator.ctorParameters = [{ type: undefined, decorators: [{ type: Attribute, args: ['pattern'] }] }];

	/**
	 *
	 * A list of all the form directives used as part of a `@Component` annotation.
	 *
	 *  This is a shorthand for importing them each individually.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-app',
	 *   directives: [FORM_DIRECTIVES]
	 * })
	 * class MyApp {}
	 * ```
	 * @experimental
	 */
	var OLD_FORM_DIRECTIVES = [NgControlName, NgControlGroup, NgFormControl, NgModel, NgFormModel, NgForm, NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator];

	/**
	 * Shorthand set of providers used for building Angular forms.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * bootstrap(MyApp, [FORM_PROVIDERS]);
	 * ```
	 *
	 * @experimental
	 */
	var FORM_PROVIDERS = [FormBuilder, RadioControlRegistry];

	/**
	 * A collection of Angular core directives that are likely to be used in each and every Angular
	 * application. This includes core directives (e.g., NgIf and NgFor), and forms directives (e.g.,
	 * NgModel).
	 *
	 * This collection can be used to quickly enumerate all the built-in directives in the `directives`
	 * property of the `@Component` decorator.
	 *
	 * ### Example
	 *
	 * Instead of writing:
	 *
	 * ```typescript
	 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm} from
	 * '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm,
	 * OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 * one could import all the common directives at once:
	 *
	 * ```typescript
	 * import {COMMON_DIRECTIVES} from '@angular/common';
	 * import {OtherDirective} from './myDirectives';
	 *
	 * @Component({
	 *   selector: 'my-component',
	 *   templateUrl: 'myComponent.html',
	 *   directives: [COMMON_DIRECTIVES, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 *
	 * @experimental Contains forms which are experimental.
	 */
	var COMMON_DIRECTIVES = [CORE_DIRECTIVES, OLD_FORM_DIRECTIVES];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * This class should not be used directly by an application developer. Instead, use
	 * {@link Location}.
	 *
	 * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
	 * agnostic.
	 * This means that we can have different implementation of `PlatformLocation` for the different
	 * platforms
	 * that angular supports. For example, the default `PlatformLocation` is {@link
	 * BrowserPlatformLocation},
	 * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.
	 *
	 * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}
	 * when
	 * they need to interact with the DOM apis like pushState, popState, etc...
	 *
	 * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly
	 * by
	 * the {@link Router} in order to navigate between routes. Since all interactions between {@link
	 * Router} /
	 * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
	 * class
	 * they are all platform independent.
	 *
	 * @stable
	 */
	var PlatformLocation = function () {
	  function PlatformLocation() {
	    classCallCheck(this, PlatformLocation);
	  }

	  createClass(PlatformLocation, [{
	    key: "pathname",
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: "search",
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: "hash",
	    get: function get() {
	      return null;
	    }
	  }]);
	  return PlatformLocation;
	}();

	/**
	 * `LocationStrategy` is responsible for representing and reading route state
	 * from the browser's URL. Angular provides two strategies:
	 * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).
	 *
	 * This is used under the hood of the {@link Location} service.
	 *
	 * Applications should use the {@link Router} or {@link Location} services to
	 * interact with application route state.
	 *
	 * For instance, {@link HashLocationStrategy} produces URLs like
	 * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
	 * `http://example.com/foo` as an equivalent URL.
	 *
	 * See these two classes for more.
	 *
	 * @stable
	 */
	var LocationStrategy = function LocationStrategy() {
	  classCallCheck(this, LocationStrategy);
	};
	/**
	 * The `APP_BASE_HREF` token represents the base href to be used with the
	 * {@link PathLocationStrategy}.
	 *
	 * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
	 * representing the URL prefix that should be preserved when generating and recognizing
	 * URLs.
	 *
	 * ### Example
	 *
	 * ```
	 * import {Component} from '@angular/core';
	 * import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from '@angular/router';
	 * import {APP_BASE_HREF} from '@angular/common';
	 *
	 * @Component({directives: [ROUTER_DIRECTIVES]})
	 * @RouteConfig([
	 *  {...},
	 * ])
	 * class AppCmp {
	 *   // ...
	 * }
	 *
	 * bootstrap(AppCmp, [
	 *   ROUTER_PROVIDERS,
	 *   {provide: APP_BASE_HREF, useValue: '/my/app'}
	 * ]);
	 * ```
	 * @stable
	 */
	var APP_BASE_HREF = new OpaqueToken('appBaseHref');

	var Location = function () {
	    function Location(platformStrategy) {
	        var _this = this;

	        classCallCheck(this, Location);

	        /** @internal */
	        this._subject = new EventEmitter();
	        this._platformStrategy = platformStrategy;
	        var browserBaseHref = this._platformStrategy.getBaseHref();
	        this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
	        this._platformStrategy.onPopState(function (ev) {
	            ObservableWrapper$1.callEmit(_this._subject, { 'url': _this.path(true), 'pop': true, 'type': ev.type });
	        });
	    }
	    /**
	     * Returns the normalized URL path.
	     */
	    // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
	    // removed.


	    createClass(Location, [{
	        key: 'path',
	        value: function path() {
	            var includeHash = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

	            return this.normalize(this._platformStrategy.path(includeHash));
	        }
	        /**
	         * Normalizes the given path and compares to the current normalized path.
	         */

	    }, {
	        key: 'isCurrentPathEqualTo',
	        value: function isCurrentPathEqualTo(path) {
	            var query = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
	        }
	        /**
	         * Given a string representing a URL, returns the normalized URL path without leading or
	         * trailing slashes
	         */

	    }, {
	        key: 'normalize',
	        value: function normalize(url) {
	            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
	        }
	        /**
	         * Given a string representing a URL, returns the platform-specific external URL path.
	         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
	         * before normalizing. This method will also add a hash if `HashLocationStrategy` is
	         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
	         */

	    }, {
	        key: 'prepareExternalUrl',
	        value: function prepareExternalUrl(url) {
	            if (url.length > 0 && !url.startsWith('/')) {
	                url = '/' + url;
	            }
	            return this._platformStrategy.prepareExternalUrl(url);
	        }
	        // TODO: rename this method to pushState
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and pushes a
	         * new item onto the platform's history.
	         */

	    }, {
	        key: 'go',
	        value: function go(path) {
	            var query = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            this._platformStrategy.pushState(null, '', path, query);
	        }
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and replaces
	         * the top item on the platform's history stack.
	         */

	    }, {
	        key: 'replaceState',
	        value: function replaceState(path) {
	            var query = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            this._platformStrategy.replaceState(null, '', path, query);
	        }
	        /**
	         * Navigates forward in the platform's history.
	         */

	    }, {
	        key: 'forward',
	        value: function forward() {
	            this._platformStrategy.forward();
	        }
	        /**
	         * Navigates back in the platform's history.
	         */

	    }, {
	        key: 'back',
	        value: function back() {
	            this._platformStrategy.back();
	        }
	        /**
	         * Subscribe to the platform's `popState` events.
	         */

	    }, {
	        key: 'subscribe',
	        value: function subscribe(onNext) {
	            var onThrow = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var onReturn = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return ObservableWrapper$1.subscribe(this._subject, onNext, onThrow, onReturn);
	        }
	        /**
	         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
	         * is.
	         */

	    }], [{
	        key: 'normalizeQueryParams',
	        value: function normalizeQueryParams(params) {
	            return params.length > 0 && params.substring(0, 1) != '?' ? '?' + params : params;
	        }
	        /**
	         * Given 2 parts of a url, join them with a slash if needed.
	         */

	    }, {
	        key: 'joinWithSlash',
	        value: function joinWithSlash(start, end) {
	            if (start.length == 0) {
	                return end;
	            }
	            if (end.length == 0) {
	                return start;
	            }
	            var slashes = 0;
	            if (start.endsWith('/')) {
	                slashes++;
	            }
	            if (end.startsWith('/')) {
	                slashes++;
	            }
	            if (slashes == 2) {
	                return start + end.substring(1);
	            }
	            if (slashes == 1) {
	                return start + end;
	            }
	            return start + '/' + end;
	        }
	        /**
	         * If url has a trailing slash, remove it, otherwise return url as is.
	         */

	    }, {
	        key: 'stripTrailingSlash',
	        value: function stripTrailingSlash(url) {
	            if (/\/$/g.test(url)) {
	                url = url.substring(0, url.length - 1);
	            }
	            return url;
	        }
	    }]);
	    return Location;
	}();
	/** @nocollapse */
	Location.decorators = [{ type: Injectable }];
	/** @nocollapse */
	Location.ctorParameters = [{ type: LocationStrategy }];
	function _stripBaseHref(baseHref, url) {
	    if (baseHref.length > 0 && url.startsWith(baseHref)) {
	        return url.substring(baseHref.length);
	    }
	    return url;
	}
	function _stripIndexHtml(url) {
	    if (/\/index.html$/g.test(url)) {
	        // '/index.html'.length == 11
	        return url.substring(0, url.length - 11);
	    }
	    return url;
	}

	var HashLocationStrategy = function (_LocationStrategy) {
	    inherits(HashLocationStrategy, _LocationStrategy);

	    function HashLocationStrategy(_platformLocation, _baseHref) {
	        classCallCheck(this, HashLocationStrategy);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(HashLocationStrategy).call(this));

	        _this._platformLocation = _platformLocation;
	        _this._baseHref = '';
	        if (isPresent$1(_baseHref)) {
	            _this._baseHref = _baseHref;
	        }
	        return _this;
	    }

	    createClass(HashLocationStrategy, [{
	        key: 'onPopState',
	        value: function onPopState(fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        }
	    }, {
	        key: 'getBaseHref',
	        value: function getBaseHref() {
	            return this._baseHref;
	        }
	    }, {
	        key: 'path',
	        value: function path() {
	            var includeHash = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

	            // the hash value is always prefixed with a `#`
	            // and if it is empty then it will stay empty
	            var path = this._platformLocation.hash;
	            if (!isPresent$1(path)) path = '#';
	            // Dart will complain if a call to substring is
	            // executed with a position value that extends the
	            // length of string.
	            return path.length > 0 ? path.substring(1) : path;
	        }
	    }, {
	        key: 'prepareExternalUrl',
	        value: function prepareExternalUrl(internal) {
	            var url = Location.joinWithSlash(this._baseHref, internal);
	            return url.length > 0 ? '#' + url : url;
	        }
	    }, {
	        key: 'pushState',
	        value: function pushState(state, title, path, queryParams) {
	            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.pushState(state, title, url);
	        }
	    }, {
	        key: 'replaceState',
	        value: function replaceState(state, title, path, queryParams) {
	            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.replaceState(state, title, url);
	        }
	    }, {
	        key: 'forward',
	        value: function forward() {
	            this._platformLocation.forward();
	        }
	    }, {
	        key: 'back',
	        value: function back() {
	            this._platformLocation.back();
	        }
	    }]);
	    return HashLocationStrategy;
	}(LocationStrategy);
	/** @nocollapse */
	HashLocationStrategy.decorators = [{ type: Injectable }];
	/** @nocollapse */
	HashLocationStrategy.ctorParameters = [{ type: PlatformLocation }, { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APP_BASE_HREF] }] }];

	var PathLocationStrategy = function (_LocationStrategy) {
	    inherits(PathLocationStrategy, _LocationStrategy);

	    function PathLocationStrategy(_platformLocation, href) {
	        classCallCheck(this, PathLocationStrategy);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(PathLocationStrategy).call(this));

	        _this._platformLocation = _platformLocation;
	        if (isBlank$1(href)) {
	            href = _this._platformLocation.getBaseHrefFromDOM();
	        }
	        if (isBlank$1(href)) {
	            throw new BaseException$1('No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.');
	        }
	        _this._baseHref = href;
	        return _this;
	    }

	    createClass(PathLocationStrategy, [{
	        key: 'onPopState',
	        value: function onPopState(fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        }
	    }, {
	        key: 'getBaseHref',
	        value: function getBaseHref() {
	            return this._baseHref;
	        }
	    }, {
	        key: 'prepareExternalUrl',
	        value: function prepareExternalUrl(internal) {
	            return Location.joinWithSlash(this._baseHref, internal);
	        }
	    }, {
	        key: 'path',
	        value: function path() {
	            var includeHash = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

	            var pathname = this._platformLocation.pathname + Location.normalizeQueryParams(this._platformLocation.search);
	            var hash = this._platformLocation.hash;
	            return hash && includeHash ? '' + pathname + hash : pathname;
	        }
	    }, {
	        key: 'pushState',
	        value: function pushState(state, title, url, queryParams) {
	            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.pushState(state, title, externalUrl);
	        }
	    }, {
	        key: 'replaceState',
	        value: function replaceState(state, title, url, queryParams) {
	            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.replaceState(state, title, externalUrl);
	        }
	    }, {
	        key: 'forward',
	        value: function forward() {
	            this._platformLocation.forward();
	        }
	    }, {
	        key: 'back',
	        value: function back() {
	            this._platformLocation.back();
	        }
	    }]);
	    return PathLocationStrategy;
	}(LocationStrategy);
	/** @nocollapse */
	PathLocationStrategy.decorators = [{ type: Injectable }];
	/** @nocollapse */
	PathLocationStrategy.ctorParameters = [{ type: PlatformLocation }, { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APP_BASE_HREF] }] }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalScope$2;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope$2 = self;
	    } else {
	        globalScope$2 = global;
	    }
	} else {
	    globalScope$2 = window;
	}
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var global$3 = globalScope$2;
	var Date$3 = global$3.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	global$3.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent$2(obj) {
	    return obj !== undefined && obj !== null;
	}
	function isBlank$2(obj) {
	    return obj === undefined || obj === null;
	}
	function isNumber$2(obj) {
	    return typeof obj === 'number';
	}
	function isString$2(obj) {
	    return typeof obj === 'string';
	}
	function isFunction$3(obj) {
	    return typeof obj === 'function';
	}
	function isArray$3(obj) {
	    return Array.isArray(obj);
	}
	function noop$2() {}
	function stringify$2(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token === undefined || token === null) {
	        return '' + token;
	    }
	    if (token.name) {
	        return token.name;
	    }
	    if (token.overriddenName) {
	        return token.overriddenName;
	    }
	    var res = token.toString();
	    var newLineIndex = res.indexOf('\n');
	    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	}
	// serialize / deserialize enum exist only for consistency with dart API
	// enums in typescript don't need to be serialized
	function serializeEnum$2(val) {
	    return val;
	}
	var StringWrapper$2 = function () {
	    function StringWrapper() {
	        classCallCheck(this, StringWrapper);
	    }

	    createClass(StringWrapper, null, [{
	        key: 'fromCharCode',
	        value: function fromCharCode(code) {
	            return String.fromCharCode(code);
	        }
	    }, {
	        key: 'charCodeAt',
	        value: function charCodeAt(s, index) {
	            return s.charCodeAt(index);
	        }
	    }, {
	        key: 'split',
	        value: function split(s, regExp) {
	            return s.split(regExp);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(s, s2) {
	            return s === s2;
	        }
	    }, {
	        key: 'stripLeft',
	        value: function stripLeft(s, charVal) {
	            if (s && s.length) {
	                var pos = 0;
	                for (var i = 0; i < s.length; i++) {
	                    if (s[i] != charVal) break;
	                    pos++;
	                }
	                s = s.substring(pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'stripRight',
	        value: function stripRight(s, charVal) {
	            if (s && s.length) {
	                var pos = s.length;
	                for (var i = s.length - 1; i >= 0; i--) {
	                    if (s[i] != charVal) break;
	                    pos--;
	                }
	                s = s.substring(0, pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'replace',
	        value: function replace(s, from, _replace) {
	            return s.replace(from, _replace);
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(s, from, replace) {
	            return s.replace(from, replace);
	        }
	    }, {
	        key: 'slice',
	        value: function slice(s) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return s.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'replaceAllMapped',
	        value: function replaceAllMapped(s, from, cb) {
	            return s.replace(from, function () {
	                for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
	                    matches[_key] = arguments[_key];
	                }

	                // Remove offset & string from the result array
	                matches.splice(-2, 2);
	                // The callback receives match, p1, ..., pn
	                return cb(matches);
	            });
	        }
	    }, {
	        key: 'contains',
	        value: function contains(s, substr) {
	            return s.indexOf(substr) != -1;
	        }
	    }, {
	        key: 'compare',
	        value: function compare(a, b) {
	            if (a < b) {
	                return -1;
	            } else if (a > b) {
	                return 1;
	            } else {
	                return 0;
	            }
	        }
	    }]);
	    return StringWrapper;
	}();

	var StringJoiner$2 = function () {
	    function StringJoiner() {
	        var parts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, StringJoiner);

	        this.parts = parts;
	    }

	    createClass(StringJoiner, [{
	        key: 'add',
	        value: function add(part) {
	            this.parts.push(part);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.parts.join('');
	        }
	    }]);
	    return StringJoiner;
	}();
	var NumberParseError$2 = function (_Error) {
	    inherits(NumberParseError, _Error);

	    function NumberParseError(message) {
	        classCallCheck(this, NumberParseError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NumberParseError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(NumberParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return NumberParseError;
	}(Error);
	var NumberWrapper$2 = function () {
	    function NumberWrapper() {
	        classCallCheck(this, NumberWrapper);
	    }

	    createClass(NumberWrapper, null, [{
	        key: 'toFixed',
	        value: function toFixed(n, fractionDigits) {
	            return n.toFixed(fractionDigits);
	        }
	    }, {
	        key: 'equal',
	        value: function equal(a, b) {
	            return a === b;
	        }
	    }, {
	        key: 'parseIntAutoRadix',
	        value: function parseIntAutoRadix(text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new NumberParseError$2('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        }
	    }, {
	        key: 'parseInt',
	        value: function (_parseInt) {
	            function parseInt(_x4, _x5) {
	                return _parseInt.apply(this, arguments);
	            }

	            parseInt.toString = function () {
	                return _parseInt.toString();
	            };

	            return parseInt;
	        }(function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new NumberParseError$2('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        })
	        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.

	    }, {
	        key: 'parseFloat',
	        value: function (_parseFloat) {
	            function parseFloat(_x6) {
	                return _parseFloat.apply(this, arguments);
	            }

	            parseFloat.toString = function () {
	                return _parseFloat.toString();
	            };

	            return parseFloat;
	        }(function (text) {
	            return parseFloat(text);
	        })
	    }, {
	        key: 'isNumeric',
	        value: function isNumeric(value) {
	            return !isNaN(value - parseFloat(value));
	        }
	    }, {
	        key: 'isNaN',
	        value: function (_isNaN) {
	            function isNaN(_x7) {
	                return _isNaN.apply(this, arguments);
	            }

	            isNaN.toString = function () {
	                return _isNaN.toString();
	            };

	            return isNaN;
	        }(function (value) {
	            return isNaN(value);
	        })
	    }, {
	        key: 'isInteger',
	        value: function isInteger(value) {
	            return Number.isInteger(value);
	        }
	    }, {
	        key: 'NaN',
	        get: function get() {
	            return NaN;
	        }
	    }]);
	    return NumberWrapper;
	}();
	var RegExpWrapper$2 = function () {
	    function RegExpWrapper() {
	        classCallCheck(this, RegExpWrapper);
	    }

	    createClass(RegExpWrapper, null, [{
	        key: 'create',
	        value: function create(regExpStr) {
	            var flags = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            flags = flags.replace(/g/g, '');
	            return new global$3.RegExp(regExpStr, flags + 'g');
	        }
	    }, {
	        key: 'firstMatch',
	        value: function firstMatch(regExp, input) {
	            // Reset multimatch regex state
	            regExp.lastIndex = 0;
	            return regExp.exec(input);
	        }
	    }, {
	        key: 'test',
	        value: function test(regExp, input) {
	            regExp.lastIndex = 0;
	            return regExp.test(input);
	        }
	    }, {
	        key: 'matcher',
	        value: function matcher(regExp, input) {
	            // Reset regex state for the case
	            // someone did not loop over all matches
	            // last time.
	            regExp.lastIndex = 0;
	            return { re: regExp, input: input };
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(regExp, input, replace) {
	            var c = regExp.exec(input);
	            var res = '';
	            regExp.lastIndex = 0;
	            var prev = 0;
	            while (c) {
	                res += input.substring(prev, c.index);
	                res += replace(c);
	                prev = c.index + c[0].length;
	                regExp.lastIndex = prev;
	                c = regExp.exec(input);
	            }
	            res += input.substring(prev);
	            return res;
	        }
	    }]);
	    return RegExpWrapper;
	}();
	var RegExpMatcherWrapper$2 = function () {
	    function RegExpMatcherWrapper() {
	        classCallCheck(this, RegExpMatcherWrapper);
	    }

	    createClass(RegExpMatcherWrapper, null, [{
	        key: 'next',
	        value: function next(matcher) {
	            return matcher.re.exec(matcher.input);
	        }
	    }]);
	    return RegExpMatcherWrapper;
	}();
	var FunctionWrapper$2 = function () {
	    function FunctionWrapper() {
	        classCallCheck(this, FunctionWrapper);
	    }

	    createClass(FunctionWrapper, null, [{
	        key: 'apply',
	        value: function apply(fn, posArgs) {
	            return fn.apply(null, posArgs);
	        }
	    }, {
	        key: 'bind',
	        value: function bind(fn, scope) {
	            return fn.bind(scope);
	        }
	    }]);
	    return FunctionWrapper;
	}();
	function isJsObject$2(o) {
	    return o !== null && (typeof o === 'function' || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object');
	}
	function print$2(obj) {
	    console.log(obj);
	}
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json$2 = function () {
	    function Json() {
	        classCallCheck(this, Json);
	    }

	    createClass(Json, null, [{
	        key: 'parse',
	        value: function parse(s) {
	            return global$3.JSON.parse(s);
	        }
	    }, {
	        key: 'stringify',
	        value: function stringify(data) {
	            // Dart doesn't take 3 arguments
	            return global$3.JSON.stringify(data, null, 2);
	        }
	    }]);
	    return Json;
	}();
	var DateWrapper$2 = function () {
	    function DateWrapper() {
	        classCallCheck(this, DateWrapper);
	    }

	    createClass(DateWrapper, null, [{
	        key: 'create',
	        value: function create(year) {
	            var month = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var day = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	            var hour = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	            var minutes = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
	            var seconds = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
	            var milliseconds = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];

	            return new Date$3(year, month - 1, day, hour, minutes, seconds, milliseconds);
	        }
	    }, {
	        key: 'fromISOString',
	        value: function fromISOString(str) {
	            return new Date$3(str);
	        }
	    }, {
	        key: 'fromMillis',
	        value: function fromMillis(ms) {
	            return new Date$3(ms);
	        }
	    }, {
	        key: 'toMillis',
	        value: function toMillis(date) {
	            return date.getTime();
	        }
	    }, {
	        key: 'now',
	        value: function now() {
	            return new Date$3();
	        }
	    }, {
	        key: 'toJson',
	        value: function toJson(date) {
	            return date.toJSON();
	        }
	    }]);
	    return DateWrapper;
	}();
	function setValueOnPath$2(global, path, value) {
	    var parts = path.split('.');
	    var obj = global;
	    while (parts.length > 1) {
	        var name = parts.shift();
	        if (obj.hasOwnProperty(name) && isPresent$2(obj[name])) {
	            obj = obj[name];
	        } else {
	            obj = obj[name] = {};
	        }
	    }
	    if (obj === undefined || obj === null) {
	        obj = {};
	    }
	    obj[parts.shift()] = value;
	}
	var _symbolIterator$2 = null;
	function getSymbolIterator$2() {
	    if (isBlank$2(_symbolIterator$2)) {
	        if (isPresent$2(globalScope$2.Symbol) && isPresent$2(Symbol.iterator)) {
	            _symbolIterator$2 = Symbol.iterator;
	        } else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator$2 = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator$2;
	}

	var _DOM = null;
	function getDOM() {
	    return _DOM;
	}
	function setRootDomAdapter(adapter) {
	    if (isBlank$2(_DOM)) {
	        _DOM = adapter;
	    }
	}
	/* tslint:disable:requireParameterType */
	/**
	 * Provides DOM operations in an environment-agnostic way.
	 */
	var DomAdapter = function () {
	    function DomAdapter() {
	        classCallCheck(this, DomAdapter);

	        this.xhrType = null;
	    }
	    /** @deprecated */


	    createClass(DomAdapter, [{
	        key: 'getXHR',
	        value: function getXHR() {
	            return this.xhrType;
	        }
	        /**
	         * Maps attribute names to their corresponding property names for cases
	         * where attribute name doesn't match property name.
	         */

	    }, {
	        key: 'attrToPropMap',
	        get: function get() {
	            return this._attrToPropMap;
	        },
	        set: function set(value) {
	            this._attrToPropMap = value;
	        }
	    }]);
	    return DomAdapter;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	function supportsState() {
	  return !!window.history.pushState;
	}

	var BrowserPlatformLocation = function (_PlatformLocation) {
	    inherits(BrowserPlatformLocation, _PlatformLocation);

	    function BrowserPlatformLocation() {
	        classCallCheck(this, BrowserPlatformLocation);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BrowserPlatformLocation).call(this));

	        _this._init();
	        return _this;
	    }
	    // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it
	    /** @internal */


	    createClass(BrowserPlatformLocation, [{
	        key: '_init',
	        value: function _init() {
	            this._location = getDOM().getLocation();
	            this._history = getDOM().getHistory();
	        }
	        /** @internal */

	    }, {
	        key: 'getBaseHrefFromDOM',
	        value: function getBaseHrefFromDOM() {
	            return getDOM().getBaseHref();
	        }
	    }, {
	        key: 'onPopState',
	        value: function onPopState(fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
	        }
	    }, {
	        key: 'onHashChange',
	        value: function onHashChange(fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
	        }
	    }, {
	        key: 'pushState',
	        value: function pushState(state, title, url) {
	            if (supportsState()) {
	                this._history.pushState(state, title, url);
	            } else {
	                this._location.hash = url;
	            }
	        }
	    }, {
	        key: 'replaceState',
	        value: function replaceState(state, title, url) {
	            if (supportsState()) {
	                this._history.replaceState(state, title, url);
	            } else {
	                this._location.hash = url;
	            }
	        }
	    }, {
	        key: 'forward',
	        value: function forward() {
	            this._history.forward();
	        }
	    }, {
	        key: 'back',
	        value: function back() {
	            this._history.back();
	        }
	    }, {
	        key: 'location',
	        get: function get() {
	            return this._location;
	        }
	    }, {
	        key: 'pathname',
	        get: function get() {
	            return this._location.pathname;
	        },
	        set: function set(newPath) {
	            this._location.pathname = newPath;
	        }
	    }, {
	        key: 'search',
	        get: function get() {
	            return this._location.search;
	        }
	    }, {
	        key: 'hash',
	        get: function get() {
	            return this._location.hash;
	        }
	    }]);
	    return BrowserPlatformLocation;
	}(PlatformLocation);
	/** @nocollapse */
	BrowserPlatformLocation.decorators = [{ type: Injectable }];
	/** @nocollapse */
	BrowserPlatformLocation.ctorParameters = [];

	/**
	 * A service that can be used to get and set the title of a current HTML document.
	 *
	 * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
	 * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
	 * (representing the `<title>` tag). Instead, this service can be used to set and get the current
	 * title value.
	 *
	 * @experimental
	 */
	var Title = function () {
	  function Title() {
	    classCallCheck(this, Title);
	  }

	  createClass(Title, [{
	    key: 'getTitle',

	    /**
	     * Get the title of the current HTML document.
	     * @returns {string}
	     */
	    value: function getTitle() {
	      return getDOM().getTitle();
	    }
	    /**
	     * Set the title of the current HTML document.
	     * @param newTitle
	     */

	  }, {
	    key: 'setTitle',
	    value: function setTitle(newTitle) {
	      getDOM().setTitle(newTitle);
	    }
	  }]);
	  return Title;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * JS version of browser APIs. This library can only run in the browser.
	 */
	var win = typeof window !== 'undefined' && window || {};

	var ChangeDetectionPerfRecord = function ChangeDetectionPerfRecord(msPerTick, numTicks) {
	    classCallCheck(this, ChangeDetectionPerfRecord);

	    this.msPerTick = msPerTick;
	    this.numTicks = numTicks;
	};
	/**
	 * Entry point for all Angular profiling-related debug tools. This object
	 * corresponds to the `ng.profiler` in the dev console.
	 */
	var AngularProfiler = function () {
	    function AngularProfiler(ref) {
	        classCallCheck(this, AngularProfiler);

	        this.appRef = ref.injector.get(ApplicationRef);
	    }
	    /**
	     * Exercises change detection in a loop and then prints the average amount of
	     * time in milliseconds how long a single round of change detection takes for
	     * the current state of the UI. It runs a minimum of 5 rounds for a minimum
	     * of 500 milliseconds.
	     *
	     * Optionally, a user may pass a `config` parameter containing a map of
	     * options. Supported options are:
	     *
	     * `record` (boolean) - causes the profiler to record a CPU profile while
	     * it exercises the change detector. Example:
	     *
	     * ```
	     * ng.profiler.timeChangeDetection({record: true})
	     * ```
	     */


	    createClass(AngularProfiler, [{
	        key: 'timeChangeDetection',
	        value: function timeChangeDetection(config) {
	            var record = isPresent$2(config) && config['record'];
	            var profileName = 'Change Detection';
	            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
	            var isProfilerAvailable = isPresent$2(win.console.profile);
	            if (record && isProfilerAvailable) {
	                win.console.profile(profileName);
	            }
	            var start = getDOM().performanceNow();
	            var numTicks = 0;
	            while (numTicks < 5 || getDOM().performanceNow() - start < 500) {
	                this.appRef.tick();
	                numTicks++;
	            }
	            var end = getDOM().performanceNow();
	            if (record && isProfilerAvailable) {
	                // need to cast to <any> because type checker thinks there's no argument
	                // while in fact there is:
	                //
	                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
	                win.console.profileEnd(profileName);
	            }
	            var msPerTick = (end - start) / numTicks;
	            win.console.log('ran ' + numTicks + ' change detection cycles');
	            win.console.log(NumberWrapper$2.toFixed(msPerTick, 2) + ' ms per check');
	            return new ChangeDetectionPerfRecord(msPerTick, numTicks);
	        }
	    }]);
	    return AngularProfiler;
	}();

	var context = global$3;

	/**
	 * Predicates for use with {@link DebugElement}'s query functions.
	 *
	 * @experimental All debugging apis are currently experimental.
	 */
	var By = function () {
	  function By() {
	    classCallCheck(this, By);
	  }

	  createClass(By, null, [{
	    key: 'all',

	    /**
	     * Match all elements.
	     *
	     * ## Example
	     *
	     * {@example platform/dom/debug/ts/by/by.ts region='by_all'}
	     */
	    value: function all() {
	      return function (debugElement) {
	        return true;
	      };
	    }
	    /**
	     * Match elements by the given CSS selector.
	     *
	     * ## Example
	     *
	     * {@example platform/dom/debug/ts/by/by.ts region='by_css'}
	     */

	  }, {
	    key: 'css',
	    value: function css(selector) {
	      return function (debugElement) {
	        return isPresent$2(debugElement.nativeElement) ? getDOM().elementMatches(debugElement.nativeElement, selector) : false;
	      };
	    }
	    /**
	     * Match elements that have the given directive present.
	     *
	     * ## Example
	     *
	     * {@example platform/dom/debug/ts/by/by.ts region='by_directive'}
	     */

	  }, {
	    key: 'directive',
	    value: function directive(type) {
	      return function (debugElement) {
	        return debugElement.providerTokens.indexOf(type) !== -1;
	      };
	    }
	  }]);
	  return By;
	}();

	/**
	 * A DI Token representing the main rendering context. In a browser this is the DOM Document.
	 *
	 * Note: Document might not be available in the Application Context when Application and Rendering
	 * Contexts are not the same (e.g. when running the application into a Web Worker).
	 *
	 * @stable
	 */
	var DOCUMENT = new OpaqueToken('DocumentToken');

	var Map$3 = global$3.Map;
	var Set$3 = global$3.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs$2 = function () {
	    try {
	        if (new Map$3([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) {
	                return new Map$3(pairs);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new Map$3();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	}();
	var createMapFromMap$2 = function () {
	    try {
	        if (new Map$3(new Map$3())) {
	            return function createMapFromMap(m) {
	                return new Map$3(m);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromMap(m) {
	        var map = new Map$3();
	        m.forEach(function (v, k) {
	            map.set(k, v);
	        });
	        return map;
	    };
	}();
	var _clearValues$2 = function () {
	    if (new Map$3().keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!(k = keyIterator.next()).done) {
	                m.set(k.value, null);
	            }
	        };
	    } else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) {
	                m.set(k, null);
	            });
	        };
	    }
	}();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap$2 = function () {
	    try {
	        if (new Map$3().values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    } catch (e) {}
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper$2.createFixedSize(m.size),
	            i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	}();
	var MapWrapper$2 = function () {
	    function MapWrapper() {
	        classCallCheck(this, MapWrapper);
	    }

	    createClass(MapWrapper, null, [{
	        key: 'clone',
	        value: function clone(m) {
	            return createMapFromMap$2(m);
	        }
	    }, {
	        key: 'createFromStringMap',
	        value: function createFromStringMap(stringMap) {
	            var result = new Map$3();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        }
	    }, {
	        key: 'toStringMap',
	        value: function toStringMap(m) {
	            var r = {};
	            m.forEach(function (v, k) {
	                return r[k] = v;
	            });
	            return r;
	        }
	    }, {
	        key: 'createFromPairs',
	        value: function createFromPairs(pairs) {
	            return createMapFromPairs$2(pairs);
	        }
	    }, {
	        key: 'clearValues',
	        value: function clearValues(m) {
	            _clearValues$2(m);
	        }
	    }, {
	        key: 'iterable',
	        value: function iterable(m) {
	            return m;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(m) {
	            return _arrayFromMap$2(m, false);
	        }
	    }, {
	        key: 'values',
	        value: function values(m) {
	            return _arrayFromMap$2(m, true);
	        }
	    }]);
	    return MapWrapper;
	}();
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper$2 = function () {
	    function StringMapWrapper() {
	        classCallCheck(this, StringMapWrapper);
	    }

	    createClass(StringMapWrapper, null, [{
	        key: 'create',
	        value: function create() {
	            // Note: We are not using Object.create(null) here due to
	            // performance!
	            // http://jsperf.com/ng2-object-create-null
	            return {};
	        }
	    }, {
	        key: 'contains',
	        value: function contains(map, key) {
	            return map.hasOwnProperty(key);
	        }
	    }, {
	        key: 'get',
	        value: function get(map, key) {
	            return map.hasOwnProperty(key) ? map[key] : undefined;
	        }
	    }, {
	        key: 'set',
	        value: function set(map, key, value) {
	            map[key] = value;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(map) {
	            return Object.keys(map);
	        }
	    }, {
	        key: 'values',
	        value: function values(map) {
	            return Object.keys(map).reduce(function (r, a) {
	                r.push(map[a]);
	                return r;
	            }, []);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(map) {
	            for (var prop in map) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(map, key) {
	            delete map[key];
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(map, callback) {
	            for (var prop in map) {
	                if (map.hasOwnProperty(prop)) {
	                    callback(map[prop], prop);
	                }
	            }
	        }
	    }, {
	        key: 'merge',
	        value: function merge(m1, m2) {
	            var m = {};
	            for (var attr in m1) {
	                if (m1.hasOwnProperty(attr)) {
	                    m[attr] = m1[attr];
	                }
	            }
	            for (var attr in m2) {
	                if (m2.hasOwnProperty(attr)) {
	                    m[attr] = m2[attr];
	                }
	            }
	            return m;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            var key;
	            for (var i = 0; i < k1.length; i++) {
	                key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }]);
	    return StringMapWrapper;
	}();
	var ListWrapper$2 = function () {
	    function ListWrapper() {
	        classCallCheck(this, ListWrapper);
	    }

	    createClass(ListWrapper, null, [{
	        key: 'createFixedSize',

	        // JS has no way to express a statically fixed size list, but dart does so we
	        // keep both methods.
	        value: function createFixedSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'createGrowableSize',
	        value: function createGrowableSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'clone',
	        value: function clone(array) {
	            return array.slice(0);
	        }
	    }, {
	        key: 'forEachWithIndex',
	        value: function forEachWithIndex(array, fn) {
	            for (var i = 0; i < array.length; i++) {
	                fn(array[i], i);
	            }
	        }
	    }, {
	        key: 'first',
	        value: function first(array) {
	            if (!array) return null;
	            return array[0];
	        }
	    }, {
	        key: 'last',
	        value: function last(array) {
	            if (!array || array.length == 0) return null;
	            return array[array.length - 1];
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(array, value) {
	            var startIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	            return array.indexOf(value, startIndex);
	        }
	    }, {
	        key: 'contains',
	        value: function contains(list, el) {
	            return list.indexOf(el) !== -1;
	        }
	    }, {
	        key: 'reversed',
	        value: function reversed(array) {
	            var a = ListWrapper.clone(array);
	            return a.reverse();
	        }
	    }, {
	        key: 'concat',
	        value: function concat(a, b) {
	            return a.concat(b);
	        }
	    }, {
	        key: 'insert',
	        value: function insert(list, index, value) {
	            list.splice(index, 0, value);
	        }
	    }, {
	        key: 'removeAt',
	        value: function removeAt(list, index) {
	            var res = list[index];
	            list.splice(index, 1);
	            return res;
	        }
	    }, {
	        key: 'removeAll',
	        value: function removeAll(list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'clear',
	        value: function clear(list) {
	            list.length = 0;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(list) {
	            return list.length == 0;
	        }
	    }, {
	        key: 'fill',
	        value: function fill(list, value) {
	            var start = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	            var end = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            list.fill(value, start, end === null ? list.length : end);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(a, b) {
	            if (a.length != b.length) return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i]) return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'slice',
	        value: function slice(l) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return l.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'splice',
	        value: function splice(l, from, length) {
	            return l.splice(from, length);
	        }
	    }, {
	        key: 'sort',
	        value: function sort(l, compareFn) {
	            if (isPresent$2(compareFn)) {
	                l.sort(compareFn);
	            } else {
	                l.sort();
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString(l) {
	            return l.toString();
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON(l) {
	            return JSON.stringify(l);
	        }
	    }, {
	        key: 'maximum',
	        value: function maximum(list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (isBlank$2(candidate)) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        }
	    }, {
	        key: 'flatten',
	        value: function flatten(list) {
	            var target = [];
	            _flattenArray$2(list, target);
	            return target;
	        }
	    }, {
	        key: 'addAll',
	        value: function addAll(list, source) {
	            for (var i = 0; i < source.length; i++) {
	                list.push(source[i]);
	            }
	        }
	    }]);
	    return ListWrapper;
	}();
	function _flattenArray$2(source, target) {
	    if (isPresent$2(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (isArray$3(item)) {
	                _flattenArray$2(item, target);
	            } else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable$2(obj) {
	    if (!isJsObject$2(obj)) return false;
	    return isArray$3(obj) || !(obj instanceof Map$3) && getSymbolIterator$2() in obj; // JS Iterable have a Symbol.iterator prop
	}
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList$2 = function () {
	    var test = new Set$3([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) {
	            return new Set$3(lst);
	        };
	    } else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new Set$3(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	}();
	var SetWrapper$2 = function () {
	    function SetWrapper() {
	        classCallCheck(this, SetWrapper);
	    }

	    createClass(SetWrapper, null, [{
	        key: 'createFromList',
	        value: function createFromList(lst) {
	            return createSetFromList$2(lst);
	        }
	    }, {
	        key: 'has',
	        value: function has(s, key) {
	            return s.has(key);
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(m, k) {
	            m.delete(k);
	        }
	    }]);
	    return SetWrapper;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException$2 = function (_Error) {
	  inherits(BaseWrappedException, _Error);

	  function BaseWrappedException(message) {
	    classCallCheck(this, BaseWrappedException);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(BaseWrappedException).call(this, message));
	  }

	  createClass(BaseWrappedException, [{
	    key: 'wrapperMessage',
	    get: function get() {
	      return '';
	    }
	  }, {
	    key: 'wrapperStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalException',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'message',
	    get: function get() {
	      return '';
	    }
	  }]);
	  return BaseWrappedException;
	}(Error);

	var _ArrayLogger$2 = function () {
	    function _ArrayLogger() {
	        classCallCheck(this, _ArrayLogger);

	        this.res = [];
	    }

	    createClass(_ArrayLogger, [{
	        key: 'log',
	        value: function log(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logError',
	        value: function logError(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return _ArrayLogger;
	}();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */


	var ExceptionHandler$2 = function () {
	    function ExceptionHandler(_logger) {
	        var _rethrowException = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        classCallCheck(this, ExceptionHandler);

	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }

	    createClass(ExceptionHandler, [{
	        key: 'call',
	        value: function call(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var originalException = this._findOriginalException(exception);
	            var originalStack = this._findOriginalStack(exception);
	            var context = this._findContext(exception);
	            this._logger.logGroup('EXCEPTION: ' + this._extractMessage(exception));
	            if (isPresent$2(stackTrace) && isBlank$2(originalStack)) {
	                this._logger.logError('STACKTRACE:');
	                this._logger.logError(this._longStackTrace(stackTrace));
	            }
	            if (isPresent$2(reason)) {
	                this._logger.logError('REASON: ' + reason);
	            }
	            if (isPresent$2(originalException)) {
	                this._logger.logError('ORIGINAL EXCEPTION: ' + this._extractMessage(originalException));
	            }
	            if (isPresent$2(originalStack)) {
	                this._logger.logError('ORIGINAL STACKTRACE:');
	                this._logger.logError(this._longStackTrace(originalStack));
	            }
	            if (isPresent$2(context)) {
	                this._logger.logError('ERROR CONTEXT:');
	                this._logger.logError(context);
	            }
	            this._logger.logGroupEnd();
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	            if (this._rethrowException) throw exception;
	        }
	        /** @internal */

	    }, {
	        key: '_extractMessage',
	        value: function _extractMessage(exception) {
	            return exception instanceof BaseWrappedException$2 ? exception.wrapperMessage : exception.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_longStackTrace',
	        value: function _longStackTrace(stackTrace) {
	            return isListLikeIterable$2(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_findContext',
	        value: function _findContext(exception) {
	            try {
	                if (!(exception instanceof BaseWrappedException$2)) return null;
	                return isPresent$2(exception.context) ? exception.context : this._findContext(exception.originalException);
	            } catch (e) {
	                // exception.context can throw an exception. if it happens, we ignore the context.
	                return null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalException',
	        value: function _findOriginalException(exception) {
	            if (!(exception instanceof BaseWrappedException$2)) return null;
	            var e = exception.originalException;
	            while (e instanceof BaseWrappedException$2 && isPresent$2(e.originalException)) {
	                e = e.originalException;
	            }
	            return e;
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalStack',
	        value: function _findOriginalStack(exception) {
	            if (!(exception instanceof BaseWrappedException$2)) return null;
	            var e = exception;
	            var stack = exception.originalStack;
	            while (e instanceof BaseWrappedException$2 && isPresent$2(e.originalException)) {
	                e = e.originalException;
	                if (e instanceof BaseWrappedException$2 && isPresent$2(e.originalException)) {
	                    stack = e.originalStack;
	                }
	            }
	            return stack;
	        }
	    }], [{
	        key: 'exceptionToString',
	        value: function exceptionToString(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var l = new _ArrayLogger$2();
	            var e = new ExceptionHandler(l, false);
	            e.call(exception, stackTrace, reason);
	            return l.res.join('\n');
	        }
	    }]);
	    return ExceptionHandler;
	}();

	/**
	 * @stable
	 */
	var BaseException$2 = function (_Error) {
	    inherits(BaseException, _Error);

	    function BaseException() {
	        var message = arguments.length <= 0 || arguments[0] === undefined ? '--' : arguments[0];
	        classCallCheck(this, BaseException);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseException).call(this, message));

	        _this.message = message;
	        _this.stack = new Error(message).stack;
	        return _this;
	    }

	    createClass(BaseException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return BaseException;
	}(Error);
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException$2 = function (_BaseWrappedException) {
	    inherits(WrappedException, _BaseWrappedException);

	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        classCallCheck(this, WrappedException);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(WrappedException).call(this, _wrapperMessage));

	        _this2._wrapperMessage = _wrapperMessage;
	        _this2._originalException = _originalException;
	        _this2._originalStack = _originalStack;
	        _this2._context = _context;
	        _this2._wrapperStack = new Error(_wrapperMessage).stack;
	        return _this2;
	    }

	    createClass(WrappedException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            return this._wrapperMessage;
	        }
	    }, {
	        key: 'wrapperStack',
	        get: function get() {
	            return this._wrapperStack;
	        }
	    }, {
	        key: 'originalException',
	        get: function get() {
	            return this._originalException;
	        }
	    }, {
	        key: 'originalStack',
	        get: function get() {
	            return this._originalStack;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._context;
	        }
	    }, {
	        key: 'message',
	        get: function get() {
	            return ExceptionHandler$2.exceptionToString(this);
	        }
	    }]);
	    return WrappedException;
	}(BaseWrappedException$2);

	/**
	 * @stable
	 */
	var EVENT_MANAGER_PLUGINS = new OpaqueToken('EventManagerPlugins');
	var EventManager = function () {
	    function EventManager(plugins, _zone) {
	        var _this = this;

	        classCallCheck(this, EventManager);

	        this._zone = _zone;
	        plugins.forEach(function (p) {
	            return p.manager = _this;
	        });
	        this._plugins = ListWrapper$2.reversed(plugins);
	    }

	    createClass(EventManager, [{
	        key: 'addEventListener',
	        value: function addEventListener(element, eventName, handler) {
	            var plugin = this._findPluginFor(eventName);
	            return plugin.addEventListener(element, eventName, handler);
	        }
	    }, {
	        key: 'addGlobalEventListener',
	        value: function addGlobalEventListener(target, eventName, handler) {
	            var plugin = this._findPluginFor(eventName);
	            return plugin.addGlobalEventListener(target, eventName, handler);
	        }
	    }, {
	        key: 'getZone',
	        value: function getZone() {
	            return this._zone;
	        }
	        /** @internal */

	    }, {
	        key: '_findPluginFor',
	        value: function _findPluginFor(eventName) {
	            var plugins = this._plugins;
	            for (var i = 0; i < plugins.length; i++) {
	                var plugin = plugins[i];
	                if (plugin.supports(eventName)) {
	                    return plugin;
	                }
	            }
	            throw new BaseException$2('No event manager plugin found for event ' + eventName);
	        }
	    }]);
	    return EventManager;
	}();
	/** @nocollapse */
	EventManager.decorators = [{ type: Injectable }];
	/** @nocollapse */
	EventManager.ctorParameters = [{ type: Array, decorators: [{ type: Inject, args: [EVENT_MANAGER_PLUGINS] }] }, { type: NgZone }];
	var EventManagerPlugin = function () {
	    function EventManagerPlugin() {
	        classCallCheck(this, EventManagerPlugin);
	    }

	    createClass(EventManagerPlugin, [{
	        key: 'supports',

	        // That is equivalent to having supporting $event.target
	        value: function supports(eventName) {
	            return false;
	        }
	    }, {
	        key: 'addEventListener',
	        value: function addEventListener(element, eventName, handler) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'addGlobalEventListener',
	        value: function addGlobalEventListener(element, eventName, handler) {
	            throw 'not implemented';
	        }
	    }]);
	    return EventManagerPlugin;
	}();

	var _eventNames = {
	    // pan
	    'pan': true,
	    'panstart': true,
	    'panmove': true,
	    'panend': true,
	    'pancancel': true,
	    'panleft': true,
	    'panright': true,
	    'panup': true,
	    'pandown': true,
	    // pinch
	    'pinch': true,
	    'pinchstart': true,
	    'pinchmove': true,
	    'pinchend': true,
	    'pinchcancel': true,
	    'pinchin': true,
	    'pinchout': true,
	    // press
	    'press': true,
	    'pressup': true,
	    // rotate
	    'rotate': true,
	    'rotatestart': true,
	    'rotatemove': true,
	    'rotateend': true,
	    'rotatecancel': true,
	    // swipe
	    'swipe': true,
	    'swipeleft': true,
	    'swiperight': true,
	    'swipeup': true,
	    'swipedown': true,
	    // tap
	    'tap': true
	};
	var HammerGesturesPluginCommon = function (_EventManagerPlugin) {
	    inherits(HammerGesturesPluginCommon, _EventManagerPlugin);

	    function HammerGesturesPluginCommon() {
	        classCallCheck(this, HammerGesturesPluginCommon);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(HammerGesturesPluginCommon).call(this));
	    }

	    createClass(HammerGesturesPluginCommon, [{
	        key: 'supports',
	        value: function supports(eventName) {
	            eventName = eventName.toLowerCase();
	            return StringMapWrapper$2.contains(_eventNames, eventName);
	        }
	    }]);
	    return HammerGesturesPluginCommon;
	}(EventManagerPlugin);

	/**
	 * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
	 * Hammer gestures.
	 *
	 * @experimental
	 */
	var HAMMER_GESTURE_CONFIG = new OpaqueToken('HammerGestureConfig');
	var HammerGestureConfig = function () {
	    function HammerGestureConfig() {
	        classCallCheck(this, HammerGestureConfig);

	        this.events = [];
	        this.overrides = {};
	    }

	    createClass(HammerGestureConfig, [{
	        key: 'buildHammer',
	        value: function buildHammer(element) {
	            var mc = new Hammer(element);
	            mc.get('pinch').set({ enable: true });
	            mc.get('rotate').set({ enable: true });
	            for (var eventName in this.overrides) {
	                mc.get(eventName).set(this.overrides[eventName]);
	            }
	            return mc;
	        }
	    }]);
	    return HammerGestureConfig;
	}();
	/** @nocollapse */
	HammerGestureConfig.decorators = [{ type: Injectable }];
	var HammerGesturesPlugin = function (_HammerGesturesPlugin) {
	    inherits(HammerGesturesPlugin, _HammerGesturesPlugin);

	    function HammerGesturesPlugin(_config) {
	        classCallCheck(this, HammerGesturesPlugin);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(HammerGesturesPlugin).call(this));

	        _this._config = _config;
	        return _this;
	    }

	    createClass(HammerGesturesPlugin, [{
	        key: 'supports',
	        value: function supports(eventName) {
	            if (!get(Object.getPrototypeOf(HammerGesturesPlugin.prototype), 'supports', this).call(this, eventName) && !this.isCustomEvent(eventName)) return false;
	            if (!isPresent$2(window['Hammer'])) {
	                throw new BaseException$2('Hammer.js is not loaded, can not bind ' + eventName + ' event');
	            }
	            return true;
	        }
	    }, {
	        key: 'addEventListener',
	        value: function addEventListener(element, eventName, handler) {
	            var _this2 = this;

	            var zone = this.manager.getZone();
	            eventName = eventName.toLowerCase();
	            return zone.runOutsideAngular(function () {
	                // Creating the manager bind events, must be done outside of angular
	                var mc = _this2._config.buildHammer(element);
	                var callback = function callback(eventObj /** TODO #???? */) {
	                    zone.runGuarded(function () {
	                        handler(eventObj);
	                    });
	                };
	                mc.on(eventName, callback);
	                return function () {
	                    mc.off(eventName, callback);
	                };
	            });
	        }
	    }, {
	        key: 'isCustomEvent',
	        value: function isCustomEvent(eventName) {
	            return this._config.events.indexOf(eventName) > -1;
	        }
	    }]);
	    return HammerGesturesPlugin;
	}(HammerGesturesPluginCommon);
	/** @nocollapse */
	HammerGesturesPlugin.decorators = [{ type: Injectable }];
	/** @nocollapse */
	HammerGesturesPlugin.ctorParameters = [{ type: HammerGestureConfig, decorators: [{ type: Inject, args: [HAMMER_GESTURE_CONFIG] }] }];

	var wtfInit$1 = r.wtfInit;
	var VIEW_ENCAPSULATION_VALUES$1 = r.VIEW_ENCAPSULATION_VALUES;
	var DebugDomRootRenderer$1 = r.DebugDomRootRenderer;
	/**
	 * @experimental bogus marker to pass the ts-api-guardian's check - this api should be public so
	 * this line will go away when that happens
	 */
	var SecurityContext$1 = r.SecurityContext;
	var SanitizationService$1 = r.SanitizationService;
	var NoOpAnimationDriver$1 = r.NoOpAnimationDriver;
	var AnimationDriver$1 = r.AnimationDriver;

	/**
	 * A pattern that recognizes a commonly useful subset of URLs that are safe.
	 *
	 * This regular expression matches a subset of URLs that will not cause script
	 * execution if used in URL context within a HTML document. Specifically, this
	 * regular expression matches if (comment from here on and regex copied from
	 * Soy's EscapingConventions):
	 * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
	 * (2) or no protocol.  A protocol must be followed by a colon. The below
	 *     allows that by allowing colons only after one of the characters [/?#].
	 *     A colon after a hash (#) must be in the fragment.
	 *     Otherwise, a colon after a (?) must be in a query.
	 *     Otherwise, a colon after a single solidus (/) must be in a path.
	 *     Otherwise, a colon after a double solidus (//) must be in the authority
	 *     (before port).
	 *
	 * The pattern disallows &, used in HTML entity declarations before
	 * one of the characters in [/?#]. This disallows HTML entities used in the
	 * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
	 * It also disallows HTML entities in the first path part of a relative path,
	 * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
	 * that. More importantly, it disallows masking of a colon,
	 * e.g. "javascript&#58;...".
	 *
	 * This regular expression was taken from the Closure sanitization library.
	 */
	var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	/** A pattern that matches safe data URLs. Only matches image, video and audio types. */
	var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
	function sanitizeUrl(url) {
	    url = String(url);
	    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;
	    if (isDevMode()) {
	        getDOM().log('WARNING: sanitizing unsafe URL value ' + url + ' (see http://g.co/ng/security#xss)');
	    }
	    return 'unsafe:' + url;
	}
	function sanitizeSrcset(srcset) {
	    srcset = String(srcset);
	    return srcset.split(',').map(function (srcset) {
	        return sanitizeUrl(srcset.trim());
	    }).join(', ');
	}

	/** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */
	var inertElement = null;
	/** Lazily initialized to make sure the DOM adapter gets set before use. */
	var DOM = null;
	/** Returns an HTML element that is guaranteed to not execute code when creating elements in it. */
	function getInertElement() {
	    if (inertElement) return inertElement;
	    DOM = getDOM();
	    // Prefer using <template> element if supported.
	    var templateEl = DOM.createElement('template');
	    if ('content' in templateEl) return templateEl;
	    var doc = DOM.createHtmlDocument();
	    inertElement = DOM.querySelector(doc, 'body');
	    if (inertElement == null) {
	        // usually there should be only one body element in the document, but IE doesn't have any, so we
	        // need to create one.
	        var html = DOM.createElement('html', doc);
	        inertElement = DOM.createElement('body', doc);
	        DOM.appendChild(html, inertElement);
	        DOM.appendChild(doc, html);
	    }
	    return inertElement;
	}
	function tagSet(tags) {
	    var res = {};
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	        for (var _iterator = tags.split(',')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var t = _step.value;

	            res[t.toLowerCase()] = true;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }

	    return res;
	}
	function merge() {
	    var res = {};

	    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
	        sets[_key] = arguments[_key];
	    }

	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;

	    try {
	        for (var _iterator2 = sets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var s = _step2.value;

	            for (var v in s) {
	                if (s.hasOwnProperty(v)) res[v] = true;
	            }
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }

	    return res;
	}
	// Good source of info about elements and attributes
	// http://dev.w3.org/html5/spec/Overview.html#semantics
	// http://simon.html5.org/html-elements
	// Safe Void Elements - HTML5
	// http://dev.w3.org/html5/spec/Overview.html#void-elements
	var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
	// Elements that you can, intentionally, leave open (and which close themselves)
	// http://dev.w3.org/html5/spec/Overview.html#optional-tags
	var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
	var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
	var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
	// Safe Block Elements - HTML5
	var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
	// Inline Elements - HTML5
	var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
	var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
	// Attributes that have href and hence need to be sanitized
	var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
	// Attributes that have special href set hence need to be sanitized
	var SRCSET_ATTRS = tagSet('srcset');
	var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width');
	// NB: This currently conciously doesn't support SVG. SVG sanitization has had several security
	// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
	// innerHTML is required, SVG attributes should be added here.
	// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
	// can be sanitized, but they increase security surface area without a legitimate use case, so they
	// are left out here.
	var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
	/**
	 * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
	 * attributes.
	 */

	var SanitizingHtmlSerializer = function () {
	    function SanitizingHtmlSerializer() {
	        classCallCheck(this, SanitizingHtmlSerializer);

	        this.buf = [];
	    }

	    createClass(SanitizingHtmlSerializer, [{
	        key: 'sanitizeChildren',
	        value: function sanitizeChildren(el) {
	            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
	            // However this code never accesses properties off of `document` before deleting its contents
	            // again, so it shouldn't be vulnerable to DOM clobbering.
	            var current = el.firstChild;
	            while (current) {
	                if (DOM.isElementNode(current)) {
	                    this.startElement(current);
	                } else if (DOM.isTextNode(current)) {
	                    this.chars(DOM.nodeValue(current));
	                }
	                if (DOM.firstChild(current)) {
	                    current = DOM.firstChild(current);
	                    continue;
	                }
	                while (current) {
	                    // Leaving the element. Walk up and to the right, closing tags as we go.
	                    if (DOM.isElementNode(current)) {
	                        this.endElement(DOM.nodeName(current).toLowerCase());
	                    }
	                    if (DOM.nextSibling(current)) {
	                        current = DOM.nextSibling(current);
	                        break;
	                    }
	                    current = DOM.parentElement(current);
	                }
	            }
	            return this.buf.join('');
	        }
	    }, {
	        key: 'startElement',
	        value: function startElement(element) {
	            var _this = this;

	            var tagName = DOM.nodeName(element).toLowerCase();
	            tagName = tagName.toLowerCase();
	            if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.buf.push('<');
	                this.buf.push(tagName);
	                DOM.attributeMap(element).forEach(function (value, attrName) {
	                    var lower = attrName.toLowerCase();
	                    if (!VALID_ATTRS.hasOwnProperty(lower)) return;
	                    // TODO(martinprobst): Special case image URIs for data:image/...
	                    if (URI_ATTRS[lower]) value = sanitizeUrl(value);
	                    if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);
	                    _this.buf.push(' ');
	                    _this.buf.push(attrName);
	                    _this.buf.push('="');
	                    _this.buf.push(encodeEntities(value));
	                    _this.buf.push('"');
	                });
	                this.buf.push('>');
	            }
	        }
	    }, {
	        key: 'endElement',
	        value: function endElement(tagName) {
	            tagName = tagName.toLowerCase();
	            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.buf.push('</');
	                this.buf.push(tagName);
	                this.buf.push('>');
	            }
	        }
	    }, {
	        key: 'chars',
	        value: function chars(_chars /** TODO #9100 */) {
	            this.buf.push(encodeEntities(_chars));
	        }
	    }]);
	    return SanitizingHtmlSerializer;
	}();
	// Regular Expressions for parsing tags and attributes


	var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	// ! to ~ is the ASCII range.
	var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	/**
	 * Escapes all potentially dangerous characters, so that the
	 * resulting string can be safely inserted into attribute or
	 * element text.
	 * @param value
	 * @returns {string} escaped text
	 */
	function encodeEntities(value /** TODO #9100 */) {
	    return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function (match /** TODO #9100 */) {
	        var hi = match.charCodeAt(0);
	        var low = match.charCodeAt(1);
	        return '&#' + ((hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000) + ';';
	    }).replace(NON_ALPHANUMERIC_REGEXP, function (match /** TODO #9100 */) {
	        return '&#' + match.charCodeAt(0) + ';';
	    }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}
	/**
	 * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
	 * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
	 *
	 * This is undesirable since we don't want to allow any of these custom attributes. This method
	 * strips them all.
	 */
	function stripCustomNsAttrs(el) {
	    DOM.attributeMap(el).forEach(function (_, attrName) {
	        if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	            DOM.removeAttribute(el, attrName);
	        }
	    });
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;

	    try {
	        for (var _iterator3 = DOM.childNodesAsList(el)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var n = _step3.value;

	            if (DOM.isElementNode(n)) stripCustomNsAttrs(n);
	        }
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	}
	/**
	 * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
	 * the DOM in a browser environment.
	 */
	function sanitizeHtml(unsafeHtmlInput) {
	    try {
	        var containerEl = getInertElement();
	        // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
	        var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
	        // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
	        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
	        var mXSSAttempts = 5;
	        var parsedHtml = unsafeHtml;
	        do {
	            if (mXSSAttempts === 0) {
	                throw new Error('Failed to sanitize html because the input is unstable');
	            }
	            mXSSAttempts--;
	            unsafeHtml = parsedHtml;
	            DOM.setInnerHTML(containerEl, unsafeHtml);
	            if (DOM.defaultDoc().documentMode) {
	                // strip custom-namespaced attributes on IE<=11
	                stripCustomNsAttrs(containerEl);
	            }
	            parsedHtml = DOM.getInnerHTML(containerEl);
	        } while (unsafeHtml !== parsedHtml);
	        var sanitizer = new SanitizingHtmlSerializer();
	        var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
	        // Clear out the body element.
	        var parent = DOM.getTemplateContent(containerEl) || containerEl;
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;

	        try {
	            for (var _iterator4 = DOM.childNodesAsList(parent)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                var child = _step4.value;

	                DOM.removeChild(parent, child);
	            }
	        } catch (err) {
	            _didIteratorError4 = true;
	            _iteratorError4 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                    _iterator4.return();
	                }
	            } finally {
	                if (_didIteratorError4) {
	                    throw _iteratorError4;
	                }
	            }
	        }

	        if (isDevMode() && safeHtml !== unsafeHtmlInput) {
	            DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
	        }
	        return safeHtml;
	    } catch (e) {
	        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
	        inertElement = null;
	        throw e;
	    }
	}

	/**
	 * Regular expression for safe style values.
	 *
	 * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
	 *
	 * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
	 * font-family) and hence could allow multiple values to get injected, but that should pose no risk
	 * of XSS.
	 *
	 * The function expression checks only for XSS safety, not for CSS validity.
	 *
	 * This regular expression was taken from the Closure sanitization library, and augmented for
	 * transformation values.
	 */
	var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
	var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
	var COLOR_FNS = '(?:rgb|hsl)a?';
	var FN_ARGS = '\\([-0-9.%, a-zA-Z]+\\)';
	var SAFE_STYLE_VALUE = new RegExp('^(' + VALUES + '|(?:' + TRANSFORMATION_FNS + '|' + COLOR_FNS + ')' + FN_ARGS + ')$', 'g');
	/**
	 * Matches a `url(...)` value with an arbitrary argument as long as it does
	 * not contain parentheses.
	 *
	 * The URL value still needs to be sanitized separately.
	 *
	 * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
	 * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
	 * by observing whether scroll bars are displayed, or character ranges used by a font face
	 * definition.
	 *
	 * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
	 * binding a URL value without further cooperation from the page will cause an information leak, and
	 * if so, it is just a leak, not a full blown XSS vulnerability.
	 *
	 * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
	 * code is permissive and allows URLs that sanitize otherwise.
	 */
	var URL_RE = /^url\(([^)]+)\)$/;
	/**
	 * Checks that quotes (" and ') are properly balanced inside a string. Assumes
	 * that neither escape (\) nor any other character that could result in
	 * breaking out of a string parsing context are allowed;
	 * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
	 *
	 * This code was taken from the Closure sanitization library.
	 */
	function hasBalancedQuotes(value) {
	    var outsideSingle = true;
	    var outsideDouble = true;
	    for (var i = 0; i < value.length; i++) {
	        var c = value.charAt(i);
	        if (c === '\'' && outsideDouble) {
	            outsideSingle = !outsideSingle;
	        } else if (c === '"' && outsideSingle) {
	            outsideDouble = !outsideDouble;
	        }
	    }
	    return outsideSingle && outsideDouble;
	}
	/**
	 * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
	 * value) and returns a value that is safe to use in a browser environment.
	 */
	function sanitizeStyle(value) {
	    value = String(value).trim(); // Make sure it's actually a string.
	    if (!value) return '';
	    // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
	    // reasoning behind this.
	    var urlMatch = URL_RE.exec(value);
	    if (urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1] || value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
	        return value; // Safe style values.
	    }
	    if (isDevMode()) {
	        getDOM().log('WARNING: sanitizing unsafe style value ' + value + ' (see http://g.co/ng/security#xss).');
	    }
	    return 'unsafe';
	}

	/**
	 * DomSanitizationService helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
	 * values to be safe to use in the different DOM contexts.
	 *
	 * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
	 * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
	 * the website.
	 *
	 * In specific situations, it might be necessary to disable sanitization, for example if the
	 * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
	 * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
	 * methods, and then binding to that value from the template.
	 *
	 * These situations should be very rare, and extraordinary care must be taken to avoid creating a
	 * Cross Site Scripting (XSS) security bug!
	 *
	 * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
	 * close as possible to the source of the value, to make it easy to verify no security bug is
	 * created by its use.
	 *
	 * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
	 * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
	 * code. The sanitizer leaves safe values intact.
	 *
	 * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
	 * sanitization for the value passed in. Carefully check and audit all values and code paths going
	 * into this call. Make sure any user data is appropriately escaped for this security context.
	 * For more detail, see the [Security Guide](http://g.co/ng/security).
	 *
	 * @stable
	 */
	var DomSanitizationService = function DomSanitizationService() {
	    classCallCheck(this, DomSanitizationService);
	};
	var DomSanitizationServiceImpl = function (_DomSanitizationServi) {
	    inherits(DomSanitizationServiceImpl, _DomSanitizationServi);

	    function DomSanitizationServiceImpl() {
	        classCallCheck(this, DomSanitizationServiceImpl);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(DomSanitizationServiceImpl).apply(this, arguments));
	    }

	    createClass(DomSanitizationServiceImpl, [{
	        key: 'sanitize',
	        value: function sanitize(ctx, value) {
	            if (value == null) return null;
	            switch (ctx) {
	                case SecurityContext$1.NONE:
	                    return value;
	                case SecurityContext$1.HTML:
	                    if (value instanceof SafeHtmlImpl) return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'HTML');
	                    return sanitizeHtml(String(value));
	                case SecurityContext$1.STYLE:
	                    if (value instanceof SafeStyleImpl) return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Style');
	                    return sanitizeStyle(value);
	                case SecurityContext$1.SCRIPT:
	                    if (value instanceof SafeScriptImpl) return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Script');
	                    throw new Error('unsafe value used in a script context');
	                case SecurityContext$1.URL:
	                    if (value instanceof SafeUrlImpl) return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'URL');
	                    return sanitizeUrl(String(value));
	                case SecurityContext$1.RESOURCE_URL:
	                    if (value instanceof SafeResourceUrlImpl) {
	                        return value.changingThisBreaksApplicationSecurity;
	                    }
	                    this.checkNotSafeValue(value, 'ResourceURL');
	                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
	                default:
	                    throw new Error('Unexpected SecurityContext ' + ctx + ' (see http://g.co/ng/security#xss)');
	            }
	        }
	    }, {
	        key: 'checkNotSafeValue',
	        value: function checkNotSafeValue(value, expectedType) {
	            if (value instanceof SafeValueImpl) {
	                throw new Error('Required a safe ' + expectedType + ', got a ' + value.getTypeName() + ' ' + '(see http://g.co/ng/security#xss)');
	            }
	        }
	    }, {
	        key: 'bypassSecurityTrustHtml',
	        value: function bypassSecurityTrustHtml(value) {
	            return new SafeHtmlImpl(value);
	        }
	    }, {
	        key: 'bypassSecurityTrustStyle',
	        value: function bypassSecurityTrustStyle(value) {
	            return new SafeStyleImpl(value);
	        }
	    }, {
	        key: 'bypassSecurityTrustScript',
	        value: function bypassSecurityTrustScript(value) {
	            return new SafeScriptImpl(value);
	        }
	    }, {
	        key: 'bypassSecurityTrustUrl',
	        value: function bypassSecurityTrustUrl(value) {
	            return new SafeUrlImpl(value);
	        }
	    }, {
	        key: 'bypassSecurityTrustResourceUrl',
	        value: function bypassSecurityTrustResourceUrl(value) {
	            return new SafeResourceUrlImpl(value);
	        }
	    }]);
	    return DomSanitizationServiceImpl;
	}(DomSanitizationService);
	/** @nocollapse */
	DomSanitizationServiceImpl.decorators = [{ type: Injectable }];

	var SafeValueImpl = function () {
	    function SafeValueImpl(changingThisBreaksApplicationSecurity) {
	        classCallCheck(this, SafeValueImpl);

	        this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
	        // empty
	    }

	    createClass(SafeValueImpl, [{
	        key: 'toString',
	        value: function toString() {
	            return 'SafeValue must use [property]=binding: ' + this.changingThisBreaksApplicationSecurity + ' (see http://g.co/ng/security#xss)';
	        }
	    }]);
	    return SafeValueImpl;
	}();

	var SafeHtmlImpl = function (_SafeValueImpl) {
	    inherits(SafeHtmlImpl, _SafeValueImpl);

	    function SafeHtmlImpl() {
	        classCallCheck(this, SafeHtmlImpl);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(SafeHtmlImpl).apply(this, arguments));
	    }

	    createClass(SafeHtmlImpl, [{
	        key: 'getTypeName',
	        value: function getTypeName() {
	            return 'HTML';
	        }
	    }]);
	    return SafeHtmlImpl;
	}(SafeValueImpl);

	var SafeStyleImpl = function (_SafeValueImpl2) {
	    inherits(SafeStyleImpl, _SafeValueImpl2);

	    function SafeStyleImpl() {
	        classCallCheck(this, SafeStyleImpl);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(SafeStyleImpl).apply(this, arguments));
	    }

	    createClass(SafeStyleImpl, [{
	        key: 'getTypeName',
	        value: function getTypeName() {
	            return 'Style';
	        }
	    }]);
	    return SafeStyleImpl;
	}(SafeValueImpl);

	var SafeScriptImpl = function (_SafeValueImpl3) {
	    inherits(SafeScriptImpl, _SafeValueImpl3);

	    function SafeScriptImpl() {
	        classCallCheck(this, SafeScriptImpl);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(SafeScriptImpl).apply(this, arguments));
	    }

	    createClass(SafeScriptImpl, [{
	        key: 'getTypeName',
	        value: function getTypeName() {
	            return 'Script';
	        }
	    }]);
	    return SafeScriptImpl;
	}(SafeValueImpl);

	var SafeUrlImpl = function (_SafeValueImpl4) {
	    inherits(SafeUrlImpl, _SafeValueImpl4);

	    function SafeUrlImpl() {
	        classCallCheck(this, SafeUrlImpl);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(SafeUrlImpl).apply(this, arguments));
	    }

	    createClass(SafeUrlImpl, [{
	        key: 'getTypeName',
	        value: function getTypeName() {
	            return 'URL';
	        }
	    }]);
	    return SafeUrlImpl;
	}(SafeValueImpl);

	var SafeResourceUrlImpl = function (_SafeValueImpl5) {
	    inherits(SafeResourceUrlImpl, _SafeValueImpl5);

	    function SafeResourceUrlImpl() {
	        classCallCheck(this, SafeResourceUrlImpl);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(SafeResourceUrlImpl).apply(this, arguments));
	    }

	    createClass(SafeResourceUrlImpl, [{
	        key: 'getTypeName',
	        value: function getTypeName() {
	            return 'ResourceURL';
	        }
	    }]);
	    return SafeResourceUrlImpl;
	}(SafeValueImpl);

	var CAMEL_CASE_REGEXP = /([A-Z])/g;
	var DASH_CASE_REGEXP = /-([a-z])/g;
	function camelCaseToDashCase(input) {
	    return StringWrapper$2.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m /** TODO #9100 */) {
	        return '-' + m[1].toLowerCase();
	    });
	}
	function dashCaseToCamelCase(input) {
	    return StringWrapper$2.replaceAllMapped(input, DASH_CASE_REGEXP, function (m /** TODO #9100 */) {
	        return m[1].toUpperCase();
	    });
	}

	var WebAnimationsPlayer = function () {
	    function WebAnimationsPlayer(_player, totalTime) {
	        var _this = this;

	        classCallCheck(this, WebAnimationsPlayer);

	        this._player = _player;
	        this.totalTime = totalTime;
	        this._subscriptions = [];
	        this._finished = false;
	        this.parentPlayer = null;
	        // this is required to make the player startable at a later time
	        this.reset();
	        this._player.onfinish = function () {
	            return _this._onFinish();
	        };
	    }

	    createClass(WebAnimationsPlayer, [{
	        key: '_onFinish',
	        value: function _onFinish() {
	            if (!this._finished) {
	                this._finished = true;
	                if (!isPresent$2(this.parentPlayer)) {
	                    this.destroy();
	                }
	                this._subscriptions.forEach(function (fn) {
	                    return fn();
	                });
	                this._subscriptions = [];
	            }
	        }
	    }, {
	        key: 'onDone',
	        value: function onDone(fn) {
	            this._subscriptions.push(fn);
	        }
	    }, {
	        key: 'play',
	        value: function play() {
	            this._player.play();
	        }
	    }, {
	        key: 'pause',
	        value: function pause() {
	            this._player.pause();
	        }
	    }, {
	        key: 'finish',
	        value: function finish() {
	            this._onFinish();
	            this._player.finish();
	        }
	    }, {
	        key: 'reset',
	        value: function reset() {
	            this._player.cancel();
	        }
	    }, {
	        key: 'restart',
	        value: function restart() {
	            this.reset();
	            this.play();
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            this.reset();
	            this._onFinish();
	        }
	    }, {
	        key: 'setPosition',
	        value: function setPosition(p /** TODO #9100 */) {
	            this._player.currentTime = p * this.totalTime;
	        }
	    }, {
	        key: 'getPosition',
	        value: function getPosition() {
	            return this._player.currentTime / this.totalTime;
	        }
	    }]);
	    return WebAnimationsPlayer;
	}();

	var WebAnimationsDriver = function () {
	    function WebAnimationsDriver() {
	        classCallCheck(this, WebAnimationsDriver);
	    }

	    createClass(WebAnimationsDriver, [{
	        key: 'animate',
	        value: function animate(element, startingStyles, keyframes, duration, delay, easing) {
	            var anyElm = element;
	            var formattedSteps = [];
	            var startingStyleLookup = {};
	            if (isPresent$2(startingStyles) && startingStyles.styles.length > 0) {
	                startingStyleLookup = _populateStyles(anyElm, startingStyles, {});
	                startingStyleLookup['offset'] = 0;
	                formattedSteps.push(startingStyleLookup);
	            }
	            keyframes.forEach(function (keyframe) {
	                var data = _populateStyles(anyElm, keyframe.styles, startingStyleLookup);
	                data['offset'] = keyframe.offset;
	                formattedSteps.push(data);
	            });
	            // this is a special case when only styles are applied as an
	            // animation. When this occurs we want to animate from start to
	            // end with the same values. Removing the offset and having only
	            // start/end values is suitable enough for the web-animations API
	            if (formattedSteps.length == 1) {
	                var start = formattedSteps[0];
	                start['offset'] = null;
	                formattedSteps = [start, start];
	            }
	            var playerOptions = {
	                'duration': duration,
	                'delay': delay,
	                'easing': easing,
	                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`
	            };
	            var player = this._triggerWebAnimation(anyElm, formattedSteps, playerOptions);
	            return new WebAnimationsPlayer(player, duration);
	        }
	        /** @internal */

	    }, {
	        key: '_triggerWebAnimation',
	        value: function _triggerWebAnimation(elm, keyframes, options) {
	            return elm.animate(keyframes, options);
	        }
	    }]);
	    return WebAnimationsDriver;
	}();
	function _populateStyles(element, styles, defaultStyles) {
	    var data = {};
	    styles.styles.forEach(function (entry) {
	        StringMapWrapper$2.forEach(entry, function (val, prop) {
	            var formattedProp = dashCaseToCamelCase(prop);
	            data[formattedProp] = val == AUTO_STYLE ? _computeStyle(element, formattedProp) : val.toString() + _resolveStyleUnit(val, prop, formattedProp);
	        });
	    });
	    StringMapWrapper$2.forEach(defaultStyles, function (value, prop) {
	        if (!isPresent$2(data[prop])) {
	            data[prop] = value;
	        }
	    });
	    return data;
	}
	function _resolveStyleUnit(val, userProvidedProp, formattedProp) {
	    var unit = '';
	    if (_isPixelDimensionStyle(formattedProp) && val != 0 && val != '0') {
	        if (isNumber$2(val)) {
	            unit = 'px';
	        } else if (_findDimensionalSuffix(val.toString()).length == 0) {
	            throw new BaseException('Please provide a CSS unit value for ' + userProvidedProp + ':' + val);
	        }
	    }
	    return unit;
	}
	var _$0 = 48;
	var _$9 = 57;
	var _$PERIOD = 46;
	function _findDimensionalSuffix(value) {
	    for (var i = 0; i < value.length; i++) {
	        var c = StringWrapper$2.charCodeAt(value, i);
	        if (c >= _$0 && c <= _$9 || c == _$PERIOD) continue;
	        return value.substring(i, value.length);
	    }
	    return '';
	}
	function _isPixelDimensionStyle(prop) {
	    switch (prop) {
	        case 'width':
	        case 'height':
	        case 'minWidth':
	        case 'minHeight':
	        case 'maxWidth':
	        case 'maxHeight':
	        case 'left':
	        case 'top':
	        case 'bottom':
	        case 'right':
	        case 'fontSize':
	        case 'outlineWidth':
	        case 'outlineOffset':
	        case 'paddingTop':
	        case 'paddingLeft':
	        case 'paddingBottom':
	        case 'paddingRight':
	        case 'marginTop':
	        case 'marginLeft':
	        case 'marginBottom':
	        case 'marginRight':
	        case 'borderRadius':
	        case 'borderWidth':
	        case 'borderTopWidth':
	        case 'borderLeftWidth':
	        case 'borderRightWidth':
	        case 'borderBottomWidth':
	        case 'textIndent':
	            return true;
	        default:
	            return false;
	    }
	}
	function _computeStyle(element, prop) {
	    return getDOM().getComputedStyle(element)[prop];
	}

	/**
	 * Provides DOM operations in any browser environment.
	 */
	var GenericBrowserDomAdapter = function (_DomAdapter) {
	    inherits(GenericBrowserDomAdapter, _DomAdapter);

	    function GenericBrowserDomAdapter() {
	        classCallCheck(this, GenericBrowserDomAdapter);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(GenericBrowserDomAdapter).call(this));

	        _this._animationPrefix = null;
	        _this._transitionEnd = null;
	        try {
	            var element = _this.createElement('div', _this.defaultDoc());
	            if (isPresent$2(_this.getStyle(element, 'animationName'))) {
	                _this._animationPrefix = '';
	            } else {
	                var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
	                for (var i = 0; i < domPrefixes.length; i++) {
	                    if (isPresent$2(_this.getStyle(element, domPrefixes[i] + 'AnimationName'))) {
	                        _this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
	                        break;
	                    }
	                }
	            }
	            var transEndEventNames = {
	                WebkitTransition: 'webkitTransitionEnd',
	                MozTransition: 'transitionend',
	                OTransition: 'oTransitionEnd otransitionend',
	                transition: 'transitionend'
	            };
	            StringMapWrapper$2.forEach(transEndEventNames, function (value, key) {
	                if (isPresent$2(_this.getStyle(element, key))) {
	                    _this._transitionEnd = value;
	                }
	            });
	        } catch (e) {
	            _this._animationPrefix = null;
	            _this._transitionEnd = null;
	        }
	        return _this;
	    }

	    createClass(GenericBrowserDomAdapter, [{
	        key: 'getDistributedNodes',
	        value: function getDistributedNodes(el) {
	            return el.getDistributedNodes();
	        }
	    }, {
	        key: 'resolveAndSetHref',
	        value: function resolveAndSetHref(el, baseUrl, href) {
	            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
	        }
	    }, {
	        key: 'supportsDOMEvents',
	        value: function supportsDOMEvents() {
	            return true;
	        }
	    }, {
	        key: 'supportsNativeShadowDOM',
	        value: function supportsNativeShadowDOM() {
	            return isFunction$3(this.defaultDoc().body.createShadowRoot);
	        }
	    }, {
	        key: 'getAnimationPrefix',
	        value: function getAnimationPrefix() {
	            return isPresent$2(this._animationPrefix) ? this._animationPrefix : '';
	        }
	    }, {
	        key: 'getTransitionEnd',
	        value: function getTransitionEnd() {
	            return isPresent$2(this._transitionEnd) ? this._transitionEnd : '';
	        }
	    }, {
	        key: 'supportsAnimation',
	        value: function supportsAnimation() {
	            return isPresent$2(this._animationPrefix) && isPresent$2(this._transitionEnd);
	        }
	    }]);
	    return GenericBrowserDomAdapter;
	}(DomAdapter);

	var _attrToPropMap = {
	    'class': 'className',
	    'innerHtml': 'innerHTML',
	    'readonly': 'readOnly',
	    'tabindex': 'tabIndex'
	};
	var DOM_KEY_LOCATION_NUMPAD = 3;
	// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
	var _keyMap = {
	    // The following values are here for cross-browser compatibility and to match the W3C standard
	    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
	    '\b': 'Backspace',
	    '\t': 'Tab',
	    '\x7F': 'Delete',
	    '\x1B': 'Escape',
	    'Del': 'Delete',
	    'Esc': 'Escape',
	    'Left': 'ArrowLeft',
	    'Right': 'ArrowRight',
	    'Up': 'ArrowUp',
	    'Down': 'ArrowDown',
	    'Menu': 'ContextMenu',
	    'Scroll': 'ScrollLock',
	    'Win': 'OS'
	};
	// There is a bug in Chrome for numeric keypad keys:
	// https://code.google.com/p/chromium/issues/detail?id=155654
	// 1, 2, 3 ... are reported as A, B, C ...
	var _chromeNumKeyPadMap = {
	    'A': '1',
	    'B': '2',
	    'C': '3',
	    'D': '4',
	    'E': '5',
	    'F': '6',
	    'G': '7',
	    'H': '8',
	    'I': '9',
	    'J': '*',
	    'K': '+',
	    'M': '-',
	    'N': '.',
	    'O': '/',
	    '\x60': '0',
	    '\x90': 'NumLock'
	};
	/**
	 * A `DomAdapter` powered by full browser DOM APIs.
	 */
	/* tslint:disable:requireParameterType */
	var BrowserDomAdapter = function (_GenericBrowserDomAda) {
	    inherits(BrowserDomAdapter, _GenericBrowserDomAda);

	    function BrowserDomAdapter() {
	        classCallCheck(this, BrowserDomAdapter);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(BrowserDomAdapter).apply(this, arguments));
	    }

	    createClass(BrowserDomAdapter, [{
	        key: 'parse',
	        value: function parse(templateHtml) {
	            throw new Error('parse not implemented');
	        }
	    }, {
	        key: 'hasProperty',
	        value: function hasProperty(element /** TODO #9100 */, name) {
	            return name in element;
	        }
	    }, {
	        key: 'setProperty',
	        value: function setProperty(el, name, value) {
	            el[name] = value;
	        }
	    }, {
	        key: 'getProperty',
	        value: function getProperty(el, name) {
	            return el[name];
	        }
	    }, {
	        key: 'invoke',
	        value: function invoke(el, methodName, args) {
	            el[methodName].apply(el, args);
	        }
	        // TODO(tbosch): move this into a separate environment class once we have it

	    }, {
	        key: 'logError',
	        value: function logError(error /** TODO #9100 */) {
	            if (window.console.error) {
	                window.console.error(error);
	            } else {
	                window.console.log(error);
	            }
	        }
	    }, {
	        key: 'log',
	        value: function log(error /** TODO #9100 */) {
	            window.console.log(error);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(error /** TODO #9100 */) {
	            if (window.console.group) {
	                window.console.group(error);
	                this.logError(error);
	            } else {
	                window.console.log(error);
	            }
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {
	            if (window.console.groupEnd) {
	                window.console.groupEnd();
	            }
	        }
	    }, {
	        key: 'query',
	        value: function query(selector) {
	            return document.querySelector(selector);
	        }
	    }, {
	        key: 'querySelector',
	        value: function querySelector(el /** TODO #9100 */, selector) {
	            return el.querySelector(selector);
	        }
	    }, {
	        key: 'querySelectorAll',
	        value: function querySelectorAll(el /** TODO #9100 */, selector) {
	            return el.querySelectorAll(selector);
	        }
	    }, {
	        key: 'on',
	        value: function on(el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	            el.addEventListener(evt, listener, false);
	        }
	    }, {
	        key: 'onAndCancel',
	        value: function onAndCancel(el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	            el.addEventListener(evt, listener, false);
	            // Needed to follow Dart's subscription semantic, until fix of
	            // https://code.google.com/p/dart/issues/detail?id=17406
	            return function () {
	                el.removeEventListener(evt, listener, false);
	            };
	        }
	    }, {
	        key: 'dispatchEvent',
	        value: function dispatchEvent(el /** TODO #9100 */, evt /** TODO #9100 */) {
	            el.dispatchEvent(evt);
	        }
	    }, {
	        key: 'createMouseEvent',
	        value: function createMouseEvent(eventType) {
	            var evt = document.createEvent('MouseEvent');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        }
	    }, {
	        key: 'createEvent',
	        value: function createEvent(eventType /** TODO #9100 */) {
	            var evt = document.createEvent('Event');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        }
	    }, {
	        key: 'preventDefault',
	        value: function preventDefault(evt) {
	            evt.preventDefault();
	            evt.returnValue = false;
	        }
	    }, {
	        key: 'isPrevented',
	        value: function isPrevented(evt) {
	            return evt.defaultPrevented || isPresent$2(evt.returnValue) && !evt.returnValue;
	        }
	    }, {
	        key: 'getInnerHTML',
	        value: function getInnerHTML(el /** TODO #9100 */) {
	            return el.innerHTML;
	        }
	    }, {
	        key: 'getTemplateContent',
	        value: function getTemplateContent(el /** TODO #9100 */) {
	            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
	        }
	    }, {
	        key: 'getOuterHTML',
	        value: function getOuterHTML(el /** TODO #9100 */) {
	            return el.outerHTML;
	        }
	    }, {
	        key: 'nodeName',
	        value: function nodeName(node) {
	            return node.nodeName;
	        }
	    }, {
	        key: 'nodeValue',
	        value: function nodeValue(node) {
	            return node.nodeValue;
	        }
	    }, {
	        key: 'type',
	        value: function type(node) {
	            return node.type;
	        }
	    }, {
	        key: 'content',
	        value: function content(node) {
	            if (this.hasProperty(node, 'content')) {
	                return node.content;
	            } else {
	                return node;
	            }
	        }
	    }, {
	        key: 'firstChild',
	        value: function firstChild(el /** TODO #9100 */) {
	            return el.firstChild;
	        }
	    }, {
	        key: 'nextSibling',
	        value: function nextSibling(el /** TODO #9100 */) {
	            return el.nextSibling;
	        }
	    }, {
	        key: 'parentElement',
	        value: function parentElement(el /** TODO #9100 */) {
	            return el.parentNode;
	        }
	    }, {
	        key: 'childNodes',
	        value: function childNodes(el /** TODO #9100 */) {
	            return el.childNodes;
	        }
	    }, {
	        key: 'childNodesAsList',
	        value: function childNodesAsList(el /** TODO #9100 */) {
	            var childNodes = el.childNodes;
	            var res = ListWrapper$2.createFixedSize(childNodes.length);
	            for (var i = 0; i < childNodes.length; i++) {
	                res[i] = childNodes[i];
	            }
	            return res;
	        }
	    }, {
	        key: 'clearNodes',
	        value: function clearNodes(el /** TODO #9100 */) {
	            while (el.firstChild) {
	                el.removeChild(el.firstChild);
	            }
	        }
	    }, {
	        key: 'appendChild',
	        value: function appendChild(el /** TODO #9100 */, node /** TODO #9100 */) {
	            el.appendChild(node);
	        }
	    }, {
	        key: 'removeChild',
	        value: function removeChild(el /** TODO #9100 */, node /** TODO #9100 */) {
	            el.removeChild(node);
	        }
	    }, {
	        key: 'replaceChild',
	        value: function replaceChild(el, newChild /** TODO #9100 */, oldChild /** TODO #9100 */) {
	            el.replaceChild(newChild, oldChild);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(node /** TODO #9100 */) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(node);
	            }
	            return node;
	        }
	    }, {
	        key: 'insertBefore',
	        value: function insertBefore(el /** TODO #9100 */, node /** TODO #9100 */) {
	            el.parentNode.insertBefore(node, el);
	        }
	    }, {
	        key: 'insertAllBefore',
	        value: function insertAllBefore(el /** TODO #9100 */, nodes /** TODO #9100 */) {
	            nodes.forEach(function (n /** TODO #9100 */) {
	                return el.parentNode.insertBefore(n, el);
	            });
	        }
	    }, {
	        key: 'insertAfter',
	        value: function insertAfter(el /** TODO #9100 */, node /** TODO #9100 */) {
	            el.parentNode.insertBefore(node, el.nextSibling);
	        }
	    }, {
	        key: 'setInnerHTML',
	        value: function setInnerHTML(el /** TODO #9100 */, value /** TODO #9100 */) {
	            el.innerHTML = value;
	        }
	    }, {
	        key: 'getText',
	        value: function getText(el /** TODO #9100 */) {
	            return el.textContent;
	        }
	        // TODO(vicb): removed Element type because it does not support StyleElement

	    }, {
	        key: 'setText',
	        value: function setText(el /** TODO #9100 */, value) {
	            el.textContent = value;
	        }
	    }, {
	        key: 'getValue',
	        value: function getValue(el /** TODO #9100 */) {
	            return el.value;
	        }
	    }, {
	        key: 'setValue',
	        value: function setValue(el /** TODO #9100 */, value) {
	            el.value = value;
	        }
	    }, {
	        key: 'getChecked',
	        value: function getChecked(el /** TODO #9100 */) {
	            return el.checked;
	        }
	    }, {
	        key: 'setChecked',
	        value: function setChecked(el /** TODO #9100 */, value) {
	            el.checked = value;
	        }
	    }, {
	        key: 'createComment',
	        value: function createComment(text) {
	            return document.createComment(text);
	        }
	    }, {
	        key: 'createTemplate',
	        value: function createTemplate(html /** TODO #9100 */) {
	            var t = document.createElement('template');
	            t.innerHTML = html;
	            return t;
	        }
	    }, {
	        key: 'createElement',
	        value: function createElement(tagName /* TODO #9100 */) {
	            var doc = arguments.length <= 1 || arguments[1] === undefined ? document : arguments[1];

	            return doc.createElement(tagName);
	        }
	    }, {
	        key: 'createElementNS',
	        value: function createElementNS(ns /* TODO #9100 */, tagName /* TODO #9100 */) {
	            var doc = arguments.length <= 2 || arguments[2] === undefined ? document : arguments[2];

	            return doc.createElementNS(ns, tagName);
	        }
	    }, {
	        key: 'createTextNode',
	        value: function createTextNode(text) {
	            var doc = arguments.length <= 1 || arguments[1] === undefined ? document : arguments[1];
	            return doc.createTextNode(text);
	        }
	    }, {
	        key: 'createScriptTag',
	        value: function createScriptTag(attrName, attrValue) {
	            var doc = arguments.length <= 2 || arguments[2] === undefined ? document : arguments[2];

	            var el = doc.createElement('SCRIPT');
	            el.setAttribute(attrName, attrValue);
	            return el;
	        }
	    }, {
	        key: 'createStyleElement',
	        value: function createStyleElement(css) {
	            var doc = arguments.length <= 1 || arguments[1] === undefined ? document : arguments[1];

	            var style = doc.createElement('style');
	            this.appendChild(style, this.createTextNode(css));
	            return style;
	        }
	    }, {
	        key: 'createShadowRoot',
	        value: function createShadowRoot(el) {
	            return el.createShadowRoot();
	        }
	    }, {
	        key: 'getShadowRoot',
	        value: function getShadowRoot(el) {
	            return el.shadowRoot;
	        }
	    }, {
	        key: 'getHost',
	        value: function getHost(el) {
	            return el.host;
	        }
	    }, {
	        key: 'clone',
	        value: function clone(node) {
	            return node.cloneNode(true);
	        }
	    }, {
	        key: 'getElementsByClassName',
	        value: function getElementsByClassName(element /** TODO #9100 */, name) {
	            return element.getElementsByClassName(name);
	        }
	    }, {
	        key: 'getElementsByTagName',
	        value: function getElementsByTagName(element /** TODO #9100 */, name) {
	            return element.getElementsByTagName(name);
	        }
	    }, {
	        key: 'classList',
	        value: function classList(element /** TODO #9100 */) {
	            return Array.prototype.slice.call(element.classList, 0);
	        }
	    }, {
	        key: 'addClass',
	        value: function addClass(element /** TODO #9100 */, className) {
	            element.classList.add(className);
	        }
	    }, {
	        key: 'removeClass',
	        value: function removeClass(element /** TODO #9100 */, className) {
	            element.classList.remove(className);
	        }
	    }, {
	        key: 'hasClass',
	        value: function hasClass(element /** TODO #9100 */, className) {
	            return element.classList.contains(className);
	        }
	    }, {
	        key: 'setStyle',
	        value: function setStyle(element /** TODO #9100 */, styleName, styleValue) {
	            element.style[styleName] = styleValue;
	        }
	    }, {
	        key: 'removeStyle',
	        value: function removeStyle(element /** TODO #9100 */, stylename) {
	            element.style[stylename] = null;
	        }
	    }, {
	        key: 'getStyle',
	        value: function getStyle(element /** TODO #9100 */, stylename) {
	            return element.style[stylename];
	        }
	    }, {
	        key: 'hasStyle',
	        value: function hasStyle(element /** TODO #9100 */, styleName) {
	            var styleValue = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var value = this.getStyle(element, styleName) || '';
	            return styleValue ? value == styleValue : value.length > 0;
	        }
	    }, {
	        key: 'tagName',
	        value: function tagName(element /** TODO #9100 */) {
	            return element.tagName;
	        }
	    }, {
	        key: 'attributeMap',
	        value: function attributeMap(element /** TODO #9100 */) {
	            var res = new Map();
	            var elAttrs = element.attributes;
	            for (var i = 0; i < elAttrs.length; i++) {
	                var attrib = elAttrs[i];
	                res.set(attrib.name, attrib.value);
	            }
	            return res;
	        }
	    }, {
	        key: 'hasAttribute',
	        value: function hasAttribute(element /** TODO #9100 */, attribute) {
	            return element.hasAttribute(attribute);
	        }
	    }, {
	        key: 'hasAttributeNS',
	        value: function hasAttributeNS(element /** TODO #9100 */, ns, attribute) {
	            return element.hasAttributeNS(ns, attribute);
	        }
	    }, {
	        key: 'getAttribute',
	        value: function getAttribute(element /** TODO #9100 */, attribute) {
	            return element.getAttribute(attribute);
	        }
	    }, {
	        key: 'getAttributeNS',
	        value: function getAttributeNS(element /** TODO #9100 */, ns, name) {
	            return element.getAttributeNS(ns, name);
	        }
	    }, {
	        key: 'setAttribute',
	        value: function setAttribute(element /** TODO #9100 */, name, value) {
	            element.setAttribute(name, value);
	        }
	    }, {
	        key: 'setAttributeNS',
	        value: function setAttributeNS(element /** TODO #9100 */, ns, name, value) {
	            element.setAttributeNS(ns, name, value);
	        }
	    }, {
	        key: 'removeAttribute',
	        value: function removeAttribute(element /** TODO #9100 */, attribute) {
	            element.removeAttribute(attribute);
	        }
	    }, {
	        key: 'removeAttributeNS',
	        value: function removeAttributeNS(element /** TODO #9100 */, ns, name) {
	            element.removeAttributeNS(ns, name);
	        }
	    }, {
	        key: 'templateAwareRoot',
	        value: function templateAwareRoot(el /** TODO #9100 */) {
	            return this.isTemplateElement(el) ? this.content(el) : el;
	        }
	    }, {
	        key: 'createHtmlDocument',
	        value: function createHtmlDocument() {
	            return document.implementation.createHTMLDocument('fakeTitle');
	        }
	    }, {
	        key: 'defaultDoc',
	        value: function defaultDoc() {
	            return document;
	        }
	    }, {
	        key: 'getBoundingClientRect',
	        value: function getBoundingClientRect(el /** TODO #9100 */) {
	            try {
	                return el.getBoundingClientRect();
	            } catch (e) {
	                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
	            }
	        }
	    }, {
	        key: 'getTitle',
	        value: function getTitle() {
	            return document.title;
	        }
	    }, {
	        key: 'setTitle',
	        value: function setTitle(newTitle) {
	            document.title = newTitle || '';
	        }
	    }, {
	        key: 'elementMatches',
	        value: function elementMatches(n /** TODO #9100 */, selector) {
	            var matches = false;
	            if (n instanceof HTMLElement) {
	                if (n.matches) {
	                    matches = n.matches(selector);
	                } else if (n.msMatchesSelector) {
	                    matches = n.msMatchesSelector(selector);
	                } else if (n.webkitMatchesSelector) {
	                    matches = n.webkitMatchesSelector(selector);
	                }
	            }
	            return matches;
	        }
	    }, {
	        key: 'isTemplateElement',
	        value: function isTemplateElement(el) {
	            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
	        }
	    }, {
	        key: 'isTextNode',
	        value: function isTextNode(node) {
	            return node.nodeType === Node.TEXT_NODE;
	        }
	    }, {
	        key: 'isCommentNode',
	        value: function isCommentNode(node) {
	            return node.nodeType === Node.COMMENT_NODE;
	        }
	    }, {
	        key: 'isElementNode',
	        value: function isElementNode(node) {
	            return node.nodeType === Node.ELEMENT_NODE;
	        }
	    }, {
	        key: 'hasShadowRoot',
	        value: function hasShadowRoot(node /** TODO #9100 */) {
	            return node instanceof HTMLElement && isPresent$2(node.shadowRoot);
	        }
	    }, {
	        key: 'isShadowRoot',
	        value: function isShadowRoot(node /** TODO #9100 */) {
	            return node instanceof DocumentFragment;
	        }
	    }, {
	        key: 'importIntoDoc',
	        value: function importIntoDoc(node) {
	            var toImport = node;
	            if (this.isTemplateElement(node)) {
	                toImport = this.content(node);
	            }
	            return document.importNode(toImport, true);
	        }
	    }, {
	        key: 'adoptNode',
	        value: function adoptNode(node) {
	            return document.adoptNode(node);
	        }
	    }, {
	        key: 'getHref',
	        value: function getHref(el) {
	            return el.href;
	        }
	    }, {
	        key: 'getEventKey',
	        value: function getEventKey(event /** TODO #9100 */) {
	            var key = event.key;
	            if (isBlank$2(key)) {
	                key = event.keyIdentifier;
	                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
	                // Safari
	                // cf
	                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
	                if (isBlank$2(key)) {
	                    return 'Unidentified';
	                }
	                if (key.startsWith('U+')) {
	                    key = String.fromCharCode(parseInt(key.substring(2), 16));
	                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
	                        // There is a bug in Chrome for numeric keypad keys:
	                        // https://code.google.com/p/chromium/issues/detail?id=155654
	                        // 1, 2, 3 ... are reported as A, B, C ...
	                        key = _chromeNumKeyPadMap[key];
	                    }
	                }
	            }
	            if (_keyMap.hasOwnProperty(key)) {
	                key = _keyMap[key];
	            }
	            return key;
	        }
	    }, {
	        key: 'getGlobalEventTarget',
	        value: function getGlobalEventTarget(target) {
	            if (target == 'window') {
	                return window;
	            } else if (target == 'document') {
	                return document;
	            } else if (target == 'body') {
	                return document.body;
	            }
	        }
	    }, {
	        key: 'getHistory',
	        value: function getHistory() {
	            return window.history;
	        }
	    }, {
	        key: 'getLocation',
	        value: function getLocation() {
	            return window.location;
	        }
	    }, {
	        key: 'getBaseHref',
	        value: function getBaseHref() {
	            var href = getBaseElementHref();
	            if (isBlank$2(href)) {
	                return null;
	            }
	            return relativePath(href);
	        }
	    }, {
	        key: 'resetBaseElement',
	        value: function resetBaseElement() {
	            baseElement = null;
	        }
	    }, {
	        key: 'getUserAgent',
	        value: function getUserAgent() {
	            return window.navigator.userAgent;
	        }
	    }, {
	        key: 'setData',
	        value: function setData(element /** TODO #9100 */, name, value) {
	            this.setAttribute(element, 'data-' + name, value);
	        }
	    }, {
	        key: 'getData',
	        value: function getData(element /** TODO #9100 */, name) {
	            return this.getAttribute(element, 'data-' + name);
	        }
	    }, {
	        key: 'getComputedStyle',
	        value: function (_getComputedStyle) {
	            function getComputedStyle(_x) {
	                return _getComputedStyle.apply(this, arguments);
	            }

	            getComputedStyle.toString = function () {
	                return _getComputedStyle.toString();
	            };

	            return getComputedStyle;
	        }(function (element /** TODO #9100 */) {
	            return getComputedStyle(element);
	        })
	        // TODO(tbosch): move this into a separate environment class once we have it

	    }, {
	        key: 'setGlobalVar',
	        value: function setGlobalVar(path, value) {
	            setValueOnPath$2(global$3, path, value);
	        }
	    }, {
	        key: 'requestAnimationFrame',
	        value: function requestAnimationFrame(callback /** TODO #9100 */) {
	            return window.requestAnimationFrame(callback);
	        }
	    }, {
	        key: 'cancelAnimationFrame',
	        value: function cancelAnimationFrame(id) {
	            window.cancelAnimationFrame(id);
	        }
	    }, {
	        key: 'supportsWebAnimation',
	        value: function supportsWebAnimation() {
	            return isFunction$3(document.body['animate']);
	        }
	    }, {
	        key: 'performanceNow',
	        value: function performanceNow() {
	            // performance.now() is not available in all browsers, see
	            // http://caniuse.com/#search=performance.now
	            if (isPresent$2(window.performance) && isPresent$2(window.performance.now)) {
	                return window.performance.now();
	            } else {
	                return DateWrapper$2.toMillis(DateWrapper$2.now());
	            }
	        }
	    }, {
	        key: 'supportsCookies',
	        value: function supportsCookies() {
	            return true;
	        }
	    }, {
	        key: 'getCookie',
	        value: function getCookie(name) {
	            return parseCookieValue(document.cookie, name);
	        }
	    }, {
	        key: 'setCookie',
	        value: function setCookie(name, value) {
	            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
	            // not clear other cookies.
	            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
	        }
	    }, {
	        key: 'attrToPropMap',
	        get: function get() {
	            return _attrToPropMap;
	        }
	    }], [{
	        key: 'makeCurrent',
	        value: function makeCurrent() {
	            setRootDomAdapter(new BrowserDomAdapter());
	        }
	    }]);
	    return BrowserDomAdapter;
	}(GenericBrowserDomAdapter);
	var baseElement = null;
	function getBaseElementHref() {
	    if (isBlank$2(baseElement)) {
	        baseElement = document.querySelector('base');
	        if (isBlank$2(baseElement)) {
	            return null;
	        }
	    }
	    return baseElement.getAttribute('href');
	}
	// based on urlUtils.js in AngularJS 1
	var urlParsingNode = null;
	function relativePath(url /** TODO #9100 */) {
	    if (isBlank$2(urlParsingNode)) {
	        urlParsingNode = document.createElement('a');
	    }
	    urlParsingNode.setAttribute('href', url);
	    return urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;
	}
	function parseCookieValue(cookie, name) {
	    name = encodeURIComponent(name);
	    var cookies = cookie.split(';');
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	        for (var _iterator = cookies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var _cookie = _step.value;

	            var _cookie$split = _cookie.split('=', 2);

	            var _cookie$split2 = slicedToArray(_cookie$split, 2);

	            var key = _cookie$split2[0];
	            var value = _cookie$split2[1];

	            if (key.trim() === name) {
	                return decodeURIComponent(value);
	            }
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }

	    return null;
	}

	var PublicTestability = function () {
	    function PublicTestability(testability) {
	        classCallCheck(this, PublicTestability);

	        this._testability = testability;
	    }

	    createClass(PublicTestability, [{
	        key: 'isStable',
	        value: function isStable() {
	            return this._testability.isStable();
	        }
	    }, {
	        key: 'whenStable',
	        value: function whenStable(callback) {
	            this._testability.whenStable(callback);
	        }
	    }, {
	        key: 'findBindings',
	        value: function findBindings(using, provider, exactMatch) {
	            return this.findProviders(using, provider, exactMatch);
	        }
	    }, {
	        key: 'findProviders',
	        value: function findProviders(using, provider, exactMatch) {
	            return this._testability.findBindings(using, provider, exactMatch);
	        }
	    }]);
	    return PublicTestability;
	}();

	var BrowserGetTestability = function () {
	    function BrowserGetTestability() {
	        classCallCheck(this, BrowserGetTestability);
	    }

	    createClass(BrowserGetTestability, [{
	        key: 'addToWindow',
	        value: function addToWindow(registry) {
	            global$3.getAngularTestability = function (elem) {
	                var findInAncestors = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	                var testability = registry.findTestabilityInTree(elem, findInAncestors);
	                if (testability == null) {
	                    throw new Error('Could not find testability for element.');
	                }
	                return new PublicTestability(testability);
	            };
	            global$3.getAllAngularTestabilities = function () {
	                var testabilities = registry.getAllTestabilities();
	                return testabilities.map(function (testability) {
	                    return new PublicTestability(testability);
	                });
	            };
	            global$3.getAllAngularRootElements = function () {
	                return registry.getAllRootElements();
	            };
	            var whenAllStable = function whenAllStable(callback /** TODO #9100 */) {
	                var testabilities = global$3.getAllAngularTestabilities();
	                var count = testabilities.length;
	                var didWork = false;
	                var decrement = function decrement(didWork_ /** TODO #9100 */) {
	                    didWork = didWork || didWork_;
	                    count--;
	                    if (count == 0) {
	                        callback(didWork);
	                    }
	                };
	                testabilities.forEach(function (testability /** TODO #9100 */) {
	                    testability.whenStable(decrement);
	                });
	            };
	            if (!global$3.frameworkStabilizers) {
	                global$3.frameworkStabilizers = ListWrapper$2.createGrowableSize(0);
	            }
	            global$3.frameworkStabilizers.push(whenAllStable);
	        }
	    }, {
	        key: 'findTestabilityInTree',
	        value: function findTestabilityInTree(registry, elem, findInAncestors) {
	            if (elem == null) {
	                return null;
	            }
	            var t = registry.getTestability(elem);
	            if (isPresent$2(t)) {
	                return t;
	            } else if (!findInAncestors) {
	                return null;
	            }
	            if (getDOM().isShadowRoot(elem)) {
	                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
	            }
	            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
	        }
	    }], [{
	        key: 'init',
	        value: function init() {
	            setTestabilityGetter(new BrowserGetTestability());
	        }
	    }]);
	    return BrowserGetTestability;
	}();

	var SharedStylesHost = function () {
	    function SharedStylesHost() {
	        classCallCheck(this, SharedStylesHost);

	        /** @internal */
	        this._styles = [];
	        /** @internal */
	        this._stylesSet = new Set();
	    }

	    createClass(SharedStylesHost, [{
	        key: 'addStyles',
	        value: function addStyles(styles) {
	            var _this = this;

	            var additions = [];
	            styles.forEach(function (style) {
	                if (!SetWrapper$2.has(_this._stylesSet, style)) {
	                    _this._stylesSet.add(style);
	                    _this._styles.push(style);
	                    additions.push(style);
	                }
	            });
	            this.onStylesAdded(additions);
	        }
	    }, {
	        key: 'onStylesAdded',
	        value: function onStylesAdded(additions) {}
	    }, {
	        key: 'getAllStyles',
	        value: function getAllStyles() {
	            return this._styles;
	        }
	    }]);
	    return SharedStylesHost;
	}();
	/** @nocollapse */
	SharedStylesHost.decorators = [{ type: Injectable }];
	/** @nocollapse */
	SharedStylesHost.ctorParameters = [];
	var DomSharedStylesHost = function (_SharedStylesHost) {
	    inherits(DomSharedStylesHost, _SharedStylesHost);

	    function DomSharedStylesHost(doc) {
	        classCallCheck(this, DomSharedStylesHost);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(DomSharedStylesHost).call(this));

	        _this2._hostNodes = new Set();
	        _this2._hostNodes.add(doc.head);
	        return _this2;
	    }
	    /** @internal */


	    createClass(DomSharedStylesHost, [{
	        key: '_addStylesToHost',
	        value: function _addStylesToHost(styles, host) {
	            for (var i = 0; i < styles.length; i++) {
	                var style = styles[i];
	                getDOM().appendChild(host, getDOM().createStyleElement(style));
	            }
	        }
	    }, {
	        key: 'addHost',
	        value: function addHost(hostNode) {
	            this._addStylesToHost(this._styles, hostNode);
	            this._hostNodes.add(hostNode);
	        }
	    }, {
	        key: 'removeHost',
	        value: function removeHost(hostNode) {
	            SetWrapper$2.delete(this._hostNodes, hostNode);
	        }
	    }, {
	        key: 'onStylesAdded',
	        value: function onStylesAdded(additions) {
	            var _this3 = this;

	            this._hostNodes.forEach(function (hostNode) {
	                _this3._addStylesToHost(additions, hostNode);
	            });
	        }
	    }]);
	    return DomSharedStylesHost;
	}(SharedStylesHost);
	/** @nocollapse */
	DomSharedStylesHost.decorators = [{ type: Injectable }];
	/** @nocollapse */
	DomSharedStylesHost.ctorParameters = [{ type: undefined, decorators: [{ type: Inject, args: [DOCUMENT] }] }];

	var NAMESPACE_URIS = {
	    'xlink': 'http://www.w3.org/1999/xlink',
	    'svg': 'http://www.w3.org/2000/svg',
	    'xhtml': 'http://www.w3.org/1999/xhtml'
	};
	var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
	var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/g;
	var DomRootRenderer = function () {
	    function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver) {
	        classCallCheck(this, DomRootRenderer);

	        this.document = document;
	        this.eventManager = eventManager;
	        this.sharedStylesHost = sharedStylesHost;
	        this.animationDriver = animationDriver;
	        this.registeredComponents = new Map();
	    }

	    createClass(DomRootRenderer, [{
	        key: 'renderComponent',
	        value: function renderComponent(componentProto) {
	            var renderer = this.registeredComponents.get(componentProto.id);
	            if (isBlank$2(renderer)) {
	                renderer = new DomRenderer(this, componentProto, this.animationDriver);
	                this.registeredComponents.set(componentProto.id, renderer);
	            }
	            return renderer;
	        }
	    }]);
	    return DomRootRenderer;
	}();
	var DomRootRenderer_ = function (_DomRootRenderer) {
	    inherits(DomRootRenderer_, _DomRootRenderer);

	    function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver) {
	        classCallCheck(this, DomRootRenderer_);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(DomRootRenderer_).call(this, _document, _eventManager, sharedStylesHost, animationDriver));
	    }

	    return DomRootRenderer_;
	}(DomRootRenderer);
	/** @nocollapse */
	DomRootRenderer_.decorators = [{ type: Injectable }];
	/** @nocollapse */
	DomRootRenderer_.ctorParameters = [{ type: undefined, decorators: [{ type: Inject, args: [DOCUMENT] }] }, { type: EventManager }, { type: DomSharedStylesHost }, { type: AnimationDriver$1 }];
	var DomRenderer = function () {
	    function DomRenderer(_rootRenderer, componentProto, _animationDriver) {
	        classCallCheck(this, DomRenderer);

	        this._rootRenderer = _rootRenderer;
	        this.componentProto = componentProto;
	        this._animationDriver = _animationDriver;
	        this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
	        if (componentProto.encapsulation !== ViewEncapsulation.Native) {
	            this._rootRenderer.sharedStylesHost.addStyles(this._styles);
	        }
	        if (this.componentProto.encapsulation === ViewEncapsulation.Emulated) {
	            this._contentAttr = _shimContentAttribute(componentProto.id);
	            this._hostAttr = _shimHostAttribute(componentProto.id);
	        } else {
	            this._contentAttr = null;
	            this._hostAttr = null;
	        }
	    }

	    createClass(DomRenderer, [{
	        key: 'selectRootElement',
	        value: function selectRootElement(selectorOrNode, debugInfo) {
	            var el;
	            if (isString$2(selectorOrNode)) {
	                el = getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
	                if (isBlank$2(el)) {
	                    throw new BaseException$2('The selector "' + selectorOrNode + '" did not match any elements');
	                }
	            } else {
	                el = selectorOrNode;
	            }
	            getDOM().clearNodes(el);
	            return el;
	        }
	    }, {
	        key: 'createElement',
	        value: function createElement(parent, name, debugInfo) {
	            var nsAndName = splitNamespace(name);
	            var el = isPresent$2(nsAndName[0]) ? getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) : getDOM().createElement(nsAndName[1]);
	            if (isPresent$2(this._contentAttr)) {
	                getDOM().setAttribute(el, this._contentAttr, '');
	            }
	            if (isPresent$2(parent)) {
	                getDOM().appendChild(parent, el);
	            }
	            return el;
	        }
	    }, {
	        key: 'createViewRoot',
	        value: function createViewRoot(hostElement) {
	            var nodesParent;
	            if (this.componentProto.encapsulation === ViewEncapsulation.Native) {
	                nodesParent = getDOM().createShadowRoot(hostElement);
	                this._rootRenderer.sharedStylesHost.addHost(nodesParent);
	                for (var i = 0; i < this._styles.length; i++) {
	                    getDOM().appendChild(nodesParent, getDOM().createStyleElement(this._styles[i]));
	                }
	            } else {
	                if (isPresent$2(this._hostAttr)) {
	                    getDOM().setAttribute(hostElement, this._hostAttr, '');
	                }
	                nodesParent = hostElement;
	            }
	            return nodesParent;
	        }
	    }, {
	        key: 'createTemplateAnchor',
	        value: function createTemplateAnchor(parentElement, debugInfo) {
	            var comment = getDOM().createComment(TEMPLATE_COMMENT_TEXT);
	            if (isPresent$2(parentElement)) {
	                getDOM().appendChild(parentElement, comment);
	            }
	            return comment;
	        }
	    }, {
	        key: 'createText',
	        value: function createText(parentElement, value, debugInfo) {
	            var node = getDOM().createTextNode(value);
	            if (isPresent$2(parentElement)) {
	                getDOM().appendChild(parentElement, node);
	            }
	            return node;
	        }
	    }, {
	        key: 'projectNodes',
	        value: function projectNodes(parentElement, nodes) {
	            if (isBlank$2(parentElement)) return;
	            appendNodes(parentElement, nodes);
	        }
	    }, {
	        key: 'attachViewAfter',
	        value: function attachViewAfter(node, viewRootNodes) {
	            moveNodesAfterSibling(node, viewRootNodes);
	        }
	    }, {
	        key: 'detachView',
	        value: function detachView(viewRootNodes) {
	            for (var i = 0; i < viewRootNodes.length; i++) {
	                getDOM().remove(viewRootNodes[i]);
	            }
	        }
	    }, {
	        key: 'destroyView',
	        value: function destroyView(hostElement, viewAllNodes) {
	            if (this.componentProto.encapsulation === ViewEncapsulation.Native && isPresent$2(hostElement)) {
	                this._rootRenderer.sharedStylesHost.removeHost(getDOM().getShadowRoot(hostElement));
	            }
	        }
	    }, {
	        key: 'listen',
	        value: function listen(renderElement, name, callback) {
	            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
	        }
	    }, {
	        key: 'listenGlobal',
	        value: function listenGlobal(target, name, callback) {
	            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
	        }
	    }, {
	        key: 'setElementProperty',
	        value: function setElementProperty(renderElement, propertyName, propertyValue) {
	            getDOM().setProperty(renderElement, propertyName, propertyValue);
	        }
	    }, {
	        key: 'setElementAttribute',
	        value: function setElementAttribute(renderElement, attributeName, attributeValue) {
	            var attrNs;
	            var nsAndName = splitNamespace(attributeName);
	            if (isPresent$2(nsAndName[0])) {
	                attributeName = nsAndName[0] + ':' + nsAndName[1];
	                attrNs = NAMESPACE_URIS[nsAndName[0]];
	            }
	            if (isPresent$2(attributeValue)) {
	                if (isPresent$2(attrNs)) {
	                    getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
	                } else {
	                    getDOM().setAttribute(renderElement, attributeName, attributeValue);
	                }
	            } else {
	                if (isPresent$2(attrNs)) {
	                    getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
	                } else {
	                    getDOM().removeAttribute(renderElement, attributeName);
	                }
	            }
	        }
	    }, {
	        key: 'setBindingDebugInfo',
	        value: function setBindingDebugInfo(renderElement, propertyName, propertyValue) {
	            var dashCasedPropertyName = camelCaseToDashCase(propertyName);
	            if (getDOM().isCommentNode(renderElement)) {
	                var existingBindings = RegExpWrapper$2.firstMatch(TEMPLATE_BINDINGS_EXP, StringWrapper$2.replaceAll(getDOM().getText(renderElement), /\n/g, ''));
	                var parsedBindings = Json$2.parse(existingBindings[1]);
	                parsedBindings[dashCasedPropertyName] = propertyValue;
	                getDOM().setText(renderElement, StringWrapper$2.replace(TEMPLATE_COMMENT_TEXT, '{}', Json$2.stringify(parsedBindings)));
	            } else {
	                this.setElementAttribute(renderElement, propertyName, propertyValue);
	            }
	        }
	    }, {
	        key: 'setElementClass',
	        value: function setElementClass(renderElement, className, isAdd) {
	            if (isAdd) {
	                getDOM().addClass(renderElement, className);
	            } else {
	                getDOM().removeClass(renderElement, className);
	            }
	        }
	    }, {
	        key: 'setElementStyle',
	        value: function setElementStyle(renderElement, styleName, styleValue) {
	            if (isPresent$2(styleValue)) {
	                getDOM().setStyle(renderElement, styleName, stringify$2(styleValue));
	            } else {
	                getDOM().removeStyle(renderElement, styleName);
	            }
	        }
	    }, {
	        key: 'invokeElementMethod',
	        value: function invokeElementMethod(renderElement, methodName, args) {
	            getDOM().invoke(renderElement, methodName, args);
	        }
	    }, {
	        key: 'setText',
	        value: function setText(renderNode, text) {
	            getDOM().setText(renderNode, text);
	        }
	    }, {
	        key: 'animate',
	        value: function animate(element, startingStyles, keyframes, duration, delay, easing) {
	            return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);
	        }
	    }]);
	    return DomRenderer;
	}();
	function moveNodesAfterSibling(sibling /** TODO #9100 */, nodes /** TODO #9100 */) {
	    var parent = getDOM().parentElement(sibling);
	    if (nodes.length > 0 && isPresent$2(parent)) {
	        var nextSibling = getDOM().nextSibling(sibling);
	        if (isPresent$2(nextSibling)) {
	            for (var i = 0; i < nodes.length; i++) {
	                getDOM().insertBefore(nextSibling, nodes[i]);
	            }
	        } else {
	            for (var i = 0; i < nodes.length; i++) {
	                getDOM().appendChild(parent, nodes[i]);
	            }
	        }
	    }
	}
	function appendNodes(parent /** TODO #9100 */, nodes /** TODO #9100 */) {
	    for (var i = 0; i < nodes.length; i++) {
	        getDOM().appendChild(parent, nodes[i]);
	    }
	}
	function decoratePreventDefault(eventHandler) {
	    return function (event /** TODO #9100 */) {
	        var allowDefaultBehavior = eventHandler(event);
	        if (allowDefaultBehavior === false) {
	            // TODO(tbosch): move preventDefault into event plugins...
	            getDOM().preventDefault(event);
	        }
	    };
	}
	var COMPONENT_REGEX = /%COMP%/g;
	var COMPONENT_VARIABLE = '%COMP%';
	var HOST_ATTR = '_nghost-' + COMPONENT_VARIABLE;
	var CONTENT_ATTR = '_ngcontent-' + COMPONENT_VARIABLE;
	function _shimContentAttribute(componentShortId) {
	    return StringWrapper$2.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
	}
	function _shimHostAttribute(componentShortId) {
	    return StringWrapper$2.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentShortId);
	}
	function _flattenStyles(compId, styles, target) {
	    for (var i = 0; i < styles.length; i++) {
	        var style = styles[i];
	        if (isArray$3(style)) {
	            _flattenStyles(compId, style, target);
	        } else {
	            style = StringWrapper$2.replaceAll(style, COMPONENT_REGEX, compId);
	            target.push(style);
	        }
	    }
	    return target;
	}
	var NS_PREFIX_RE = /^:([^:]+):(.+)/g;
	function splitNamespace(name) {
	    if (name[0] != ':') {
	        return [null, name];
	    }
	    var match = RegExpWrapper$2.firstMatch(NS_PREFIX_RE, name);
	    return [match[1], match[2]];
	}

	var CORE_TOKENS = {
	    'ApplicationRef': ApplicationRef,
	    'NgZone': NgZone
	};
	var INSPECT_GLOBAL_NAME = 'ng.probe';
	var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
	/**
	 * Returns a {@link DebugElement} for the given native DOM element, or
	 * null if the given native element does not have an Angular view associated
	 * with it.
	 */
	function inspectNativeElement(element /** TODO #9100 */) {
	    return getDebugNode(element);
	}
	function _createConditionalRootRenderer(rootRenderer /** TODO #9100 */) {
	    if (isDevMode()) {
	        return _createRootRenderer(rootRenderer);
	    }
	    return rootRenderer;
	}
	function _createRootRenderer(rootRenderer /** TODO #9100 */) {
	    getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
	    getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, CORE_TOKENS);
	    return new DebugDomRootRenderer$1(rootRenderer);
	}
	/**
	 * Providers which support debugging Angular applications (e.g. via `ng.probe`).
	 */
	var ELEMENT_PROBE_PROVIDERS = [{ provide: RootRenderer, useFactory: _createConditionalRootRenderer, deps: [DomRootRenderer] }];

	var DomEventsPlugin = function (_EventManagerPlugin) {
	    inherits(DomEventsPlugin, _EventManagerPlugin);

	    function DomEventsPlugin() {
	        classCallCheck(this, DomEventsPlugin);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(DomEventsPlugin).apply(this, arguments));
	    }

	    createClass(DomEventsPlugin, [{
	        key: 'supports',

	        // This plugin should come last in the list of plugins, because it accepts all
	        // events.
	        value: function supports(eventName) {
	            return true;
	        }
	    }, {
	        key: 'addEventListener',
	        value: function addEventListener(element, eventName, handler) {
	            var zone = this.manager.getZone();
	            var outsideHandler = function outsideHandler(event /** TODO #9100 */) {
	                return zone.runGuarded(function () {
	                    return handler(event);
	                });
	            };
	            return this.manager.getZone().runOutsideAngular(function () {
	                return getDOM().onAndCancel(element, eventName, outsideHandler);
	            });
	        }
	    }, {
	        key: 'addGlobalEventListener',
	        value: function addGlobalEventListener(target, eventName, handler) {
	            var element = getDOM().getGlobalEventTarget(target);
	            var zone = this.manager.getZone();
	            var outsideHandler = function outsideHandler(event /** TODO #9100 */) {
	                return zone.runGuarded(function () {
	                    return handler(event);
	                });
	            };
	            return this.manager.getZone().runOutsideAngular(function () {
	                return getDOM().onAndCancel(element, eventName, outsideHandler);
	            });
	        }
	    }]);
	    return DomEventsPlugin;
	}(EventManagerPlugin);
	/** @nocollapse */
	DomEventsPlugin.decorators = [{ type: Injectable }];

	var modifierKeys = ['alt', 'control', 'meta', 'shift'];
	var modifierKeyGetters = {
	    'alt': function alt(event) {
	        return event.altKey;
	    },
	    'control': function control(event) {
	        return event.ctrlKey;
	    },
	    'meta': function meta(event) {
	        return event.metaKey;
	    },
	    'shift': function shift(event) {
	        return event.shiftKey;
	    }
	};
	var KeyEventsPlugin = function (_EventManagerPlugin) {
	    inherits(KeyEventsPlugin, _EventManagerPlugin);

	    function KeyEventsPlugin() {
	        classCallCheck(this, KeyEventsPlugin);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(KeyEventsPlugin).call(this));
	    }

	    createClass(KeyEventsPlugin, [{
	        key: 'supports',
	        value: function supports(eventName) {
	            return isPresent$2(KeyEventsPlugin.parseEventName(eventName));
	        }
	    }, {
	        key: 'addEventListener',
	        value: function addEventListener(element, eventName, handler) {
	            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
	            var outsideHandler = KeyEventsPlugin.eventCallback(element, StringMapWrapper$2.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
	            return this.manager.getZone().runOutsideAngular(function () {
	                return getDOM().onAndCancel(element, StringMapWrapper$2.get(parsedEvent, 'domEventName'), outsideHandler);
	            });
	        }
	    }], [{
	        key: 'parseEventName',
	        value: function parseEventName(eventName) {
	            var parts = eventName.toLowerCase().split('.');
	            var domEventName = parts.shift();
	            if (parts.length === 0 || !(StringWrapper$2.equals(domEventName, 'keydown') || StringWrapper$2.equals(domEventName, 'keyup'))) {
	                return null;
	            }
	            var key = KeyEventsPlugin._normalizeKey(parts.pop());
	            var fullKey = '';
	            modifierKeys.forEach(function (modifierName) {
	                if (ListWrapper$2.contains(parts, modifierName)) {
	                    ListWrapper$2.remove(parts, modifierName);
	                    fullKey += modifierName + '.';
	                }
	            });
	            fullKey += key;
	            if (parts.length != 0 || key.length === 0) {
	                // returning null instead of throwing to let another plugin process the event
	                return null;
	            }
	            var result = StringMapWrapper$2.create();
	            StringMapWrapper$2.set(result, 'domEventName', domEventName);
	            StringMapWrapper$2.set(result, 'fullKey', fullKey);
	            return result;
	        }
	    }, {
	        key: 'getEventFullKey',
	        value: function getEventFullKey(event) {
	            var fullKey = '';
	            var key = getDOM().getEventKey(event);
	            key = key.toLowerCase();
	            if (StringWrapper$2.equals(key, ' ')) {
	                key = 'space'; // for readability
	            } else if (StringWrapper$2.equals(key, '.')) {
	                key = 'dot'; // because '.' is used as a separator in event names
	            }
	            modifierKeys.forEach(function (modifierName) {
	                if (modifierName != key) {
	                    var modifierGetter = StringMapWrapper$2.get(modifierKeyGetters, modifierName);
	                    if (modifierGetter(event)) {
	                        fullKey += modifierName + '.';
	                    }
	                }
	            });
	            fullKey += key;
	            return fullKey;
	        }
	    }, {
	        key: 'eventCallback',
	        value: function eventCallback(element, fullKey, handler, zone) {
	            return function (event /** TODO #9100 */) {
	                if (StringWrapper$2.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
	                    zone.runGuarded(function () {
	                        return handler(event);
	                    });
	                }
	            };
	        }
	        /** @internal */

	    }, {
	        key: '_normalizeKey',
	        value: function _normalizeKey(keyName) {
	            // TODO: switch to a StringMap if the mapping grows too much
	            switch (keyName) {
	                case 'esc':
	                    return 'escape';
	                default:
	                    return keyName;
	            }
	        }
	    }]);
	    return KeyEventsPlugin;
	}(EventManagerPlugin);
	/** @nocollapse */
	KeyEventsPlugin.decorators = [{ type: Injectable }];
	/** @nocollapse */
	KeyEventsPlugin.ctorParameters = [];

	var BROWSER_PLATFORM_MARKER = new OpaqueToken('BrowserPlatformMarker');
	/**
	 * A set of providers to initialize the Angular platform in a web browser.
	 *
	 * Used automatically by `bootstrap`, or can be passed to {@link platform}.
	 *
	 * @experimental API related to bootstrapping are still under review.
	 */
	var BROWSER_PLATFORM_PROVIDERS = [{ provide: BROWSER_PLATFORM_MARKER, useValue: true }, PLATFORM_COMMON_PROVIDERS, { provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true }, { provide: PlatformLocation, useClass: BrowserPlatformLocation }];
	/**
	 * @security Replacing built-in sanitization providers exposes the application to XSS risks.
	 * Attacker-controlled data introduced by an unsanitized provider could expose your
	 * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	 * @experimental
	 */
	var BROWSER_SANITIZATION_PROVIDERS = [{ provide: SanitizationService$1, useExisting: DomSanitizationService }, { provide: DomSanitizationService, useClass: DomSanitizationServiceImpl }];
	/**
	 * A set of providers to initialize an Angular application in a web browser.
	 *
	 * Used automatically by `bootstrap`, or can be passed to {@link PlatformRef.application}.
	 *
	 * @experimental API related to bootstrapping are still under review.
	 */
	var BROWSER_APP_PROVIDERS = [APPLICATION_COMMON_PROVIDERS, FORM_PROVIDERS, BROWSER_SANITIZATION_PROVIDERS, { provide: ExceptionHandler, useFactory: _exceptionHandler, deps: [] }, { provide: DOCUMENT, useFactory: _document, deps: [] }, { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true }, { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true }, { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true }, { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig }, { provide: DomRootRenderer, useClass: DomRootRenderer_ }, { provide: RootRenderer, useExisting: DomRootRenderer }, { provide: SharedStylesHost, useExisting: DomSharedStylesHost }, { provide: AnimationDriver$1, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost, Testability, EventManager, ELEMENT_PROBE_PROVIDERS];
	/**
	 * @experimental API related to bootstrapping are still under review.
	 */
	function browserPlatform() {
	    if (isBlank$2(getPlatform())) {
	        createPlatform(ReflectiveInjector.resolveAndCreate(BROWSER_PLATFORM_PROVIDERS));
	    }
	    return assertPlatform(BROWSER_PLATFORM_MARKER);
	}
	function initDomAdapter() {
	    BrowserDomAdapter.makeCurrent();
	    wtfInit$1();
	    BrowserGetTestability.init();
	}
	function _exceptionHandler() {
	    return new ExceptionHandler(getDOM());
	}
	function _document() {
	    return getDOM().defaultDoc();
	}
	function _resolveDefaultAnimationDriver() {
	    if (getDOM().supportsWebAnimation()) {
	        return new WebAnimationsDriver();
	    }
	    return new NoOpAnimationDriver$1();
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PromiseCompleter$2 = function PromiseCompleter() {
	    var _this = this;

	    classCallCheck(this, PromiseCompleter);

	    this.promise = new Promise(function (res, rej) {
	        _this.resolve = res;
	        _this.reject = rej;
	    });
	};
	var PromiseWrapper$2 = function () {
	    function PromiseWrapper() {
	        classCallCheck(this, PromiseWrapper);
	    }

	    createClass(PromiseWrapper, null, [{
	        key: "resolve",
	        value: function resolve(obj) {
	            return Promise.resolve(obj);
	        }
	    }, {
	        key: "reject",
	        value: function reject(obj, _) {
	            return Promise.reject(obj);
	        }
	        // Note: We can't rename this method into `catch`, as this is not a valid
	        // method name in Dart.

	    }, {
	        key: "catchError",
	        value: function catchError(promise, onError) {
	            return promise.catch(onError);
	        }
	    }, {
	        key: "all",
	        value: function all(promises) {
	            if (promises.length == 0) return Promise.resolve([]);
	            return Promise.all(promises);
	        }
	    }, {
	        key: "then",
	        value: function then(promise, success, rejection) {
	            return promise.then(success, rejection);
	        }
	    }, {
	        key: "wrap",
	        value: function wrap(computation) {
	            return new Promise(function (res, rej) {
	                try {
	                    res(computation());
	                } catch (e) {
	                    rej(e);
	                }
	            });
	        }
	    }, {
	        key: "scheduleMicrotask",
	        value: function scheduleMicrotask(computation) {
	            PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) {});
	        }
	    }, {
	        key: "completer",
	        value: function completer() {
	            return new PromiseCompleter$2();
	        }
	    }]);
	    return PromiseWrapper;
	}();

	var TimerWrapper$2 = function () {
	    function TimerWrapper() {
	        classCallCheck(this, TimerWrapper);
	    }

	    createClass(TimerWrapper, null, [{
	        key: 'setTimeout',
	        value: function setTimeout(fn, millis) {
	            return global$3.setTimeout(fn, millis);
	        }
	    }, {
	        key: 'clearTimeout',
	        value: function clearTimeout(id) {
	            global$3.clearTimeout(id);
	        }
	    }, {
	        key: 'setInterval',
	        value: function setInterval(fn, millis) {
	            return global$3.setInterval(fn, millis);
	        }
	    }, {
	        key: 'clearInterval',
	        value: function clearInterval(id) {
	            global$3.clearInterval(id);
	        }
	    }]);
	    return TimerWrapper;
	}();
	var ObservableWrapper$2 = function () {
	    function ObservableWrapper() {
	        classCallCheck(this, ObservableWrapper);
	    }

	    createClass(ObservableWrapper, null, [{
	        key: 'subscribe',

	        // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	        value: function subscribe(emitter, onNext, onError) {
	            var onComplete = arguments.length <= 3 || arguments[3] === undefined ? function () {} : arguments[3];

	            onError = typeof onError === 'function' && onError || noop$2;
	            onComplete = typeof onComplete === 'function' && onComplete || noop$2;
	            return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
	        }
	    }, {
	        key: 'isObservable',
	        value: function isObservable(obs) {
	            return !!obs.subscribe;
	        }
	        /**
	         * Returns whether `obs` has any subscribers listening to events.
	         */

	    }, {
	        key: 'hasSubscribers',
	        value: function hasSubscribers(obs) {
	            return obs.observers.length > 0;
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {
	            subscription.unsubscribe();
	        }
	        /**
	         * @deprecated - use callEmit() instead
	         */

	    }, {
	        key: 'callNext',
	        value: function callNext(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callEmit',
	        value: function callEmit(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callError',
	        value: function callError(emitter, error) {
	            emitter.error(error);
	        }
	    }, {
	        key: 'callComplete',
	        value: function callComplete(emitter) {
	            emitter.complete();
	        }
	    }, {
	        key: 'fromPromise',
	        value: function fromPromise(promise) {
	            return PromiseObservable.create(promise);
	        }
	    }, {
	        key: 'toPromise',
	        value: function toPromise(obj) {
	            return _toPromise.call(obj);
	        }
	    }]);
	    return ObservableWrapper;
	}();
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter$2 = function (_Subject) {
	    inherits(EventEmitter, _Subject);

	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */

	    function EventEmitter() {
	        var isAsync = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	        classCallCheck(this, EventEmitter);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EventEmitter).call(this));

	        _this.__isAsync = isAsync;
	        return _this;
	    }

	    createClass(EventEmitter, [{
	        key: 'emit',
	        value: function emit(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	        /**
	         * @deprecated - use .emit(value) instead
	         */

	    }, {
	        key: 'next',
	        value: function next(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	    }, {
	        key: 'subscribe',
	        value: function subscribe(generatorOrNext, error, complete) {
	            var schedulerFn = void 0;
	            var errorFn = function errorFn(err) {
	                return null;
	            };
	            var completeFn = function completeFn() {
	                return null;
	            };
	            if (generatorOrNext && (typeof generatorOrNext === 'undefined' ? 'undefined' : _typeof(generatorOrNext)) === 'object') {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext.next(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext.next(value);
	                };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return generatorOrNext.error(err);
	                        });
	                    } : function (err) {
	                        generatorOrNext.error(err);
	                    };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return generatorOrNext.complete();
	                        });
	                    } : function () {
	                        generatorOrNext.complete();
	                    };
	                }
	            } else {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext(value);
	                };
	                if (error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return error(err);
	                        });
	                    } : function (err) {
	                        error(err);
	                    };
	                }
	                if (complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return complete();
	                        });
	                    } : function () {
	                        complete();
	                    };
	                }
	            }
	            return get(Object.getPrototypeOf(EventEmitter.prototype), 'subscribe', this).call(this, schedulerFn, errorFn, completeFn);
	        }
	    }]);
	    return EventEmitter;
	}(Subject);

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Message Bus is a low level API used to communicate between the UI and the background.
	 * Communication is based on a channel abstraction. Messages published in a
	 * given channel to one MessageBusSink are received on the same channel
	 * by the corresponding MessageBusSource.
	 *
	 * @experimental WebWorker support in Angular is currenlty experimental.
	 */
	var MessageBus = function MessageBus() {
	  classCallCheck(this, MessageBus);
	};

	var RenderStore = function () {
	    function RenderStore() {
	        classCallCheck(this, RenderStore);

	        this._nextIndex = 0;
	        this._lookupById = new Map();
	        this._lookupByObject = new Map();
	    }

	    createClass(RenderStore, [{
	        key: 'allocateId',
	        value: function allocateId() {
	            return this._nextIndex++;
	        }
	    }, {
	        key: 'store',
	        value: function store(obj, id) {
	            this._lookupById.set(id, obj);
	            this._lookupByObject.set(obj, id);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(obj) {
	            var index = this._lookupByObject.get(obj);
	            this._lookupByObject.delete(obj);
	            this._lookupById.delete(index);
	        }
	    }, {
	        key: 'deserialize',
	        value: function deserialize(id) {
	            if (id == null) {
	                return null;
	            }
	            if (!this._lookupById.has(id)) {
	                return null;
	            }
	            return this._lookupById.get(id);
	        }
	    }, {
	        key: 'serialize',
	        value: function serialize(obj) {
	            if (obj == null) {
	                return null;
	            }
	            return this._lookupByObject.get(obj);
	        }
	    }]);
	    return RenderStore;
	}();
	/** @nocollapse */
	RenderStore.decorators = [{ type: Injectable }];
	/** @nocollapse */
	RenderStore.ctorParameters = [];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// This file contains interface versions of browser types that can be serialized to Plain Old
	// JavaScript Objects
	var LocationType = function LocationType(href, protocol, host, hostname, port, pathname, search, hash, origin) {
	    classCallCheck(this, LocationType);

	    this.href = href;
	    this.protocol = protocol;
	    this.host = host;
	    this.hostname = hostname;
	    this.port = port;
	    this.pathname = pathname;
	    this.search = search;
	    this.hash = hash;
	    this.origin = origin;
	};

	// PRIMITIVE is any type that does not need to be serialized (string, number, boolean)
	// We set it to String so that it is considered a Type.
	/**
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	var PRIMITIVE = String;
	var Serializer = function () {
	    function Serializer(_renderStore) {
	        classCallCheck(this, Serializer);

	        this._renderStore = _renderStore;
	    }

	    createClass(Serializer, [{
	        key: 'serialize',
	        value: function serialize(obj, type) {
	            var _this = this;

	            if (!isPresent$2(obj)) {
	                return null;
	            }
	            if (isArray$3(obj)) {
	                return obj.map(function (v) {
	                    return _this.serialize(v, type);
	                });
	            }
	            if (type == PRIMITIVE) {
	                return obj;
	            }
	            if (type == RenderStoreObject) {
	                return this._renderStore.serialize(obj);
	            } else if (type === RenderComponentType) {
	                return this._serializeRenderComponentType(obj);
	            } else if (type === ViewEncapsulation) {
	                return serializeEnum$2(obj);
	            } else if (type === LocationType) {
	                return this._serializeLocation(obj);
	            } else {
	                throw new BaseException$2('No serializer for ' + type.toString());
	            }
	        }
	    }, {
	        key: 'deserialize',
	        value: function deserialize(map, type, data) {
	            var _this2 = this;

	            if (!isPresent$2(map)) {
	                return null;
	            }
	            if (isArray$3(map)) {
	                var obj = [];
	                map.forEach(function (val) {
	                    return obj.push(_this2.deserialize(val, type, data));
	                });
	                return obj;
	            }
	            if (type == PRIMITIVE) {
	                return map;
	            }
	            if (type == RenderStoreObject) {
	                return this._renderStore.deserialize(map);
	            } else if (type === RenderComponentType) {
	                return this._deserializeRenderComponentType(map);
	            } else if (type === ViewEncapsulation) {
	                return VIEW_ENCAPSULATION_VALUES$1[map];
	            } else if (type === LocationType) {
	                return this._deserializeLocation(map);
	            } else {
	                throw new BaseException$2('No deserializer for ' + type.toString());
	            }
	        }
	    }, {
	        key: '_serializeLocation',
	        value: function _serializeLocation(loc) {
	            return {
	                'href': loc.href,
	                'protocol': loc.protocol,
	                'host': loc.host,
	                'hostname': loc.hostname,
	                'port': loc.port,
	                'pathname': loc.pathname,
	                'search': loc.search,
	                'hash': loc.hash,
	                'origin': loc.origin
	            };
	        }
	    }, {
	        key: '_deserializeLocation',
	        value: function _deserializeLocation(loc) {
	            return new LocationType(loc['href'], loc['protocol'], loc['host'], loc['hostname'], loc['port'], loc['pathname'], loc['search'], loc['hash'], loc['origin']);
	        }
	    }, {
	        key: '_serializeRenderComponentType',
	        value: function _serializeRenderComponentType(obj) {
	            return {
	                'id': obj.id,
	                'templateUrl': obj.templateUrl,
	                'slotCount': obj.slotCount,
	                'encapsulation': this.serialize(obj.encapsulation, ViewEncapsulation),
	                'styles': this.serialize(obj.styles, PRIMITIVE)
	            };
	        }
	    }, {
	        key: '_deserializeRenderComponentType',
	        value: function _deserializeRenderComponentType(map) {
	            return new RenderComponentType(map['id'], map['templateUrl'], map['slotCount'], this.deserialize(map['encapsulation'], ViewEncapsulation), this.deserialize(map['styles'], PRIMITIVE));
	        }
	    }]);
	    return Serializer;
	}();
	/** @nocollapse */
	Serializer.decorators = [{ type: Injectable }];
	/** @nocollapse */
	Serializer.ctorParameters = [{ type: RenderStore }];
	var RenderStoreObject = function RenderStoreObject() {
	    classCallCheck(this, RenderStoreObject);
	};

	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */
	var ClientMessageBrokerFactory = function ClientMessageBrokerFactory() {
	    classCallCheck(this, ClientMessageBrokerFactory);
	};
	var ClientMessageBrokerFactory_ = function (_ClientMessageBrokerF) {
	    inherits(ClientMessageBrokerFactory_, _ClientMessageBrokerF);

	    function ClientMessageBrokerFactory_(_messageBus, _serializer) {
	        classCallCheck(this, ClientMessageBrokerFactory_);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ClientMessageBrokerFactory_).call(this));

	        _this._messageBus = _messageBus;
	        _this._serializer = _serializer;
	        return _this;
	    }
	    /**
	     * Initializes the given channel and attaches a new {@link ClientMessageBroker} to it.
	     */


	    createClass(ClientMessageBrokerFactory_, [{
	        key: 'createMessageBroker',
	        value: function createMessageBroker(channel) {
	            var runInZone = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            this._messageBus.initChannel(channel, runInZone);
	            return new ClientMessageBroker_(this._messageBus, this._serializer, channel);
	        }
	    }]);
	    return ClientMessageBrokerFactory_;
	}(ClientMessageBrokerFactory);
	/** @nocollapse */
	ClientMessageBrokerFactory_.decorators = [{ type: Injectable }];
	/** @nocollapse */
	ClientMessageBrokerFactory_.ctorParameters = [{ type: MessageBus }, { type: Serializer }];
	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */
	var ClientMessageBroker = function ClientMessageBroker() {
	    classCallCheck(this, ClientMessageBroker);
	};
	var ClientMessageBroker_ = function (_ClientMessageBroker) {
	    inherits(ClientMessageBroker_, _ClientMessageBroker);

	    function ClientMessageBroker_(messageBus, _serializer, channel /** TODO #9100 */) {
	        classCallCheck(this, ClientMessageBroker_);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(ClientMessageBroker_).call(this));

	        _this2.channel = channel;
	        _this2._pending = new Map();
	        _this2._sink = messageBus.to(channel);
	        _this2._serializer = _serializer;
	        var source = messageBus.from(channel);
	        ObservableWrapper$2.subscribe(source, function (message) {
	            return _this2._handleMessage(message);
	        });
	        return _this2;
	    }

	    createClass(ClientMessageBroker_, [{
	        key: '_generateMessageId',
	        value: function _generateMessageId(name) {
	            var time = stringify$2(DateWrapper$2.toMillis(DateWrapper$2.now()));
	            var iteration = 0;
	            var id = name + time + stringify$2(iteration);
	            while (isPresent$2(this._pending[id])) {
	                id = '' + name + time + iteration;
	                iteration++;
	            }
	            return id;
	        }
	    }, {
	        key: 'runOnService',
	        value: function runOnService(args, returnType) {
	            var _this3 = this;

	            var fnArgs = [];
	            if (isPresent$2(args.args)) {
	                args.args.forEach(function (argument) {
	                    if (argument.type != null) {
	                        fnArgs.push(_this3._serializer.serialize(argument.value, argument.type));
	                    } else {
	                        fnArgs.push(argument.value);
	                    }
	                });
	            }
	            var promise;
	            var id = null;
	            if (returnType != null) {
	                var completer = PromiseWrapper$2.completer();
	                id = this._generateMessageId(args.method);
	                this._pending.set(id, completer);
	                PromiseWrapper$2.catchError(completer.promise, function (err, stack) {
	                    print$2(err);
	                    completer.reject(err, stack);
	                });
	                promise = PromiseWrapper$2.then(completer.promise, function (value) {
	                    if (_this3._serializer == null) {
	                        return value;
	                    } else {
	                        return _this3._serializer.deserialize(value, returnType);
	                    }
	                });
	            } else {
	                promise = null;
	            }
	            // TODO(jteplitz602): Create a class for these messages so we don't keep using StringMap #3685
	            var message = { 'method': args.method, 'args': fnArgs };
	            if (id != null) {
	                message['id'] = id;
	            }
	            ObservableWrapper$2.callEmit(this._sink, message);
	            return promise;
	        }
	    }, {
	        key: '_handleMessage',
	        value: function _handleMessage(message) {
	            var data = new MessageData(message);
	            // TODO(jteplitz602): replace these strings with messaging constants #3685
	            if (StringWrapper$2.equals(data.type, 'result') || StringWrapper$2.equals(data.type, 'error')) {
	                var id = data.id;
	                if (this._pending.has(id)) {
	                    if (StringWrapper$2.equals(data.type, 'result')) {
	                        this._pending.get(id).resolve(data.value);
	                    } else {
	                        this._pending.get(id).reject(data.value, null);
	                    }
	                    this._pending.delete(id);
	                }
	            }
	        }
	    }]);
	    return ClientMessageBroker_;
	}(ClientMessageBroker);

	var MessageData = function () {
	    function MessageData(data) {
	        classCallCheck(this, MessageData);

	        this.type = StringMapWrapper$2.get(data, 'type');
	        this.id = this._getValueIfPresent(data, 'id');
	        this.value = this._getValueIfPresent(data, 'value');
	    }
	    /**
	     * Returns the value from the StringMap if present. Otherwise returns null
	     * @internal
	     */


	    createClass(MessageData, [{
	        key: '_getValueIfPresent',
	        value: function _getValueIfPresent(data, key) {
	            if (StringMapWrapper$2.contains(data, key)) {
	                return StringMapWrapper$2.get(data, key);
	            } else {
	                return null;
	            }
	        }
	    }]);
	    return MessageData;
	}();
	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */


	var FnArg = function FnArg(value /** TODO #9100 */, type) {
	    classCallCheck(this, FnArg);

	    this.value = value;
	    this.type = type;
	};
	/**
	 * @experimental WebWorker support in Angular is experimental.
	 */
	var UiArguments = function UiArguments(method, args) {
	    classCallCheck(this, UiArguments);

	    this.method = method;
	    this.args = args;
	};

	/**
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	var ServiceMessageBrokerFactory = function ServiceMessageBrokerFactory() {
	    classCallCheck(this, ServiceMessageBrokerFactory);
	};
	var ServiceMessageBrokerFactory_ = function (_ServiceMessageBroker) {
	    inherits(ServiceMessageBrokerFactory_, _ServiceMessageBroker);

	    function ServiceMessageBrokerFactory_(_messageBus, _serializer) {
	        classCallCheck(this, ServiceMessageBrokerFactory_);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ServiceMessageBrokerFactory_).call(this));

	        _this._messageBus = _messageBus;
	        _this._serializer = _serializer;
	        return _this;
	    }

	    createClass(ServiceMessageBrokerFactory_, [{
	        key: 'createMessageBroker',
	        value: function createMessageBroker(channel) {
	            var runInZone = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            this._messageBus.initChannel(channel, runInZone);
	            return new ServiceMessageBroker_(this._messageBus, this._serializer, channel);
	        }
	    }]);
	    return ServiceMessageBrokerFactory_;
	}(ServiceMessageBrokerFactory);
	/** @nocollapse */
	ServiceMessageBrokerFactory_.decorators = [{ type: Injectable }];
	/** @nocollapse */
	ServiceMessageBrokerFactory_.ctorParameters = [{ type: MessageBus }, { type: Serializer }];
	/**
	 * Helper class for UIComponents that allows components to register methods.
	 * If a registered method message is received from the broker on the worker,
	 * the UIMessageBroker deserializes its arguments and calls the registered method.
	 * If that method returns a promise, the UIMessageBroker returns the result to the worker.
	 *
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	var ServiceMessageBroker = function ServiceMessageBroker() {
	    classCallCheck(this, ServiceMessageBroker);
	};
	var ServiceMessageBroker_ = function (_ServiceMessageBroker2) {
	    inherits(ServiceMessageBroker_, _ServiceMessageBroker2);

	    function ServiceMessageBroker_(messageBus, _serializer, channel /** TODO #9100 */) {
	        classCallCheck(this, ServiceMessageBroker_);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(ServiceMessageBroker_).call(this));

	        _this2._serializer = _serializer;
	        _this2.channel = channel;
	        _this2._methods = new Map$3();
	        _this2._sink = messageBus.to(channel);
	        var source = messageBus.from(channel);
	        ObservableWrapper$2.subscribe(source, function (message) {
	            return _this2._handleMessage(message);
	        });
	        return _this2;
	    }

	    createClass(ServiceMessageBroker_, [{
	        key: 'registerMethod',
	        value: function registerMethod(methodName, signature, method, returnType) {
	            var _this3 = this;

	            this._methods.set(methodName, function (message) {
	                var serializedArgs = message.args;
	                var numArgs = signature === null ? 0 : signature.length;
	                var deserializedArgs = ListWrapper$2.createFixedSize(numArgs);
	                for (var i = 0; i < numArgs; i++) {
	                    var serializedArg = serializedArgs[i];
	                    deserializedArgs[i] = _this3._serializer.deserialize(serializedArg, signature[i]);
	                }
	                var promise = FunctionWrapper$2.apply(method, deserializedArgs);
	                if (isPresent$2(returnType) && isPresent$2(promise)) {
	                    _this3._wrapWebWorkerPromise(message.id, promise, returnType);
	                }
	            });
	        }
	    }, {
	        key: '_handleMessage',
	        value: function _handleMessage(map) {
	            var message = new ReceivedMessage(map);
	            if (this._methods.has(message.method)) {
	                this._methods.get(message.method)(message);
	            }
	        }
	    }, {
	        key: '_wrapWebWorkerPromise',
	        value: function _wrapWebWorkerPromise(id, promise, type) {
	            var _this4 = this;

	            PromiseWrapper$2.then(promise, function (result) {
	                ObservableWrapper$2.callEmit(_this4._sink, { 'type': 'result', 'value': _this4._serializer.serialize(result, type), 'id': id });
	            });
	        }
	    }]);
	    return ServiceMessageBroker_;
	}(ServiceMessageBroker);
	/**
	 * @experimental WebWorker support in Angular is currently experimental.
	 */
	var ReceivedMessage = function ReceivedMessage(data) {
	    classCallCheck(this, ReceivedMessage);

	    this.method = data['method'];
	    this.args = data['args'];
	    this.id = data['id'];
	    this.type = data['type'];
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * All channels used by angular's WebWorker components are listed here.
	 * You should not use these channels in your application code.
	 */
	var RENDERER_CHANNEL = 'ng-Renderer';
	var EVENT_CHANNEL = 'ng-Events';
	var ROUTER_CHANNEL = 'ng-Router';

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// no deserialization is necessary in TS.
	// This is only here to match dart interface
	function deserializeGenericEvent(serializedEvent) {
	  return serializedEvent;
	}

	var WebWorkerPlatformLocation = function (_PlatformLocation) {
	    inherits(WebWorkerPlatformLocation, _PlatformLocation);

	    function WebWorkerPlatformLocation(brokerFactory, bus, _serializer) {
	        classCallCheck(this, WebWorkerPlatformLocation);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(WebWorkerPlatformLocation).call(this));

	        _this._serializer = _serializer;
	        _this._popStateListeners = [];
	        _this._hashChangeListeners = [];
	        _this._location = null;
	        _this._broker = brokerFactory.createMessageBroker(ROUTER_CHANNEL);
	        _this._channelSource = bus.from(ROUTER_CHANNEL);
	        ObservableWrapper$2.subscribe(_this._channelSource, function (msg) {
	            var listeners = null;
	            if (StringMapWrapper$2.contains(msg, 'event')) {
	                var type = msg['event']['type'];
	                if (StringWrapper$2.equals(type, 'popstate')) {
	                    listeners = _this._popStateListeners;
	                } else if (StringWrapper$2.equals(type, 'hashchange')) {
	                    listeners = _this._hashChangeListeners;
	                }
	                if (listeners !== null) {
	                    (function () {
	                        var e = deserializeGenericEvent(msg['event']);
	                        // There was a popState or hashChange event, so the location object thas been updated
	                        _this._location = _this._serializer.deserialize(msg['location'], LocationType);
	                        listeners.forEach(function (fn) {
	                            return fn(e);
	                        });
	                    })();
	                }
	            }
	        });
	        return _this;
	    }
	    /** @internal **/


	    createClass(WebWorkerPlatformLocation, [{
	        key: 'init',
	        value: function init() {
	            var _this2 = this;

	            var args = new UiArguments('getLocation');
	            var locationPromise = this._broker.runOnService(args, LocationType);
	            return PromiseWrapper$2.then(locationPromise, function (val) {
	                _this2._location = val;
	                return true;
	            }, function (err) {
	                throw new BaseException$2(err);
	            });
	        }
	    }, {
	        key: 'getBaseHrefFromDOM',
	        value: function getBaseHrefFromDOM() {
	            throw new BaseException$2('Attempt to get base href from DOM from WebWorker. You must either provide a value for the APP_BASE_HREF token through DI or use the hash location strategy.');
	        }
	    }, {
	        key: 'onPopState',
	        value: function onPopState(fn) {
	            this._popStateListeners.push(fn);
	        }
	    }, {
	        key: 'onHashChange',
	        value: function onHashChange(fn) {
	            this._hashChangeListeners.push(fn);
	        }
	    }, {
	        key: 'pushState',
	        value: function pushState(state, title, url) {
	            var fnArgs = [new FnArg(state, PRIMITIVE), new FnArg(title, PRIMITIVE), new FnArg(url, PRIMITIVE)];
	            var args = new UiArguments('pushState', fnArgs);
	            this._broker.runOnService(args, null);
	        }
	    }, {
	        key: 'replaceState',
	        value: function replaceState(state, title, url) {
	            var fnArgs = [new FnArg(state, PRIMITIVE), new FnArg(title, PRIMITIVE), new FnArg(url, PRIMITIVE)];
	            var args = new UiArguments('replaceState', fnArgs);
	            this._broker.runOnService(args, null);
	        }
	    }, {
	        key: 'forward',
	        value: function forward() {
	            var args = new UiArguments('forward');
	            this._broker.runOnService(args, null);
	        }
	    }, {
	        key: 'back',
	        value: function back() {
	            var args = new UiArguments('back');
	            this._broker.runOnService(args, null);
	        }
	    }, {
	        key: 'pathname',
	        get: function get() {
	            if (this._location === null) {
	                return null;
	            }
	            return this._location.pathname;
	        },
	        set: function set(newPath) {
	            if (this._location === null) {
	                throw new BaseException$2('Attempt to set pathname before value is obtained from UI');
	            }
	            this._location.pathname = newPath;
	            var fnArgs = [new FnArg(newPath, PRIMITIVE)];
	            var args = new UiArguments('setPathname', fnArgs);
	            this._broker.runOnService(args, null);
	        }
	    }, {
	        key: 'search',
	        get: function get() {
	            if (this._location === null) {
	                return null;
	            }
	            return this._location.search;
	        }
	    }, {
	        key: 'hash',
	        get: function get() {
	            if (this._location === null) {
	                return null;
	            }
	            return this._location.hash;
	        }
	    }]);
	    return WebWorkerPlatformLocation;
	}(PlatformLocation);
	/** @nocollapse */
	WebWorkerPlatformLocation.decorators = [{ type: Injectable }];
	/** @nocollapse */
	WebWorkerPlatformLocation.ctorParameters = [{ type: ClientMessageBrokerFactory }, { type: MessageBus }, { type: Serializer }];

	var MessageBasedPlatformLocation = function () {
	    function MessageBasedPlatformLocation(_brokerFactory, _platformLocation, bus, _serializer) {
	        classCallCheck(this, MessageBasedPlatformLocation);

	        this._brokerFactory = _brokerFactory;
	        this._platformLocation = _platformLocation;
	        this._serializer = _serializer;
	        this._platformLocation.onPopState(FunctionWrapper$2.bind(this._sendUrlChangeEvent, this));
	        this._platformLocation.onHashChange(FunctionWrapper$2.bind(this._sendUrlChangeEvent, this));
	        this._broker = this._brokerFactory.createMessageBroker(ROUTER_CHANNEL);
	        this._channelSink = bus.to(ROUTER_CHANNEL);
	    }

	    createClass(MessageBasedPlatformLocation, [{
	        key: 'start',
	        value: function start() {
	            this._broker.registerMethod('getLocation', null, FunctionWrapper$2.bind(this._getLocation, this), LocationType);
	            this._broker.registerMethod('setPathname', [PRIMITIVE], FunctionWrapper$2.bind(this._setPathname, this));
	            this._broker.registerMethod('pushState', [PRIMITIVE, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._platformLocation.pushState, this._platformLocation));
	            this._broker.registerMethod('replaceState', [PRIMITIVE, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._platformLocation.replaceState, this._platformLocation));
	            this._broker.registerMethod('forward', null, FunctionWrapper$2.bind(this._platformLocation.forward, this._platformLocation));
	            this._broker.registerMethod('back', null, FunctionWrapper$2.bind(this._platformLocation.back, this._platformLocation));
	        }
	    }, {
	        key: '_getLocation',
	        value: function _getLocation() {
	            return PromiseWrapper$2.resolve(this._platformLocation.location);
	        }
	    }, {
	        key: '_sendUrlChangeEvent',
	        value: function _sendUrlChangeEvent(e) {
	            var loc = this._serializer.serialize(this._platformLocation.location, LocationType);
	            var serializedEvent = { 'type': e.type };
	            ObservableWrapper$2.callEmit(this._channelSink, { 'event': serializedEvent, 'location': loc });
	        }
	    }, {
	        key: '_setPathname',
	        value: function _setPathname(pathname) {
	            this._platformLocation.pathname = pathname;
	        }
	    }]);
	    return MessageBasedPlatformLocation;
	}();
	/** @nocollapse */
	MessageBasedPlatformLocation.decorators = [{ type: Injectable }];
	/** @nocollapse */
	MessageBasedPlatformLocation.ctorParameters = [{ type: ServiceMessageBrokerFactory }, { type: BrowserPlatformLocation }, { type: MessageBus }, { type: Serializer }];

	var ON_WEB_WORKER = new OpaqueToken('WebWorker.onWebWorker');

	var PostMessageBusSink = function () {
	    function PostMessageBusSink(_postMessageTarget) {
	        classCallCheck(this, PostMessageBusSink);

	        this._postMessageTarget = _postMessageTarget;
	        this._channels = StringMapWrapper$2.create();
	        this._messageBuffer = [];
	    }

	    createClass(PostMessageBusSink, [{
	        key: 'attachToZone',
	        value: function attachToZone(zone) {
	            var _this = this;

	            this._zone = zone;
	            this._zone.runOutsideAngular(function () {
	                ObservableWrapper$2.subscribe(_this._zone.onStable, function (_) {
	                    _this._handleOnEventDone();
	                });
	            });
	        }
	    }, {
	        key: 'initChannel',
	        value: function initChannel(channel) {
	            var _this2 = this;

	            var runInZone = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            if (StringMapWrapper$2.contains(this._channels, channel)) {
	                throw new BaseException$2(channel + ' has already been initialized');
	            }
	            var emitter = new EventEmitter$2(false);
	            var channelInfo = new _Channel(emitter, runInZone);
	            this._channels[channel] = channelInfo;
	            emitter.subscribe(function (data) {
	                var message = { channel: channel, message: data };
	                if (runInZone) {
	                    _this2._messageBuffer.push(message);
	                } else {
	                    _this2._sendMessages([message]);
	                }
	            });
	        }
	    }, {
	        key: 'to',
	        value: function to(channel) {
	            if (StringMapWrapper$2.contains(this._channels, channel)) {
	                return this._channels[channel].emitter;
	            } else {
	                throw new BaseException$2(channel + ' is not set up. Did you forget to call initChannel?');
	            }
	        }
	    }, {
	        key: '_handleOnEventDone',
	        value: function _handleOnEventDone() {
	            if (this._messageBuffer.length > 0) {
	                this._sendMessages(this._messageBuffer);
	                this._messageBuffer = [];
	            }
	        }
	    }, {
	        key: '_sendMessages',
	        value: function _sendMessages(messages) {
	            this._postMessageTarget.postMessage(messages);
	        }
	    }]);
	    return PostMessageBusSink;
	}();
	var PostMessageBusSource = function () {
	    function PostMessageBusSource(eventTarget) {
	        var _this3 = this;

	        classCallCheck(this, PostMessageBusSource);

	        this._channels = StringMapWrapper$2.create();
	        if (eventTarget) {
	            eventTarget.addEventListener('message', function (ev) {
	                return _this3._handleMessages(ev);
	            });
	        } else {
	            // if no eventTarget is given we assume we're in a WebWorker and listen on the global scope
	            var workerScope = self;
	            workerScope.addEventListener('message', function (ev) {
	                return _this3._handleMessages(ev);
	            });
	        }
	    }

	    createClass(PostMessageBusSource, [{
	        key: 'attachToZone',
	        value: function attachToZone(zone) {
	            this._zone = zone;
	        }
	    }, {
	        key: 'initChannel',
	        value: function initChannel(channel) {
	            var runInZone = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            if (StringMapWrapper$2.contains(this._channels, channel)) {
	                throw new BaseException$2(channel + ' has already been initialized');
	            }
	            var emitter = new EventEmitter$2(false);
	            var channelInfo = new _Channel(emitter, runInZone);
	            this._channels[channel] = channelInfo;
	        }
	    }, {
	        key: 'from',
	        value: function from(channel) {
	            if (StringMapWrapper$2.contains(this._channels, channel)) {
	                return this._channels[channel].emitter;
	            } else {
	                throw new BaseException$2(channel + ' is not set up. Did you forget to call initChannel?');
	            }
	        }
	    }, {
	        key: '_handleMessages',
	        value: function _handleMessages(ev) {
	            var messages = ev.data;
	            for (var i = 0; i < messages.length; i++) {
	                this._handleMessage(messages[i]);
	            }
	        }
	    }, {
	        key: '_handleMessage',
	        value: function _handleMessage(data) {
	            var channel = data.channel;
	            if (StringMapWrapper$2.contains(this._channels, channel)) {
	                var channelInfo = this._channels[channel];
	                if (channelInfo.runInZone) {
	                    this._zone.run(function () {
	                        channelInfo.emitter.emit(data.message);
	                    });
	                } else {
	                    channelInfo.emitter.emit(data.message);
	                }
	            }
	        }
	    }]);
	    return PostMessageBusSource;
	}();
	var PostMessageBus = function () {
	    function PostMessageBus(sink, source) {
	        classCallCheck(this, PostMessageBus);

	        this.sink = sink;
	        this.source = source;
	    }

	    createClass(PostMessageBus, [{
	        key: 'attachToZone',
	        value: function attachToZone(zone) {
	            this.source.attachToZone(zone);
	            this.sink.attachToZone(zone);
	        }
	    }, {
	        key: 'initChannel',
	        value: function initChannel(channel) {
	            var runInZone = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            this.source.initChannel(channel, runInZone);
	            this.sink.initChannel(channel, runInZone);
	        }
	    }, {
	        key: 'from',
	        value: function from(channel) {
	            return this.source.from(channel);
	        }
	    }, {
	        key: 'to',
	        value: function to(channel) {
	            return this.sink.to(channel);
	        }
	    }]);
	    return PostMessageBus;
	}();
	/** @nocollapse */
	PostMessageBus.decorators = [{ type: Injectable }];
	/** @nocollapse */
	PostMessageBus.ctorParameters = [{ type: PostMessageBusSink }, { type: PostMessageBusSource }];
	/**
	 * Helper class that wraps a channel's {@link EventEmitter} and
	 * keeps track of if it should run in the zone.
	 */

	var _Channel = function _Channel(emitter, runInZone) {
	    classCallCheck(this, _Channel);

	    this.emitter = emitter;
	    this.runInZone = runInZone;
	};

	var MOUSE_EVENT_PROPERTIES = ['altKey', 'button', 'clientX', 'clientY', 'metaKey', 'movementX', 'movementY', 'offsetX', 'offsetY', 'region', 'screenX', 'screenY', 'shiftKey'];
	var KEYBOARD_EVENT_PROPERTIES = ['altkey', 'charCode', 'code', 'ctrlKey', 'isComposing', 'key', 'keyCode', 'location', 'metaKey', 'repeat', 'shiftKey', 'which'];
	var TRANSITION_EVENT_PROPERTIES = ['propertyName', 'elapsedTime', 'pseudoElement'];
	var EVENT_PROPERTIES = ['type', 'bubbles', 'cancelable'];
	var NODES_WITH_VALUE = new Set$3(['input', 'select', 'option', 'button', 'li', 'meter', 'progress', 'param', 'textarea']);
	function serializeGenericEvent(e) {
	    return serializeEvent(e, EVENT_PROPERTIES);
	}
	// TODO(jteplitz602): Allow users to specify the properties they need rather than always
	// adding value and files #3374
	function serializeEventWithTarget(e) {
	    var serializedEvent = serializeEvent(e, EVENT_PROPERTIES);
	    return addTarget(e, serializedEvent);
	}
	function serializeMouseEvent(e) {
	    return serializeEvent(e, MOUSE_EVENT_PROPERTIES);
	}
	function serializeKeyboardEvent(e) {
	    var serializedEvent = serializeEvent(e, KEYBOARD_EVENT_PROPERTIES);
	    return addTarget(e, serializedEvent);
	}
	function serializeTransitionEvent(e) {
	    var serializedEvent = serializeEvent(e, TRANSITION_EVENT_PROPERTIES);
	    return addTarget(e, serializedEvent);
	}
	// TODO(jteplitz602): #3374. See above.
	function addTarget(e, serializedEvent) {
	    if (NODES_WITH_VALUE.has(e.target.tagName.toLowerCase())) {
	        var target = e.target;
	        serializedEvent['target'] = { 'value': target.value };
	        if (isPresent$2(target.files)) {
	            serializedEvent['target']['files'] = target.files;
	        }
	    }
	    return serializedEvent;
	}
	function serializeEvent(e, properties) {
	    var serialized = {};
	    for (var i = 0; i < properties.length; i++) {
	        var prop = properties[i];
	        serialized[prop] = e[prop];
	    }
	    return serialized;
	}

	var EventDispatcher = function () {
	    function EventDispatcher(_sink, _serializer) {
	        classCallCheck(this, EventDispatcher);

	        this._sink = _sink;
	        this._serializer = _serializer;
	    }

	    createClass(EventDispatcher, [{
	        key: 'dispatchRenderEvent',
	        value: function dispatchRenderEvent(element, eventTarget, eventName, event) {
	            var serializedEvent;
	            // TODO (jteplitz602): support custom events #3350
	            switch (event.type) {
	                case 'click':
	                case 'mouseup':
	                case 'mousedown':
	                case 'dblclick':
	                case 'contextmenu':
	                case 'mouseenter':
	                case 'mouseleave':
	                case 'mousemove':
	                case 'mouseout':
	                case 'mouseover':
	                case 'show':
	                    serializedEvent = serializeMouseEvent(event);
	                    break;
	                case 'keydown':
	                case 'keypress':
	                case 'keyup':
	                    serializedEvent = serializeKeyboardEvent(event);
	                    break;
	                case 'input':
	                case 'change':
	                case 'blur':
	                    serializedEvent = serializeEventWithTarget(event);
	                    break;
	                case 'abort':
	                case 'afterprint':
	                case 'beforeprint':
	                case 'cached':
	                case 'canplay':
	                case 'canplaythrough':
	                case 'chargingchange':
	                case 'chargingtimechange':
	                case 'close':
	                case 'dischargingtimechange':
	                case 'DOMContentLoaded':
	                case 'downloading':
	                case 'durationchange':
	                case 'emptied':
	                case 'ended':
	                case 'error':
	                case 'fullscreenchange':
	                case 'fullscreenerror':
	                case 'invalid':
	                case 'languagechange':
	                case 'levelfchange':
	                case 'loadeddata':
	                case 'loadedmetadata':
	                case 'obsolete':
	                case 'offline':
	                case 'online':
	                case 'open':
	                case 'orientatoinchange':
	                case 'pause':
	                case 'pointerlockchange':
	                case 'pointerlockerror':
	                case 'play':
	                case 'playing':
	                case 'ratechange':
	                case 'readystatechange':
	                case 'reset':
	                case 'scroll':
	                case 'seeked':
	                case 'seeking':
	                case 'stalled':
	                case 'submit':
	                case 'success':
	                case 'suspend':
	                case 'timeupdate':
	                case 'updateready':
	                case 'visibilitychange':
	                case 'volumechange':
	                case 'waiting':
	                    serializedEvent = serializeGenericEvent(event);
	                    break;
	                case 'transitionend':
	                    serializedEvent = serializeTransitionEvent(event);
	                    break;
	                default:
	                    throw new BaseException$2(eventName + ' not supported on WebWorkers');
	            }
	            ObservableWrapper$2.callEmit(this._sink, {
	                'element': this._serializer.serialize(element, RenderStoreObject),
	                'eventName': eventName,
	                'eventTarget': eventTarget,
	                'event': serializedEvent
	            });
	            // TODO(kegluneq): Eventually, we want the user to indicate from the UI side whether the event
	            // should be canceled, but for now just call `preventDefault` on the original DOM event.
	            return false;
	        }
	    }]);
	    return EventDispatcher;
	}();

	var MessageBasedRenderer = function () {
	    function MessageBasedRenderer(_brokerFactory, _bus, _serializer, _renderStore, _rootRenderer) {
	        classCallCheck(this, MessageBasedRenderer);

	        this._brokerFactory = _brokerFactory;
	        this._bus = _bus;
	        this._serializer = _serializer;
	        this._renderStore = _renderStore;
	        this._rootRenderer = _rootRenderer;
	    }

	    createClass(MessageBasedRenderer, [{
	        key: 'start',
	        value: function start() {
	            var broker = this._brokerFactory.createMessageBroker(RENDERER_CHANNEL);
	            this._bus.initChannel(EVENT_CHANNEL);
	            this._eventDispatcher = new EventDispatcher(this._bus.to(EVENT_CHANNEL), this._serializer);
	            broker.registerMethod('renderComponent', [RenderComponentType, PRIMITIVE], FunctionWrapper$2.bind(this._renderComponent, this));
	            broker.registerMethod('selectRootElement', [RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._selectRootElement, this));
	            broker.registerMethod('createElement', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._createElement, this));
	            broker.registerMethod('createViewRoot', [RenderStoreObject, RenderStoreObject, PRIMITIVE], FunctionWrapper$2.bind(this._createViewRoot, this));
	            broker.registerMethod('createTemplateAnchor', [RenderStoreObject, RenderStoreObject, PRIMITIVE], FunctionWrapper$2.bind(this._createTemplateAnchor, this));
	            broker.registerMethod('createText', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._createText, this));
	            broker.registerMethod('projectNodes', [RenderStoreObject, RenderStoreObject, RenderStoreObject], FunctionWrapper$2.bind(this._projectNodes, this));
	            broker.registerMethod('attachViewAfter', [RenderStoreObject, RenderStoreObject, RenderStoreObject], FunctionWrapper$2.bind(this._attachViewAfter, this));
	            broker.registerMethod('detachView', [RenderStoreObject, RenderStoreObject], FunctionWrapper$2.bind(this._detachView, this));
	            broker.registerMethod('destroyView', [RenderStoreObject, RenderStoreObject, RenderStoreObject], FunctionWrapper$2.bind(this._destroyView, this));
	            broker.registerMethod('setElementProperty', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._setElementProperty, this));
	            broker.registerMethod('setElementAttribute', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._setElementAttribute, this));
	            broker.registerMethod('setBindingDebugInfo', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._setBindingDebugInfo, this));
	            broker.registerMethod('setElementClass', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._setElementClass, this));
	            broker.registerMethod('setElementStyle', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._setElementStyle, this));
	            broker.registerMethod('invokeElementMethod', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._invokeElementMethod, this));
	            broker.registerMethod('setText', [RenderStoreObject, RenderStoreObject, PRIMITIVE], FunctionWrapper$2.bind(this._setText, this));
	            broker.registerMethod('listen', [RenderStoreObject, RenderStoreObject, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._listen, this));
	            broker.registerMethod('listenGlobal', [RenderStoreObject, PRIMITIVE, PRIMITIVE, PRIMITIVE], FunctionWrapper$2.bind(this._listenGlobal, this));
	            broker.registerMethod('listenDone', [RenderStoreObject, RenderStoreObject], FunctionWrapper$2.bind(this._listenDone, this));
	        }
	    }, {
	        key: '_renderComponent',
	        value: function _renderComponent(renderComponentType, rendererId) {
	            var renderer = this._rootRenderer.renderComponent(renderComponentType);
	            this._renderStore.store(renderer, rendererId);
	        }
	    }, {
	        key: '_selectRootElement',
	        value: function _selectRootElement(renderer, selector, elId) {
	            this._renderStore.store(renderer.selectRootElement(selector, null), elId);
	        }
	    }, {
	        key: '_createElement',
	        value: function _createElement(renderer, parentElement, name, elId) {
	            this._renderStore.store(renderer.createElement(parentElement, name, null), elId);
	        }
	    }, {
	        key: '_createViewRoot',
	        value: function _createViewRoot(renderer, hostElement, elId) {
	            var viewRoot = renderer.createViewRoot(hostElement);
	            if (this._renderStore.serialize(hostElement) !== elId) {
	                this._renderStore.store(viewRoot, elId);
	            }
	        }
	    }, {
	        key: '_createTemplateAnchor',
	        value: function _createTemplateAnchor(renderer, parentElement, elId) {
	            this._renderStore.store(renderer.createTemplateAnchor(parentElement, null), elId);
	        }
	    }, {
	        key: '_createText',
	        value: function _createText(renderer, parentElement, value, elId) {
	            this._renderStore.store(renderer.createText(parentElement, value, null), elId);
	        }
	    }, {
	        key: '_projectNodes',
	        value: function _projectNodes(renderer, parentElement, nodes) {
	            renderer.projectNodes(parentElement, nodes);
	        }
	    }, {
	        key: '_attachViewAfter',
	        value: function _attachViewAfter(renderer, node, viewRootNodes) {
	            renderer.attachViewAfter(node, viewRootNodes);
	        }
	    }, {
	        key: '_detachView',
	        value: function _detachView(renderer, viewRootNodes) {
	            renderer.detachView(viewRootNodes);
	        }
	    }, {
	        key: '_destroyView',
	        value: function _destroyView(renderer, hostElement, viewAllNodes) {
	            renderer.destroyView(hostElement, viewAllNodes);
	            for (var i = 0; i < viewAllNodes.length; i++) {
	                this._renderStore.remove(viewAllNodes[i]);
	            }
	        }
	    }, {
	        key: '_setElementProperty',
	        value: function _setElementProperty(renderer, renderElement, propertyName, propertyValue) {
	            renderer.setElementProperty(renderElement, propertyName, propertyValue);
	        }
	    }, {
	        key: '_setElementAttribute',
	        value: function _setElementAttribute(renderer, renderElement, attributeName, attributeValue) {
	            renderer.setElementAttribute(renderElement, attributeName, attributeValue);
	        }
	    }, {
	        key: '_setBindingDebugInfo',
	        value: function _setBindingDebugInfo(renderer, renderElement, propertyName, propertyValue) {
	            renderer.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	        }
	    }, {
	        key: '_setElementClass',
	        value: function _setElementClass(renderer, renderElement, className, isAdd) {
	            renderer.setElementClass(renderElement, className, isAdd);
	        }
	    }, {
	        key: '_setElementStyle',
	        value: function _setElementStyle(renderer, renderElement, styleName, styleValue) {
	            renderer.setElementStyle(renderElement, styleName, styleValue);
	        }
	    }, {
	        key: '_invokeElementMethod',
	        value: function _invokeElementMethod(renderer, renderElement, methodName, args) {
	            renderer.invokeElementMethod(renderElement, methodName, args);
	        }
	    }, {
	        key: '_setText',
	        value: function _setText(renderer, renderNode, text) {
	            renderer.setText(renderNode, text);
	        }
	    }, {
	        key: '_listen',
	        value: function _listen(renderer, renderElement, eventName, unlistenId) {
	            var _this = this;

	            var unregisterCallback = renderer.listen(renderElement, eventName, function (event /** TODO #9100 */) {
	                return _this._eventDispatcher.dispatchRenderEvent(renderElement, null, eventName, event);
	            });
	            this._renderStore.store(unregisterCallback, unlistenId);
	        }
	    }, {
	        key: '_listenGlobal',
	        value: function _listenGlobal(renderer, eventTarget, eventName, unlistenId) {
	            var _this2 = this;

	            var unregisterCallback = renderer.listenGlobal(eventTarget, eventName, function (event /** TODO #9100 */) {
	                return _this2._eventDispatcher.dispatchRenderEvent(null, eventTarget, eventName, event);
	            });
	            this._renderStore.store(unregisterCallback, unlistenId);
	        }
	    }, {
	        key: '_listenDone',
	        value: function _listenDone(renderer, unlistenCallback) {
	            unlistenCallback();
	        }
	    }]);
	    return MessageBasedRenderer;
	}();
	/** @nocollapse */
	MessageBasedRenderer.decorators = [{ type: Injectable }];
	/** @nocollapse */
	MessageBasedRenderer.ctorParameters = [{ type: ServiceMessageBrokerFactory }, { type: MessageBus }, { type: Serializer }, { type: RenderStore }, { type: RootRenderer }];

	var WORKER_RENDER_PLATFORM_MARKER = new OpaqueToken('WorkerRenderPlatformMarker');
	var WebWorkerInstance = function () {
	    function WebWorkerInstance() {
	        classCallCheck(this, WebWorkerInstance);
	    }

	    createClass(WebWorkerInstance, [{
	        key: 'init',

	        /** @internal */
	        value: function init(worker, bus) {
	            this.worker = worker;
	            this.bus = bus;
	        }
	    }]);
	    return WebWorkerInstance;
	}();
	/** @nocollapse */
	WebWorkerInstance.decorators = [{ type: Injectable }];
	/**
	 * @experimental WebWorker support is currently experimental.
	 */
	var WORKER_SCRIPT = new OpaqueToken('WebWorkerScript');
	/**
	 * A multiple providers used to automatically call the `start()` method after the service is
	 * created.
	 *
	 * TODO(vicb): create an interface for startable services to implement
	 * @experimental WebWorker support is currently experimental.
	 */
	var WORKER_UI_STARTABLE_MESSAGING_SERVICE = new OpaqueToken('WorkerRenderStartableMsgService');

	var WebWorkerRootRenderer = function () {
	    function WebWorkerRootRenderer(messageBrokerFactory, bus, _serializer, _renderStore) {
	        var _this = this;

	        classCallCheck(this, WebWorkerRootRenderer);

	        this._serializer = _serializer;
	        this._renderStore = _renderStore;
	        this.globalEvents = new NamedEventEmitter();
	        this._componentRenderers = new Map();
	        this._messageBroker = messageBrokerFactory.createMessageBroker(RENDERER_CHANNEL);
	        bus.initChannel(EVENT_CHANNEL);
	        var source = bus.from(EVENT_CHANNEL);
	        ObservableWrapper$2.subscribe(source, function (message) {
	            return _this._dispatchEvent(message);
	        });
	    }

	    createClass(WebWorkerRootRenderer, [{
	        key: '_dispatchEvent',
	        value: function _dispatchEvent(message) {
	            var eventName = message['eventName'];
	            var target = message['eventTarget'];
	            var event = deserializeGenericEvent(message['event']);
	            if (isPresent$2(target)) {
	                this.globalEvents.dispatchEvent(eventNameWithTarget(target, eventName), event);
	            } else {
	                var element = this._serializer.deserialize(message['element'], RenderStoreObject);
	                element.events.dispatchEvent(eventName, event);
	            }
	        }
	    }, {
	        key: 'renderComponent',
	        value: function renderComponent(componentType) {
	            var result = this._componentRenderers.get(componentType.id);
	            if (isBlank$2(result)) {
	                result = new WebWorkerRenderer(this, componentType);
	                this._componentRenderers.set(componentType.id, result);
	                var id = this._renderStore.allocateId();
	                this._renderStore.store(result, id);
	                this.runOnService('renderComponent', [new FnArg(componentType, RenderComponentType), new FnArg(result, RenderStoreObject)]);
	            }
	            return result;
	        }
	    }, {
	        key: 'runOnService',
	        value: function runOnService(fnName, fnArgs) {
	            var args = new UiArguments(fnName, fnArgs);
	            this._messageBroker.runOnService(args, null);
	        }
	    }, {
	        key: 'allocateNode',
	        value: function allocateNode() {
	            var result = new WebWorkerRenderNode();
	            var id = this._renderStore.allocateId();
	            this._renderStore.store(result, id);
	            return result;
	        }
	    }, {
	        key: 'allocateId',
	        value: function allocateId() {
	            return this._renderStore.allocateId();
	        }
	    }, {
	        key: 'destroyNodes',
	        value: function destroyNodes(nodes) {
	            for (var i = 0; i < nodes.length; i++) {
	                this._renderStore.remove(nodes[i]);
	            }
	        }
	    }]);
	    return WebWorkerRootRenderer;
	}();
	/** @nocollapse */
	WebWorkerRootRenderer.decorators = [{ type: Injectable }];
	/** @nocollapse */
	WebWorkerRootRenderer.ctorParameters = [{ type: ClientMessageBrokerFactory }, { type: MessageBus }, { type: Serializer }, { type: RenderStore }];
	var WebWorkerRenderer = function () {
	    function WebWorkerRenderer(_rootRenderer, _componentType) {
	        classCallCheck(this, WebWorkerRenderer);

	        this._rootRenderer = _rootRenderer;
	        this._componentType = _componentType;
	    }

	    createClass(WebWorkerRenderer, [{
	        key: '_runOnService',
	        value: function _runOnService(fnName, fnArgs) {
	            var fnArgsWithRenderer = [new FnArg(this, RenderStoreObject)].concat(fnArgs);
	            this._rootRenderer.runOnService(fnName, fnArgsWithRenderer);
	        }
	    }, {
	        key: 'selectRootElement',
	        value: function selectRootElement(selectorOrNode, debugInfo) {
	            var node = this._rootRenderer.allocateNode();
	            this._runOnService('selectRootElement', [new FnArg(selectorOrNode, null), new FnArg(node, RenderStoreObject)]);
	            return node;
	        }
	    }, {
	        key: 'createElement',
	        value: function createElement(parentElement, name, debugInfo) {
	            var node = this._rootRenderer.allocateNode();
	            this._runOnService('createElement', [new FnArg(parentElement, RenderStoreObject), new FnArg(name, null), new FnArg(node, RenderStoreObject)]);
	            return node;
	        }
	    }, {
	        key: 'createViewRoot',
	        value: function createViewRoot(hostElement) {
	            var viewRoot = this._componentType.encapsulation === ViewEncapsulation.Native ? this._rootRenderer.allocateNode() : hostElement;
	            this._runOnService('createViewRoot', [new FnArg(hostElement, RenderStoreObject), new FnArg(viewRoot, RenderStoreObject)]);
	            return viewRoot;
	        }
	    }, {
	        key: 'createTemplateAnchor',
	        value: function createTemplateAnchor(parentElement, debugInfo) {
	            var node = this._rootRenderer.allocateNode();
	            this._runOnService('createTemplateAnchor', [new FnArg(parentElement, RenderStoreObject), new FnArg(node, RenderStoreObject)]);
	            return node;
	        }
	    }, {
	        key: 'createText',
	        value: function createText(parentElement, value, debugInfo) {
	            var node = this._rootRenderer.allocateNode();
	            this._runOnService('createText', [new FnArg(parentElement, RenderStoreObject), new FnArg(value, null), new FnArg(node, RenderStoreObject)]);
	            return node;
	        }
	    }, {
	        key: 'projectNodes',
	        value: function projectNodes(parentElement, nodes) {
	            this._runOnService('projectNodes', [new FnArg(parentElement, RenderStoreObject), new FnArg(nodes, RenderStoreObject)]);
	        }
	    }, {
	        key: 'attachViewAfter',
	        value: function attachViewAfter(node, viewRootNodes) {
	            this._runOnService('attachViewAfter', [new FnArg(node, RenderStoreObject), new FnArg(viewRootNodes, RenderStoreObject)]);
	        }
	    }, {
	        key: 'detachView',
	        value: function detachView(viewRootNodes) {
	            this._runOnService('detachView', [new FnArg(viewRootNodes, RenderStoreObject)]);
	        }
	    }, {
	        key: 'destroyView',
	        value: function destroyView(hostElement, viewAllNodes) {
	            this._runOnService('destroyView', [new FnArg(hostElement, RenderStoreObject), new FnArg(viewAllNodes, RenderStoreObject)]);
	            this._rootRenderer.destroyNodes(viewAllNodes);
	        }
	    }, {
	        key: 'setElementProperty',
	        value: function setElementProperty(renderElement, propertyName, propertyValue) {
	            this._runOnService('setElementProperty', [new FnArg(renderElement, RenderStoreObject), new FnArg(propertyName, null), new FnArg(propertyValue, null)]);
	        }
	    }, {
	        key: 'setElementAttribute',
	        value: function setElementAttribute(renderElement, attributeName, attributeValue) {
	            this._runOnService('setElementAttribute', [new FnArg(renderElement, RenderStoreObject), new FnArg(attributeName, null), new FnArg(attributeValue, null)]);
	        }
	    }, {
	        key: 'setBindingDebugInfo',
	        value: function setBindingDebugInfo(renderElement, propertyName, propertyValue) {
	            this._runOnService('setBindingDebugInfo', [new FnArg(renderElement, RenderStoreObject), new FnArg(propertyName, null), new FnArg(propertyValue, null)]);
	        }
	    }, {
	        key: 'setElementClass',
	        value: function setElementClass(renderElement, className, isAdd) {
	            this._runOnService('setElementClass', [new FnArg(renderElement, RenderStoreObject), new FnArg(className, null), new FnArg(isAdd, null)]);
	        }
	    }, {
	        key: 'setElementStyle',
	        value: function setElementStyle(renderElement, styleName, styleValue) {
	            this._runOnService('setElementStyle', [new FnArg(renderElement, RenderStoreObject), new FnArg(styleName, null), new FnArg(styleValue, null)]);
	        }
	    }, {
	        key: 'invokeElementMethod',
	        value: function invokeElementMethod(renderElement, methodName, args) {
	            this._runOnService('invokeElementMethod', [new FnArg(renderElement, RenderStoreObject), new FnArg(methodName, null), new FnArg(args, null)]);
	        }
	    }, {
	        key: 'setText',
	        value: function setText(renderNode, text) {
	            this._runOnService('setText', [new FnArg(renderNode, RenderStoreObject), new FnArg(text, null)]);
	        }
	    }, {
	        key: 'listen',
	        value: function listen(renderElement, name, callback) {
	            var _this2 = this;

	            renderElement.events.listen(name, callback);
	            var unlistenCallbackId = this._rootRenderer.allocateId();
	            this._runOnService('listen', [new FnArg(renderElement, RenderStoreObject), new FnArg(name, null), new FnArg(unlistenCallbackId, null)]);
	            return function () {
	                renderElement.events.unlisten(name, callback);
	                _this2._runOnService('listenDone', [new FnArg(unlistenCallbackId, null)]);
	            };
	        }
	    }, {
	        key: 'listenGlobal',
	        value: function listenGlobal(target, name, callback) {
	            var _this3 = this;

	            this._rootRenderer.globalEvents.listen(eventNameWithTarget(target, name), callback);
	            var unlistenCallbackId = this._rootRenderer.allocateId();
	            this._runOnService('listenGlobal', [new FnArg(target, null), new FnArg(name, null), new FnArg(unlistenCallbackId, null)]);
	            return function () {
	                _this3._rootRenderer.globalEvents.unlisten(eventNameWithTarget(target, name), callback);
	                _this3._runOnService('listenDone', [new FnArg(unlistenCallbackId, null)]);
	            };
	        }
	    }, {
	        key: 'animate',
	        value: function animate(element, startingStyles, keyframes, duration, delay, easing) {
	            // TODO
	            return null;
	        }
	    }]);
	    return WebWorkerRenderer;
	}();
	var NamedEventEmitter = function () {
	    function NamedEventEmitter() {
	        classCallCheck(this, NamedEventEmitter);
	    }

	    createClass(NamedEventEmitter, [{
	        key: '_getListeners',
	        value: function _getListeners(eventName) {
	            if (isBlank$2(this._listeners)) {
	                this._listeners = new Map();
	            }
	            var listeners = this._listeners.get(eventName);
	            if (isBlank$2(listeners)) {
	                listeners = [];
	                this._listeners.set(eventName, listeners);
	            }
	            return listeners;
	        }
	    }, {
	        key: 'listen',
	        value: function listen(eventName, callback) {
	            this._getListeners(eventName).push(callback);
	        }
	    }, {
	        key: 'unlisten',
	        value: function unlisten(eventName, callback) {
	            ListWrapper$2.remove(this._getListeners(eventName), callback);
	        }
	    }, {
	        key: 'dispatchEvent',
	        value: function dispatchEvent(eventName, event) {
	            var listeners = this._getListeners(eventName);
	            for (var i = 0; i < listeners.length; i++) {
	                listeners[i](event);
	            }
	        }
	    }]);
	    return NamedEventEmitter;
	}();
	function eventNameWithTarget(target, eventName) {
	    return target + ':' + eventName;
	}
	var WebWorkerRenderNode = function WebWorkerRenderNode() {
	    classCallCheck(this, WebWorkerRenderNode);

	    this.events = new NamedEventEmitter();
	};

	/**
	 * This adapter is required to log error messages.
	 *
	 * Note: other methods all throw as the DOM is not accessible directly in web worker context.
	 */
	var WorkerDomAdapter = function (_DomAdapter) {
	    inherits(WorkerDomAdapter, _DomAdapter);

	    function WorkerDomAdapter() {
	        classCallCheck(this, WorkerDomAdapter);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(WorkerDomAdapter).apply(this, arguments));
	    }

	    createClass(WorkerDomAdapter, [{
	        key: 'logError',
	        value: function logError(error /** TODO #9100 */) {
	            if (console.error) {
	                console.error(error);
	            } else {
	                console.log(error);
	            }
	        }
	    }, {
	        key: 'log',
	        value: function log(error /** TODO #9100 */) {
	            console.log(error);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(error /** TODO #9100 */) {
	            if (console.group) {
	                console.group(error);
	                this.logError(error);
	            } else {
	                console.log(error);
	            }
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {
	            if (console.groupEnd) {
	                console.groupEnd();
	            }
	        }
	    }, {
	        key: 'hasProperty',
	        value: function hasProperty(element /** TODO #9100 */, name) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setProperty',
	        value: function setProperty(el, name, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getProperty',
	        value: function getProperty(el, name) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'invoke',
	        value: function invoke(el, methodName, args) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getXHR',
	        value: function getXHR() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'parse',
	        value: function parse(templateHtml) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'query',
	        value: function query(selector) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'querySelector',
	        value: function querySelector(el /** TODO #9100 */, selector) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'querySelectorAll',
	        value: function querySelectorAll(el /** TODO #9100 */, selector) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'on',
	        value: function on(el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'onAndCancel',
	        value: function onAndCancel(el /** TODO #9100 */, evt /** TODO #9100 */, listener /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'dispatchEvent',
	        value: function dispatchEvent(el /** TODO #9100 */, evt /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createMouseEvent',
	        value: function createMouseEvent(eventType /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createEvent',
	        value: function createEvent(eventType) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'preventDefault',
	        value: function preventDefault(evt /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'isPrevented',
	        value: function isPrevented(evt /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getInnerHTML',
	        value: function getInnerHTML(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getTemplateContent',
	        value: function getTemplateContent(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getOuterHTML',
	        value: function getOuterHTML(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'nodeName',
	        value: function nodeName(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'nodeValue',
	        value: function nodeValue(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'type',
	        value: function type(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'content',
	        value: function content(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'firstChild',
	        value: function firstChild(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'nextSibling',
	        value: function nextSibling(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'parentElement',
	        value: function parentElement(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'childNodes',
	        value: function childNodes(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'childNodesAsList',
	        value: function childNodesAsList(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'clearNodes',
	        value: function clearNodes(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'appendChild',
	        value: function appendChild(el /** TODO #9100 */, node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'removeChild',
	        value: function removeChild(el /** TODO #9100 */, node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'replaceChild',
	        value: function replaceChild(el /** TODO #9100 */, newNode /** TODO #9100 */, oldNode /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'remove',
	        value: function remove(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'insertBefore',
	        value: function insertBefore(el /** TODO #9100 */, node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'insertAllBefore',
	        value: function insertAllBefore(el /** TODO #9100 */, nodes /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'insertAfter',
	        value: function insertAfter(el /** TODO #9100 */, node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setInnerHTML',
	        value: function setInnerHTML(el /** TODO #9100 */, value /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getText',
	        value: function getText(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setText',
	        value: function setText(el /** TODO #9100 */, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getValue',
	        value: function getValue(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setValue',
	        value: function setValue(el /** TODO #9100 */, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getChecked',
	        value: function getChecked(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setChecked',
	        value: function setChecked(el /** TODO #9100 */, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createComment',
	        value: function createComment(text) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createTemplate',
	        value: function createTemplate(html /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createElement',
	        value: function createElement(tagName /** TODO #9100 */, doc /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createElementNS',
	        value: function createElementNS(ns, tagName, doc /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createTextNode',
	        value: function createTextNode(text, doc /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createScriptTag',
	        value: function createScriptTag(attrName, attrValue, doc /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createStyleElement',
	        value: function createStyleElement(css, doc /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createShadowRoot',
	        value: function createShadowRoot(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getShadowRoot',
	        value: function getShadowRoot(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getHost',
	        value: function getHost(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getDistributedNodes',
	        value: function getDistributedNodes(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'clone',
	        value: function clone(node) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getElementsByClassName',
	        value: function getElementsByClassName(element /** TODO #9100 */, name) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getElementsByTagName',
	        value: function getElementsByTagName(element /** TODO #9100 */, name) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'classList',
	        value: function classList(element /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'addClass',
	        value: function addClass(element /** TODO #9100 */, className) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'removeClass',
	        value: function removeClass(element /** TODO #9100 */, className) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'hasClass',
	        value: function hasClass(element /** TODO #9100 */, className) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setStyle',
	        value: function setStyle(element /** TODO #9100 */, styleName, styleValue) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'removeStyle',
	        value: function removeStyle(element /** TODO #9100 */, styleName) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getStyle',
	        value: function getStyle(element /** TODO #9100 */, styleName) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'hasStyle',
	        value: function hasStyle(element /** TODO #9100 */, styleName, styleValue) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'tagName',
	        value: function tagName(element /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'attributeMap',
	        value: function attributeMap(element /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'hasAttribute',
	        value: function hasAttribute(element /** TODO #9100 */, attribute) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'hasAttributeNS',
	        value: function hasAttributeNS(element /** TODO #9100 */, ns, attribute) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getAttribute',
	        value: function getAttribute(element /** TODO #9100 */, attribute) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getAttributeNS',
	        value: function getAttributeNS(element /** TODO #9100 */, ns, attribute) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setAttribute',
	        value: function setAttribute(element /** TODO #9100 */, name, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setAttributeNS',
	        value: function setAttributeNS(element /** TODO #9100 */, ns, name, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'removeAttribute',
	        value: function removeAttribute(element /** TODO #9100 */, attribute) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'removeAttributeNS',
	        value: function removeAttributeNS(element /** TODO #9100 */, ns, attribute) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'templateAwareRoot',
	        value: function templateAwareRoot(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'createHtmlDocument',
	        value: function createHtmlDocument() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'defaultDoc',
	        value: function defaultDoc() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getBoundingClientRect',
	        value: function getBoundingClientRect(el /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getTitle',
	        value: function getTitle() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setTitle',
	        value: function setTitle(newTitle) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'elementMatches',
	        value: function elementMatches(n /** TODO #9100 */, selector) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'isTemplateElement',
	        value: function isTemplateElement(el) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'isTextNode',
	        value: function isTextNode(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'isCommentNode',
	        value: function isCommentNode(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'isElementNode',
	        value: function isElementNode(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'hasShadowRoot',
	        value: function hasShadowRoot(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'isShadowRoot',
	        value: function isShadowRoot(node /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'importIntoDoc',
	        value: function importIntoDoc(node) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'adoptNode',
	        value: function adoptNode(node) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getHref',
	        value: function getHref(element /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getEventKey',
	        value: function getEventKey(event /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'resolveAndSetHref',
	        value: function resolveAndSetHref(element /** TODO #9100 */, baseUrl, href) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'supportsDOMEvents',
	        value: function supportsDOMEvents() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'supportsNativeShadowDOM',
	        value: function supportsNativeShadowDOM() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getGlobalEventTarget',
	        value: function getGlobalEventTarget(target) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getHistory',
	        value: function getHistory() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getLocation',
	        value: function getLocation() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getBaseHref',
	        value: function getBaseHref() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'resetBaseElement',
	        value: function resetBaseElement() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getUserAgent',
	        value: function getUserAgent() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setData',
	        value: function setData(element /** TODO #9100 */, name, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getComputedStyle',
	        value: function getComputedStyle(element /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getData',
	        value: function getData(element /** TODO #9100 */, name) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setGlobalVar',
	        value: function setGlobalVar(name, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'requestAnimationFrame',
	        value: function requestAnimationFrame(callback /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'cancelAnimationFrame',
	        value: function cancelAnimationFrame(id /** TODO #9100 */) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'performanceNow',
	        value: function performanceNow() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getAnimationPrefix',
	        value: function getAnimationPrefix() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'getTransitionEnd',
	        value: function getTransitionEnd() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'supportsAnimation',
	        value: function supportsAnimation() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'supportsWebAnimation',
	        value: function supportsWebAnimation() {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'supportsCookies',
	        value: function supportsCookies() {
	            return false;
	        }
	    }, {
	        key: 'getCookie',
	        value: function getCookie(name) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'setCookie',
	        value: function setCookie(name, value) {
	            throw 'not implemented';
	        }
	    }, {
	        key: 'attrToPropMap',
	        get: function get() {
	            throw 'not implemented';
	        },
	        set: function set(value) {
	            throw 'not implemented';
	        }
	    }], [{
	        key: 'makeCurrent',
	        value: function makeCurrent() {
	            setRootDomAdapter(new WorkerDomAdapter());
	        }
	    }]);
	    return WorkerDomAdapter;
	}(DomAdapter);

	var PrintLogger = function () {
	    function PrintLogger() {
	        classCallCheck(this, PrintLogger);

	        this.log = print$2;
	        this.logError = print$2;
	        this.logGroup = print$2;
	    }

	    createClass(PrintLogger, [{
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return PrintLogger;
	}();

	var WORKER_APP_PLATFORM_MARKER = new OpaqueToken('WorkerAppPlatformMarker');
	// TODO(jteplitz602) remove this and compile with lib.webworker.d.ts (#3492)
	var _postMessage = {
	    postMessage: function (_postMessage2) {
	        function postMessage(_x, _x2) {
	            return _postMessage2.apply(this, arguments);
	        }

	        postMessage.toString = function () {
	            return _postMessage2.toString();
	        };

	        return postMessage;
	    }(function (message, transferrables) {
	        postMessage(message, transferrables);
	    })
	};

	var __platform_browser_private__ = {
	    DomAdapter: DomAdapter,
	    getDOM: getDOM,
	    setRootDomAdapter: setRootDomAdapter,
	    DomRootRenderer: DomRootRenderer,
	    DomRootRenderer_: DomRootRenderer_,
	    DomSharedStylesHost: DomSharedStylesHost,
	    SharedStylesHost: SharedStylesHost,
	    ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,
	    DomEventsPlugin: DomEventsPlugin
	};

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalScope$3;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope$3 = self;
	    } else {
	        globalScope$3 = global;
	    }
	} else {
	    globalScope$3 = window;
	}
	var IS_DART$3 = false;
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var global$4 = globalScope$3;
	/**
	 * Runtime representation a type that a Component or other object is instances of.
	 *
	 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	 * the `MyCustomComponent` constructor function.
	 *
	 * @stable
	 */
	var Type$3 = Function;
	var Date$4 = global$4.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	global$4.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent$3(obj) {
	    return obj !== undefined && obj !== null;
	}
	function isBlank$3(obj) {
	    return obj === undefined || obj === null;
	}
	function isBoolean$3(obj) {
	    return typeof obj === 'boolean';
	}
	function isNumber$3(obj) {
	    return typeof obj === 'number';
	}
	function isString$3(obj) {
	    return typeof obj === 'string';
	}
	function isStringMap$3(obj) {
	    return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null;
	}
	var STRING_MAP_PROTO$3 = Object.getPrototypeOf({});
	function isStrictStringMap$3(obj) {
	    return isStringMap$3(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO$3;
	}
	function isArray$4(obj) {
	    return Array.isArray(obj);
	}
	function noop$3() {}
	function stringify$3(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token === undefined || token === null) {
	        return '' + token;
	    }
	    if (token.name) {
	        return token.name;
	    }
	    if (token.overriddenName) {
	        return token.overriddenName;
	    }
	    var res = token.toString();
	    var newLineIndex = res.indexOf('\n');
	    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	}
	// serialize / deserialize enum exist only for consistency with dart API
	// enums in typescript don't need to be serialized
	function serializeEnum$3(val) {
	    return val;
	}
	function resolveEnumToken$3(enumValue, val) {
	    return enumValue[val];
	}

	var StringWrapper$3 = function () {
	    function StringWrapper() {
	        classCallCheck(this, StringWrapper);
	    }

	    createClass(StringWrapper, null, [{
	        key: 'fromCharCode',
	        value: function fromCharCode(code) {
	            return String.fromCharCode(code);
	        }
	    }, {
	        key: 'charCodeAt',
	        value: function charCodeAt(s, index) {
	            return s.charCodeAt(index);
	        }
	    }, {
	        key: 'split',
	        value: function split(s, regExp) {
	            return s.split(regExp);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(s, s2) {
	            return s === s2;
	        }
	    }, {
	        key: 'stripLeft',
	        value: function stripLeft(s, charVal) {
	            if (s && s.length) {
	                var pos = 0;
	                for (var i = 0; i < s.length; i++) {
	                    if (s[i] != charVal) break;
	                    pos++;
	                }
	                s = s.substring(pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'stripRight',
	        value: function stripRight(s, charVal) {
	            if (s && s.length) {
	                var pos = s.length;
	                for (var i = s.length - 1; i >= 0; i--) {
	                    if (s[i] != charVal) break;
	                    pos--;
	                }
	                s = s.substring(0, pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'replace',
	        value: function replace(s, from, _replace) {
	            return s.replace(from, _replace);
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(s, from, replace) {
	            return s.replace(from, replace);
	        }
	    }, {
	        key: 'slice',
	        value: function slice(s) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return s.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'replaceAllMapped',
	        value: function replaceAllMapped(s, from, cb) {
	            return s.replace(from, function () {
	                for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
	                    matches[_key] = arguments[_key];
	                }

	                // Remove offset & string from the result array
	                matches.splice(-2, 2);
	                // The callback receives match, p1, ..., pn
	                return cb(matches);
	            });
	        }
	    }, {
	        key: 'contains',
	        value: function contains(s, substr) {
	            return s.indexOf(substr) != -1;
	        }
	    }, {
	        key: 'compare',
	        value: function compare(a, b) {
	            if (a < b) {
	                return -1;
	            } else if (a > b) {
	                return 1;
	            } else {
	                return 0;
	            }
	        }
	    }]);
	    return StringWrapper;
	}();

	var StringJoiner$3 = function () {
	    function StringJoiner() {
	        var parts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, StringJoiner);

	        this.parts = parts;
	    }

	    createClass(StringJoiner, [{
	        key: 'add',
	        value: function add(part) {
	            this.parts.push(part);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.parts.join('');
	        }
	    }]);
	    return StringJoiner;
	}();
	var NumberParseError$3 = function (_Error) {
	    inherits(NumberParseError, _Error);

	    function NumberParseError(message) {
	        classCallCheck(this, NumberParseError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NumberParseError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(NumberParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return NumberParseError;
	}(Error);
	var NumberWrapper$3 = function () {
	    function NumberWrapper() {
	        classCallCheck(this, NumberWrapper);
	    }

	    createClass(NumberWrapper, null, [{
	        key: 'toFixed',
	        value: function toFixed(n, fractionDigits) {
	            return n.toFixed(fractionDigits);
	        }
	    }, {
	        key: 'equal',
	        value: function equal(a, b) {
	            return a === b;
	        }
	    }, {
	        key: 'parseIntAutoRadix',
	        value: function parseIntAutoRadix(text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new NumberParseError$3('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        }
	    }, {
	        key: 'parseInt',
	        value: function (_parseInt) {
	            function parseInt(_x4, _x5) {
	                return _parseInt.apply(this, arguments);
	            }

	            parseInt.toString = function () {
	                return _parseInt.toString();
	            };

	            return parseInt;
	        }(function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new NumberParseError$3('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        })
	        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.

	    }, {
	        key: 'parseFloat',
	        value: function (_parseFloat) {
	            function parseFloat(_x6) {
	                return _parseFloat.apply(this, arguments);
	            }

	            parseFloat.toString = function () {
	                return _parseFloat.toString();
	            };

	            return parseFloat;
	        }(function (text) {
	            return parseFloat(text);
	        })
	    }, {
	        key: 'isNumeric',
	        value: function isNumeric(value) {
	            return !isNaN(value - parseFloat(value));
	        }
	    }, {
	        key: 'isNaN',
	        value: function (_isNaN) {
	            function isNaN(_x7) {
	                return _isNaN.apply(this, arguments);
	            }

	            isNaN.toString = function () {
	                return _isNaN.toString();
	            };

	            return isNaN;
	        }(function (value) {
	            return isNaN(value);
	        })
	    }, {
	        key: 'isInteger',
	        value: function isInteger(value) {
	            return Number.isInteger(value);
	        }
	    }, {
	        key: 'NaN',
	        get: function get() {
	            return NaN;
	        }
	    }]);
	    return NumberWrapper;
	}();
	var RegExpWrapper$3 = function () {
	    function RegExpWrapper() {
	        classCallCheck(this, RegExpWrapper);
	    }

	    createClass(RegExpWrapper, null, [{
	        key: 'create',
	        value: function create(regExpStr) {
	            var flags = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            flags = flags.replace(/g/g, '');
	            return new global$4.RegExp(regExpStr, flags + 'g');
	        }
	    }, {
	        key: 'firstMatch',
	        value: function firstMatch(regExp, input) {
	            // Reset multimatch regex state
	            regExp.lastIndex = 0;
	            return regExp.exec(input);
	        }
	    }, {
	        key: 'test',
	        value: function test(regExp, input) {
	            regExp.lastIndex = 0;
	            return regExp.test(input);
	        }
	    }, {
	        key: 'matcher',
	        value: function matcher(regExp, input) {
	            // Reset regex state for the case
	            // someone did not loop over all matches
	            // last time.
	            regExp.lastIndex = 0;
	            return { re: regExp, input: input };
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(regExp, input, replace) {
	            var c = regExp.exec(input);
	            var res = '';
	            regExp.lastIndex = 0;
	            var prev = 0;
	            while (c) {
	                res += input.substring(prev, c.index);
	                res += replace(c);
	                prev = c.index + c[0].length;
	                regExp.lastIndex = prev;
	                c = regExp.exec(input);
	            }
	            res += input.substring(prev);
	            return res;
	        }
	    }]);
	    return RegExpWrapper;
	}();
	var RegExpMatcherWrapper$3 = function () {
	    function RegExpMatcherWrapper() {
	        classCallCheck(this, RegExpMatcherWrapper);
	    }

	    createClass(RegExpMatcherWrapper, null, [{
	        key: 'next',
	        value: function next(matcher) {
	            return matcher.re.exec(matcher.input);
	        }
	    }]);
	    return RegExpMatcherWrapper;
	}();
	var FunctionWrapper$3 = function () {
	    function FunctionWrapper() {
	        classCallCheck(this, FunctionWrapper);
	    }

	    createClass(FunctionWrapper, null, [{
	        key: 'apply',
	        value: function apply(fn, posArgs) {
	            return fn.apply(null, posArgs);
	        }
	    }, {
	        key: 'bind',
	        value: function bind(fn, scope) {
	            return fn.bind(scope);
	        }
	    }]);
	    return FunctionWrapper;
	}();
	function normalizeBlank$3(obj) {
	    return isBlank$3(obj) ? null : obj;
	}
	function normalizeBool$3(obj) {
	    return isBlank$3(obj) ? false : obj;
	}
	function isJsObject$3(o) {
	    return o !== null && (typeof o === 'function' || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object');
	}
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json$3 = function () {
	    function Json() {
	        classCallCheck(this, Json);
	    }

	    createClass(Json, null, [{
	        key: 'parse',
	        value: function parse(s) {
	            return global$4.JSON.parse(s);
	        }
	    }, {
	        key: 'stringify',
	        value: function stringify(data) {
	            // Dart doesn't take 3 arguments
	            return global$4.JSON.stringify(data, null, 2);
	        }
	    }]);
	    return Json;
	}();
	var DateWrapper$3 = function () {
	    function DateWrapper() {
	        classCallCheck(this, DateWrapper);
	    }

	    createClass(DateWrapper, null, [{
	        key: 'create',
	        value: function create(year) {
	            var month = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var day = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	            var hour = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	            var minutes = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
	            var seconds = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
	            var milliseconds = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];

	            return new Date$4(year, month - 1, day, hour, minutes, seconds, milliseconds);
	        }
	    }, {
	        key: 'fromISOString',
	        value: function fromISOString(str) {
	            return new Date$4(str);
	        }
	    }, {
	        key: 'fromMillis',
	        value: function fromMillis(ms) {
	            return new Date$4(ms);
	        }
	    }, {
	        key: 'toMillis',
	        value: function toMillis(date) {
	            return date.getTime();
	        }
	    }, {
	        key: 'now',
	        value: function now() {
	            return new Date$4();
	        }
	    }, {
	        key: 'toJson',
	        value: function toJson(date) {
	            return date.toJSON();
	        }
	    }]);
	    return DateWrapper;
	}();
	var _symbolIterator$3 = null;
	function getSymbolIterator$3() {
	    if (isBlank$3(_symbolIterator$3)) {
	        if (isPresent$3(globalScope$3.Symbol) && isPresent$3(Symbol.iterator)) {
	            _symbolIterator$3 = Symbol.iterator;
	        } else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator$3 = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator$3;
	}
	function evalExpression$3(sourceUrl, expr, declarations, vars) {
	    var fnBody = declarations + '\nreturn ' + expr + '\n//# sourceURL=' + sourceUrl;
	    var fnArgNames = [];
	    var fnArgValues = [];
	    for (var argName in vars) {
	        fnArgNames.push(argName);
	        fnArgValues.push(vars[argName]);
	    }
	    return new (Function.prototype.bind.apply(Function, [null].concat(toConsumableArray(fnArgNames.concat(fnBody)))))().apply(undefined, fnArgValues);
	}
	function isPrimitive$3(obj) {
	    return !isJsObject$3(obj);
	}
	function escape$3(s) {
	    return global$4.encodeURI(s);
	}
	function escapeRegExp$3(s) {
	    return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
	}

	/**
	 * A segment of text within the template.
	 */
	var TextAst = function () {
	    function TextAst(value, ngContentIndex, sourceSpan) {
	        classCallCheck(this, TextAst);

	        this.value = value;
	        this.ngContentIndex = ngContentIndex;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(TextAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitText(this, context);
	        }
	    }]);
	    return TextAst;
	}();
	/**
	 * A bound expression within the text of a template.
	 */
	var BoundTextAst = function () {
	    function BoundTextAst(value, ngContentIndex, sourceSpan) {
	        classCallCheck(this, BoundTextAst);

	        this.value = value;
	        this.ngContentIndex = ngContentIndex;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(BoundTextAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitBoundText(this, context);
	        }
	    }]);
	    return BoundTextAst;
	}();
	/**
	 * A plain attribute on an element.
	 */
	var AttrAst = function () {
	    function AttrAst(name, value, sourceSpan) {
	        classCallCheck(this, AttrAst);

	        this.name = name;
	        this.value = value;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(AttrAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAttr(this, context);
	        }
	    }]);
	    return AttrAst;
	}();
	/**
	 * A binding for an element property (e.g. `[property]="expression"`).
	 */
	var BoundElementPropertyAst = function () {
	    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
	        classCallCheck(this, BoundElementPropertyAst);

	        this.name = name;
	        this.type = type;
	        this.securityContext = securityContext;
	        this.value = value;
	        this.unit = unit;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(BoundElementPropertyAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitElementProperty(this, context);
	        }
	    }]);
	    return BoundElementPropertyAst;
	}();
	/**
	 * A binding for an element event (e.g. `(event)="handler()"`).
	 */
	var BoundEventAst = function () {
	    function BoundEventAst(name, target, handler, sourceSpan) {
	        classCallCheck(this, BoundEventAst);

	        this.name = name;
	        this.target = target;
	        this.handler = handler;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(BoundEventAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitEvent(this, context);
	        }
	    }, {
	        key: "fullName",
	        get: function get() {
	            if (isPresent$3(this.target)) {
	                return this.target + ":" + this.name;
	            } else {
	                return this.name;
	            }
	        }
	    }]);
	    return BoundEventAst;
	}();
	/**
	 * A reference declaration on an element (e.g. `let someName="expression"`).
	 */
	var ReferenceAst = function () {
	    function ReferenceAst(name, value, sourceSpan) {
	        classCallCheck(this, ReferenceAst);

	        this.name = name;
	        this.value = value;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(ReferenceAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitReference(this, context);
	        }
	    }]);
	    return ReferenceAst;
	}();
	/**
	 * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
	 */
	var VariableAst = function () {
	    function VariableAst(name, value, sourceSpan) {
	        classCallCheck(this, VariableAst);

	        this.name = name;
	        this.value = value;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(VariableAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitVariable(this, context);
	        }
	    }]);
	    return VariableAst;
	}();
	/**
	 * An element declaration in a template.
	 */
	var ElementAst = function () {
	    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
	        classCallCheck(this, ElementAst);

	        this.name = name;
	        this.attrs = attrs;
	        this.inputs = inputs;
	        this.outputs = outputs;
	        this.references = references;
	        this.directives = directives;
	        this.providers = providers;
	        this.hasViewContainer = hasViewContainer;
	        this.children = children;
	        this.ngContentIndex = ngContentIndex;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(ElementAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitElement(this, context);
	        }
	    }]);
	    return ElementAst;
	}();
	/**
	 * A `<template>` element included in an Angular template.
	 */
	var EmbeddedTemplateAst = function () {
	    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
	        classCallCheck(this, EmbeddedTemplateAst);

	        this.attrs = attrs;
	        this.outputs = outputs;
	        this.references = references;
	        this.variables = variables;
	        this.directives = directives;
	        this.providers = providers;
	        this.hasViewContainer = hasViewContainer;
	        this.children = children;
	        this.ngContentIndex = ngContentIndex;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(EmbeddedTemplateAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitEmbeddedTemplate(this, context);
	        }
	    }]);
	    return EmbeddedTemplateAst;
	}();
	/**
	 * A directive property with a bound value (e.g. `*ngIf="condition").
	 */
	var BoundDirectivePropertyAst = function () {
	    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
	        classCallCheck(this, BoundDirectivePropertyAst);

	        this.directiveName = directiveName;
	        this.templateName = templateName;
	        this.value = value;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(BoundDirectivePropertyAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitDirectiveProperty(this, context);
	        }
	    }]);
	    return BoundDirectivePropertyAst;
	}();
	/**
	 * A directive declared on an element.
	 */
	var DirectiveAst = function () {
	    function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
	        classCallCheck(this, DirectiveAst);

	        this.directive = directive;
	        this.inputs = inputs;
	        this.hostProperties = hostProperties;
	        this.hostEvents = hostEvents;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(DirectiveAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitDirective(this, context);
	        }
	    }]);
	    return DirectiveAst;
	}();
	/**
	 * A provider declared on an element
	 */
	var ProviderAst = function () {
	    function ProviderAst(token, multiProvider, eager, providers, providerType, sourceSpan) {
	        classCallCheck(this, ProviderAst);

	        this.token = token;
	        this.multiProvider = multiProvider;
	        this.eager = eager;
	        this.providers = providers;
	        this.providerType = providerType;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(ProviderAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            // No visit method in the visitor for now...
	            return null;
	        }
	    }]);
	    return ProviderAst;
	}();
	var ProviderAstType;
	(function (ProviderAstType) {
	    ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
	    ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
	    ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
	    ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
	    ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
	})(ProviderAstType || (ProviderAstType = {}));
	/**
	 * Position where content is to be projected (instance of `<ng-content>` in a template).
	 */
	var NgContentAst = function () {
	    function NgContentAst(index, ngContentIndex, sourceSpan) {
	        classCallCheck(this, NgContentAst);

	        this.index = index;
	        this.ngContentIndex = ngContentIndex;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(NgContentAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitNgContent(this, context);
	        }
	    }]);
	    return NgContentAst;
	}();
	/**
	 * Enumeration of types of property bindings.
	 */
	var PropertyBindingType;
	(function (PropertyBindingType) {
	    /**
	     * A normal binding to a property (e.g. `[property]="expression"`).
	     */
	    PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
	    /**
	     * A binding to an element attribute (e.g. `[attr.name]="expression"`).
	     */
	    PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
	    /**
	     * A binding to a CSS class (e.g. `[class.name]="condition"`).
	     */
	    PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
	    /**
	     * A binding to a style rule (e.g. `[style.rule]="expression"`).
	     */
	    PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
	    /**
	     * A binding to an animation reference (e.g. `[animate.key]="expression"`).
	     */
	    PropertyBindingType[PropertyBindingType["Animation"] = 4] = "Animation";
	})(PropertyBindingType || (PropertyBindingType = {}));
	/**
	 * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
	 */
	function templateVisitAll(visitor, asts) {
	    var context = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	    var result = [];
	    asts.forEach(function (ast) {
	        var astResult = ast.visit(visitor, context);
	        if (isPresent$3(astResult)) {
	            result.push(astResult);
	        }
	    });
	    return result;
	}

	var isDefaultChangeDetectionStrategy$1 = r.isDefaultChangeDetectionStrategy;
	var ChangeDetectorStatus$1 = r.ChangeDetectorStatus;
	var CHANGE_DETECTION_STRATEGY_VALUES$1 = r.CHANGE_DETECTION_STRATEGY_VALUES;
	var LifecycleHooks$1 = r.LifecycleHooks;
	var LIFECYCLE_HOOKS_VALUES$1 = r.LIFECYCLE_HOOKS_VALUES;
	var ReflectorReader$1 = r.ReflectorReader;
	var AppElement$1 = r.AppElement;
	var CodegenComponentFactoryResolver$1 = r.CodegenComponentFactoryResolver;
	var AppView$1 = r.AppView;
	var DebugAppView$1 = r.DebugAppView;
	var ViewType$1 = r.ViewType;
	var MAX_INTERPOLATION_VALUES$1 = r.MAX_INTERPOLATION_VALUES;
	var checkBinding$1 = r.checkBinding;
	var flattenNestedViewRenderNodes$1 = r.flattenNestedViewRenderNodes;
	var interpolate$1 = r.interpolate;
	var ViewUtils$1 = r.ViewUtils;
	var VIEW_ENCAPSULATION_VALUES$2 = r.VIEW_ENCAPSULATION_VALUES;
	var DebugContext$1 = r.DebugContext;
	var StaticNodeDebugInfo$1 = r.StaticNodeDebugInfo;
	var devModeEqual$1 = r.devModeEqual;
	var uninitialized$1 = r.uninitialized;
	var ValueUnwrapper$1 = r.ValueUnwrapper;
	var TemplateRef_$1 = r.TemplateRef_;
	var SecurityContext$2 = r.SecurityContext;
	var createProvider$1 = r.createProvider;
	var isProviderLiteral$1 = r.isProviderLiteral;
	var EMPTY_ARRAY$1 = r.EMPTY_ARRAY;
	var EMPTY_MAP$1 = r.EMPTY_MAP;
	var pureProxy1$1 = r.pureProxy1;
	var pureProxy2$1 = r.pureProxy2;
	var pureProxy3$1 = r.pureProxy3;
	var pureProxy4$1 = r.pureProxy4;
	var pureProxy5$1 = r.pureProxy5;
	var pureProxy6$1 = r.pureProxy6;
	var pureProxy7$1 = r.pureProxy7;
	var pureProxy8$1 = r.pureProxy8;
	var pureProxy9$1 = r.pureProxy9;
	var pureProxy10$1 = r.pureProxy10;
	var castByValue$1 = r.castByValue;
	var Console$1 = r.Console;
	var reflector$2 = r.reflector;
	var NoOpAnimationPlayer_ = r.NoOpAnimationPlayer;
	var AnimationSequencePlayer_ = r.AnimationSequencePlayer;
	var AnimationGroupPlayer_ = r.AnimationGroupPlayer;
	var AnimationKeyframe_ = r.AnimationKeyframe;
	var AnimationStyles_ = r.AnimationStyles;
	var ANY_STATE$1 = r.ANY_STATE;
	var DEFAULT_STATE$1 = r.DEFAULT_STATE;
	var EMPTY_ANIMATION_STATE = r.EMPTY_STATE;
	var FILL_STYLE_FLAG$1 = r.FILL_STYLE_FLAG;
	var impBalanceAnimationStyles = r.prepareFinalAnimationStyles;
	var impBalanceAnimationKeyframes = r.balanceAnimationKeyframes;
	var impClearStyles = r.clearStyles;
	var impCollectAndResolveStyles = r.collectAndResolveStyles;
	var impRenderStyles = r.renderStyles;

	var Map$4 = global$4.Map;
	var Set$4 = global$4.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs$3 = function () {
	    try {
	        if (new Map$4([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) {
	                return new Map$4(pairs);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new Map$4();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	}();
	var createMapFromMap$3 = function () {
	    try {
	        if (new Map$4(new Map$4())) {
	            return function createMapFromMap(m) {
	                return new Map$4(m);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromMap(m) {
	        var map = new Map$4();
	        m.forEach(function (v, k) {
	            map.set(k, v);
	        });
	        return map;
	    };
	}();
	var _clearValues$3 = function () {
	    if (new Map$4().keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!(k = keyIterator.next()).done) {
	                m.set(k.value, null);
	            }
	        };
	    } else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) {
	                m.set(k, null);
	            });
	        };
	    }
	}();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap$3 = function () {
	    try {
	        if (new Map$4().values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    } catch (e) {}
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper$3.createFixedSize(m.size),
	            i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	}();
	var MapWrapper$3 = function () {
	    function MapWrapper() {
	        classCallCheck(this, MapWrapper);
	    }

	    createClass(MapWrapper, null, [{
	        key: 'clone',
	        value: function clone(m) {
	            return createMapFromMap$3(m);
	        }
	    }, {
	        key: 'createFromStringMap',
	        value: function createFromStringMap(stringMap) {
	            var result = new Map$4();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        }
	    }, {
	        key: 'toStringMap',
	        value: function toStringMap(m) {
	            var r = {};
	            m.forEach(function (v, k) {
	                return r[k] = v;
	            });
	            return r;
	        }
	    }, {
	        key: 'createFromPairs',
	        value: function createFromPairs(pairs) {
	            return createMapFromPairs$3(pairs);
	        }
	    }, {
	        key: 'clearValues',
	        value: function clearValues(m) {
	            _clearValues$3(m);
	        }
	    }, {
	        key: 'iterable',
	        value: function iterable(m) {
	            return m;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(m) {
	            return _arrayFromMap$3(m, false);
	        }
	    }, {
	        key: 'values',
	        value: function values(m) {
	            return _arrayFromMap$3(m, true);
	        }
	    }]);
	    return MapWrapper;
	}();
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper$3 = function () {
	    function StringMapWrapper() {
	        classCallCheck(this, StringMapWrapper);
	    }

	    createClass(StringMapWrapper, null, [{
	        key: 'create',
	        value: function create() {
	            // Note: We are not using Object.create(null) here due to
	            // performance!
	            // http://jsperf.com/ng2-object-create-null
	            return {};
	        }
	    }, {
	        key: 'contains',
	        value: function contains(map, key) {
	            return map.hasOwnProperty(key);
	        }
	    }, {
	        key: 'get',
	        value: function get(map, key) {
	            return map.hasOwnProperty(key) ? map[key] : undefined;
	        }
	    }, {
	        key: 'set',
	        value: function set(map, key, value) {
	            map[key] = value;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(map) {
	            return Object.keys(map);
	        }
	    }, {
	        key: 'values',
	        value: function values(map) {
	            return Object.keys(map).reduce(function (r, a) {
	                r.push(map[a]);
	                return r;
	            }, []);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(map) {
	            for (var prop in map) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(map, key) {
	            delete map[key];
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(map, callback) {
	            for (var prop in map) {
	                if (map.hasOwnProperty(prop)) {
	                    callback(map[prop], prop);
	                }
	            }
	        }
	    }, {
	        key: 'merge',
	        value: function merge(m1, m2) {
	            var m = {};
	            for (var attr in m1) {
	                if (m1.hasOwnProperty(attr)) {
	                    m[attr] = m1[attr];
	                }
	            }
	            for (var attr in m2) {
	                if (m2.hasOwnProperty(attr)) {
	                    m[attr] = m2[attr];
	                }
	            }
	            return m;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            var key;
	            for (var i = 0; i < k1.length; i++) {
	                key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }]);
	    return StringMapWrapper;
	}();
	var ListWrapper$3 = function () {
	    function ListWrapper() {
	        classCallCheck(this, ListWrapper);
	    }

	    createClass(ListWrapper, null, [{
	        key: 'createFixedSize',

	        // JS has no way to express a statically fixed size list, but dart does so we
	        // keep both methods.
	        value: function createFixedSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'createGrowableSize',
	        value: function createGrowableSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'clone',
	        value: function clone(array) {
	            return array.slice(0);
	        }
	    }, {
	        key: 'forEachWithIndex',
	        value: function forEachWithIndex(array, fn) {
	            for (var i = 0; i < array.length; i++) {
	                fn(array[i], i);
	            }
	        }
	    }, {
	        key: 'first',
	        value: function first(array) {
	            if (!array) return null;
	            return array[0];
	        }
	    }, {
	        key: 'last',
	        value: function last(array) {
	            if (!array || array.length == 0) return null;
	            return array[array.length - 1];
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(array, value) {
	            var startIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	            return array.indexOf(value, startIndex);
	        }
	    }, {
	        key: 'contains',
	        value: function contains(list, el) {
	            return list.indexOf(el) !== -1;
	        }
	    }, {
	        key: 'reversed',
	        value: function reversed(array) {
	            var a = ListWrapper.clone(array);
	            return a.reverse();
	        }
	    }, {
	        key: 'concat',
	        value: function concat(a, b) {
	            return a.concat(b);
	        }
	    }, {
	        key: 'insert',
	        value: function insert(list, index, value) {
	            list.splice(index, 0, value);
	        }
	    }, {
	        key: 'removeAt',
	        value: function removeAt(list, index) {
	            var res = list[index];
	            list.splice(index, 1);
	            return res;
	        }
	    }, {
	        key: 'removeAll',
	        value: function removeAll(list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'clear',
	        value: function clear(list) {
	            list.length = 0;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(list) {
	            return list.length == 0;
	        }
	    }, {
	        key: 'fill',
	        value: function fill(list, value) {
	            var start = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	            var end = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            list.fill(value, start, end === null ? list.length : end);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(a, b) {
	            if (a.length != b.length) return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i]) return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'slice',
	        value: function slice(l) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return l.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'splice',
	        value: function splice(l, from, length) {
	            return l.splice(from, length);
	        }
	    }, {
	        key: 'sort',
	        value: function sort(l, compareFn) {
	            if (isPresent$3(compareFn)) {
	                l.sort(compareFn);
	            } else {
	                l.sort();
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString(l) {
	            return l.toString();
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON(l) {
	            return JSON.stringify(l);
	        }
	    }, {
	        key: 'maximum',
	        value: function maximum(list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (isBlank$3(candidate)) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        }
	    }, {
	        key: 'flatten',
	        value: function flatten(list) {
	            var target = [];
	            _flattenArray$3(list, target);
	            return target;
	        }
	    }, {
	        key: 'addAll',
	        value: function addAll(list, source) {
	            for (var i = 0; i < source.length; i++) {
	                list.push(source[i]);
	            }
	        }
	    }]);
	    return ListWrapper;
	}();
	function _flattenArray$3(source, target) {
	    if (isPresent$3(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (isArray$4(item)) {
	                _flattenArray$3(item, target);
	            } else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable$3(obj) {
	    if (!isJsObject$3(obj)) return false;
	    return isArray$4(obj) || !(obj instanceof Map$4) && getSymbolIterator$3() in obj; // JS Iterable have a Symbol.iterator prop
	}
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList$3 = function () {
	    var test = new Set$4([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) {
	            return new Set$4(lst);
	        };
	    } else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new Set$4(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	}();
	var SetWrapper$3 = function () {
	    function SetWrapper() {
	        classCallCheck(this, SetWrapper);
	    }

	    createClass(SetWrapper, null, [{
	        key: 'createFromList',
	        value: function createFromList(lst) {
	            return createSetFromList$3(lst);
	        }
	    }, {
	        key: 'has',
	        value: function has(s, key) {
	            return s.has(key);
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(m, k) {
	            m.delete(k);
	        }
	    }]);
	    return SetWrapper;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException$3 = function (_Error) {
	  inherits(BaseWrappedException, _Error);

	  function BaseWrappedException(message) {
	    classCallCheck(this, BaseWrappedException);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(BaseWrappedException).call(this, message));
	  }

	  createClass(BaseWrappedException, [{
	    key: 'wrapperMessage',
	    get: function get() {
	      return '';
	    }
	  }, {
	    key: 'wrapperStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalException',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'message',
	    get: function get() {
	      return '';
	    }
	  }]);
	  return BaseWrappedException;
	}(Error);

	var _ArrayLogger$3 = function () {
	    function _ArrayLogger() {
	        classCallCheck(this, _ArrayLogger);

	        this.res = [];
	    }

	    createClass(_ArrayLogger, [{
	        key: 'log',
	        value: function log(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logError',
	        value: function logError(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return _ArrayLogger;
	}();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */


	var ExceptionHandler$3 = function () {
	    function ExceptionHandler(_logger) {
	        var _rethrowException = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        classCallCheck(this, ExceptionHandler);

	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }

	    createClass(ExceptionHandler, [{
	        key: 'call',
	        value: function call(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var originalException = this._findOriginalException(exception);
	            var originalStack = this._findOriginalStack(exception);
	            var context = this._findContext(exception);
	            this._logger.logGroup('EXCEPTION: ' + this._extractMessage(exception));
	            if (isPresent$3(stackTrace) && isBlank$3(originalStack)) {
	                this._logger.logError('STACKTRACE:');
	                this._logger.logError(this._longStackTrace(stackTrace));
	            }
	            if (isPresent$3(reason)) {
	                this._logger.logError('REASON: ' + reason);
	            }
	            if (isPresent$3(originalException)) {
	                this._logger.logError('ORIGINAL EXCEPTION: ' + this._extractMessage(originalException));
	            }
	            if (isPresent$3(originalStack)) {
	                this._logger.logError('ORIGINAL STACKTRACE:');
	                this._logger.logError(this._longStackTrace(originalStack));
	            }
	            if (isPresent$3(context)) {
	                this._logger.logError('ERROR CONTEXT:');
	                this._logger.logError(context);
	            }
	            this._logger.logGroupEnd();
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	            if (this._rethrowException) throw exception;
	        }
	        /** @internal */

	    }, {
	        key: '_extractMessage',
	        value: function _extractMessage(exception) {
	            return exception instanceof BaseWrappedException$3 ? exception.wrapperMessage : exception.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_longStackTrace',
	        value: function _longStackTrace(stackTrace) {
	            return isListLikeIterable$3(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_findContext',
	        value: function _findContext(exception) {
	            try {
	                if (!(exception instanceof BaseWrappedException$3)) return null;
	                return isPresent$3(exception.context) ? exception.context : this._findContext(exception.originalException);
	            } catch (e) {
	                // exception.context can throw an exception. if it happens, we ignore the context.
	                return null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalException',
	        value: function _findOriginalException(exception) {
	            if (!(exception instanceof BaseWrappedException$3)) return null;
	            var e = exception.originalException;
	            while (e instanceof BaseWrappedException$3 && isPresent$3(e.originalException)) {
	                e = e.originalException;
	            }
	            return e;
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalStack',
	        value: function _findOriginalStack(exception) {
	            if (!(exception instanceof BaseWrappedException$3)) return null;
	            var e = exception;
	            var stack = exception.originalStack;
	            while (e instanceof BaseWrappedException$3 && isPresent$3(e.originalException)) {
	                e = e.originalException;
	                if (e instanceof BaseWrappedException$3 && isPresent$3(e.originalException)) {
	                    stack = e.originalStack;
	                }
	            }
	            return stack;
	        }
	    }], [{
	        key: 'exceptionToString',
	        value: function exceptionToString(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var l = new _ArrayLogger$3();
	            var e = new ExceptionHandler(l, false);
	            e.call(exception, stackTrace, reason);
	            return l.res.join('\n');
	        }
	    }]);
	    return ExceptionHandler;
	}();

	/**
	 * @stable
	 */
	var BaseException$3 = function (_Error) {
	    inherits(BaseException, _Error);

	    function BaseException() {
	        var message = arguments.length <= 0 || arguments[0] === undefined ? '--' : arguments[0];
	        classCallCheck(this, BaseException);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseException).call(this, message));

	        _this.message = message;
	        _this.stack = new Error(message).stack;
	        return _this;
	    }

	    createClass(BaseException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return BaseException;
	}(Error);
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException$3 = function (_BaseWrappedException) {
	    inherits(WrappedException, _BaseWrappedException);

	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        classCallCheck(this, WrappedException);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(WrappedException).call(this, _wrapperMessage));

	        _this2._wrapperMessage = _wrapperMessage;
	        _this2._originalException = _originalException;
	        _this2._originalStack = _originalStack;
	        _this2._context = _context;
	        _this2._wrapperStack = new Error(_wrapperMessage).stack;
	        return _this2;
	    }

	    createClass(WrappedException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            return this._wrapperMessage;
	        }
	    }, {
	        key: 'wrapperStack',
	        get: function get() {
	            return this._wrapperStack;
	        }
	    }, {
	        key: 'originalException',
	        get: function get() {
	            return this._originalException;
	        }
	    }, {
	        key: 'originalStack',
	        get: function get() {
	            return this._originalStack;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._context;
	        }
	    }, {
	        key: 'message',
	        get: function get() {
	            return ExceptionHandler$3.exceptionToString(this);
	        }
	    }]);
	    return WrappedException;
	}(BaseWrappedException$3);
	function unimplemented$3() {
	    throw new BaseException$3('unimplemented');
	}

	var AST = function () {
	    function AST() {
	        classCallCheck(this, AST);
	    }

	    createClass(AST, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            return null;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return 'AST';
	        }
	    }]);
	    return AST;
	}();
	/**
	 * Represents a quoted expression of the form:
	 *
	 * quote = prefix `:` uninterpretedExpression
	 * prefix = identifier
	 * uninterpretedExpression = arbitrary string
	 *
	 * A quoted expression is meant to be pre-processed by an AST transformer that
	 * converts it into another AST that no longer contains quoted expressions.
	 * It is meant to allow third-party developers to extend Angular template
	 * expression language. The `uninterpretedExpression` part of the quote is
	 * therefore not interpreted by the Angular's own expression parser.
	 */
	var Quote = function (_AST) {
	    inherits(Quote, _AST);

	    function Quote(prefix, uninterpretedExpression, location) {
	        classCallCheck(this, Quote);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Quote).call(this));

	        _this.prefix = prefix;
	        _this.uninterpretedExpression = uninterpretedExpression;
	        _this.location = location;
	        return _this;
	    }

	    createClass(Quote, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            return visitor.visitQuote(this, context);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return 'Quote';
	        }
	    }]);
	    return Quote;
	}(AST);
	var EmptyExpr = function (_AST2) {
	    inherits(EmptyExpr, _AST2);

	    function EmptyExpr() {
	        classCallCheck(this, EmptyExpr);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(EmptyExpr).apply(this, arguments));
	    }

	    createClass(EmptyExpr, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            // do nothing

	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        }
	    }]);
	    return EmptyExpr;
	}(AST);
	var ImplicitReceiver = function (_AST3) {
	    inherits(ImplicitReceiver, _AST3);

	    function ImplicitReceiver() {
	        classCallCheck(this, ImplicitReceiver);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ImplicitReceiver).apply(this, arguments));
	    }

	    createClass(ImplicitReceiver, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitImplicitReceiver(this, context);
	        }
	    }]);
	    return ImplicitReceiver;
	}(AST);
	/**
	 * Multiple expressions separated by a semicolon.
	 */
	var Chain = function (_AST4) {
	    inherits(Chain, _AST4);

	    function Chain(expressions) {
	        classCallCheck(this, Chain);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(Chain).call(this));

	        _this4.expressions = expressions;
	        return _this4;
	    }

	    createClass(Chain, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            return visitor.visitChain(this, context);
	        }
	    }]);
	    return Chain;
	}(AST);
	var Conditional = function (_AST5) {
	    inherits(Conditional, _AST5);

	    function Conditional(condition, trueExp, falseExp) {
	        classCallCheck(this, Conditional);

	        var _this5 = possibleConstructorReturn(this, Object.getPrototypeOf(Conditional).call(this));

	        _this5.condition = condition;
	        _this5.trueExp = trueExp;
	        _this5.falseExp = falseExp;
	        return _this5;
	    }

	    createClass(Conditional, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitConditional(this, context);
	        }
	    }]);
	    return Conditional;
	}(AST);
	var PropertyRead = function (_AST6) {
	    inherits(PropertyRead, _AST6);

	    function PropertyRead(receiver, name) {
	        classCallCheck(this, PropertyRead);

	        var _this6 = possibleConstructorReturn(this, Object.getPrototypeOf(PropertyRead).call(this));

	        _this6.receiver = receiver;
	        _this6.name = name;
	        return _this6;
	    }

	    createClass(PropertyRead, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitPropertyRead(this, context);
	        }
	    }]);
	    return PropertyRead;
	}(AST);
	var PropertyWrite = function (_AST7) {
	    inherits(PropertyWrite, _AST7);

	    function PropertyWrite(receiver, name, value) {
	        classCallCheck(this, PropertyWrite);

	        var _this7 = possibleConstructorReturn(this, Object.getPrototypeOf(PropertyWrite).call(this));

	        _this7.receiver = receiver;
	        _this7.name = name;
	        _this7.value = value;
	        return _this7;
	    }

	    createClass(PropertyWrite, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitPropertyWrite(this, context);
	        }
	    }]);
	    return PropertyWrite;
	}(AST);
	var SafePropertyRead = function (_AST8) {
	    inherits(SafePropertyRead, _AST8);

	    function SafePropertyRead(receiver, name) {
	        classCallCheck(this, SafePropertyRead);

	        var _this8 = possibleConstructorReturn(this, Object.getPrototypeOf(SafePropertyRead).call(this));

	        _this8.receiver = receiver;
	        _this8.name = name;
	        return _this8;
	    }

	    createClass(SafePropertyRead, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitSafePropertyRead(this, context);
	        }
	    }]);
	    return SafePropertyRead;
	}(AST);
	var KeyedRead = function (_AST9) {
	    inherits(KeyedRead, _AST9);

	    function KeyedRead(obj, key) {
	        classCallCheck(this, KeyedRead);

	        var _this9 = possibleConstructorReturn(this, Object.getPrototypeOf(KeyedRead).call(this));

	        _this9.obj = obj;
	        _this9.key = key;
	        return _this9;
	    }

	    createClass(KeyedRead, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitKeyedRead(this, context);
	        }
	    }]);
	    return KeyedRead;
	}(AST);
	var KeyedWrite = function (_AST10) {
	    inherits(KeyedWrite, _AST10);

	    function KeyedWrite(obj, key, value) {
	        classCallCheck(this, KeyedWrite);

	        var _this10 = possibleConstructorReturn(this, Object.getPrototypeOf(KeyedWrite).call(this));

	        _this10.obj = obj;
	        _this10.key = key;
	        _this10.value = value;
	        return _this10;
	    }

	    createClass(KeyedWrite, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitKeyedWrite(this, context);
	        }
	    }]);
	    return KeyedWrite;
	}(AST);
	var BindingPipe = function (_AST11) {
	    inherits(BindingPipe, _AST11);

	    function BindingPipe(exp, name, args) {
	        classCallCheck(this, BindingPipe);

	        var _this11 = possibleConstructorReturn(this, Object.getPrototypeOf(BindingPipe).call(this));

	        _this11.exp = exp;
	        _this11.name = name;
	        _this11.args = args;
	        return _this11;
	    }

	    createClass(BindingPipe, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            return visitor.visitPipe(this, context);
	        }
	    }]);
	    return BindingPipe;
	}(AST);
	var LiteralPrimitive = function (_AST12) {
	    inherits(LiteralPrimitive, _AST12);

	    function LiteralPrimitive(value) {
	        classCallCheck(this, LiteralPrimitive);

	        var _this12 = possibleConstructorReturn(this, Object.getPrototypeOf(LiteralPrimitive).call(this));

	        _this12.value = value;
	        return _this12;
	    }

	    createClass(LiteralPrimitive, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitLiteralPrimitive(this, context);
	        }
	    }]);
	    return LiteralPrimitive;
	}(AST);
	var LiteralArray = function (_AST13) {
	    inherits(LiteralArray, _AST13);

	    function LiteralArray(expressions) {
	        classCallCheck(this, LiteralArray);

	        var _this13 = possibleConstructorReturn(this, Object.getPrototypeOf(LiteralArray).call(this));

	        _this13.expressions = expressions;
	        return _this13;
	    }

	    createClass(LiteralArray, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitLiteralArray(this, context);
	        }
	    }]);
	    return LiteralArray;
	}(AST);
	var LiteralMap = function (_AST14) {
	    inherits(LiteralMap, _AST14);

	    function LiteralMap(keys, values) {
	        classCallCheck(this, LiteralMap);

	        var _this14 = possibleConstructorReturn(this, Object.getPrototypeOf(LiteralMap).call(this));

	        _this14.keys = keys;
	        _this14.values = values;
	        return _this14;
	    }

	    createClass(LiteralMap, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitLiteralMap(this, context);
	        }
	    }]);
	    return LiteralMap;
	}(AST);
	var Interpolation = function (_AST15) {
	    inherits(Interpolation, _AST15);

	    function Interpolation(strings, expressions) {
	        classCallCheck(this, Interpolation);

	        var _this15 = possibleConstructorReturn(this, Object.getPrototypeOf(Interpolation).call(this));

	        _this15.strings = strings;
	        _this15.expressions = expressions;
	        return _this15;
	    }

	    createClass(Interpolation, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitInterpolation(this, context);
	        }
	    }]);
	    return Interpolation;
	}(AST);
	var Binary = function (_AST16) {
	    inherits(Binary, _AST16);

	    function Binary(operation, left, right) {
	        classCallCheck(this, Binary);

	        var _this16 = possibleConstructorReturn(this, Object.getPrototypeOf(Binary).call(this));

	        _this16.operation = operation;
	        _this16.left = left;
	        _this16.right = right;
	        return _this16;
	    }

	    createClass(Binary, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitBinary(this, context);
	        }
	    }]);
	    return Binary;
	}(AST);
	var PrefixNot = function (_AST17) {
	    inherits(PrefixNot, _AST17);

	    function PrefixNot(expression) {
	        classCallCheck(this, PrefixNot);

	        var _this17 = possibleConstructorReturn(this, Object.getPrototypeOf(PrefixNot).call(this));

	        _this17.expression = expression;
	        return _this17;
	    }

	    createClass(PrefixNot, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitPrefixNot(this, context);
	        }
	    }]);
	    return PrefixNot;
	}(AST);
	var MethodCall = function (_AST18) {
	    inherits(MethodCall, _AST18);

	    function MethodCall(receiver, name, args) {
	        classCallCheck(this, MethodCall);

	        var _this18 = possibleConstructorReturn(this, Object.getPrototypeOf(MethodCall).call(this));

	        _this18.receiver = receiver;
	        _this18.name = name;
	        _this18.args = args;
	        return _this18;
	    }

	    createClass(MethodCall, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitMethodCall(this, context);
	        }
	    }]);
	    return MethodCall;
	}(AST);
	var SafeMethodCall = function (_AST19) {
	    inherits(SafeMethodCall, _AST19);

	    function SafeMethodCall(receiver, name, args) {
	        classCallCheck(this, SafeMethodCall);

	        var _this19 = possibleConstructorReturn(this, Object.getPrototypeOf(SafeMethodCall).call(this));

	        _this19.receiver = receiver;
	        _this19.name = name;
	        _this19.args = args;
	        return _this19;
	    }

	    createClass(SafeMethodCall, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitSafeMethodCall(this, context);
	        }
	    }]);
	    return SafeMethodCall;
	}(AST);
	var FunctionCall = function (_AST20) {
	    inherits(FunctionCall, _AST20);

	    function FunctionCall(target, args) {
	        classCallCheck(this, FunctionCall);

	        var _this20 = possibleConstructorReturn(this, Object.getPrototypeOf(FunctionCall).call(this));

	        _this20.target = target;
	        _this20.args = args;
	        return _this20;
	    }

	    createClass(FunctionCall, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return visitor.visitFunctionCall(this, context);
	        }
	    }]);
	    return FunctionCall;
	}(AST);
	var ASTWithSource = function (_AST21) {
	    inherits(ASTWithSource, _AST21);

	    function ASTWithSource(ast, source, location) {
	        classCallCheck(this, ASTWithSource);

	        var _this21 = possibleConstructorReturn(this, Object.getPrototypeOf(ASTWithSource).call(this));

	        _this21.ast = ast;
	        _this21.source = source;
	        _this21.location = location;
	        return _this21;
	    }

	    createClass(ASTWithSource, [{
	        key: 'visit',
	        value: function visit(visitor) {
	            var context = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            return this.ast.visit(visitor, context);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.source + ' in ' + this.location;
	        }
	    }]);
	    return ASTWithSource;
	}(AST);
	var TemplateBinding = function TemplateBinding(key, keyIsVar, name, expression) {
	    classCallCheck(this, TemplateBinding);

	    this.key = key;
	    this.keyIsVar = keyIsVar;
	    this.name = name;
	    this.expression = expression;
	};
	var RecursiveAstVisitor = function () {
	    function RecursiveAstVisitor() {
	        classCallCheck(this, RecursiveAstVisitor);
	    }

	    createClass(RecursiveAstVisitor, [{
	        key: 'visitBinary',
	        value: function visitBinary(ast, context) {
	            ast.left.visit(this);
	            ast.right.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitChain',
	        value: function visitChain(ast, context) {
	            return this.visitAll(ast.expressions, context);
	        }
	    }, {
	        key: 'visitConditional',
	        value: function visitConditional(ast, context) {
	            ast.condition.visit(this);
	            ast.trueExp.visit(this);
	            ast.falseExp.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitPipe',
	        value: function visitPipe(ast, context) {
	            ast.exp.visit(this);
	            this.visitAll(ast.args, context);
	            return null;
	        }
	    }, {
	        key: 'visitFunctionCall',
	        value: function visitFunctionCall(ast, context) {
	            ast.target.visit(this);
	            this.visitAll(ast.args, context);
	            return null;
	        }
	    }, {
	        key: 'visitImplicitReceiver',
	        value: function visitImplicitReceiver(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitInterpolation',
	        value: function visitInterpolation(ast, context) {
	            return this.visitAll(ast.expressions, context);
	        }
	    }, {
	        key: 'visitKeyedRead',
	        value: function visitKeyedRead(ast, context) {
	            ast.obj.visit(this);
	            ast.key.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitKeyedWrite',
	        value: function visitKeyedWrite(ast, context) {
	            ast.obj.visit(this);
	            ast.key.visit(this);
	            ast.value.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitLiteralArray',
	        value: function visitLiteralArray(ast, context) {
	            return this.visitAll(ast.expressions, context);
	        }
	    }, {
	        key: 'visitLiteralMap',
	        value: function visitLiteralMap(ast, context) {
	            return this.visitAll(ast.values, context);
	        }
	    }, {
	        key: 'visitLiteralPrimitive',
	        value: function visitLiteralPrimitive(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitMethodCall',
	        value: function visitMethodCall(ast, context) {
	            ast.receiver.visit(this);
	            return this.visitAll(ast.args, context);
	        }
	    }, {
	        key: 'visitPrefixNot',
	        value: function visitPrefixNot(ast, context) {
	            ast.expression.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitPropertyRead',
	        value: function visitPropertyRead(ast, context) {
	            ast.receiver.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitPropertyWrite',
	        value: function visitPropertyWrite(ast, context) {
	            ast.receiver.visit(this);
	            ast.value.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitSafePropertyRead',
	        value: function visitSafePropertyRead(ast, context) {
	            ast.receiver.visit(this);
	            return null;
	        }
	    }, {
	        key: 'visitSafeMethodCall',
	        value: function visitSafeMethodCall(ast, context) {
	            ast.receiver.visit(this);
	            return this.visitAll(ast.args, context);
	        }
	    }, {
	        key: 'visitAll',
	        value: function visitAll(asts, context) {
	            var _this22 = this;

	            asts.forEach(function (ast) {
	                return ast.visit(_this22, context);
	            });
	            return null;
	        }
	    }, {
	        key: 'visitQuote',
	        value: function visitQuote(ast, context) {
	            return null;
	        }
	    }]);
	    return RecursiveAstVisitor;
	}();
	var AstTransformer = function () {
	    function AstTransformer() {
	        classCallCheck(this, AstTransformer);
	    }

	    createClass(AstTransformer, [{
	        key: 'visitImplicitReceiver',
	        value: function visitImplicitReceiver(ast, context) {
	            return ast;
	        }
	    }, {
	        key: 'visitInterpolation',
	        value: function visitInterpolation(ast, context) {
	            return new Interpolation(ast.strings, this.visitAll(ast.expressions));
	        }
	    }, {
	        key: 'visitLiteralPrimitive',
	        value: function visitLiteralPrimitive(ast, context) {
	            return new LiteralPrimitive(ast.value);
	        }
	    }, {
	        key: 'visitPropertyRead',
	        value: function visitPropertyRead(ast, context) {
	            return new PropertyRead(ast.receiver.visit(this), ast.name);
	        }
	    }, {
	        key: 'visitPropertyWrite',
	        value: function visitPropertyWrite(ast, context) {
	            return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.value);
	        }
	    }, {
	        key: 'visitSafePropertyRead',
	        value: function visitSafePropertyRead(ast, context) {
	            return new SafePropertyRead(ast.receiver.visit(this), ast.name);
	        }
	    }, {
	        key: 'visitMethodCall',
	        value: function visitMethodCall(ast, context) {
	            return new MethodCall(ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
	        }
	    }, {
	        key: 'visitSafeMethodCall',
	        value: function visitSafeMethodCall(ast, context) {
	            return new SafeMethodCall(ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
	        }
	    }, {
	        key: 'visitFunctionCall',
	        value: function visitFunctionCall(ast, context) {
	            return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
	        }
	    }, {
	        key: 'visitLiteralArray',
	        value: function visitLiteralArray(ast, context) {
	            return new LiteralArray(this.visitAll(ast.expressions));
	        }
	    }, {
	        key: 'visitLiteralMap',
	        value: function visitLiteralMap(ast, context) {
	            return new LiteralMap(ast.keys, this.visitAll(ast.values));
	        }
	    }, {
	        key: 'visitBinary',
	        value: function visitBinary(ast, context) {
	            return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
	        }
	    }, {
	        key: 'visitPrefixNot',
	        value: function visitPrefixNot(ast, context) {
	            return new PrefixNot(ast.expression.visit(this));
	        }
	    }, {
	        key: 'visitConditional',
	        value: function visitConditional(ast, context) {
	            return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
	        }
	    }, {
	        key: 'visitPipe',
	        value: function visitPipe(ast, context) {
	            return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
	        }
	    }, {
	        key: 'visitKeyedRead',
	        value: function visitKeyedRead(ast, context) {
	            return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));
	        }
	    }, {
	        key: 'visitKeyedWrite',
	        value: function visitKeyedWrite(ast, context) {
	            return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
	        }
	    }, {
	        key: 'visitAll',
	        value: function visitAll(asts) {
	            var res = ListWrapper$3.createFixedSize(asts.length);
	            for (var i = 0; i < asts.length; ++i) {
	                res[i] = asts[i].visit(this);
	            }
	            return res;
	        }
	    }, {
	        key: 'visitChain',
	        value: function visitChain(ast, context) {
	            return new Chain(this.visitAll(ast.expressions));
	        }
	    }, {
	        key: 'visitQuote',
	        value: function visitQuote(ast, context) {
	            return new Quote(ast.prefix, ast.uninterpretedExpression, ast.location);
	        }
	    }]);
	    return AstTransformer;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var $EOF = 0;
	var $TAB = 9;
	var $LF = 10;
	var $VTAB = 11;
	var $FF = 12;
	var $CR = 13;
	var $SPACE = 32;
	var $BANG = 33;
	var $DQ = 34;
	var $HASH = 35;
	var $$ = 36;
	var $PERCENT = 37;
	var $AMPERSAND = 38;
	var $SQ = 39;
	var $LPAREN = 40;
	var $RPAREN = 41;
	var $STAR = 42;
	var $PLUS = 43;
	var $COMMA = 44;
	var $MINUS = 45;
	var $PERIOD = 46;
	var $SLASH = 47;
	var $COLON = 58;
	var $SEMICOLON = 59;
	var $LT = 60;
	var $EQ = 61;
	var $GT = 62;
	var $QUESTION = 63;
	var $0 = 48;
	var $9 = 57;
	var $A = 65;
	var $E = 69;
	var $F = 70;
	var $X = 88;
	var $Z = 90;
	var $LBRACKET = 91;
	var $BACKSLASH = 92;
	var $RBRACKET = 93;
	var $CARET = 94;
	var $_ = 95;
	var $a = 97;
	var $e = 101;
	var $f = 102;
	var $n = 110;
	var $r = 114;
	var $t = 116;
	var $u = 117;
	var $v = 118;
	var $x = 120;
	var $z = 122;
	var $LBRACE = 123;
	var $BAR = 124;
	var $RBRACE = 125;
	var $NBSP = 160;
	var $BT = 96;
	function isWhitespace(code) {
	    return code >= $TAB && code <= $SPACE || code == $NBSP;
	}
	function isDigit(code) {
	    return $0 <= code && code <= $9;
	}
	function isAsciiLetter(code) {
	    return code >= $a && code <= $z || code >= $A && code <= $Z;
	}
	function isAsciiHexDigit(code) {
	    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var DEFAULT_INTERPOLATION_CONFIG = {
	  start: '{{',
	  end: '}}'
	};

	var TokenType;
	(function (TokenType) {
	    TokenType[TokenType["Character"] = 0] = "Character";
	    TokenType[TokenType["Identifier"] = 1] = "Identifier";
	    TokenType[TokenType["Keyword"] = 2] = "Keyword";
	    TokenType[TokenType["String"] = 3] = "String";
	    TokenType[TokenType["Operator"] = 4] = "Operator";
	    TokenType[TokenType["Number"] = 5] = "Number";
	})(TokenType || (TokenType = {}));
	var KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else'];
	var Lexer = function () {
	    function Lexer() {
	        classCallCheck(this, Lexer);
	    }

	    createClass(Lexer, [{
	        key: 'tokenize',
	        value: function tokenize(text) {
	            var scanner = new _Scanner(text);
	            var tokens = [];
	            var token = scanner.scanToken();
	            while (token != null) {
	                tokens.push(token);
	                token = scanner.scanToken();
	            }
	            return tokens;
	        }
	    }]);
	    return Lexer;
	}();
	/** @nocollapse */
	Lexer.decorators = [{ type: Injectable }];
	var Token = function () {
	    function Token(index, type, numValue, strValue) {
	        classCallCheck(this, Token);

	        this.index = index;
	        this.type = type;
	        this.numValue = numValue;
	        this.strValue = strValue;
	    }

	    createClass(Token, [{
	        key: 'isCharacter',
	        value: function isCharacter(code) {
	            return this.type == TokenType.Character && this.numValue == code;
	        }
	    }, {
	        key: 'isNumber',
	        value: function isNumber() {
	            return this.type == TokenType.Number;
	        }
	    }, {
	        key: 'isString',
	        value: function isString() {
	            return this.type == TokenType.String;
	        }
	    }, {
	        key: 'isOperator',
	        value: function isOperator(operater) {
	            return this.type == TokenType.Operator && this.strValue == operater;
	        }
	    }, {
	        key: 'isIdentifier',
	        value: function isIdentifier() {
	            return this.type == TokenType.Identifier;
	        }
	    }, {
	        key: 'isKeyword',
	        value: function isKeyword() {
	            return this.type == TokenType.Keyword;
	        }
	    }, {
	        key: 'isKeywordDeprecatedVar',
	        value: function isKeywordDeprecatedVar() {
	            return this.type == TokenType.Keyword && this.strValue == 'var';
	        }
	    }, {
	        key: 'isKeywordLet',
	        value: function isKeywordLet() {
	            return this.type == TokenType.Keyword && this.strValue == 'let';
	        }
	    }, {
	        key: 'isKeywordNull',
	        value: function isKeywordNull() {
	            return this.type == TokenType.Keyword && this.strValue == 'null';
	        }
	    }, {
	        key: 'isKeywordUndefined',
	        value: function isKeywordUndefined() {
	            return this.type == TokenType.Keyword && this.strValue == 'undefined';
	        }
	    }, {
	        key: 'isKeywordTrue',
	        value: function isKeywordTrue() {
	            return this.type == TokenType.Keyword && this.strValue == 'true';
	        }
	    }, {
	        key: 'isKeywordFalse',
	        value: function isKeywordFalse() {
	            return this.type == TokenType.Keyword && this.strValue == 'false';
	        }
	    }, {
	        key: 'toNumber',
	        value: function toNumber() {
	            // -1 instead of NULL ok?
	            return this.type == TokenType.Number ? this.numValue : -1;
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            switch (this.type) {
	                case TokenType.Character:
	                case TokenType.Identifier:
	                case TokenType.Keyword:
	                case TokenType.Operator:
	                case TokenType.String:
	                    return this.strValue;
	                case TokenType.Number:
	                    return this.numValue.toString();
	                default:
	                    return null;
	            }
	        }
	    }]);
	    return Token;
	}();
	function newCharacterToken(index, code) {
	    return new Token(index, TokenType.Character, code, StringWrapper$3.fromCharCode(code));
	}
	function newIdentifierToken(index, text) {
	    return new Token(index, TokenType.Identifier, 0, text);
	}
	function newKeywordToken(index, text) {
	    return new Token(index, TokenType.Keyword, 0, text);
	}
	function newOperatorToken(index, text) {
	    return new Token(index, TokenType.Operator, 0, text);
	}
	function newStringToken(index, text) {
	    return new Token(index, TokenType.String, 0, text);
	}
	function newNumberToken(index, n) {
	    return new Token(index, TokenType.Number, n, '');
	}
	var EOF = new Token(-1, TokenType.Character, 0, '');
	var ScannerError = function (_BaseException) {
	    inherits(ScannerError, _BaseException);

	    function ScannerError(message) {
	        classCallCheck(this, ScannerError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ScannerError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(ScannerError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return ScannerError;
	}(BaseException$3);

	var _Scanner = function () {
	    function _Scanner(input) {
	        classCallCheck(this, _Scanner);

	        this.input = input;
	        this.peek = 0;
	        this.index = -1;
	        this.length = input.length;
	        this.advance();
	    }

	    createClass(_Scanner, [{
	        key: 'advance',
	        value: function advance() {
	            this.peek = ++this.index >= this.length ? $EOF : StringWrapper$3.charCodeAt(this.input, this.index);
	        }
	    }, {
	        key: 'scanToken',
	        value: function scanToken() {
	            var input = this.input,
	                length = this.length,
	                peek = this.peek,
	                index = this.index;
	            // Skip whitespace.
	            while (peek <= $SPACE) {
	                if (++index >= length) {
	                    peek = $EOF;
	                    break;
	                } else {
	                    peek = StringWrapper$3.charCodeAt(input, index);
	                }
	            }
	            this.peek = peek;
	            this.index = index;
	            if (index >= length) {
	                return null;
	            }
	            // Handle identifiers and numbers.
	            if (isIdentifierStart(peek)) return this.scanIdentifier();
	            if (isDigit(peek)) return this.scanNumber(index);
	            var start = index;
	            switch (peek) {
	                case $PERIOD:
	                    this.advance();
	                    return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, $PERIOD);
	                case $LPAREN:
	                case $RPAREN:
	                case $LBRACE:
	                case $RBRACE:
	                case $LBRACKET:
	                case $RBRACKET:
	                case $COMMA:
	                case $COLON:
	                case $SEMICOLON:
	                    return this.scanCharacter(start, peek);
	                case $SQ:
	                case $DQ:
	                    return this.scanString();
	                case $HASH:
	                case $PLUS:
	                case $MINUS:
	                case $STAR:
	                case $SLASH:
	                case $PERCENT:
	                case $CARET:
	                    return this.scanOperator(start, StringWrapper$3.fromCharCode(peek));
	                case $QUESTION:
	                    return this.scanComplexOperator(start, '?', $PERIOD, '.');
	                case $LT:
	                case $GT:
	                    return this.scanComplexOperator(start, StringWrapper$3.fromCharCode(peek), $EQ, '=');
	                case $BANG:
	                case $EQ:
	                    return this.scanComplexOperator(start, StringWrapper$3.fromCharCode(peek), $EQ, '=', $EQ, '=');
	                case $AMPERSAND:
	                    return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
	                case $BAR:
	                    return this.scanComplexOperator(start, '|', $BAR, '|');
	                case $NBSP:
	                    while (isWhitespace(this.peek)) {
	                        this.advance();
	                    }return this.scanToken();
	            }
	            this.error('Unexpected character [' + StringWrapper$3.fromCharCode(peek) + ']', 0);
	            return null;
	        }
	    }, {
	        key: 'scanCharacter',
	        value: function scanCharacter(start, code) {
	            this.advance();
	            return newCharacterToken(start, code);
	        }
	    }, {
	        key: 'scanOperator',
	        value: function scanOperator(start, str) {
	            this.advance();
	            return newOperatorToken(start, str);
	        }
	        /**
	         * Tokenize a 2/3 char long operator
	         *
	         * @param start start index in the expression
	         * @param one first symbol (always part of the operator)
	         * @param twoCode code point for the second symbol
	         * @param two second symbol (part of the operator when the second code point matches)
	         * @param threeCode code point for the third symbol
	         * @param three third symbol (part of the operator when provided and matches source expression)
	         * @returns {Token}
	         */

	    }, {
	        key: 'scanComplexOperator',
	        value: function scanComplexOperator(start, one, twoCode, two, threeCode, three) {
	            this.advance();
	            var str = one;
	            if (this.peek == twoCode) {
	                this.advance();
	                str += two;
	            }
	            if (isPresent$3(threeCode) && this.peek == threeCode) {
	                this.advance();
	                str += three;
	            }
	            return newOperatorToken(start, str);
	        }
	    }, {
	        key: 'scanIdentifier',
	        value: function scanIdentifier() {
	            var start = this.index;
	            this.advance();
	            while (isIdentifierPart(this.peek)) {
	                this.advance();
	            }var str = this.input.substring(start, this.index);
	            return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) : newIdentifierToken(start, str);
	        }
	    }, {
	        key: 'scanNumber',
	        value: function scanNumber(start) {
	            var simple = this.index === start;
	            this.advance(); // Skip initial digit.
	            while (true) {
	                if (isDigit(this.peek)) {} else if (this.peek == $PERIOD) {
	                    simple = false;
	                } else if (isExponentStart(this.peek)) {
	                    this.advance();
	                    if (isExponentSign(this.peek)) this.advance();
	                    if (!isDigit(this.peek)) this.error('Invalid exponent', -1);
	                    simple = false;
	                } else {
	                    break;
	                }
	                this.advance();
	            }
	            var str = this.input.substring(start, this.index);
	            var value = simple ? NumberWrapper$3.parseIntAutoRadix(str) : NumberWrapper$3.parseFloat(str);
	            return newNumberToken(start, value);
	        }
	    }, {
	        key: 'scanString',
	        value: function scanString() {
	            var start = this.index;
	            var quote = this.peek;
	            this.advance(); // Skip initial quote.
	            var buffer;
	            var marker = this.index;
	            var input = this.input;
	            while (this.peek != quote) {
	                if (this.peek == $BACKSLASH) {
	                    if (buffer == null) buffer = new StringJoiner$3();
	                    buffer.add(input.substring(marker, this.index));
	                    this.advance();
	                    var unescapedCode;
	                    if (this.peek == $u) {
	                        // 4 character hex code for unicode character.
	                        var hex = input.substring(this.index + 1, this.index + 5);
	                        try {
	                            unescapedCode = NumberWrapper$3.parseInt(hex, 16);
	                        } catch (e) {
	                            this.error('Invalid unicode escape [\\u' + hex + ']', 0);
	                        }
	                        for (var i = 0; i < 5; i++) {
	                            this.advance();
	                        }
	                    } else {
	                        unescapedCode = unescape(this.peek);
	                        this.advance();
	                    }
	                    buffer.add(StringWrapper$3.fromCharCode(unescapedCode));
	                    marker = this.index;
	                } else if (this.peek == $EOF) {
	                    this.error('Unterminated quote', 0);
	                } else {
	                    this.advance();
	                }
	            }
	            var last = input.substring(marker, this.index);
	            this.advance(); // Skip terminating quote.
	            // Compute the unescaped string value.
	            var unescaped = last;
	            if (buffer != null) {
	                buffer.add(last);
	                unescaped = buffer.toString();
	            }
	            return newStringToken(start, unescaped);
	        }
	    }, {
	        key: 'error',
	        value: function error(message, offset) {
	            var position = this.index + offset;
	            throw new ScannerError('Lexer Error: ' + message + ' at column ' + position + ' in expression [' + this.input + ']');
	        }
	    }]);
	    return _Scanner;
	}();

	function isIdentifierStart(code) {
	    return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;
	}
	function isIdentifier(input) {
	    if (input.length == 0) return false;
	    var scanner = new _Scanner(input);
	    if (!isIdentifierStart(scanner.peek)) return false;
	    scanner.advance();
	    while (scanner.peek !== $EOF) {
	        if (!isIdentifierPart(scanner.peek)) return false;
	        scanner.advance();
	    }
	    return true;
	}
	function isIdentifierPart(code) {
	    return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;
	}
	function isExponentStart(code) {
	    return code == $e || code == $E;
	}
	function isExponentSign(code) {
	    return code == $MINUS || code == $PLUS;
	}
	function isQuote(code) {
	    return code === $SQ || code === $DQ || code === $BT;
	}
	function unescape(code) {
	    switch (code) {
	        case $n:
	            return $LF;
	        case $f:
	            return $FF;
	        case $r:
	            return $CR;
	        case $t:
	            return $TAB;
	        case $v:
	            return $VTAB;
	        default:
	            return code;
	    }
	}

	var _implicitReceiver = new ImplicitReceiver();

	var ParseException = function (_BaseException) {
	    inherits(ParseException, _BaseException);

	    function ParseException(message, input, errLocation, ctxLocation) {
	        classCallCheck(this, ParseException);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ParseException).call(this, 'Parser Error: ' + message + ' ' + errLocation + ' [' + input + '] in ' + ctxLocation));
	    }

	    return ParseException;
	}(BaseException$3);

	var SplitInterpolation = function SplitInterpolation(strings, expressions) {
	    classCallCheck(this, SplitInterpolation);

	    this.strings = strings;
	    this.expressions = expressions;
	};
	var TemplateBindingParseResult = function TemplateBindingParseResult(templateBindings, warnings) {
	    classCallCheck(this, TemplateBindingParseResult);

	    this.templateBindings = templateBindings;
	    this.warnings = warnings;
	};
	function _createInterpolateRegExp(config) {
	    var regexp = escapeRegExp$3(config.start) + '([\\s\\S]*?)' + escapeRegExp$3(config.end);
	    return RegExpWrapper$3.create(regexp, 'g');
	}
	var Parser = function () {
	    function Parser( /** @internal */_lexer) {
	        classCallCheck(this, Parser);

	        this._lexer = _lexer;
	    }

	    createClass(Parser, [{
	        key: 'parseAction',
	        value: function parseAction(input, location) {
	            var interpolationConfig = arguments.length <= 2 || arguments[2] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[2];

	            this._checkNoInterpolation(input, location, interpolationConfig);
	            var tokens = this._lexer.tokenize(this._stripComments(input));
	            var ast = new _ParseAST(input, location, tokens, true).parseChain();
	            return new ASTWithSource(ast, input, location);
	        }
	    }, {
	        key: 'parseBinding',
	        value: function parseBinding(input, location) {
	            var interpolationConfig = arguments.length <= 2 || arguments[2] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[2];

	            var ast = this._parseBindingAst(input, location, interpolationConfig);
	            return new ASTWithSource(ast, input, location);
	        }
	    }, {
	        key: 'parseSimpleBinding',
	        value: function parseSimpleBinding(input, location) {
	            var interpolationConfig = arguments.length <= 2 || arguments[2] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[2];

	            var ast = this._parseBindingAst(input, location, interpolationConfig);
	            if (!SimpleExpressionChecker.check(ast)) {
	                throw new ParseException('Host binding expression can only contain field access and constants', input, location);
	            }
	            return new ASTWithSource(ast, input, location);
	        }
	    }, {
	        key: '_parseBindingAst',
	        value: function _parseBindingAst(input, location, interpolationConfig) {
	            // Quotes expressions use 3rd-party expression language. We don't want to use
	            // our lexer or parser for that, so we check for that ahead of time.
	            var quote = this._parseQuote(input, location);
	            if (isPresent$3(quote)) {
	                return quote;
	            }
	            this._checkNoInterpolation(input, location, interpolationConfig);
	            var tokens = this._lexer.tokenize(this._stripComments(input));
	            return new _ParseAST(input, location, tokens, false).parseChain();
	        }
	    }, {
	        key: '_parseQuote',
	        value: function _parseQuote(input, location) {
	            if (isBlank$3(input)) return null;
	            var prefixSeparatorIndex = input.indexOf(':');
	            if (prefixSeparatorIndex == -1) return null;
	            var prefix = input.substring(0, prefixSeparatorIndex).trim();
	            if (!isIdentifier(prefix)) return null;
	            var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
	            return new Quote(prefix, uninterpretedExpression, location);
	        }
	    }, {
	        key: 'parseTemplateBindings',
	        value: function parseTemplateBindings(input, location) {
	            var tokens = this._lexer.tokenize(input);
	            return new _ParseAST(input, location, tokens, false).parseTemplateBindings();
	        }
	    }, {
	        key: 'parseInterpolation',
	        value: function parseInterpolation(input, location) {
	            var interpolationConfig = arguments.length <= 2 || arguments[2] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[2];

	            var split = this.splitInterpolation(input, location, interpolationConfig);
	            if (split == null) return null;
	            var expressions = [];
	            for (var i = 0; i < split.expressions.length; ++i) {
	                var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
	                var ast = new _ParseAST(input, location, tokens, false).parseChain();
	                expressions.push(ast);
	            }
	            return new ASTWithSource(new Interpolation(split.strings, expressions), input, location);
	        }
	    }, {
	        key: 'splitInterpolation',
	        value: function splitInterpolation(input, location) {
	            var interpolationConfig = arguments.length <= 2 || arguments[2] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[2];

	            var regexp = _createInterpolateRegExp(interpolationConfig);
	            var parts = StringWrapper$3.split(input, regexp);
	            if (parts.length <= 1) {
	                return null;
	            }
	            var strings = [];
	            var expressions = [];
	            for (var i = 0; i < parts.length; i++) {
	                var part = parts[i];
	                if (i % 2 === 0) {
	                    // fixed string
	                    strings.push(part);
	                } else if (part.trim().length > 0) {
	                    expressions.push(part);
	                } else {
	                    throw new ParseException('Blank expressions are not allowed in interpolated strings', input, 'at column ' + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + ' in', location);
	                }
	            }
	            return new SplitInterpolation(strings, expressions);
	        }
	    }, {
	        key: 'wrapLiteralPrimitive',
	        value: function wrapLiteralPrimitive(input, location) {
	            return new ASTWithSource(new LiteralPrimitive(input), input, location);
	        }
	    }, {
	        key: '_stripComments',
	        value: function _stripComments(input) {
	            var i = this._commentStart(input);
	            return isPresent$3(i) ? input.substring(0, i).trim() : input;
	        }
	    }, {
	        key: '_commentStart',
	        value: function _commentStart(input) {
	            var outerQuote = null;
	            for (var i = 0; i < input.length - 1; i++) {
	                var char = StringWrapper$3.charCodeAt(input, i);
	                var nextChar = StringWrapper$3.charCodeAt(input, i + 1);
	                if (char === $SLASH && nextChar == $SLASH && isBlank$3(outerQuote)) return i;
	                if (outerQuote === char) {
	                    outerQuote = null;
	                } else if (isBlank$3(outerQuote) && isQuote(char)) {
	                    outerQuote = char;
	                }
	            }
	            return null;
	        }
	    }, {
	        key: '_checkNoInterpolation',
	        value: function _checkNoInterpolation(input, location, interpolationConfig) {
	            var regexp = _createInterpolateRegExp(interpolationConfig);
	            var parts = StringWrapper$3.split(input, regexp);
	            if (parts.length > 1) {
	                throw new ParseException('Got interpolation (' + interpolationConfig.start + interpolationConfig.end + ') where expression was expected', input, 'at column ' + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + ' in', location);
	            }
	        }
	    }, {
	        key: '_findInterpolationErrorColumn',
	        value: function _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig) {
	            var errLocation = '';
	            for (var j = 0; j < partInErrIdx; j++) {
	                errLocation += j % 2 === 0 ? parts[j] : '' + interpolationConfig.start + parts[j] + interpolationConfig.end;
	            }
	            return errLocation.length;
	        }
	    }]);
	    return Parser;
	}();
	/** @nocollapse */
	Parser.decorators = [{ type: Injectable }];
	/** @nocollapse */
	Parser.ctorParameters = [{ type: Lexer }];
	var _ParseAST = function () {
	    function _ParseAST(input, location, tokens, parseAction) {
	        classCallCheck(this, _ParseAST);

	        this.input = input;
	        this.location = location;
	        this.tokens = tokens;
	        this.parseAction = parseAction;
	        this.index = 0;
	    }

	    createClass(_ParseAST, [{
	        key: 'peek',
	        value: function peek(offset) {
	            var i = this.index + offset;
	            return i < this.tokens.length ? this.tokens[i] : EOF;
	        }
	    }, {
	        key: 'advance',
	        value: function advance() {
	            this.index++;
	        }
	    }, {
	        key: 'optionalCharacter',
	        value: function optionalCharacter(code) {
	            if (this.next.isCharacter(code)) {
	                this.advance();
	                return true;
	            } else {
	                return false;
	            }
	        }
	    }, {
	        key: 'peekKeywordLet',
	        value: function peekKeywordLet() {
	            return this.next.isKeywordLet();
	        }
	    }, {
	        key: 'peekDeprecatedKeywordVar',
	        value: function peekDeprecatedKeywordVar() {
	            return this.next.isKeywordDeprecatedVar();
	        }
	    }, {
	        key: 'peekDeprecatedOperatorHash',
	        value: function peekDeprecatedOperatorHash() {
	            return this.next.isOperator('#');
	        }
	    }, {
	        key: 'expectCharacter',
	        value: function expectCharacter(code) {
	            if (this.optionalCharacter(code)) return;
	            this.error('Missing expected ' + StringWrapper$3.fromCharCode(code));
	        }
	    }, {
	        key: 'optionalOperator',
	        value: function optionalOperator(op) {
	            if (this.next.isOperator(op)) {
	                this.advance();
	                return true;
	            } else {
	                return false;
	            }
	        }
	    }, {
	        key: 'expectOperator',
	        value: function expectOperator(operator) {
	            if (this.optionalOperator(operator)) return;
	            this.error('Missing expected operator ' + operator);
	        }
	    }, {
	        key: 'expectIdentifierOrKeyword',
	        value: function expectIdentifierOrKeyword() {
	            var n = this.next;
	            if (!n.isIdentifier() && !n.isKeyword()) {
	                this.error('Unexpected token ' + n + ', expected identifier or keyword');
	            }
	            this.advance();
	            return n.toString();
	        }
	    }, {
	        key: 'expectIdentifierOrKeywordOrString',
	        value: function expectIdentifierOrKeywordOrString() {
	            var n = this.next;
	            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
	                this.error('Unexpected token ' + n + ', expected identifier, keyword, or string');
	            }
	            this.advance();
	            return n.toString();
	        }
	    }, {
	        key: 'parseChain',
	        value: function parseChain() {
	            var exprs = [];
	            while (this.index < this.tokens.length) {
	                var expr = this.parsePipe();
	                exprs.push(expr);
	                if (this.optionalCharacter($SEMICOLON)) {
	                    if (!this.parseAction) {
	                        this.error('Binding expression cannot contain chained expression');
	                    }
	                    while (this.optionalCharacter($SEMICOLON)) {} // read all semicolons
	                } else if (this.index < this.tokens.length) {
	                    this.error('Unexpected token \'' + this.next + '\'');
	                }
	            }
	            if (exprs.length == 0) return new EmptyExpr();
	            if (exprs.length == 1) return exprs[0];
	            return new Chain(exprs);
	        }
	    }, {
	        key: 'parsePipe',
	        value: function parsePipe() {
	            var result = this.parseExpression();
	            if (this.optionalOperator('|')) {
	                if (this.parseAction) {
	                    this.error('Cannot have a pipe in an action expression');
	                }
	                do {
	                    var name = this.expectIdentifierOrKeyword();
	                    var args = [];
	                    while (this.optionalCharacter($COLON)) {
	                        args.push(this.parseExpression());
	                    }
	                    result = new BindingPipe(result, name, args);
	                } while (this.optionalOperator('|'));
	            }
	            return result;
	        }
	    }, {
	        key: 'parseExpression',
	        value: function parseExpression() {
	            return this.parseConditional();
	        }
	    }, {
	        key: 'parseConditional',
	        value: function parseConditional() {
	            var start = this.inputIndex;
	            var result = this.parseLogicalOr();
	            if (this.optionalOperator('?')) {
	                var yes = this.parsePipe();
	                if (!this.optionalCharacter($COLON)) {
	                    var end = this.inputIndex;
	                    var expression = this.input.substring(start, end);
	                    this.error('Conditional expression ' + expression + ' requires all 3 expressions');
	                }
	                var no = this.parsePipe();
	                return new Conditional(result, yes, no);
	            } else {
	                return result;
	            }
	        }
	    }, {
	        key: 'parseLogicalOr',
	        value: function parseLogicalOr() {
	            // '||'
	            var result = this.parseLogicalAnd();
	            while (this.optionalOperator('||')) {
	                result = new Binary('||', result, this.parseLogicalAnd());
	            }
	            return result;
	        }
	    }, {
	        key: 'parseLogicalAnd',
	        value: function parseLogicalAnd() {
	            // '&&'
	            var result = this.parseEquality();
	            while (this.optionalOperator('&&')) {
	                result = new Binary('&&', result, this.parseEquality());
	            }
	            return result;
	        }
	    }, {
	        key: 'parseEquality',
	        value: function parseEquality() {
	            // '==','!=','===','!=='
	            var result = this.parseRelational();
	            while (true) {
	                if (this.optionalOperator('==')) {
	                    result = new Binary('==', result, this.parseRelational());
	                } else if (this.optionalOperator('===')) {
	                    result = new Binary('===', result, this.parseRelational());
	                } else if (this.optionalOperator('!=')) {
	                    result = new Binary('!=', result, this.parseRelational());
	                } else if (this.optionalOperator('!==')) {
	                    result = new Binary('!==', result, this.parseRelational());
	                } else {
	                    return result;
	                }
	            }
	        }
	    }, {
	        key: 'parseRelational',
	        value: function parseRelational() {
	            // '<', '>', '<=', '>='
	            var result = this.parseAdditive();
	            while (true) {
	                if (this.optionalOperator('<')) {
	                    result = new Binary('<', result, this.parseAdditive());
	                } else if (this.optionalOperator('>')) {
	                    result = new Binary('>', result, this.parseAdditive());
	                } else if (this.optionalOperator('<=')) {
	                    result = new Binary('<=', result, this.parseAdditive());
	                } else if (this.optionalOperator('>=')) {
	                    result = new Binary('>=', result, this.parseAdditive());
	                } else {
	                    return result;
	                }
	            }
	        }
	    }, {
	        key: 'parseAdditive',
	        value: function parseAdditive() {
	            // '+', '-'
	            var result = this.parseMultiplicative();
	            while (true) {
	                if (this.optionalOperator('+')) {
	                    result = new Binary('+', result, this.parseMultiplicative());
	                } else if (this.optionalOperator('-')) {
	                    result = new Binary('-', result, this.parseMultiplicative());
	                } else {
	                    return result;
	                }
	            }
	        }
	    }, {
	        key: 'parseMultiplicative',
	        value: function parseMultiplicative() {
	            // '*', '%', '/'
	            var result = this.parsePrefix();
	            while (true) {
	                if (this.optionalOperator('*')) {
	                    result = new Binary('*', result, this.parsePrefix());
	                } else if (this.optionalOperator('%')) {
	                    result = new Binary('%', result, this.parsePrefix());
	                } else if (this.optionalOperator('/')) {
	                    result = new Binary('/', result, this.parsePrefix());
	                } else {
	                    return result;
	                }
	            }
	        }
	    }, {
	        key: 'parsePrefix',
	        value: function parsePrefix() {
	            if (this.optionalOperator('+')) {
	                return this.parsePrefix();
	            } else if (this.optionalOperator('-')) {
	                return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
	            } else if (this.optionalOperator('!')) {
	                return new PrefixNot(this.parsePrefix());
	            } else {
	                return this.parseCallChain();
	            }
	        }
	    }, {
	        key: 'parseCallChain',
	        value: function parseCallChain() {
	            var result = this.parsePrimary();
	            while (true) {
	                if (this.optionalCharacter($PERIOD)) {
	                    result = this.parseAccessMemberOrMethodCall(result, false);
	                } else if (this.optionalOperator('?.')) {
	                    result = this.parseAccessMemberOrMethodCall(result, true);
	                } else if (this.optionalCharacter($LBRACKET)) {
	                    var key = this.parsePipe();
	                    this.expectCharacter($RBRACKET);
	                    if (this.optionalOperator('=')) {
	                        var value = this.parseConditional();
	                        result = new KeyedWrite(result, key, value);
	                    } else {
	                        result = new KeyedRead(result, key);
	                    }
	                } else if (this.optionalCharacter($LPAREN)) {
	                    var args = this.parseCallArguments();
	                    this.expectCharacter($RPAREN);
	                    result = new FunctionCall(result, args);
	                } else {
	                    return result;
	                }
	            }
	        }
	    }, {
	        key: 'parsePrimary',
	        value: function parsePrimary() {
	            if (this.optionalCharacter($LPAREN)) {
	                var result = this.parsePipe();
	                this.expectCharacter($RPAREN);
	                return result;
	            } else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
	                this.advance();
	                return new LiteralPrimitive(null);
	            } else if (this.next.isKeywordTrue()) {
	                this.advance();
	                return new LiteralPrimitive(true);
	            } else if (this.next.isKeywordFalse()) {
	                this.advance();
	                return new LiteralPrimitive(false);
	            } else if (this.optionalCharacter($LBRACKET)) {
	                var elements = this.parseExpressionList($RBRACKET);
	                this.expectCharacter($RBRACKET);
	                return new LiteralArray(elements);
	            } else if (this.next.isCharacter($LBRACE)) {
	                return this.parseLiteralMap();
	            } else if (this.next.isIdentifier()) {
	                return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
	            } else if (this.next.isNumber()) {
	                var value = this.next.toNumber();
	                this.advance();
	                return new LiteralPrimitive(value);
	            } else if (this.next.isString()) {
	                var literalValue = this.next.toString();
	                this.advance();
	                return new LiteralPrimitive(literalValue);
	            } else if (this.index >= this.tokens.length) {
	                this.error('Unexpected end of expression: ' + this.input);
	            } else {
	                this.error('Unexpected token ' + this.next);
	            }
	            // error() throws, so we don't reach here.
	            throw new BaseException$3('Fell through all cases in parsePrimary');
	        }
	    }, {
	        key: 'parseExpressionList',
	        value: function parseExpressionList(terminator) {
	            var result = [];
	            if (!this.next.isCharacter(terminator)) {
	                do {
	                    result.push(this.parsePipe());
	                } while (this.optionalCharacter($COMMA));
	            }
	            return result;
	        }
	    }, {
	        key: 'parseLiteralMap',
	        value: function parseLiteralMap() {
	            var keys = [];
	            var values = [];
	            this.expectCharacter($LBRACE);
	            if (!this.optionalCharacter($RBRACE)) {
	                do {
	                    var key = this.expectIdentifierOrKeywordOrString();
	                    keys.push(key);
	                    this.expectCharacter($COLON);
	                    values.push(this.parsePipe());
	                } while (this.optionalCharacter($COMMA));
	                this.expectCharacter($RBRACE);
	            }
	            return new LiteralMap(keys, values);
	        }
	    }, {
	        key: 'parseAccessMemberOrMethodCall',
	        value: function parseAccessMemberOrMethodCall(receiver) {
	            var isSafe = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

	            var id = this.expectIdentifierOrKeyword();
	            if (this.optionalCharacter($LPAREN)) {
	                var args = this.parseCallArguments();
	                this.expectCharacter($RPAREN);
	                return isSafe ? new SafeMethodCall(receiver, id, args) : new MethodCall(receiver, id, args);
	            } else {
	                if (isSafe) {
	                    if (this.optionalOperator('=')) {
	                        this.error('The \'?.\' operator cannot be used in the assignment');
	                    } else {
	                        return new SafePropertyRead(receiver, id);
	                    }
	                } else {
	                    if (this.optionalOperator('=')) {
	                        if (!this.parseAction) {
	                            this.error('Bindings cannot contain assignments');
	                        }
	                        var value = this.parseConditional();
	                        return new PropertyWrite(receiver, id, value);
	                    } else {
	                        return new PropertyRead(receiver, id);
	                    }
	                }
	            }
	            return null;
	        }
	    }, {
	        key: 'parseCallArguments',
	        value: function parseCallArguments() {
	            if (this.next.isCharacter($RPAREN)) return [];
	            var positionals = [];
	            do {
	                positionals.push(this.parsePipe());
	            } while (this.optionalCharacter($COMMA));
	            return positionals;
	        }
	        /**
	         * An identifier, a keyword, a string with an optional `-` inbetween.
	         */

	    }, {
	        key: 'expectTemplateBindingKey',
	        value: function expectTemplateBindingKey() {
	            var result = '';
	            var operatorFound = false;
	            do {
	                result += this.expectIdentifierOrKeywordOrString();
	                operatorFound = this.optionalOperator('-');
	                if (operatorFound) {
	                    result += '-';
	                }
	            } while (operatorFound);
	            return result.toString();
	        }
	    }, {
	        key: 'parseTemplateBindings',
	        value: function parseTemplateBindings() {
	            var bindings = [];
	            var prefix = null;
	            var warnings = [];
	            while (this.index < this.tokens.length) {
	                var keyIsVar = this.peekKeywordLet();
	                if (!keyIsVar && this.peekDeprecatedKeywordVar()) {
	                    keyIsVar = true;
	                    warnings.push('"var" inside of expressions is deprecated. Use "let" instead!');
	                }
	                if (!keyIsVar && this.peekDeprecatedOperatorHash()) {
	                    keyIsVar = true;
	                    warnings.push('"#" inside of expressions is deprecated. Use "let" instead!');
	                }
	                if (keyIsVar) {
	                    this.advance();
	                }
	                var key = this.expectTemplateBindingKey();
	                if (!keyIsVar) {
	                    if (prefix == null) {
	                        prefix = key;
	                    } else {
	                        key = prefix + key[0].toUpperCase() + key.substring(1);
	                    }
	                }
	                this.optionalCharacter($COLON);
	                var name = null;
	                var expression = null;
	                if (keyIsVar) {
	                    if (this.optionalOperator('=')) {
	                        name = this.expectTemplateBindingKey();
	                    } else {
	                        name = '\$implicit';
	                    }
	                } else if (this.next !== EOF && !this.peekKeywordLet() && !this.peekDeprecatedKeywordVar() && !this.peekDeprecatedOperatorHash()) {
	                    var start = this.inputIndex;
	                    var ast = this.parsePipe();
	                    var source = this.input.substring(start, this.inputIndex);
	                    expression = new ASTWithSource(ast, source, this.location);
	                }
	                bindings.push(new TemplateBinding(key, keyIsVar, name, expression));
	                if (!this.optionalCharacter($SEMICOLON)) {
	                    this.optionalCharacter($COMMA);
	                }
	            }
	            return new TemplateBindingParseResult(bindings, warnings);
	        }
	    }, {
	        key: 'error',
	        value: function error(message) {
	            var index = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            if (isBlank$3(index)) index = this.index;
	            var location = index < this.tokens.length ? 'at column ' + (this.tokens[index].index + 1) + ' in' : 'at the end of the expression';
	            throw new ParseException(message, this.input, location, this.location);
	        }
	    }, {
	        key: 'next',
	        get: function get() {
	            return this.peek(0);
	        }
	    }, {
	        key: 'inputIndex',
	        get: function get() {
	            return this.index < this.tokens.length ? this.next.index : this.input.length;
	        }
	    }]);
	    return _ParseAST;
	}();

	var SimpleExpressionChecker = function () {
	    function SimpleExpressionChecker() {
	        classCallCheck(this, SimpleExpressionChecker);

	        this.simple = true;
	    }

	    createClass(SimpleExpressionChecker, [{
	        key: 'visitImplicitReceiver',
	        value: function visitImplicitReceiver(ast, context) {}
	    }, {
	        key: 'visitInterpolation',
	        value: function visitInterpolation(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitLiteralPrimitive',
	        value: function visitLiteralPrimitive(ast, context) {}
	    }, {
	        key: 'visitPropertyRead',
	        value: function visitPropertyRead(ast, context) {}
	    }, {
	        key: 'visitPropertyWrite',
	        value: function visitPropertyWrite(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitSafePropertyRead',
	        value: function visitSafePropertyRead(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitMethodCall',
	        value: function visitMethodCall(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitSafeMethodCall',
	        value: function visitSafeMethodCall(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitFunctionCall',
	        value: function visitFunctionCall(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitLiteralArray',
	        value: function visitLiteralArray(ast, context) {
	            this.visitAll(ast.expressions);
	        }
	    }, {
	        key: 'visitLiteralMap',
	        value: function visitLiteralMap(ast, context) {
	            this.visitAll(ast.values);
	        }
	    }, {
	        key: 'visitBinary',
	        value: function visitBinary(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitPrefixNot',
	        value: function visitPrefixNot(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitConditional',
	        value: function visitConditional(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitPipe',
	        value: function visitPipe(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitKeyedRead',
	        value: function visitKeyedRead(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitKeyedWrite',
	        value: function visitKeyedWrite(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitAll',
	        value: function visitAll(asts) {
	            var res = ListWrapper$3.createFixedSize(asts.length);
	            for (var i = 0; i < asts.length; ++i) {
	                res[i] = asts[i].visit(this);
	            }
	            return res;
	        }
	    }, {
	        key: 'visitChain',
	        value: function visitChain(ast, context) {
	            this.simple = false;
	        }
	    }, {
	        key: 'visitQuote',
	        value: function visitQuote(ast, context) {
	            this.simple = false;
	        }
	    }], [{
	        key: 'check',
	        value: function check(ast) {
	            var s = new SimpleExpressionChecker();
	            ast.visit(s);
	            return s.simple;
	        }
	    }]);
	    return SimpleExpressionChecker;
	}();

	var HtmlTextAst = function () {
	    function HtmlTextAst(value, sourceSpan) {
	        classCallCheck(this, HtmlTextAst);

	        this.value = value;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(HtmlTextAst, [{
	        key: 'visit',
	        value: function visit(visitor, context) {
	            return visitor.visitText(this, context);
	        }
	    }]);
	    return HtmlTextAst;
	}();
	var HtmlExpansionAst = function () {
	    function HtmlExpansionAst(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
	        classCallCheck(this, HtmlExpansionAst);

	        this.switchValue = switchValue;
	        this.type = type;
	        this.cases = cases;
	        this.sourceSpan = sourceSpan;
	        this.switchValueSourceSpan = switchValueSourceSpan;
	    }

	    createClass(HtmlExpansionAst, [{
	        key: 'visit',
	        value: function visit(visitor, context) {
	            return visitor.visitExpansion(this, context);
	        }
	    }]);
	    return HtmlExpansionAst;
	}();
	var HtmlExpansionCaseAst = function () {
	    function HtmlExpansionCaseAst(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
	        classCallCheck(this, HtmlExpansionCaseAst);

	        this.value = value;
	        this.expression = expression;
	        this.sourceSpan = sourceSpan;
	        this.valueSourceSpan = valueSourceSpan;
	        this.expSourceSpan = expSourceSpan;
	    }

	    createClass(HtmlExpansionCaseAst, [{
	        key: 'visit',
	        value: function visit(visitor, context) {
	            return visitor.visitExpansionCase(this, context);
	        }
	    }]);
	    return HtmlExpansionCaseAst;
	}();
	var HtmlAttrAst = function () {
	    function HtmlAttrAst(name, value, sourceSpan) {
	        classCallCheck(this, HtmlAttrAst);

	        this.name = name;
	        this.value = value;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(HtmlAttrAst, [{
	        key: 'visit',
	        value: function visit(visitor, context) {
	            return visitor.visitAttr(this, context);
	        }
	    }]);
	    return HtmlAttrAst;
	}();
	var HtmlElementAst = function () {
	    function HtmlElementAst(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
	        classCallCheck(this, HtmlElementAst);

	        this.name = name;
	        this.attrs = attrs;
	        this.children = children;
	        this.sourceSpan = sourceSpan;
	        this.startSourceSpan = startSourceSpan;
	        this.endSourceSpan = endSourceSpan;
	    }

	    createClass(HtmlElementAst, [{
	        key: 'visit',
	        value: function visit(visitor, context) {
	            return visitor.visitElement(this, context);
	        }
	    }]);
	    return HtmlElementAst;
	}();
	var HtmlCommentAst = function () {
	    function HtmlCommentAst(value, sourceSpan) {
	        classCallCheck(this, HtmlCommentAst);

	        this.value = value;
	        this.sourceSpan = sourceSpan;
	    }

	    createClass(HtmlCommentAst, [{
	        key: 'visit',
	        value: function visit(visitor, context) {
	            return visitor.visitComment(this, context);
	        }
	    }]);
	    return HtmlCommentAst;
	}();
	function htmlVisitAll(visitor, asts) {
	    var context = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	    var result = [];
	    asts.forEach(function (ast) {
	        var astResult = ast.visit(visitor, context);
	        if (isPresent$3(astResult)) {
	            result.push(astResult);
	        }
	    });
	    return result;
	}

	// see http://www.w3.org/TR/html51/syntax.html#named-character-references
	// see https://html.spec.whatwg.org/multipage/entities.json
	// This list is not exhaustive to keep the compiler footprint low.
	// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.
	var NAMED_ENTITIES = {
	    'Aacute': 'Á',
	    'aacute': 'á',
	    'Acirc': 'Â',
	    'acirc': 'â',
	    'acute': '´',
	    'AElig': 'Æ',
	    'aelig': 'æ',
	    'Agrave': 'À',
	    'agrave': 'à',
	    'alefsym': 'ℵ',
	    'Alpha': 'Α',
	    'alpha': 'α',
	    'amp': '&',
	    'and': '∧',
	    'ang': '∠',
	    'apos': '\'',
	    'Aring': 'Å',
	    'aring': 'å',
	    'asymp': '≈',
	    'Atilde': 'Ã',
	    'atilde': 'ã',
	    'Auml': 'Ä',
	    'auml': 'ä',
	    'bdquo': '„',
	    'Beta': 'Β',
	    'beta': 'β',
	    'brvbar': '¦',
	    'bull': '•',
	    'cap': '∩',
	    'Ccedil': 'Ç',
	    'ccedil': 'ç',
	    'cedil': '¸',
	    'cent': '¢',
	    'Chi': 'Χ',
	    'chi': 'χ',
	    'circ': 'ˆ',
	    'clubs': '♣',
	    'cong': '≅',
	    'copy': '©',
	    'crarr': '↵',
	    'cup': '∪',
	    'curren': '¤',
	    'dagger': '†',
	    'Dagger': '‡',
	    'darr': '↓',
	    'dArr': '⇓',
	    'deg': '°',
	    'Delta': 'Δ',
	    'delta': 'δ',
	    'diams': '♦',
	    'divide': '÷',
	    'Eacute': 'É',
	    'eacute': 'é',
	    'Ecirc': 'Ê',
	    'ecirc': 'ê',
	    'Egrave': 'È',
	    'egrave': 'è',
	    'empty': '∅',
	    'emsp': ' ',
	    'ensp': ' ',
	    'Epsilon': 'Ε',
	    'epsilon': 'ε',
	    'equiv': '≡',
	    'Eta': 'Η',
	    'eta': 'η',
	    'ETH': 'Ð',
	    'eth': 'ð',
	    'Euml': 'Ë',
	    'euml': 'ë',
	    'euro': '€',
	    'exist': '∃',
	    'fnof': 'ƒ',
	    'forall': '∀',
	    'frac12': '½',
	    'frac14': '¼',
	    'frac34': '¾',
	    'frasl': '⁄',
	    'Gamma': 'Γ',
	    'gamma': 'γ',
	    'ge': '≥',
	    'gt': '>',
	    'harr': '↔',
	    'hArr': '⇔',
	    'hearts': '♥',
	    'hellip': '…',
	    'Iacute': 'Í',
	    'iacute': 'í',
	    'Icirc': 'Î',
	    'icirc': 'î',
	    'iexcl': '¡',
	    'Igrave': 'Ì',
	    'igrave': 'ì',
	    'image': 'ℑ',
	    'infin': '∞',
	    'int': '∫',
	    'Iota': 'Ι',
	    'iota': 'ι',
	    'iquest': '¿',
	    'isin': '∈',
	    'Iuml': 'Ï',
	    'iuml': 'ï',
	    'Kappa': 'Κ',
	    'kappa': 'κ',
	    'Lambda': 'Λ',
	    'lambda': 'λ',
	    'lang': '⟨',
	    'laquo': '«',
	    'larr': '←',
	    'lArr': '⇐',
	    'lceil': '⌈',
	    'ldquo': '“',
	    'le': '≤',
	    'lfloor': '⌊',
	    'lowast': '∗',
	    'loz': '◊',
	    'lrm': '‎',
	    'lsaquo': '‹',
	    'lsquo': '‘',
	    'lt': '<',
	    'macr': '¯',
	    'mdash': '—',
	    'micro': 'µ',
	    'middot': '·',
	    'minus': '−',
	    'Mu': 'Μ',
	    'mu': 'μ',
	    'nabla': '∇',
	    'nbsp': ' ',
	    'ndash': '–',
	    'ne': '≠',
	    'ni': '∋',
	    'not': '¬',
	    'notin': '∉',
	    'nsub': '⊄',
	    'Ntilde': 'Ñ',
	    'ntilde': 'ñ',
	    'Nu': 'Ν',
	    'nu': 'ν',
	    'Oacute': 'Ó',
	    'oacute': 'ó',
	    'Ocirc': 'Ô',
	    'ocirc': 'ô',
	    'OElig': 'Œ',
	    'oelig': 'œ',
	    'Ograve': 'Ò',
	    'ograve': 'ò',
	    'oline': '‾',
	    'Omega': 'Ω',
	    'omega': 'ω',
	    'Omicron': 'Ο',
	    'omicron': 'ο',
	    'oplus': '⊕',
	    'or': '∨',
	    'ordf': 'ª',
	    'ordm': 'º',
	    'Oslash': 'Ø',
	    'oslash': 'ø',
	    'Otilde': 'Õ',
	    'otilde': 'õ',
	    'otimes': '⊗',
	    'Ouml': 'Ö',
	    'ouml': 'ö',
	    'para': '¶',
	    'permil': '‰',
	    'perp': '⊥',
	    'Phi': 'Φ',
	    'phi': 'φ',
	    'Pi': 'Π',
	    'pi': 'π',
	    'piv': 'ϖ',
	    'plusmn': '±',
	    'pound': '£',
	    'prime': '′',
	    'Prime': '″',
	    'prod': '∏',
	    'prop': '∝',
	    'Psi': 'Ψ',
	    'psi': 'ψ',
	    'quot': '"',
	    'radic': '√',
	    'rang': '⟩',
	    'raquo': '»',
	    'rarr': '→',
	    'rArr': '⇒',
	    'rceil': '⌉',
	    'rdquo': '”',
	    'real': 'ℜ',
	    'reg': '®',
	    'rfloor': '⌋',
	    'Rho': 'Ρ',
	    'rho': 'ρ',
	    'rlm': '‏',
	    'rsaquo': '›',
	    'rsquo': '’',
	    'sbquo': '‚',
	    'Scaron': 'Š',
	    'scaron': 'š',
	    'sdot': '⋅',
	    'sect': '§',
	    'shy': '­',
	    'Sigma': 'Σ',
	    'sigma': 'σ',
	    'sigmaf': 'ς',
	    'sim': '∼',
	    'spades': '♠',
	    'sub': '⊂',
	    'sube': '⊆',
	    'sum': '∑',
	    'sup': '⊃',
	    'sup1': '¹',
	    'sup2': '²',
	    'sup3': '³',
	    'supe': '⊇',
	    'szlig': 'ß',
	    'Tau': 'Τ',
	    'tau': 'τ',
	    'there4': '∴',
	    'Theta': 'Θ',
	    'theta': 'θ',
	    'thetasym': 'ϑ',
	    'thinsp': ' ',
	    'THORN': 'Þ',
	    'thorn': 'þ',
	    'tilde': '˜',
	    'times': '×',
	    'trade': '™',
	    'Uacute': 'Ú',
	    'uacute': 'ú',
	    'uarr': '↑',
	    'uArr': '⇑',
	    'Ucirc': 'Û',
	    'ucirc': 'û',
	    'Ugrave': 'Ù',
	    'ugrave': 'ù',
	    'uml': '¨',
	    'upsih': 'ϒ',
	    'Upsilon': 'Υ',
	    'upsilon': 'υ',
	    'Uuml': 'Ü',
	    'uuml': 'ü',
	    'weierp': '℘',
	    'Xi': 'Ξ',
	    'xi': 'ξ',
	    'Yacute': 'Ý',
	    'yacute': 'ý',
	    'yen': '¥',
	    'yuml': 'ÿ',
	    'Yuml': 'Ÿ',
	    'Zeta': 'Ζ',
	    'zeta': 'ζ',
	    'zwj': '‍',
	    'zwnj': '‌'
	};
	var HtmlTagContentType;
	(function (HtmlTagContentType) {
	    HtmlTagContentType[HtmlTagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
	    HtmlTagContentType[HtmlTagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
	    HtmlTagContentType[HtmlTagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
	})(HtmlTagContentType || (HtmlTagContentType = {}));
	var HtmlTagDefinition = function () {
	    function HtmlTagDefinition() {
	        var _this = this;

	        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var closedByChildren = _ref.closedByChildren;
	        var requiredParents = _ref.requiredParents;
	        var implicitNamespacePrefix = _ref.implicitNamespacePrefix;
	        var contentType = _ref.contentType;
	        var closedByParent = _ref.closedByParent;
	        var isVoid = _ref.isVoid;
	        var ignoreFirstLf = _ref.ignoreFirstLf;
	        classCallCheck(this, HtmlTagDefinition);

	        this.closedByChildren = {};
	        this.closedByParent = false;
	        if (isPresent$3(closedByChildren) && closedByChildren.length > 0) {
	            closedByChildren.forEach(function (tagName) {
	                return _this.closedByChildren[tagName] = true;
	            });
	        }
	        this.isVoid = normalizeBool$3(isVoid);
	        this.closedByParent = normalizeBool$3(closedByParent) || this.isVoid;
	        if (isPresent$3(requiredParents) && requiredParents.length > 0) {
	            this.requiredParents = {};
	            this.parentToAdd = requiredParents[0];
	            requiredParents.forEach(function (tagName) {
	                return _this.requiredParents[tagName] = true;
	            });
	        }
	        this.implicitNamespacePrefix = implicitNamespacePrefix;
	        this.contentType = isPresent$3(contentType) ? contentType : HtmlTagContentType.PARSABLE_DATA;
	        this.ignoreFirstLf = normalizeBool$3(ignoreFirstLf);
	    }

	    createClass(HtmlTagDefinition, [{
	        key: 'requireExtraParent',
	        value: function requireExtraParent(currentParent) {
	            if (isBlank$3(this.requiredParents)) {
	                return false;
	            }
	            if (isBlank$3(currentParent)) {
	                return true;
	            }
	            var lcParent = currentParent.toLowerCase();
	            return this.requiredParents[lcParent] != true && lcParent != 'template';
	        }
	    }, {
	        key: 'isClosedByChild',
	        value: function isClosedByChild(name) {
	            return this.isVoid || normalizeBool$3(this.closedByChildren[name.toLowerCase()]);
	        }
	    }]);
	    return HtmlTagDefinition;
	}();
	// see http://www.w3.org/TR/html51/syntax.html#optional-tags
	// This implementation does not fully conform to the HTML5 spec.
	var TAG_DEFINITIONS = {
	    'base': new HtmlTagDefinition({ isVoid: true }),
	    'meta': new HtmlTagDefinition({ isVoid: true }),
	    'area': new HtmlTagDefinition({ isVoid: true }),
	    'embed': new HtmlTagDefinition({ isVoid: true }),
	    'link': new HtmlTagDefinition({ isVoid: true }),
	    'img': new HtmlTagDefinition({ isVoid: true }),
	    'input': new HtmlTagDefinition({ isVoid: true }),
	    'param': new HtmlTagDefinition({ isVoid: true }),
	    'hr': new HtmlTagDefinition({ isVoid: true }),
	    'br': new HtmlTagDefinition({ isVoid: true }),
	    'source': new HtmlTagDefinition({ isVoid: true }),
	    'track': new HtmlTagDefinition({ isVoid: true }),
	    'wbr': new HtmlTagDefinition({ isVoid: true }),
	    'p': new HtmlTagDefinition({
	        closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],
	        closedByParent: true
	    }),
	    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
	    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
	    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
	    'tr': new HtmlTagDefinition({
	        closedByChildren: ['tr'],
	        requiredParents: ['tbody', 'tfoot', 'thead'],
	        closedByParent: true
	    }),
	    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
	    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
	    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),
	    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
	    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
	    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
	    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
	    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
	    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
	    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
	    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
	    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
	    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
	    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
	    'style': new HtmlTagDefinition({ contentType: HtmlTagContentType.RAW_TEXT }),
	    'script': new HtmlTagDefinition({ contentType: HtmlTagContentType.RAW_TEXT }),
	    'title': new HtmlTagDefinition({ contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT }),
	    'textarea': new HtmlTagDefinition({ contentType: HtmlTagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true })
	};
	var DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
	function getHtmlTagDefinition(tagName) {
	    var result = TAG_DEFINITIONS[tagName.toLowerCase()];
	    return isPresent$3(result) ? result : DEFAULT_TAG_DEFINITION;
	}
	var NS_PREFIX_RE$1 = /^:([^:]+):(.+)/g;
	function splitNsName(elementName) {
	    if (elementName[0] != ':') {
	        return [null, elementName];
	    }
	    var match = RegExpWrapper$3.firstMatch(NS_PREFIX_RE$1, elementName);
	    return [match[1], match[2]];
	}
	function getNsPrefix(elementName) {
	    return splitNsName(elementName)[0];
	}
	function mergeNsAndName(prefix, localName) {
	    return isPresent$3(prefix) ? ':' + prefix + ':' + localName : localName;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ParseLocation = function () {
	    function ParseLocation(file, offset, line, col) {
	        classCallCheck(this, ParseLocation);

	        this.file = file;
	        this.offset = offset;
	        this.line = line;
	        this.col = col;
	    }

	    createClass(ParseLocation, [{
	        key: "toString",
	        value: function toString() {
	            return this.file.url + "@" + this.line + ":" + this.col;
	        }
	    }]);
	    return ParseLocation;
	}();
	var ParseSourceFile = function ParseSourceFile(content, url) {
	    classCallCheck(this, ParseSourceFile);

	    this.content = content;
	    this.url = url;
	};
	var ParseSourceSpan = function () {
	    function ParseSourceSpan(start, end) {
	        classCallCheck(this, ParseSourceSpan);

	        this.start = start;
	        this.end = end;
	    }

	    createClass(ParseSourceSpan, [{
	        key: "toString",
	        value: function toString() {
	            return this.start.file.content.substring(this.start.offset, this.end.offset);
	        }
	    }]);
	    return ParseSourceSpan;
	}();
	var ParseErrorLevel;
	(function (ParseErrorLevel) {
	    ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
	    ParseErrorLevel[ParseErrorLevel["FATAL"] = 1] = "FATAL";
	})(ParseErrorLevel || (ParseErrorLevel = {}));
	var ParseError = function () {
	    function ParseError(span, msg) {
	        var level = arguments.length <= 2 || arguments[2] === undefined ? ParseErrorLevel.FATAL : arguments[2];
	        classCallCheck(this, ParseError);

	        this.span = span;
	        this.msg = msg;
	        this.level = level;
	    }

	    createClass(ParseError, [{
	        key: "toString",
	        value: function toString() {
	            var source = this.span.start.file.content;
	            var ctxStart = this.span.start.offset;
	            if (ctxStart > source.length - 1) {
	                ctxStart = source.length - 1;
	            }
	            var ctxEnd = ctxStart;
	            var ctxLen = 0;
	            var ctxLines = 0;
	            while (ctxLen < 100 && ctxStart > 0) {
	                ctxStart--;
	                ctxLen++;
	                if (source[ctxStart] == '\n') {
	                    if (++ctxLines == 3) {
	                        break;
	                    }
	                }
	            }
	            ctxLen = 0;
	            ctxLines = 0;
	            while (ctxLen < 100 && ctxEnd < source.length - 1) {
	                ctxEnd++;
	                ctxLen++;
	                if (source[ctxEnd] == '\n') {
	                    if (++ctxLines == 3) {
	                        break;
	                    }
	                }
	            }
	            var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' + source.substring(this.span.start.offset, ctxEnd + 1);
	            return this.msg + " (\"" + context + "\"): " + this.span.start;
	        }
	    }]);
	    return ParseError;
	}();

	var HtmlTokenType;
	(function (HtmlTokenType) {
	    HtmlTokenType[HtmlTokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
	    HtmlTokenType[HtmlTokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
	    HtmlTokenType[HtmlTokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
	    HtmlTokenType[HtmlTokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
	    HtmlTokenType[HtmlTokenType["TEXT"] = 4] = "TEXT";
	    HtmlTokenType[HtmlTokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
	    HtmlTokenType[HtmlTokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
	    HtmlTokenType[HtmlTokenType["COMMENT_START"] = 7] = "COMMENT_START";
	    HtmlTokenType[HtmlTokenType["COMMENT_END"] = 8] = "COMMENT_END";
	    HtmlTokenType[HtmlTokenType["CDATA_START"] = 9] = "CDATA_START";
	    HtmlTokenType[HtmlTokenType["CDATA_END"] = 10] = "CDATA_END";
	    HtmlTokenType[HtmlTokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
	    HtmlTokenType[HtmlTokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
	    HtmlTokenType[HtmlTokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
	    HtmlTokenType[HtmlTokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
	    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
	    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
	    HtmlTokenType[HtmlTokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
	    HtmlTokenType[HtmlTokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
	    HtmlTokenType[HtmlTokenType["EOF"] = 19] = "EOF";
	})(HtmlTokenType || (HtmlTokenType = {}));
	var HtmlToken = function HtmlToken(type, parts, sourceSpan) {
	    classCallCheck(this, HtmlToken);

	    this.type = type;
	    this.parts = parts;
	    this.sourceSpan = sourceSpan;
	};
	var HtmlTokenError = function (_ParseError) {
	    inherits(HtmlTokenError, _ParseError);

	    function HtmlTokenError(errorMsg, tokenType, span) {
	        classCallCheck(this, HtmlTokenError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(HtmlTokenError).call(this, span, errorMsg));

	        _this.tokenType = tokenType;
	        return _this;
	    }

	    return HtmlTokenError;
	}(ParseError);
	var HtmlTokenizeResult = function HtmlTokenizeResult(tokens, errors) {
	    classCallCheck(this, HtmlTokenizeResult);

	    this.tokens = tokens;
	    this.errors = errors;
	};
	function tokenizeHtml(sourceContent, sourceUrl) {
	    var tokenizeExpansionForms = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	    var interpolationConfig = arguments.length <= 3 || arguments[3] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[3];

	    return new _HtmlTokenizer(new ParseSourceFile(sourceContent, sourceUrl), tokenizeExpansionForms, interpolationConfig).tokenize();
	}
	var CR_OR_CRLF_REGEXP = /\r\n?/g;
	function unexpectedCharacterErrorMsg(charCode) {
	    var char = charCode === $EOF ? 'EOF' : StringWrapper$3.fromCharCode(charCode);
	    return 'Unexpected character "' + char + '"';
	}
	function unknownEntityErrorMsg(entitySrc) {
	    return 'Unknown entity "' + entitySrc + '" - use the "&#<decimal>;" or  "&#x<hex>;" syntax';
	}

	var ControlFlowError = function ControlFlowError(error) {
	    classCallCheck(this, ControlFlowError);

	    this.error = error;
	};
	// See http://www.w3.org/TR/html51/syntax.html#writing


	var _HtmlTokenizer = function () {
	    function _HtmlTokenizer(file, tokenizeExpansionForms) {
	        var interpolationConfig = arguments.length <= 2 || arguments[2] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[2];
	        classCallCheck(this, _HtmlTokenizer);

	        this.file = file;
	        this.tokenizeExpansionForms = tokenizeExpansionForms;
	        this.interpolationConfig = interpolationConfig;
	        // Note: this is always lowercase!
	        this._peek = -1;
	        this._nextPeek = -1;
	        this._index = -1;
	        this._line = 0;
	        this._column = -1;
	        this._expansionCaseStack = [];
	        this._inInterpolation = false;
	        this.tokens = [];
	        this.errors = [];
	        this._input = file.content;
	        this._length = file.content.length;
	        this._advance();
	    }

	    createClass(_HtmlTokenizer, [{
	        key: '_processCarriageReturns',
	        value: function _processCarriageReturns(content) {
	            // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
	            // In order to keep the original position in the source, we can not
	            // pre-process it.
	            // Instead CRs are processed right before instantiating the tokens.
	            return StringWrapper$3.replaceAll(content, CR_OR_CRLF_REGEXP, '\n');
	        }
	    }, {
	        key: 'tokenize',
	        value: function tokenize() {
	            while (this._peek !== $EOF) {
	                var start = this._getLocation();
	                try {
	                    if (this._attemptCharCode($LT)) {
	                        if (this._attemptCharCode($BANG)) {
	                            if (this._attemptCharCode($LBRACKET)) {
	                                this._consumeCdata(start);
	                            } else if (this._attemptCharCode($MINUS)) {
	                                this._consumeComment(start);
	                            } else {
	                                this._consumeDocType(start);
	                            }
	                        } else if (this._attemptCharCode($SLASH)) {
	                            this._consumeTagClose(start);
	                        } else {
	                            this._consumeTagOpen(start);
	                        }
	                    } else if (isExpansionFormStart(this._input, this._index, this.interpolationConfig.start) && this.tokenizeExpansionForms) {
	                        this._consumeExpansionFormStart();
	                    } else if (isExpansionCaseStart(this._peek) && this._isInExpansionForm() && this.tokenizeExpansionForms) {
	                        this._consumeExpansionCaseStart();
	                    } else if (this._peek === $RBRACE && this._isInExpansionCase() && this.tokenizeExpansionForms) {
	                        this._consumeExpansionCaseEnd();
	                    } else if (this._peek === $RBRACE && this._isInExpansionForm() && this.tokenizeExpansionForms) {
	                        this._consumeExpansionFormEnd();
	                    } else {
	                        this._consumeText();
	                    }
	                } catch (e) {
	                    if (e instanceof ControlFlowError) {
	                        this.errors.push(e.error);
	                    } else {
	                        throw e;
	                    }
	                }
	            }
	            this._beginToken(HtmlTokenType.EOF);
	            this._endToken([]);
	            return new HtmlTokenizeResult(mergeTextTokens(this.tokens), this.errors);
	        }
	    }, {
	        key: '_getLocation',
	        value: function _getLocation() {
	            return new ParseLocation(this.file, this._index, this._line, this._column);
	        }
	    }, {
	        key: '_getSpan',
	        value: function _getSpan(start, end) {
	            if (isBlank$3(start)) {
	                start = this._getLocation();
	            }
	            if (isBlank$3(end)) {
	                end = this._getLocation();
	            }
	            return new ParseSourceSpan(start, end);
	        }
	    }, {
	        key: '_beginToken',
	        value: function _beginToken(type) {
	            var start = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            if (isBlank$3(start)) {
	                start = this._getLocation();
	            }
	            this._currentTokenStart = start;
	            this._currentTokenType = type;
	        }
	    }, {
	        key: '_endToken',
	        value: function _endToken(parts) {
	            var end = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            if (isBlank$3(end)) {
	                end = this._getLocation();
	            }
	            var token = new HtmlToken(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));
	            this.tokens.push(token);
	            this._currentTokenStart = null;
	            this._currentTokenType = null;
	            return token;
	        }
	    }, {
	        key: '_createError',
	        value: function _createError(msg, span) {
	            var error = new HtmlTokenError(msg, this._currentTokenType, span);
	            this._currentTokenStart = null;
	            this._currentTokenType = null;
	            return new ControlFlowError(error);
	        }
	    }, {
	        key: '_advance',
	        value: function _advance() {
	            if (this._index >= this._length) {
	                throw this._createError(unexpectedCharacterErrorMsg($EOF), this._getSpan());
	            }
	            if (this._peek === $LF) {
	                this._line++;
	                this._column = 0;
	            } else if (this._peek !== $LF && this._peek !== $CR) {
	                this._column++;
	            }
	            this._index++;
	            this._peek = this._index >= this._length ? $EOF : StringWrapper$3.charCodeAt(this._input, this._index);
	            this._nextPeek = this._index + 1 >= this._length ? $EOF : StringWrapper$3.charCodeAt(this._input, this._index + 1);
	        }
	    }, {
	        key: '_attemptCharCode',
	        value: function _attemptCharCode(charCode) {
	            if (this._peek === charCode) {
	                this._advance();
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: '_attemptCharCodeCaseInsensitive',
	        value: function _attemptCharCodeCaseInsensitive(charCode) {
	            if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
	                this._advance();
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: '_requireCharCode',
	        value: function _requireCharCode(charCode) {
	            var location = this._getLocation();
	            if (!this._attemptCharCode(charCode)) {
	                throw this._createError(unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
	            }
	        }
	    }, {
	        key: '_attemptStr',
	        value: function _attemptStr(chars) {
	            var len = chars.length;
	            if (this._index + len > this._length) {
	                return false;
	            }
	            var initialPosition = this._savePosition();
	            for (var i = 0; i < len; i++) {
	                if (!this._attemptCharCode(StringWrapper$3.charCodeAt(chars, i))) {
	                    // If attempting to parse the string fails, we want to reset the parser
	                    // to where it was before the attempt
	                    this._restorePosition(initialPosition);
	                    return false;
	                }
	            }
	            return true;
	        }
	    }, {
	        key: '_attemptStrCaseInsensitive',
	        value: function _attemptStrCaseInsensitive(chars) {
	            for (var i = 0; i < chars.length; i++) {
	                if (!this._attemptCharCodeCaseInsensitive(StringWrapper$3.charCodeAt(chars, i))) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }, {
	        key: '_requireStr',
	        value: function _requireStr(chars) {
	            var location = this._getLocation();
	            if (!this._attemptStr(chars)) {
	                throw this._createError(unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
	            }
	        }
	    }, {
	        key: '_attemptCharCodeUntilFn',
	        value: function _attemptCharCodeUntilFn(predicate) {
	            while (!predicate(this._peek)) {
	                this._advance();
	            }
	        }
	    }, {
	        key: '_requireCharCodeUntilFn',
	        value: function _requireCharCodeUntilFn(predicate, len) {
	            var start = this._getLocation();
	            this._attemptCharCodeUntilFn(predicate);
	            if (this._index - start.offset < len) {
	                throw this._createError(unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
	            }
	        }
	    }, {
	        key: '_attemptUntilChar',
	        value: function _attemptUntilChar(char) {
	            while (this._peek !== char) {
	                this._advance();
	            }
	        }
	    }, {
	        key: '_readChar',
	        value: function _readChar(decodeEntities) {
	            if (decodeEntities && this._peek === $AMPERSAND) {
	                return this._decodeEntity();
	            } else {
	                var index = this._index;
	                this._advance();
	                return this._input[index];
	            }
	        }
	    }, {
	        key: '_decodeEntity',
	        value: function _decodeEntity() {
	            var start = this._getLocation();
	            this._advance();
	            if (this._attemptCharCode($HASH)) {
	                var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
	                var numberStart = this._getLocation().offset;
	                this._attemptCharCodeUntilFn(isDigitEntityEnd);
	                if (this._peek != $SEMICOLON) {
	                    throw this._createError(unexpectedCharacterErrorMsg(this._peek), this._getSpan());
	                }
	                this._advance();
	                var strNum = this._input.substring(numberStart, this._index - 1);
	                try {
	                    var charCode = NumberWrapper$3.parseInt(strNum, isHex ? 16 : 10);
	                    return StringWrapper$3.fromCharCode(charCode);
	                } catch (e) {
	                    var entity = this._input.substring(start.offset + 1, this._index - 1);
	                    throw this._createError(unknownEntityErrorMsg(entity), this._getSpan(start));
	                }
	            } else {
	                var startPosition = this._savePosition();
	                this._attemptCharCodeUntilFn(isNamedEntityEnd);
	                if (this._peek != $SEMICOLON) {
	                    this._restorePosition(startPosition);
	                    return '&';
	                }
	                this._advance();
	                var name = this._input.substring(start.offset + 1, this._index - 1);
	                var char = NAMED_ENTITIES[name];
	                if (isBlank$3(char)) {
	                    throw this._createError(unknownEntityErrorMsg(name), this._getSpan(start));
	                }
	                return char;
	            }
	        }
	    }, {
	        key: '_consumeRawText',
	        value: function _consumeRawText(decodeEntities, firstCharOfEnd, attemptEndRest) {
	            var tagCloseStart;
	            var textStart = this._getLocation();
	            this._beginToken(decodeEntities ? HtmlTokenType.ESCAPABLE_RAW_TEXT : HtmlTokenType.RAW_TEXT, textStart);
	            var parts = [];
	            while (true) {
	                tagCloseStart = this._getLocation();
	                if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
	                    break;
	                }
	                if (this._index > tagCloseStart.offset) {
	                    // add the characters consumed by the previous if statement to the output
	                    parts.push(this._input.substring(tagCloseStart.offset, this._index));
	                }
	                while (this._peek !== firstCharOfEnd) {
	                    parts.push(this._readChar(decodeEntities));
	                }
	            }
	            return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
	        }
	    }, {
	        key: '_consumeComment',
	        value: function _consumeComment(start) {
	            var _this2 = this;

	            this._beginToken(HtmlTokenType.COMMENT_START, start);
	            this._requireCharCode($MINUS);
	            this._endToken([]);
	            var textToken = this._consumeRawText(false, $MINUS, function () {
	                return _this2._attemptStr('->');
	            });
	            this._beginToken(HtmlTokenType.COMMENT_END, textToken.sourceSpan.end);
	            this._endToken([]);
	        }
	    }, {
	        key: '_consumeCdata',
	        value: function _consumeCdata(start) {
	            var _this3 = this;

	            this._beginToken(HtmlTokenType.CDATA_START, start);
	            this._requireStr('CDATA[');
	            this._endToken([]);
	            var textToken = this._consumeRawText(false, $RBRACKET, function () {
	                return _this3._attemptStr(']>');
	            });
	            this._beginToken(HtmlTokenType.CDATA_END, textToken.sourceSpan.end);
	            this._endToken([]);
	        }
	    }, {
	        key: '_consumeDocType',
	        value: function _consumeDocType(start) {
	            this._beginToken(HtmlTokenType.DOC_TYPE, start);
	            this._attemptUntilChar($GT);
	            this._advance();
	            this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
	        }
	    }, {
	        key: '_consumePrefixAndName',
	        value: function _consumePrefixAndName() {
	            var nameOrPrefixStart = this._index;
	            var prefix = null;
	            while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {
	                this._advance();
	            }
	            var nameStart;
	            if (this._peek === $COLON) {
	                this._advance();
	                prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
	                nameStart = this._index;
	            } else {
	                nameStart = nameOrPrefixStart;
	            }
	            this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
	            var name = this._input.substring(nameStart, this._index);
	            return [prefix, name];
	        }
	    }, {
	        key: '_consumeTagOpen',
	        value: function _consumeTagOpen(start) {
	            var savedPos = this._savePosition();
	            var lowercaseTagName = void 0;
	            try {
	                if (!isAsciiLetter(this._peek)) {
	                    throw this._createError(unexpectedCharacterErrorMsg(this._peek), this._getSpan());
	                }
	                var nameStart = this._index;
	                this._consumeTagOpenStart(start);
	                lowercaseTagName = this._input.substring(nameStart, this._index).toLowerCase();
	                this._attemptCharCodeUntilFn(isNotWhitespace);
	                while (this._peek !== $SLASH && this._peek !== $GT) {
	                    this._consumeAttributeName();
	                    this._attemptCharCodeUntilFn(isNotWhitespace);
	                    if (this._attemptCharCode($EQ)) {
	                        this._attemptCharCodeUntilFn(isNotWhitespace);
	                        this._consumeAttributeValue();
	                    }
	                    this._attemptCharCodeUntilFn(isNotWhitespace);
	                }
	                this._consumeTagOpenEnd();
	            } catch (e) {
	                if (e instanceof ControlFlowError) {
	                    // When the start tag is invalid, assume we want a "<"
	                    this._restorePosition(savedPos);
	                    // Back to back text tokens are merged at the end
	                    this._beginToken(HtmlTokenType.TEXT, start);
	                    this._endToken(['<']);
	                    return;
	                }
	                throw e;
	            }
	            var contentTokenType = getHtmlTagDefinition(lowercaseTagName).contentType;
	            if (contentTokenType === HtmlTagContentType.RAW_TEXT) {
	                this._consumeRawTextWithTagClose(lowercaseTagName, false);
	            } else if (contentTokenType === HtmlTagContentType.ESCAPABLE_RAW_TEXT) {
	                this._consumeRawTextWithTagClose(lowercaseTagName, true);
	            }
	        }
	    }, {
	        key: '_consumeRawTextWithTagClose',
	        value: function _consumeRawTextWithTagClose(lowercaseTagName, decodeEntities) {
	            var _this4 = this;

	            var textToken = this._consumeRawText(decodeEntities, $LT, function () {
	                if (!_this4._attemptCharCode($SLASH)) return false;
	                _this4._attemptCharCodeUntilFn(isNotWhitespace);
	                if (!_this4._attemptStrCaseInsensitive(lowercaseTagName)) return false;
	                _this4._attemptCharCodeUntilFn(isNotWhitespace);
	                if (!_this4._attemptCharCode($GT)) return false;
	                return true;
	            });
	            this._beginToken(HtmlTokenType.TAG_CLOSE, textToken.sourceSpan.end);
	            this._endToken([null, lowercaseTagName]);
	        }
	    }, {
	        key: '_consumeTagOpenStart',
	        value: function _consumeTagOpenStart(start) {
	            this._beginToken(HtmlTokenType.TAG_OPEN_START, start);
	            var parts = this._consumePrefixAndName();
	            this._endToken(parts);
	        }
	    }, {
	        key: '_consumeAttributeName',
	        value: function _consumeAttributeName() {
	            this._beginToken(HtmlTokenType.ATTR_NAME);
	            var prefixAndName = this._consumePrefixAndName();
	            this._endToken(prefixAndName);
	        }
	    }, {
	        key: '_consumeAttributeValue',
	        value: function _consumeAttributeValue() {
	            this._beginToken(HtmlTokenType.ATTR_VALUE);
	            var value;
	            if (this._peek === $SQ || this._peek === $DQ) {
	                var quoteChar = this._peek;
	                this._advance();
	                var parts = [];
	                while (this._peek !== quoteChar) {
	                    parts.push(this._readChar(true));
	                }
	                value = parts.join('');
	                this._advance();
	            } else {
	                var valueStart = this._index;
	                this._requireCharCodeUntilFn(isNameEnd, 1);
	                value = this._input.substring(valueStart, this._index);
	            }
	            this._endToken([this._processCarriageReturns(value)]);
	        }
	    }, {
	        key: '_consumeTagOpenEnd',
	        value: function _consumeTagOpenEnd() {
	            var tokenType = this._attemptCharCode($SLASH) ? HtmlTokenType.TAG_OPEN_END_VOID : HtmlTokenType.TAG_OPEN_END;
	            this._beginToken(tokenType);
	            this._requireCharCode($GT);
	            this._endToken([]);
	        }
	    }, {
	        key: '_consumeTagClose',
	        value: function _consumeTagClose(start) {
	            this._beginToken(HtmlTokenType.TAG_CLOSE, start);
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            var prefixAndName = this._consumePrefixAndName();
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._requireCharCode($GT);
	            this._endToken(prefixAndName);
	        }
	    }, {
	        key: '_consumeExpansionFormStart',
	        value: function _consumeExpansionFormStart() {
	            this._beginToken(HtmlTokenType.EXPANSION_FORM_START, this._getLocation());
	            this._requireCharCode($LBRACE);
	            this._endToken([]);
	            this._beginToken(HtmlTokenType.RAW_TEXT, this._getLocation());
	            var condition = this._readUntil($COMMA);
	            this._endToken([condition], this._getLocation());
	            this._requireCharCode($COMMA);
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._beginToken(HtmlTokenType.RAW_TEXT, this._getLocation());
	            var type = this._readUntil($COMMA);
	            this._endToken([type], this._getLocation());
	            this._requireCharCode($COMMA);
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._expansionCaseStack.push(HtmlTokenType.EXPANSION_FORM_START);
	        }
	    }, {
	        key: '_consumeExpansionCaseStart',
	        value: function _consumeExpansionCaseStart() {
	            this._beginToken(HtmlTokenType.EXPANSION_CASE_VALUE, this._getLocation());
	            var value = this._readUntil($LBRACE).trim();
	            this._endToken([value], this._getLocation());
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._beginToken(HtmlTokenType.EXPANSION_CASE_EXP_START, this._getLocation());
	            this._requireCharCode($LBRACE);
	            this._endToken([], this._getLocation());
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._expansionCaseStack.push(HtmlTokenType.EXPANSION_CASE_EXP_START);
	        }
	    }, {
	        key: '_consumeExpansionCaseEnd',
	        value: function _consumeExpansionCaseEnd() {
	            this._beginToken(HtmlTokenType.EXPANSION_CASE_EXP_END, this._getLocation());
	            this._requireCharCode($RBRACE);
	            this._endToken([], this._getLocation());
	            this._attemptCharCodeUntilFn(isNotWhitespace);
	            this._expansionCaseStack.pop();
	        }
	    }, {
	        key: '_consumeExpansionFormEnd',
	        value: function _consumeExpansionFormEnd() {
	            this._beginToken(HtmlTokenType.EXPANSION_FORM_END, this._getLocation());
	            this._requireCharCode($RBRACE);
	            this._endToken([]);
	            this._expansionCaseStack.pop();
	        }
	    }, {
	        key: '_consumeText',
	        value: function _consumeText() {
	            var start = this._getLocation();
	            this._beginToken(HtmlTokenType.TEXT, start);
	            var parts = [];
	            do {
	                if (this._attemptStr(this.interpolationConfig.start)) {
	                    parts.push(this.interpolationConfig.start);
	                    this._inInterpolation = true;
	                } else if (this._attemptStr(this.interpolationConfig.end) && this._inInterpolation) {
	                    parts.push(this.interpolationConfig.end);
	                    this._inInterpolation = false;
	                } else {
	                    parts.push(this._readChar(true));
	                }
	            } while (!this._isTextEnd());
	            this._endToken([this._processCarriageReturns(parts.join(''))]);
	        }
	    }, {
	        key: '_isTextEnd',
	        value: function _isTextEnd() {
	            if (this._peek === $LT || this._peek === $EOF) {
	                return true;
	            }
	            if (this.tokenizeExpansionForms) {
	                if (isExpansionFormStart(this._input, this._index, this.interpolationConfig.start)) {
	                    // start of an expansion form
	                    return true;
	                }
	                if (this._peek === $RBRACE && !this._inInterpolation && this._isInExpansionCase()) {
	                    // end of and expansion case
	                    return true;
	                }
	            }
	            return false;
	        }
	    }, {
	        key: '_savePosition',
	        value: function _savePosition() {
	            return [this._peek, this._index, this._column, this._line, this.tokens.length];
	        }
	    }, {
	        key: '_readUntil',
	        value: function _readUntil(char) {
	            var start = this._index;
	            this._attemptUntilChar(char);
	            return this._input.substring(start, this._index);
	        }
	    }, {
	        key: '_restorePosition',
	        value: function _restorePosition(position) {
	            this._peek = position[0];
	            this._index = position[1];
	            this._column = position[2];
	            this._line = position[3];
	            var nbTokens = position[4];
	            if (nbTokens < this.tokens.length) {
	                // remove any extra tokens
	                this.tokens = this.tokens.slice(0, nbTokens);
	            }
	        }
	    }, {
	        key: '_isInExpansionCase',
	        value: function _isInExpansionCase() {
	            return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === HtmlTokenType.EXPANSION_CASE_EXP_START;
	        }
	    }, {
	        key: '_isInExpansionForm',
	        value: function _isInExpansionForm() {
	            return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === HtmlTokenType.EXPANSION_FORM_START;
	        }
	    }]);
	    return _HtmlTokenizer;
	}();

	function isNotWhitespace(code) {
	    return !isWhitespace(code) || code === $EOF;
	}
	function isNameEnd(code) {
	    return isWhitespace(code) || code === $GT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ;
	}
	function isPrefixEnd(code) {
	    return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
	}
	function isDigitEntityEnd(code) {
	    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
	}
	function isNamedEntityEnd(code) {
	    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
	}
	function isExpansionFormStart(input, offset, interpolationStart) {
	    return input.charCodeAt(offset) == $LBRACE && input.indexOf(interpolationStart, offset) != offset;
	}
	function isExpansionCaseStart(peek) {
	    return peek === $EQ || isAsciiLetter(peek);
	}
	function compareCharCodeCaseInsensitive(code1, code2) {
	    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
	}
	function toUpperCaseCharCode(code) {
	    return code >= $a && code <= $z ? code - $a + $A : code;
	}
	function mergeTextTokens(srcTokens) {
	    var dstTokens = [];
	    var lastDstToken = void 0;
	    for (var i = 0; i < srcTokens.length; i++) {
	        var token = srcTokens[i];
	        if (isPresent$3(lastDstToken) && lastDstToken.type == HtmlTokenType.TEXT && token.type == HtmlTokenType.TEXT) {
	            lastDstToken.parts[0] += token.parts[0];
	            lastDstToken.sourceSpan.end = token.sourceSpan.end;
	        } else {
	            lastDstToken = token;
	            dstTokens.push(lastDstToken);
	        }
	    }
	    return dstTokens;
	}

	var HtmlTreeError = function (_ParseError) {
	    inherits(HtmlTreeError, _ParseError);

	    function HtmlTreeError(elementName, span, msg) {
	        classCallCheck(this, HtmlTreeError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(HtmlTreeError).call(this, span, msg));

	        _this.elementName = elementName;
	        return _this;
	    }

	    createClass(HtmlTreeError, null, [{
	        key: 'create',
	        value: function create(elementName, span, msg) {
	            return new HtmlTreeError(elementName, span, msg);
	        }
	    }]);
	    return HtmlTreeError;
	}(ParseError);
	var HtmlParseTreeResult = function HtmlParseTreeResult(rootNodes, errors) {
	    classCallCheck(this, HtmlParseTreeResult);

	    this.rootNodes = rootNodes;
	    this.errors = errors;
	};
	var HtmlParser = function () {
	    function HtmlParser() {
	        classCallCheck(this, HtmlParser);
	    }

	    createClass(HtmlParser, [{
	        key: 'parse',
	        value: function parse(sourceContent, sourceUrl) {
	            var parseExpansionForms = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	            var tokensAndErrors = tokenizeHtml(sourceContent, sourceUrl, parseExpansionForms);
	            var treeAndErrors = new TreeBuilder(tokensAndErrors.tokens).build();
	            return new HtmlParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
	        }
	    }]);
	    return HtmlParser;
	}();
	/** @nocollapse */
	HtmlParser.decorators = [{ type: Injectable }];

	var TreeBuilder = function () {
	    function TreeBuilder(tokens) {
	        classCallCheck(this, TreeBuilder);

	        this.tokens = tokens;
	        this.index = -1;
	        this.rootNodes = [];
	        this.errors = [];
	        this.elementStack = [];
	        this._advance();
	    }

	    createClass(TreeBuilder, [{
	        key: 'build',
	        value: function build() {
	            while (this.peek.type !== HtmlTokenType.EOF) {
	                if (this.peek.type === HtmlTokenType.TAG_OPEN_START) {
	                    this._consumeStartTag(this._advance());
	                } else if (this.peek.type === HtmlTokenType.TAG_CLOSE) {
	                    this._consumeEndTag(this._advance());
	                } else if (this.peek.type === HtmlTokenType.CDATA_START) {
	                    this._closeVoidElement();
	                    this._consumeCdata(this._advance());
	                } else if (this.peek.type === HtmlTokenType.COMMENT_START) {
	                    this._closeVoidElement();
	                    this._consumeComment(this._advance());
	                } else if (this.peek.type === HtmlTokenType.TEXT || this.peek.type === HtmlTokenType.RAW_TEXT || this.peek.type === HtmlTokenType.ESCAPABLE_RAW_TEXT) {
	                    this._closeVoidElement();
	                    this._consumeText(this._advance());
	                } else if (this.peek.type === HtmlTokenType.EXPANSION_FORM_START) {
	                    this._consumeExpansion(this._advance());
	                } else {
	                    // Skip all other tokens...
	                    this._advance();
	                }
	            }
	            return new HtmlParseTreeResult(this.rootNodes, this.errors);
	        }
	    }, {
	        key: '_advance',
	        value: function _advance() {
	            var prev = this.peek;
	            if (this.index < this.tokens.length - 1) {
	                // Note: there is always an EOF token at the end
	                this.index++;
	            }
	            this.peek = this.tokens[this.index];
	            return prev;
	        }
	    }, {
	        key: '_advanceIf',
	        value: function _advanceIf(type) {
	            if (this.peek.type === type) {
	                return this._advance();
	            }
	            return null;
	        }
	    }, {
	        key: '_consumeCdata',
	        value: function _consumeCdata(startToken) {
	            this._consumeText(this._advance());
	            this._advanceIf(HtmlTokenType.CDATA_END);
	        }
	    }, {
	        key: '_consumeComment',
	        value: function _consumeComment(token) {
	            var text = this._advanceIf(HtmlTokenType.RAW_TEXT);
	            this._advanceIf(HtmlTokenType.COMMENT_END);
	            var value = isPresent$3(text) ? text.parts[0].trim() : null;
	            this._addToParent(new HtmlCommentAst(value, token.sourceSpan));
	        }
	    }, {
	        key: '_consumeExpansion',
	        value: function _consumeExpansion(token) {
	            var switchValue = this._advance();
	            var type = this._advance();
	            var cases = [];
	            // read =
	            while (this.peek.type === HtmlTokenType.EXPANSION_CASE_VALUE) {
	                var expCase = this._parseExpansionCase();
	                if (isBlank$3(expCase)) return; // error
	                cases.push(expCase);
	            }
	            // read the final }
	            if (this.peek.type !== HtmlTokenType.EXPANSION_FORM_END) {
	                this.errors.push(HtmlTreeError.create(null, this.peek.sourceSpan, 'Invalid expansion form. Missing \'}\'.'));
	                return;
	            }
	            this._advance();
	            var mainSourceSpan = new ParseSourceSpan(token.sourceSpan.start, this.peek.sourceSpan.end);
	            this._addToParent(new HtmlExpansionAst(switchValue.parts[0], type.parts[0], cases, mainSourceSpan, switchValue.sourceSpan));
	        }
	    }, {
	        key: '_parseExpansionCase',
	        value: function _parseExpansionCase() {
	            var value = this._advance();
	            // read {
	            if (this.peek.type !== HtmlTokenType.EXPANSION_CASE_EXP_START) {
	                this.errors.push(HtmlTreeError.create(null, this.peek.sourceSpan, 'Invalid expansion form. Missing \'{\'.,'));
	                return null;
	            }
	            // read until }
	            var start = this._advance();
	            var exp = this._collectExpansionExpTokens(start);
	            if (isBlank$3(exp)) return null;
	            var end = this._advance();
	            exp.push(new HtmlToken(HtmlTokenType.EOF, [], end.sourceSpan));
	            // parse everything in between { and }
	            var parsedExp = new TreeBuilder(exp).build();
	            if (parsedExp.errors.length > 0) {
	                this.errors = this.errors.concat(parsedExp.errors);
	                return null;
	            }
	            var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
	            var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
	            return new HtmlExpansionCaseAst(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
	        }
	    }, {
	        key: '_collectExpansionExpTokens',
	        value: function _collectExpansionExpTokens(start) {
	            var exp = [];
	            var expansionFormStack = [HtmlTokenType.EXPANSION_CASE_EXP_START];
	            while (true) {
	                if (this.peek.type === HtmlTokenType.EXPANSION_FORM_START || this.peek.type === HtmlTokenType.EXPANSION_CASE_EXP_START) {
	                    expansionFormStack.push(this.peek.type);
	                }
	                if (this.peek.type === HtmlTokenType.EXPANSION_CASE_EXP_END) {
	                    if (lastOnStack(expansionFormStack, HtmlTokenType.EXPANSION_CASE_EXP_START)) {
	                        expansionFormStack.pop();
	                        if (expansionFormStack.length == 0) return exp;
	                    } else {
	                        this.errors.push(HtmlTreeError.create(null, start.sourceSpan, 'Invalid expansion form. Missing \'}\'.'));
	                        return null;
	                    }
	                }
	                if (this.peek.type === HtmlTokenType.EXPANSION_FORM_END) {
	                    if (lastOnStack(expansionFormStack, HtmlTokenType.EXPANSION_FORM_START)) {
	                        expansionFormStack.pop();
	                    } else {
	                        this.errors.push(HtmlTreeError.create(null, start.sourceSpan, 'Invalid expansion form. Missing \'}\'.'));
	                        return null;
	                    }
	                }
	                if (this.peek.type === HtmlTokenType.EOF) {
	                    this.errors.push(HtmlTreeError.create(null, start.sourceSpan, 'Invalid expansion form. Missing \'}\'.'));
	                    return null;
	                }
	                exp.push(this._advance());
	            }
	        }
	    }, {
	        key: '_consumeText',
	        value: function _consumeText(token) {
	            var text = token.parts[0];
	            if (text.length > 0 && text[0] == '\n') {
	                var parent = this._getParentElement();
	                if (isPresent$3(parent) && parent.children.length == 0 && getHtmlTagDefinition(parent.name).ignoreFirstLf) {
	                    text = text.substring(1);
	                }
	            }
	            if (text.length > 0) {
	                this._addToParent(new HtmlTextAst(text, token.sourceSpan));
	            }
	        }
	    }, {
	        key: '_closeVoidElement',
	        value: function _closeVoidElement() {
	            if (this.elementStack.length > 0) {
	                var el = ListWrapper$3.last(this.elementStack);
	                if (getHtmlTagDefinition(el.name).isVoid) {
	                    this.elementStack.pop();
	                }
	            }
	        }
	    }, {
	        key: '_consumeStartTag',
	        value: function _consumeStartTag(startTagToken) {
	            var prefix = startTagToken.parts[0];
	            var name = startTagToken.parts[1];
	            var attrs = [];
	            while (this.peek.type === HtmlTokenType.ATTR_NAME) {
	                attrs.push(this._consumeAttr(this._advance()));
	            }
	            var fullName = getElementFullName(prefix, name, this._getParentElement());
	            var selfClosing = false;
	            // Note: There could have been a tokenizer error
	            // so that we don't get a token for the end tag...
	            if (this.peek.type === HtmlTokenType.TAG_OPEN_END_VOID) {
	                this._advance();
	                selfClosing = true;
	                if (getNsPrefix(fullName) == null && !getHtmlTagDefinition(fullName).isVoid) {
	                    this.errors.push(HtmlTreeError.create(fullName, startTagToken.sourceSpan, 'Only void and foreign elements can be self closed "' + startTagToken.parts[1] + '"'));
	                }
	            } else if (this.peek.type === HtmlTokenType.TAG_OPEN_END) {
	                this._advance();
	                selfClosing = false;
	            }
	            var end = this.peek.sourceSpan.start;
	            var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
	            var el = new HtmlElementAst(fullName, attrs, [], span, span, null);
	            this._pushElement(el);
	            if (selfClosing) {
	                this._popElement(fullName);
	                el.endSourceSpan = span;
	            }
	        }
	    }, {
	        key: '_pushElement',
	        value: function _pushElement(el) {
	            if (this.elementStack.length > 0) {
	                var parentEl = ListWrapper$3.last(this.elementStack);
	                if (getHtmlTagDefinition(parentEl.name).isClosedByChild(el.name)) {
	                    this.elementStack.pop();
	                }
	            }
	            var tagDef = getHtmlTagDefinition(el.name);

	            var _getParentElementSkip = this._getParentElementSkippingContainers();

	            var parent = _getParentElementSkip.parent;
	            var container = _getParentElementSkip.container;

	            if (isPresent$3(parent) && tagDef.requireExtraParent(parent.name)) {
	                var newParent = new HtmlElementAst(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
	                this._insertBeforeContainer(parent, container, newParent);
	            }
	            this._addToParent(el);
	            this.elementStack.push(el);
	        }
	    }, {
	        key: '_consumeEndTag',
	        value: function _consumeEndTag(endTagToken) {
	            var fullName = getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
	            if (this._getParentElement()) {
	                this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
	            }
	            if (getHtmlTagDefinition(fullName).isVoid) {
	                this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan, 'Void elements do not have end tags "' + endTagToken.parts[1] + '"'));
	            } else if (!this._popElement(fullName)) {
	                this.errors.push(HtmlTreeError.create(fullName, endTagToken.sourceSpan, 'Unexpected closing tag "' + endTagToken.parts[1] + '"'));
	            }
	        }
	    }, {
	        key: '_popElement',
	        value: function _popElement(fullName) {
	            for (var stackIndex = this.elementStack.length - 1; stackIndex >= 0; stackIndex--) {
	                var el = this.elementStack[stackIndex];
	                if (el.name == fullName) {
	                    ListWrapper$3.splice(this.elementStack, stackIndex, this.elementStack.length - stackIndex);
	                    return true;
	                }
	                if (!getHtmlTagDefinition(el.name).closedByParent) {
	                    return false;
	                }
	            }
	            return false;
	        }
	    }, {
	        key: '_consumeAttr',
	        value: function _consumeAttr(attrName) {
	            var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
	            var end = attrName.sourceSpan.end;
	            var value = '';
	            if (this.peek.type === HtmlTokenType.ATTR_VALUE) {
	                var valueToken = this._advance();
	                value = valueToken.parts[0];
	                end = valueToken.sourceSpan.end;
	            }
	            return new HtmlAttrAst(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end));
	        }
	    }, {
	        key: '_getParentElement',
	        value: function _getParentElement() {
	            return this.elementStack.length > 0 ? ListWrapper$3.last(this.elementStack) : null;
	        }
	        /**
	         * Returns the parent in the DOM and the container.
	         *
	         * `<ng-container>` elements are skipped as they are not rendered as DOM element.
	         */

	    }, {
	        key: '_getParentElementSkippingContainers',
	        value: function _getParentElementSkippingContainers() {
	            var container = null;
	            for (var i = this.elementStack.length - 1; i >= 0; i--) {
	                if (this.elementStack[i].name !== 'ng-container') {
	                    return { parent: this.elementStack[i], container: container };
	                }
	                container = this.elementStack[i];
	            }
	            return { parent: ListWrapper$3.last(this.elementStack), container: container };
	        }
	    }, {
	        key: '_addToParent',
	        value: function _addToParent(node) {
	            var parent = this._getParentElement();
	            if (isPresent$3(parent)) {
	                parent.children.push(node);
	            } else {
	                this.rootNodes.push(node);
	            }
	        }
	        /**
	         * Insert a node between the parent and the container.
	         * When no container is given, the node is appended as a child of the parent.
	         * Also updates the element stack accordingly.
	         *
	         * @internal
	         */

	    }, {
	        key: '_insertBeforeContainer',
	        value: function _insertBeforeContainer(parent, container, node) {
	            if (!container) {
	                this._addToParent(node);
	                this.elementStack.push(node);
	            } else {
	                if (parent) {
	                    // replace the container with the new node in the children
	                    var index = parent.children.indexOf(container);
	                    parent.children[index] = node;
	                } else {
	                    this.rootNodes.push(node);
	                }
	                node.children.push(container);
	                this.elementStack.splice(this.elementStack.indexOf(container), 0, node);
	            }
	        }
	    }]);
	    return TreeBuilder;
	}();

	function getElementFullName(prefix, localName, parentElement) {
	    if (isBlank$3(prefix)) {
	        prefix = getHtmlTagDefinition(localName).implicitNamespacePrefix;
	        if (isBlank$3(prefix) && isPresent$3(parentElement)) {
	            prefix = getNsPrefix(parentElement.name);
	        }
	    }
	    return mergeNsAndName(prefix, localName);
	}
	function lastOnStack(stack, element) {
	    return stack.length > 0 && stack[stack.length - 1] === element;
	}

	var _EMPTY_ATTR_VALUE = '';
	// TODO: Can't use `const` here as
	// in Dart this is not transpiled into `final` yet...
	var _SELECTOR_REGEXP = RegExpWrapper$3.create('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' + '(\\))|' + '(\\s*,\\s*)'); // ","
	/**
	 * A css selector contains an element name,
	 * css classes and attribute/value pairs with the purpose
	 * of selecting subsets out of them.
	 */
	var CssSelector = function () {
	    function CssSelector() {
	        classCallCheck(this, CssSelector);

	        this.element = null;
	        this.classNames = [];
	        this.attrs = [];
	        this.notSelectors = [];
	    }

	    createClass(CssSelector, [{
	        key: 'isElementSelector',
	        value: function isElementSelector() {
	            return isPresent$3(this.element) && ListWrapper$3.isEmpty(this.classNames) && ListWrapper$3.isEmpty(this.attrs) && this.notSelectors.length === 0;
	        }
	    }, {
	        key: 'setElement',
	        value: function setElement() {
	            var element = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	            this.element = element;
	        }
	        /** Gets a template string for an element that matches the selector. */

	    }, {
	        key: 'getMatchingElementTemplate',
	        value: function getMatchingElementTemplate() {
	            var tagName = isPresent$3(this.element) ? this.element : 'div';
	            var classAttr = this.classNames.length > 0 ? ' class="' + this.classNames.join(' ') + '"' : '';
	            var attrs = '';
	            for (var i = 0; i < this.attrs.length; i += 2) {
	                var attrName = this.attrs[i];
	                var attrValue = this.attrs[i + 1] !== '' ? '="' + this.attrs[i + 1] + '"' : '';
	                attrs += ' ' + attrName + attrValue;
	            }
	            return '<' + tagName + classAttr + attrs + '></' + tagName + '>';
	        }
	    }, {
	        key: 'addAttribute',
	        value: function addAttribute(name) {
	            var value = arguments.length <= 1 || arguments[1] === undefined ? _EMPTY_ATTR_VALUE : arguments[1];

	            this.attrs.push(name);
	            if (isPresent$3(value)) {
	                value = value.toLowerCase();
	            } else {
	                value = _EMPTY_ATTR_VALUE;
	            }
	            this.attrs.push(value);
	        }
	    }, {
	        key: 'addClassName',
	        value: function addClassName(name) {
	            this.classNames.push(name.toLowerCase());
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var res = '';
	            if (isPresent$3(this.element)) {
	                res += this.element;
	            }
	            if (isPresent$3(this.classNames)) {
	                for (var i = 0; i < this.classNames.length; i++) {
	                    res += '.' + this.classNames[i];
	                }
	            }
	            if (isPresent$3(this.attrs)) {
	                for (var i = 0; i < this.attrs.length;) {
	                    var attrName = this.attrs[i++];
	                    var attrValue = this.attrs[i++];
	                    res += '[' + attrName;
	                    if (attrValue.length > 0) {
	                        res += '=' + attrValue;
	                    }
	                    res += ']';
	                }
	            }
	            this.notSelectors.forEach(function (notSelector) {
	                return res += ':not(' + notSelector + ')';
	            });
	            return res;
	        }
	    }], [{
	        key: 'parse',
	        value: function parse(selector) {
	            var results = [];
	            var _addResult = function _addResult(res, cssSel) {
	                if (cssSel.notSelectors.length > 0 && isBlank$3(cssSel.element) && ListWrapper$3.isEmpty(cssSel.classNames) && ListWrapper$3.isEmpty(cssSel.attrs)) {
	                    cssSel.element = '*';
	                }
	                res.push(cssSel);
	            };
	            var cssSelector = new CssSelector();
	            var matcher = RegExpWrapper$3.matcher(_SELECTOR_REGEXP, selector);
	            var match;
	            var current = cssSelector;
	            var inNot = false;
	            while (isPresent$3(match = RegExpMatcherWrapper$3.next(matcher))) {
	                if (isPresent$3(match[1])) {
	                    if (inNot) {
	                        throw new BaseException$3('Nesting :not is not allowed in a selector');
	                    }
	                    inNot = true;
	                    current = new CssSelector();
	                    cssSelector.notSelectors.push(current);
	                }
	                if (isPresent$3(match[2])) {
	                    current.setElement(match[2]);
	                }
	                if (isPresent$3(match[3])) {
	                    current.addClassName(match[3]);
	                }
	                if (isPresent$3(match[4])) {
	                    current.addAttribute(match[4], match[5]);
	                }
	                if (isPresent$3(match[6])) {
	                    inNot = false;
	                    current = cssSelector;
	                }
	                if (isPresent$3(match[7])) {
	                    if (inNot) {
	                        throw new BaseException$3('Multiple selectors in :not are not supported');
	                    }
	                    _addResult(results, cssSelector);
	                    cssSelector = current = new CssSelector();
	                }
	            }
	            _addResult(results, cssSelector);
	            return results;
	        }
	    }]);
	    return CssSelector;
	}();
	/**
	 * Reads a list of CssSelectors and allows to calculate which ones
	 * are contained in a given CssSelector.
	 */
	var SelectorMatcher = function () {
	    function SelectorMatcher() {
	        classCallCheck(this, SelectorMatcher);

	        this._elementMap = new Map$4();
	        this._elementPartialMap = new Map$4();
	        this._classMap = new Map$4();
	        this._classPartialMap = new Map$4();
	        this._attrValueMap = new Map$4();
	        this._attrValuePartialMap = new Map$4();
	        this._listContexts = [];
	    }

	    createClass(SelectorMatcher, [{
	        key: 'addSelectables',
	        value: function addSelectables(cssSelectors, callbackCtxt) {
	            var listContext = null;
	            if (cssSelectors.length > 1) {
	                listContext = new SelectorListContext(cssSelectors);
	                this._listContexts.push(listContext);
	            }
	            for (var i = 0; i < cssSelectors.length; i++) {
	                this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
	            }
	        }
	        /**
	         * Add an object that can be found later on by calling `match`.
	         * @param cssSelector A css selector
	         * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
	         */

	    }, {
	        key: '_addSelectable',
	        value: function _addSelectable(cssSelector, callbackCtxt, listContext) {
	            var matcher = this;
	            var element = cssSelector.element;
	            var classNames = cssSelector.classNames;
	            var attrs = cssSelector.attrs;
	            var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
	            if (isPresent$3(element)) {
	                var isTerminal = attrs.length === 0 && classNames.length === 0;
	                if (isTerminal) {
	                    this._addTerminal(matcher._elementMap, element, selectable);
	                } else {
	                    matcher = this._addPartial(matcher._elementPartialMap, element);
	                }
	            }
	            if (isPresent$3(classNames)) {
	                for (var index = 0; index < classNames.length; index++) {
	                    var isTerminal = attrs.length === 0 && index === classNames.length - 1;
	                    var className = classNames[index];
	                    if (isTerminal) {
	                        this._addTerminal(matcher._classMap, className, selectable);
	                    } else {
	                        matcher = this._addPartial(matcher._classPartialMap, className);
	                    }
	                }
	            }
	            if (isPresent$3(attrs)) {
	                for (var index = 0; index < attrs.length;) {
	                    var isTerminal = index === attrs.length - 2;
	                    var attrName = attrs[index++];
	                    var attrValue = attrs[index++];
	                    if (isTerminal) {
	                        var terminalMap = matcher._attrValueMap;
	                        var terminalValuesMap = terminalMap.get(attrName);
	                        if (isBlank$3(terminalValuesMap)) {
	                            terminalValuesMap = new Map$4();
	                            terminalMap.set(attrName, terminalValuesMap);
	                        }
	                        this._addTerminal(terminalValuesMap, attrValue, selectable);
	                    } else {
	                        var parttialMap = matcher._attrValuePartialMap;
	                        var partialValuesMap = parttialMap.get(attrName);
	                        if (isBlank$3(partialValuesMap)) {
	                            partialValuesMap = new Map$4();
	                            parttialMap.set(attrName, partialValuesMap);
	                        }
	                        matcher = this._addPartial(partialValuesMap, attrValue);
	                    }
	                }
	            }
	        }
	    }, {
	        key: '_addTerminal',
	        value: function _addTerminal(map, name, selectable) {
	            var terminalList = map.get(name);
	            if (isBlank$3(terminalList)) {
	                terminalList = [];
	                map.set(name, terminalList);
	            }
	            terminalList.push(selectable);
	        }
	    }, {
	        key: '_addPartial',
	        value: function _addPartial(map, name) {
	            var matcher = map.get(name);
	            if (isBlank$3(matcher)) {
	                matcher = new SelectorMatcher();
	                map.set(name, matcher);
	            }
	            return matcher;
	        }
	        /**
	         * Find the objects that have been added via `addSelectable`
	         * whose css selector is contained in the given css selector.
	         * @param cssSelector A css selector
	         * @param matchedCallback This callback will be called with the object handed into `addSelectable`
	         * @return boolean true if a match was found
	        */

	    }, {
	        key: 'match',
	        value: function match(cssSelector, matchedCallback) {
	            var result = false;
	            var element = cssSelector.element;
	            var classNames = cssSelector.classNames;
	            var attrs = cssSelector.attrs;
	            for (var i = 0; i < this._listContexts.length; i++) {
	                this._listContexts[i].alreadyMatched = false;
	            }
	            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
	            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
	            if (isPresent$3(classNames)) {
	                for (var index = 0; index < classNames.length; index++) {
	                    var className = classNames[index];
	                    result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
	                    result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
	                }
	            }
	            if (isPresent$3(attrs)) {
	                for (var index = 0; index < attrs.length;) {
	                    var attrName = attrs[index++];
	                    var attrValue = attrs[index++];
	                    var terminalValuesMap = this._attrValueMap.get(attrName);
	                    if (!StringWrapper$3.equals(attrValue, _EMPTY_ATTR_VALUE)) {
	                        result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
	                    }
	                    result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) || result;
	                    var partialValuesMap = this._attrValuePartialMap.get(attrName);
	                    if (!StringWrapper$3.equals(attrValue, _EMPTY_ATTR_VALUE)) {
	                        result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
	                    }
	                    result = this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
	                }
	            }
	            return result;
	        }
	        /** @internal */

	    }, {
	        key: '_matchTerminal',
	        value: function _matchTerminal(map, name, cssSelector, matchedCallback) {
	            if (isBlank$3(map) || isBlank$3(name)) {
	                return false;
	            }
	            var selectables = map.get(name);
	            var starSelectables = map.get('*');
	            if (isPresent$3(starSelectables)) {
	                selectables = selectables.concat(starSelectables);
	            }
	            if (isBlank$3(selectables)) {
	                return false;
	            }
	            var selectable;
	            var result = false;
	            for (var index = 0; index < selectables.length; index++) {
	                selectable = selectables[index];
	                result = selectable.finalize(cssSelector, matchedCallback) || result;
	            }
	            return result;
	        }
	        /** @internal */

	    }, {
	        key: '_matchPartial',
	        value: function _matchPartial(map, name, cssSelector, matchedCallback) {
	            if (isBlank$3(map) || isBlank$3(name)) {
	                return false;
	            }
	            var nestedSelector = map.get(name);
	            if (isBlank$3(nestedSelector)) {
	                return false;
	            }
	            // TODO(perf): get rid of recursion and measure again
	            // TODO(perf): don't pass the whole selector into the recursion,
	            // but only the not processed parts
	            return nestedSelector.match(cssSelector, matchedCallback);
	        }
	    }], [{
	        key: 'createNotMatcher',
	        value: function createNotMatcher(notSelectors) {
	            var notMatcher = new SelectorMatcher();
	            notMatcher.addSelectables(notSelectors, null);
	            return notMatcher;
	        }
	    }]);
	    return SelectorMatcher;
	}();
	var SelectorListContext = function SelectorListContext(selectors) {
	    classCallCheck(this, SelectorListContext);

	    this.selectors = selectors;
	    this.alreadyMatched = false;
	};
	// Store context to pass back selector and context when a selector is matched
	var SelectorContext = function () {
	    function SelectorContext(selector, cbContext, listContext) {
	        classCallCheck(this, SelectorContext);

	        this.selector = selector;
	        this.cbContext = cbContext;
	        this.listContext = listContext;
	        this.notSelectors = selector.notSelectors;
	    }

	    createClass(SelectorContext, [{
	        key: 'finalize',
	        value: function finalize(cssSelector, callback) {
	            var result = true;
	            if (this.notSelectors.length > 0 && (isBlank$3(this.listContext) || !this.listContext.alreadyMatched)) {
	                var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
	                result = !notMatcher.match(cssSelector, null);
	            }
	            if (result && isPresent$3(callback) && (isBlank$3(this.listContext) || !this.listContext.alreadyMatched)) {
	                if (isPresent$3(this.listContext)) {
	                    this.listContext.alreadyMatched = true;
	                }
	                callback(this.selector, this.cbContext);
	            }
	            return result;
	        }
	    }]);
	    return SelectorContext;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ElementSchemaRegistry = function ElementSchemaRegistry() {
	  classCallCheck(this, ElementSchemaRegistry);
	};

	var NG_CONTENT_SELECT_ATTR = 'select';
	var NG_CONTENT_ELEMENT = 'ng-content';
	var LINK_ELEMENT = 'link';
	var LINK_STYLE_REL_ATTR = 'rel';
	var LINK_STYLE_HREF_ATTR = 'href';
	var LINK_STYLE_REL_VALUE = 'stylesheet';
	var STYLE_ELEMENT = 'style';
	var SCRIPT_ELEMENT = 'script';
	var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
	var NG_PROJECT_AS = 'ngProjectAs';
	function preparseElement(ast) {
	    var selectAttr = null;
	    var hrefAttr = null;
	    var relAttr = null;
	    var nonBindable = false;
	    var projectAs = null;
	    ast.attrs.forEach(function (attr) {
	        var lcAttrName = attr.name.toLowerCase();
	        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
	            selectAttr = attr.value;
	        } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
	            hrefAttr = attr.value;
	        } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
	            relAttr = attr.value;
	        } else if (attr.name == NG_NON_BINDABLE_ATTR) {
	            nonBindable = true;
	        } else if (attr.name == NG_PROJECT_AS) {
	            if (attr.value.length > 0) {
	                projectAs = attr.value;
	            }
	        }
	    });
	    selectAttr = normalizeNgContentSelect(selectAttr);
	    var nodeName = ast.name.toLowerCase();
	    var type = PreparsedElementType.OTHER;
	    if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
	        type = PreparsedElementType.NG_CONTENT;
	    } else if (nodeName == STYLE_ELEMENT) {
	        type = PreparsedElementType.STYLE;
	    } else if (nodeName == SCRIPT_ELEMENT) {
	        type = PreparsedElementType.SCRIPT;
	    } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
	        type = PreparsedElementType.STYLESHEET;
	    }
	    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
	}
	var PreparsedElementType;
	(function (PreparsedElementType) {
	    PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
	    PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
	    PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
	    PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
	    PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
	})(PreparsedElementType || (PreparsedElementType = {}));
	var PreparsedElement = function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
	    classCallCheck(this, PreparsedElement);

	    this.type = type;
	    this.selectAttr = selectAttr;
	    this.hrefAttr = hrefAttr;
	    this.nonBindable = nonBindable;
	    this.projectAs = projectAs;
	};
	function normalizeNgContentSelect(selectAttr) {
	    if (isBlank$3(selectAttr) || selectAttr.length === 0) {
	        return '*';
	    }
	    return selectAttr;
	}

	var StyleWithImports = function StyleWithImports(style, styleUrls) {
	    classCallCheck(this, StyleWithImports);

	    this.style = style;
	    this.styleUrls = styleUrls;
	};
	function isStyleUrlResolvable(url) {
	    if (isBlank$3(url) || url.length === 0 || url[0] == '/') return false;
	    var schemeMatch = RegExpWrapper$3.firstMatch(_urlWithSchemaRe, url);
	    return isBlank$3(schemeMatch) || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
	}
	/**
	 * Rewrites stylesheets by resolving and removing the @import urls that
	 * are either relative or don't have a `package:` scheme
	 */
	function extractStyleUrls(resolver, baseUrl, cssText) {
	    var foundUrls = [];
	    var modifiedCssText = StringWrapper$3.replaceAllMapped(cssText, _cssImportRe, function (m) {
	        var url = isPresent$3(m[1]) ? m[1] : m[2];
	        if (!isStyleUrlResolvable(url)) {
	            // Do not attempt to resolve non-package absolute URLs with URI scheme
	            return m[0];
	        }
	        foundUrls.push(resolver.resolve(baseUrl, url));
	        return '';
	    });
	    return new StyleWithImports(modifiedCssText, foundUrls);
	}
	var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
	// TODO: can't use /^[^:/?#.]+:/g due to clang-format bug:
	//       https://github.com/angular/angular/issues/4596
	var _urlWithSchemaRe = /^([a-zA-Z\-\+\.]+):/g;

	var MODULE_SUFFIX = IS_DART$3 ? '.dart' : '';
	var CAMEL_CASE_REGEXP$1 = /([A-Z])/g;
	function camelCaseToDashCase$1(input) {
	    return StringWrapper$3.replaceAllMapped(input, CAMEL_CASE_REGEXP$1, function (m) {
	        return '-' + m[1].toLowerCase();
	    });
	}
	function splitAtColon(input, defaultValues) {
	    var parts = StringWrapper$3.split(input.trim(), /\s*:\s*/g);
	    if (parts.length > 1) {
	        return parts;
	    } else {
	        return defaultValues;
	    }
	}
	function sanitizeIdentifier(name) {
	    return StringWrapper$3.replaceAll(name, /\W/g, '_');
	}
	function visitValue(value, visitor, context) {
	    if (isArray$4(value)) {
	        return visitor.visitArray(value, context);
	    } else if (isStrictStringMap$3(value)) {
	        return visitor.visitStringMap(value, context);
	    } else if (isBlank$3(value) || isPrimitive$3(value)) {
	        return visitor.visitPrimitive(value, context);
	    } else {
	        return visitor.visitOther(value, context);
	    }
	}
	var ValueTransformer = function () {
	    function ValueTransformer() {
	        classCallCheck(this, ValueTransformer);
	    }

	    createClass(ValueTransformer, [{
	        key: 'visitArray',
	        value: function visitArray(arr, context) {
	            var _this = this;

	            return arr.map(function (value) {
	                return visitValue(value, _this, context);
	            });
	        }
	    }, {
	        key: 'visitStringMap',
	        value: function visitStringMap(map, context) {
	            var _this2 = this;

	            var result = {};
	            StringMapWrapper$3.forEach(map, function (value /** TODO #9100 */, key /** TODO #9100 */) {
	                result[key] = visitValue(value, _this2, context);
	            });
	            return result;
	        }
	    }, {
	        key: 'visitPrimitive',
	        value: function visitPrimitive(value, context) {
	            return value;
	        }
	    }, {
	        key: 'visitOther',
	        value: function visitOther(value, context) {
	            return value;
	        }
	    }]);
	    return ValueTransformer;
	}();
	function assetUrl(pkg) {
	    var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var type = arguments.length <= 2 || arguments[2] === undefined ? 'src' : arguments[2];

	    if (IS_DART$3) {
	        if (path == null) {
	            return 'asset:angular2/' + pkg + '/' + pkg + '.dart';
	        } else {
	            return 'asset:angular2/lib/' + pkg + '/src/' + path + '.dart';
	        }
	    } else {
	        if (path == null) {
	            return 'asset:@angular/lib/' + pkg + '/index';
	        } else {
	            return 'asset:@angular/lib/' + pkg + '/src/' + path;
	        }
	    }
	}

	var _ASSET_SCHEME = 'asset:';
	/**
	 * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
	 */
	var DEFAULT_PACKAGE_URL_PROVIDER = {
	    provide: PACKAGE_ROOT_URL,
	    useValue: '/'
	};
	var UrlResolver = function () {
	    function UrlResolver() {
	        var _packagePrefix = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	        classCallCheck(this, UrlResolver);

	        this._packagePrefix = _packagePrefix;
	    }
	    /**
	     * Resolves the `url` given the `baseUrl`:
	     * - when the `url` is null, the `baseUrl` is returned,
	     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
	     * `baseUrl` and `url`,
	     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
	     * returned as is (ignoring the `baseUrl`)
	     */


	    createClass(UrlResolver, [{
	        key: 'resolve',
	        value: function resolve(baseUrl, url) {
	            var resolvedUrl = url;
	            if (isPresent$3(baseUrl) && baseUrl.length > 0) {
	                resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
	            }
	            var resolvedParts = _split(resolvedUrl);
	            var prefix = this._packagePrefix;
	            if (isPresent$3(prefix) && isPresent$3(resolvedParts) && resolvedParts[_ComponentIndex.Scheme] == 'package') {
	                var path = resolvedParts[_ComponentIndex.Path];
	                if (this._packagePrefix === _ASSET_SCHEME) {
	                    var pathSegements = path.split(/\//);
	                    resolvedUrl = 'asset:' + pathSegements[0] + '/lib/' + pathSegements.slice(1).join('/');
	                } else {
	                    prefix = StringWrapper$3.stripRight(prefix, '/');
	                    path = StringWrapper$3.stripLeft(path, '/');
	                    return prefix + '/' + path;
	                }
	            }
	            return resolvedUrl;
	        }
	    }]);
	    return UrlResolver;
	}();
	/** @nocollapse */
	UrlResolver.decorators = [{ type: Injectable }];
	/** @nocollapse */
	UrlResolver.ctorParameters = [{ type: undefined, decorators: [{ type: Inject, args: [PACKAGE_ROOT_URL] }] }];
	/**
	 * Extract the scheme of a URL.
	 */
	function getUrlScheme(url) {
	    var match = _split(url);
	    return match && match[_ComponentIndex.Scheme] || '';
	}
	// The code below is adapted from Traceur:
	// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
	/**
	 * Builds a URI string from already-encoded parts.
	 *
	 * No encoding is performed.  Any component may be omitted as either null or
	 * undefined.
	 *
	 * @param opt_scheme The scheme such as 'http'.
	 * @param opt_userInfo The user name before the '@'.
	 * @param opt_domain The domain such as 'www.google.com', already
	 *     URI-encoded.
	 * @param opt_port The port number.
	 * @param opt_path The path, already URI-encoded.  If it is not
	 *     empty, it must begin with a slash.
	 * @param opt_queryData The URI-encoded query data.
	 * @param opt_fragment The URI-encoded fragment identifier.
	 * @return The fully combined URI.
	 */
	function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
	    var out = [];
	    if (isPresent$3(opt_scheme)) {
	        out.push(opt_scheme + ':');
	    }
	    if (isPresent$3(opt_domain)) {
	        out.push('//');
	        if (isPresent$3(opt_userInfo)) {
	            out.push(opt_userInfo + '@');
	        }
	        out.push(opt_domain);
	        if (isPresent$3(opt_port)) {
	            out.push(':' + opt_port);
	        }
	    }
	    if (isPresent$3(opt_path)) {
	        out.push(opt_path);
	    }
	    if (isPresent$3(opt_queryData)) {
	        out.push('?' + opt_queryData);
	    }
	    if (isPresent$3(opt_fragment)) {
	        out.push('#' + opt_fragment);
	    }
	    return out.join('');
	}
	/**
	 * A regular expression for breaking a URI into its component parts.
	 *
	 * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
	 * As the "first-match-wins" algorithm is identical to the "greedy"
	 * disambiguation method used by POSIX regular expressions, it is natural and
	 * commonplace to use a regular expression for parsing the potential five
	 * components of a URI reference.
	 *
	 * The following line is the regular expression for breaking-down a
	 * well-formed URI reference into its components.
	 *
	 * <pre>
	 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
	 *  12            3  4          5       6  7        8 9
	 * </pre>
	 *
	 * The numbers in the second line above are only to assist readability; they
	 * indicate the reference points for each subexpression (i.e., each paired
	 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
	 * For example, matching the above expression to
	 * <pre>
	 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
	 * </pre>
	 * results in the following subexpression matches:
	 * <pre>
	 *    $1 = http:
	 *    $2 = http
	 *    $3 = //www.ics.uci.edu
	 *    $4 = www.ics.uci.edu
	 *    $5 = /pub/ietf/uri/
	 *    $6 = <undefined>
	 *    $7 = <undefined>
	 *    $8 = #Related
	 *    $9 = Related
	 * </pre>
	 * where <undefined> indicates that the component is not present, as is the
	 * case for the query component in the above example. Therefore, we can
	 * determine the value of the five components as
	 * <pre>
	 *    scheme    = $2
	 *    authority = $4
	 *    path      = $5
	 *    query     = $7
	 *    fragment  = $9
	 * </pre>
	 *
	 * The regular expression has been modified slightly to expose the
	 * userInfo, domain, and port separately from the authority.
	 * The modified version yields
	 * <pre>
	 *    $1 = http              scheme
	 *    $2 = <undefined>       userInfo -\
	 *    $3 = www.ics.uci.edu   domain     | authority
	 *    $4 = <undefined>       port     -/
	 *    $5 = /pub/ietf/uri/    path
	 *    $6 = <undefined>       query without ?
	 *    $7 = Related           fragment without #
	 * </pre>
	 * @type {!RegExp}
	 * @internal
	 */
	var _splitRe = RegExpWrapper$3.create('^' + '(?:' + '([^:/?#.]+)' +
	// used by other URL parts such as :,
	// ?, /, #, and .
	':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
	// digits, dashes, dots, percent
	// escapes, and unicode characters.
	'(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
	/**
	 * The index of each URI component in the return value of goog.uri.utils.split.
	 * @enum {number}
	 */
	var _ComponentIndex;
	(function (_ComponentIndex) {
	    _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
	    _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
	    _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
	    _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
	    _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
	    _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
	    _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
	})(_ComponentIndex || (_ComponentIndex = {}));
	/**
	 * Splits a URI into its component parts.
	 *
	 * Each component can be accessed via the component indices; for example:
	 * <pre>
	 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
	 * </pre>
	 *
	 * @param uri The URI string to examine.
	 * @return Each component still URI-encoded.
	 *     Each component that is present will contain the encoded value, whereas
	 *     components that are not present will be undefined or empty, depending
	 *     on the browser's regular expression implementation.  Never null, since
	 *     arbitrary strings may still look like path names.
	 */
	function _split(uri) {
	    return RegExpWrapper$3.firstMatch(_splitRe, uri);
	}
	/**
	  * Removes dot segments in given path component, as described in
	  * RFC 3986, section 5.2.4.
	  *
	  * @param path A non-empty path component.
	  * @return Path component with removed dot segments.
	  */
	function _removeDotSegments(path) {
	    if (path == '/') return '/';
	    var leadingSlash = path[0] == '/' ? '/' : '';
	    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
	    var segments = path.split('/');
	    var out = [];
	    var up = 0;
	    for (var pos = 0; pos < segments.length; pos++) {
	        var segment = segments[pos];
	        switch (segment) {
	            case '':
	            case '.':
	                break;
	            case '..':
	                if (out.length > 0) {
	                    out.pop();
	                } else {
	                    up++;
	                }
	                break;
	            default:
	                out.push(segment);
	        }
	    }
	    if (leadingSlash == '') {
	        while (up-- > 0) {
	            out.unshift('..');
	        }
	        if (out.length === 0) out.push('.');
	    }
	    return leadingSlash + out.join('/') + trailingSlash;
	}
	/**
	 * Takes an array of the parts from split and canonicalizes the path part
	 * and then joins all the parts.
	 */
	function _joinAndCanonicalizePath(parts) {
	    var path = parts[_ComponentIndex.Path];
	    path = isBlank$3(path) ? '' : _removeDotSegments(path);
	    parts[_ComponentIndex.Path] = path;
	    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
	}
	/**
	 * Resolves a URL.
	 * @param base The URL acting as the base URL.
	 * @param to The URL to resolve.
	 */
	function _resolveUrl(base, url) {
	    var parts = _split(encodeURI(url));
	    var baseParts = _split(base);
	    if (isPresent$3(parts[_ComponentIndex.Scheme])) {
	        return _joinAndCanonicalizePath(parts);
	    } else {
	        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
	    }
	    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
	        if (isBlank$3(parts[i])) {
	            parts[i] = baseParts[i];
	        }
	    }
	    if (parts[_ComponentIndex.Path][0] == '/') {
	        return _joinAndCanonicalizePath(parts);
	    }
	    var path = baseParts[_ComponentIndex.Path];
	    if (isBlank$3(path)) path = '/';
	    var index = path.lastIndexOf('/');
	    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
	    parts[_ComponentIndex.Path] = path;
	    return _joinAndCanonicalizePath(parts);
	}

	// group 2: "event" from "(event)"
	var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
	var CompileMetadataWithIdentifier = function () {
	    function CompileMetadataWithIdentifier() {
	        classCallCheck(this, CompileMetadataWithIdentifier);
	    }

	    createClass(CompileMetadataWithIdentifier, [{
	        key: 'identifier',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }]);
	    return CompileMetadataWithIdentifier;
	}();
	var CompileMetadataWithType = function (_CompileMetadataWithI) {
	    inherits(CompileMetadataWithType, _CompileMetadataWithI);

	    function CompileMetadataWithType() {
	        classCallCheck(this, CompileMetadataWithType);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(CompileMetadataWithType).apply(this, arguments));
	    }

	    createClass(CompileMetadataWithType, [{
	        key: 'type',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'identifier',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }]);
	    return CompileMetadataWithType;
	}(CompileMetadataWithIdentifier);
	function metadataFromJson(data) {
	    return _COMPILE_METADATA_FROM_JSON[data['class']](data);
	}
	var CompileAnimationEntryMetadata = function () {
	    function CompileAnimationEntryMetadata() {
	        var name = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var definitions = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, CompileAnimationEntryMetadata);

	        this.name = name;
	        this.definitions = definitions;
	    }

	    createClass(CompileAnimationEntryMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'AnimationEntryMetadata',
	                'value': { 'name': this.name, 'definitions': _arrayToJson(this.definitions) }
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var value = data['value'];
	            var defs = _arrayFromJson(value['definitions'], metadataFromJson);
	            return new CompileAnimationEntryMetadata(value['name'], defs);
	        }
	    }]);
	    return CompileAnimationEntryMetadata;
	}();
	var CompileAnimationStateMetadata = function CompileAnimationStateMetadata() {
	    classCallCheck(this, CompileAnimationStateMetadata);
	};
	var CompileAnimationStateDeclarationMetadata = function (_CompileAnimationStat) {
	    inherits(CompileAnimationStateDeclarationMetadata, _CompileAnimationStat);

	    function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {
	        classCallCheck(this, CompileAnimationStateDeclarationMetadata);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationStateDeclarationMetadata).call(this));

	        _this2.stateNameExpr = stateNameExpr;
	        _this2.styles = styles;
	        return _this2;
	    }

	    createClass(CompileAnimationStateDeclarationMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'AnimationStateDeclarationMetadata',
	                'value': { 'stateNameExpr': this.stateNameExpr, 'styles': this.styles.toJson() }
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var value = data['value'];
	            var styles = _objFromJson(value['styles'], metadataFromJson);
	            return new CompileAnimationStateDeclarationMetadata(value['stateNameExpr'], styles);
	        }
	    }]);
	    return CompileAnimationStateDeclarationMetadata;
	}(CompileAnimationStateMetadata);
	var CompileAnimationStateTransitionMetadata = function (_CompileAnimationStat2) {
	    inherits(CompileAnimationStateTransitionMetadata, _CompileAnimationStat2);

	    function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {
	        classCallCheck(this, CompileAnimationStateTransitionMetadata);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationStateTransitionMetadata).call(this));

	        _this3.stateChangeExpr = stateChangeExpr;
	        _this3.steps = steps;
	        return _this3;
	    }

	    createClass(CompileAnimationStateTransitionMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'AnimationStateTransitionMetadata',
	                'value': { 'stateChangeExpr': this.stateChangeExpr, 'steps': this.steps.toJson() }
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var value = data['value'];
	            var steps = _objFromJson(value['steps'], metadataFromJson);
	            return new CompileAnimationStateTransitionMetadata(value['stateChangeExpr'], steps);
	        }
	    }]);
	    return CompileAnimationStateTransitionMetadata;
	}(CompileAnimationStateMetadata);
	var CompileAnimationMetadata = function CompileAnimationMetadata() {
	    classCallCheck(this, CompileAnimationMetadata);
	};
	var CompileAnimationKeyframesSequenceMetadata = function (_CompileAnimationMeta) {
	    inherits(CompileAnimationKeyframesSequenceMetadata, _CompileAnimationMeta);

	    function CompileAnimationKeyframesSequenceMetadata() {
	        var steps = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, CompileAnimationKeyframesSequenceMetadata);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationKeyframesSequenceMetadata).call(this));

	        _this4.steps = steps;
	        return _this4;
	    }

	    createClass(CompileAnimationKeyframesSequenceMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return { 'class': 'AnimationKeyframesSequenceMetadata', 'value': _arrayToJson(this.steps) };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var steps = _arrayFromJson(data['value'], metadataFromJson);
	            return new CompileAnimationKeyframesSequenceMetadata(steps);
	        }
	    }]);
	    return CompileAnimationKeyframesSequenceMetadata;
	}(CompileAnimationMetadata);
	var CompileAnimationStyleMetadata = function (_CompileAnimationMeta2) {
	    inherits(CompileAnimationStyleMetadata, _CompileAnimationMeta2);

	    function CompileAnimationStyleMetadata(offset) {
	        var styles = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, CompileAnimationStyleMetadata);

	        var _this5 = possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationStyleMetadata).call(this));

	        _this5.offset = offset;
	        _this5.styles = styles;
	        return _this5;
	    }

	    createClass(CompileAnimationStyleMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'AnimationStyleMetadata',
	                'value': { 'offset': this.offset, 'styles': this.styles }
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var value = data['value'];
	            var offsetVal = value['offset'];
	            var offset = isPresent$3(offsetVal) ? NumberWrapper$3.parseFloat(offsetVal) : null;
	            var styles = value['styles'];
	            return new CompileAnimationStyleMetadata(offset, styles);
	        }
	    }]);
	    return CompileAnimationStyleMetadata;
	}(CompileAnimationMetadata);
	var CompileAnimationAnimateMetadata = function (_CompileAnimationMeta3) {
	    inherits(CompileAnimationAnimateMetadata, _CompileAnimationMeta3);

	    function CompileAnimationAnimateMetadata() {
	        var timings = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var styles = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, CompileAnimationAnimateMetadata);

	        var _this6 = possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationAnimateMetadata).call(this));

	        _this6.timings = timings;
	        _this6.styles = styles;
	        return _this6;
	    }

	    createClass(CompileAnimationAnimateMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'AnimationAnimateMetadata',
	                'value': { 'timings': this.timings, 'styles': _objToJson(this.styles) }
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var value = data['value'];
	            var timings = value['timings'];
	            var styles = _objFromJson(value['styles'], metadataFromJson);
	            return new CompileAnimationAnimateMetadata(timings, styles);
	        }
	    }]);
	    return CompileAnimationAnimateMetadata;
	}(CompileAnimationMetadata);
	var CompileAnimationWithStepsMetadata = function (_CompileAnimationMeta4) {
	    inherits(CompileAnimationWithStepsMetadata, _CompileAnimationMeta4);

	    function CompileAnimationWithStepsMetadata() {
	        var steps = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        classCallCheck(this, CompileAnimationWithStepsMetadata);

	        var _this7 = possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationWithStepsMetadata).call(this));

	        _this7.steps = steps;
	        return _this7;
	    }

	    return CompileAnimationWithStepsMetadata;
	}(CompileAnimationMetadata);
	var CompileAnimationSequenceMetadata = function (_CompileAnimationWith) {
	    inherits(CompileAnimationSequenceMetadata, _CompileAnimationWith);

	    function CompileAnimationSequenceMetadata() {
	        var steps = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        classCallCheck(this, CompileAnimationSequenceMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationSequenceMetadata).call(this, steps));
	    }

	    createClass(CompileAnimationSequenceMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return { 'class': 'AnimationSequenceMetadata', 'value': _arrayToJson(this.steps) };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var steps = _arrayFromJson(data['value'], metadataFromJson);
	            return new CompileAnimationSequenceMetadata(steps);
	        }
	    }]);
	    return CompileAnimationSequenceMetadata;
	}(CompileAnimationWithStepsMetadata);
	var CompileAnimationGroupMetadata = function (_CompileAnimationWith2) {
	    inherits(CompileAnimationGroupMetadata, _CompileAnimationWith2);

	    function CompileAnimationGroupMetadata() {
	        var steps = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        classCallCheck(this, CompileAnimationGroupMetadata);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(CompileAnimationGroupMetadata).call(this, steps));
	    }

	    createClass(CompileAnimationGroupMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return { 'class': 'AnimationGroupMetadata', 'value': _arrayToJson(this.steps) };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var steps = _arrayFromJson(data['value'], metadataFromJson);
	            return new CompileAnimationGroupMetadata(steps);
	        }
	    }]);
	    return CompileAnimationGroupMetadata;
	}(CompileAnimationWithStepsMetadata);
	var CompileIdentifierMetadata = function () {
	    function CompileIdentifierMetadata() {
	        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var runtime = _ref.runtime;
	        var name = _ref.name;
	        var moduleUrl = _ref.moduleUrl;
	        var prefix = _ref.prefix;
	        var value = _ref.value;
	        classCallCheck(this, CompileIdentifierMetadata);

	        this.runtime = runtime;
	        this.name = name;
	        this.prefix = prefix;
	        this.moduleUrl = moduleUrl;
	        this.value = value;
	    }

	    createClass(CompileIdentifierMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            var value = isArray$4(this.value) ? _arrayToJson(this.value) : _objToJson(this.value);
	            return {
	                // Note: Runtime type can't be serialized...
	                'class': 'Identifier',
	                'name': this.name,
	                'moduleUrl': this.moduleUrl,
	                'prefix': this.prefix,
	                'value': value
	            };
	        }
	    }, {
	        key: 'identifier',
	        get: function get() {
	            return this;
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var value = isArray$4(data['value']) ? _arrayFromJson(data['value'], metadataFromJson) : _objFromJson(data['value'], metadataFromJson);
	            return new CompileIdentifierMetadata({ name: data['name'], prefix: data['prefix'], moduleUrl: data['moduleUrl'], value: value });
	        }
	    }]);
	    return CompileIdentifierMetadata;
	}();
	var CompileDiDependencyMetadata = function () {
	    function CompileDiDependencyMetadata() {
	        var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var isAttribute = _ref2.isAttribute;
	        var isSelf = _ref2.isSelf;
	        var isHost = _ref2.isHost;
	        var isSkipSelf = _ref2.isSkipSelf;
	        var isOptional = _ref2.isOptional;
	        var isValue = _ref2.isValue;
	        var query = _ref2.query;
	        var viewQuery = _ref2.viewQuery;
	        var token = _ref2.token;
	        var value = _ref2.value;
	        classCallCheck(this, CompileDiDependencyMetadata);

	        this.isAttribute = normalizeBool$3(isAttribute);
	        this.isSelf = normalizeBool$3(isSelf);
	        this.isHost = normalizeBool$3(isHost);
	        this.isSkipSelf = normalizeBool$3(isSkipSelf);
	        this.isOptional = normalizeBool$3(isOptional);
	        this.isValue = normalizeBool$3(isValue);
	        this.query = query;
	        this.viewQuery = viewQuery;
	        this.token = token;
	        this.value = value;
	    }

	    createClass(CompileDiDependencyMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'token': _objToJson(this.token),
	                'query': _objToJson(this.query),
	                'viewQuery': _objToJson(this.viewQuery),
	                'value': this.value,
	                'isAttribute': this.isAttribute,
	                'isSelf': this.isSelf,
	                'isHost': this.isHost,
	                'isSkipSelf': this.isSkipSelf,
	                'isOptional': this.isOptional,
	                'isValue': this.isValue
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileDiDependencyMetadata({
	                token: _objFromJson(data['token'], CompileTokenMetadata.fromJson),
	                query: _objFromJson(data['query'], CompileQueryMetadata.fromJson),
	                viewQuery: _objFromJson(data['viewQuery'], CompileQueryMetadata.fromJson),
	                value: data['value'],
	                isAttribute: data['isAttribute'],
	                isSelf: data['isSelf'],
	                isHost: data['isHost'],
	                isSkipSelf: data['isSkipSelf'],
	                isOptional: data['isOptional'],
	                isValue: data['isValue']
	            });
	        }
	    }]);
	    return CompileDiDependencyMetadata;
	}();
	var CompileProviderMetadata = function () {
	    function CompileProviderMetadata(_ref3) {
	        var token = _ref3.token;
	        var useClass = _ref3.useClass;
	        var useValue = _ref3.useValue;
	        var useExisting = _ref3.useExisting;
	        var useFactory = _ref3.useFactory;
	        var deps = _ref3.deps;
	        var multi = _ref3.multi;
	        classCallCheck(this, CompileProviderMetadata);

	        this.token = token;
	        this.useClass = useClass;
	        this.useValue = useValue;
	        this.useExisting = useExisting;
	        this.useFactory = useFactory;
	        this.deps = normalizeBlank$3(deps);
	        this.multi = normalizeBool$3(multi);
	    }

	    createClass(CompileProviderMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                // Note: Runtime type can't be serialized...
	                'class': 'Provider',
	                'token': _objToJson(this.token),
	                'useClass': _objToJson(this.useClass),
	                'useExisting': _objToJson(this.useExisting),
	                'useValue': _objToJson(this.useValue),
	                'useFactory': _objToJson(this.useFactory),
	                'multi': this.multi,
	                'deps': _arrayToJson(this.deps)
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileProviderMetadata({
	                token: _objFromJson(data['token'], CompileTokenMetadata.fromJson),
	                useClass: _objFromJson(data['useClass'], CompileTypeMetadata.fromJson),
	                useExisting: _objFromJson(data['useExisting'], CompileTokenMetadata.fromJson),
	                useValue: _objFromJson(data['useValue'], CompileIdentifierMetadata.fromJson),
	                useFactory: _objFromJson(data['useFactory'], CompileFactoryMetadata.fromJson),
	                multi: data['multi'],
	                deps: _arrayFromJson(data['deps'], CompileDiDependencyMetadata.fromJson)
	            });
	        }
	    }]);
	    return CompileProviderMetadata;
	}();
	var CompileFactoryMetadata = function () {
	    function CompileFactoryMetadata(_ref4) {
	        var runtime = _ref4.runtime;
	        var name = _ref4.name;
	        var moduleUrl = _ref4.moduleUrl;
	        var prefix = _ref4.prefix;
	        var diDeps = _ref4.diDeps;
	        var value = _ref4.value;
	        classCallCheck(this, CompileFactoryMetadata);

	        this.runtime = runtime;
	        this.name = name;
	        this.prefix = prefix;
	        this.moduleUrl = moduleUrl;
	        this.diDeps = _normalizeArray(diDeps);
	        this.value = value;
	    }

	    createClass(CompileFactoryMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'Factory',
	                'name': this.name,
	                'prefix': this.prefix,
	                'moduleUrl': this.moduleUrl,
	                'value': this.value,
	                'diDeps': _arrayToJson(this.diDeps)
	            };
	        }
	    }, {
	        key: 'identifier',
	        get: function get() {
	            return this;
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileFactoryMetadata({
	                name: data['name'],
	                prefix: data['prefix'],
	                moduleUrl: data['moduleUrl'],
	                value: data['value'],
	                diDeps: _arrayFromJson(data['diDeps'], CompileDiDependencyMetadata.fromJson)
	            });
	        }
	    }]);
	    return CompileFactoryMetadata;
	}();
	var UNDEFINED$1 = new Object();
	var CompileTokenMetadata = function () {
	    function CompileTokenMetadata(_ref5) {
	        var value = _ref5.value;
	        var identifier = _ref5.identifier;
	        var identifierIsInstance = _ref5.identifierIsInstance;
	        classCallCheck(this, CompileTokenMetadata);

	        this._assetCacheKey = UNDEFINED$1;
	        this.value = value;
	        this.identifier = identifier;
	        this.identifierIsInstance = normalizeBool$3(identifierIsInstance);
	    }

	    createClass(CompileTokenMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'value': this.value,
	                'identifier': _objToJson(this.identifier),
	                'identifierIsInstance': this.identifierIsInstance
	            };
	        }
	    }, {
	        key: 'equalsTo',
	        value: function equalsTo(token2) {
	            var rk = this.runtimeCacheKey;
	            var ak = this.assetCacheKey;
	            return isPresent$3(rk) && rk == token2.runtimeCacheKey || isPresent$3(ak) && ak == token2.assetCacheKey;
	        }
	    }, {
	        key: 'runtimeCacheKey',
	        get: function get() {
	            if (isPresent$3(this.identifier)) {
	                return this.identifier.runtime;
	            } else {
	                return this.value;
	            }
	        }
	    }, {
	        key: 'assetCacheKey',
	        get: function get() {
	            if (this._assetCacheKey === UNDEFINED$1) {
	                if (isPresent$3(this.identifier)) {
	                    if (isPresent$3(this.identifier.moduleUrl) && isPresent$3(getUrlScheme(this.identifier.moduleUrl))) {
	                        var uri = reflector$2.importUri({ 'filePath': this.identifier.moduleUrl, 'name': this.identifier.name });
	                        this._assetCacheKey = this.identifier.name + '|' + uri + '|' + this.identifierIsInstance;
	                    } else {
	                        this._assetCacheKey = null;
	                    }
	                } else {
	                    this._assetCacheKey = this.value;
	                }
	            }
	            return this._assetCacheKey;
	        }
	    }, {
	        key: 'name',
	        get: function get() {
	            return isPresent$3(this.value) ? sanitizeIdentifier(this.value) : this.identifier.name;
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileTokenMetadata({
	                value: data['value'],
	                identifier: _objFromJson(data['identifier'], CompileIdentifierMetadata.fromJson),
	                identifierIsInstance: data['identifierIsInstance']
	            });
	        }
	    }]);
	    return CompileTokenMetadata;
	}();
	var CompileTokenMap = function () {
	    function CompileTokenMap() {
	        classCallCheck(this, CompileTokenMap);

	        this._valueMap = new Map();
	        this._values = [];
	    }

	    createClass(CompileTokenMap, [{
	        key: 'add',
	        value: function add(token, value) {
	            var existing = this.get(token);
	            if (isPresent$3(existing)) {
	                throw new BaseException$3('Can only add to a TokenMap! Token: ' + token.name);
	            }
	            this._values.push(value);
	            var rk = token.runtimeCacheKey;
	            if (isPresent$3(rk)) {
	                this._valueMap.set(rk, value);
	            }
	            var ak = token.assetCacheKey;
	            if (isPresent$3(ak)) {
	                this._valueMap.set(ak, value);
	            }
	        }
	    }, {
	        key: 'get',
	        value: function get(token) {
	            var rk = token.runtimeCacheKey;
	            var ak = token.assetCacheKey;
	            var result;
	            if (isPresent$3(rk)) {
	                result = this._valueMap.get(rk);
	            }
	            if (isBlank$3(result) && isPresent$3(ak)) {
	                result = this._valueMap.get(ak);
	            }
	            return result;
	        }
	    }, {
	        key: 'values',
	        value: function values() {
	            return this._values;
	        }
	    }, {
	        key: 'size',
	        get: function get() {
	            return this._values.length;
	        }
	    }]);
	    return CompileTokenMap;
	}();
	/**
	 * Metadata regarding compilation of a type.
	 */
	var CompileTypeMetadata = function () {
	    function CompileTypeMetadata() {
	        var _ref6 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var runtime = _ref6.runtime;
	        var name = _ref6.name;
	        var moduleUrl = _ref6.moduleUrl;
	        var prefix = _ref6.prefix;
	        var isHost = _ref6.isHost;
	        var value = _ref6.value;
	        var diDeps = _ref6.diDeps;
	        classCallCheck(this, CompileTypeMetadata);

	        this.runtime = runtime;
	        this.name = name;
	        this.moduleUrl = moduleUrl;
	        this.prefix = prefix;
	        this.isHost = normalizeBool$3(isHost);
	        this.value = value;
	        this.diDeps = _normalizeArray(diDeps);
	    }

	    createClass(CompileTypeMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                // Note: Runtime type can't be serialized...
	                'class': 'Type',
	                'name': this.name,
	                'moduleUrl': this.moduleUrl,
	                'prefix': this.prefix,
	                'isHost': this.isHost,
	                'value': this.value,
	                'diDeps': _arrayToJson(this.diDeps)
	            };
	        }
	    }, {
	        key: 'identifier',
	        get: function get() {
	            return this;
	        }
	    }, {
	        key: 'type',
	        get: function get() {
	            return this;
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileTypeMetadata({
	                name: data['name'],
	                moduleUrl: data['moduleUrl'],
	                prefix: data['prefix'],
	                isHost: data['isHost'],
	                value: data['value'],
	                diDeps: _arrayFromJson(data['diDeps'], CompileDiDependencyMetadata.fromJson)
	            });
	        }
	    }]);
	    return CompileTypeMetadata;
	}();
	var CompileQueryMetadata = function () {
	    function CompileQueryMetadata() {
	        var _ref7 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var selectors = _ref7.selectors;
	        var descendants = _ref7.descendants;
	        var first = _ref7.first;
	        var propertyName = _ref7.propertyName;
	        var read = _ref7.read;
	        classCallCheck(this, CompileQueryMetadata);

	        this.selectors = selectors;
	        this.descendants = normalizeBool$3(descendants);
	        this.first = normalizeBool$3(first);
	        this.propertyName = propertyName;
	        this.read = read;
	    }

	    createClass(CompileQueryMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'selectors': _arrayToJson(this.selectors),
	                'descendants': this.descendants,
	                'first': this.first,
	                'propertyName': this.propertyName,
	                'read': _objToJson(this.read)
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileQueryMetadata({
	                selectors: _arrayFromJson(data['selectors'], CompileTokenMetadata.fromJson),
	                descendants: data['descendants'],
	                first: data['first'],
	                propertyName: data['propertyName'],
	                read: _objFromJson(data['read'], CompileTokenMetadata.fromJson)
	            });
	        }
	    }]);
	    return CompileQueryMetadata;
	}();
	/**
	 * Metadata about a stylesheet
	 */
	var CompileStylesheetMetadata = function () {
	    function CompileStylesheetMetadata() {
	        var _ref8 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var moduleUrl = _ref8.moduleUrl;
	        var styles = _ref8.styles;
	        var styleUrls = _ref8.styleUrls;
	        classCallCheck(this, CompileStylesheetMetadata);

	        this.moduleUrl = moduleUrl;
	        this.styles = _normalizeArray(styles);
	        this.styleUrls = _normalizeArray(styleUrls);
	    }

	    createClass(CompileStylesheetMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return { 'moduleUrl': this.moduleUrl, 'styles': this.styles, 'styleUrls': this.styleUrls };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileStylesheetMetadata({ moduleUrl: data['moduleUrl'], styles: data['styles'], styleUrls: data['styleUrls'] });
	        }
	    }]);
	    return CompileStylesheetMetadata;
	}();
	/**
	 * Metadata regarding compilation of a template.
	 */
	var CompileTemplateMetadata = function () {
	    function CompileTemplateMetadata() {
	        var _ref9 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var encapsulation = _ref9.encapsulation;
	        var template = _ref9.template;
	        var templateUrl = _ref9.templateUrl;
	        var styles = _ref9.styles;
	        var styleUrls = _ref9.styleUrls;
	        var externalStylesheets = _ref9.externalStylesheets;
	        var animations = _ref9.animations;
	        var ngContentSelectors = _ref9.ngContentSelectors;
	        var interpolation = _ref9.interpolation;
	        classCallCheck(this, CompileTemplateMetadata);

	        this.encapsulation = encapsulation;
	        this.template = template;
	        this.templateUrl = templateUrl;
	        this.styles = _normalizeArray(styles);
	        this.styleUrls = _normalizeArray(styleUrls);
	        this.externalStylesheets = _normalizeArray(externalStylesheets);
	        this.animations = isPresent$3(animations) ? ListWrapper$3.flatten(animations) : [];
	        this.ngContentSelectors = isPresent$3(ngContentSelectors) ? ngContentSelectors : [];
	        if (isPresent$3(interpolation) && interpolation.length != 2) {
	            throw new BaseException$3('\'interpolation\' should have a start and an end symbol.');
	        }
	        this.interpolation = interpolation;
	    }

	    createClass(CompileTemplateMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'encapsulation': isPresent$3(this.encapsulation) ? serializeEnum$3(this.encapsulation) : this.encapsulation,
	                'template': this.template,
	                'templateUrl': this.templateUrl,
	                'styles': this.styles,
	                'styleUrls': this.styleUrls,
	                'externalStylesheets': _objToJson(this.externalStylesheets),
	                'animations': _objToJson(this.animations),
	                'ngContentSelectors': this.ngContentSelectors,
	                'interpolation': this.interpolation
	            };
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            var animations = _arrayFromJson(data['animations'], metadataFromJson);
	            return new CompileTemplateMetadata({
	                encapsulation: isPresent$3(data['encapsulation']) ? VIEW_ENCAPSULATION_VALUES$2[data['encapsulation']] : data['encapsulation'],
	                template: data['template'],
	                templateUrl: data['templateUrl'],
	                styles: data['styles'],
	                styleUrls: data['styleUrls'],
	                externalStylesheets: _arrayFromJson(data['externalStylesheets'], CompileStylesheetMetadata.fromJson),
	                animations: animations,
	                ngContentSelectors: data['ngContentSelectors'],
	                interpolation: data['interpolation']
	            });
	        }
	    }]);
	    return CompileTemplateMetadata;
	}();
	/**
	 * Metadata regarding compilation of a directive.
	 */
	var CompileDirectiveMetadata = function () {
	    function CompileDirectiveMetadata() {
	        var _ref10 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var type = _ref10.type;
	        var isComponent = _ref10.isComponent;
	        var selector = _ref10.selector;
	        var exportAs = _ref10.exportAs;
	        var changeDetection = _ref10.changeDetection;
	        var inputs = _ref10.inputs;
	        var outputs = _ref10.outputs;
	        var hostListeners = _ref10.hostListeners;
	        var hostProperties = _ref10.hostProperties;
	        var hostAttributes = _ref10.hostAttributes;
	        var lifecycleHooks = _ref10.lifecycleHooks;
	        var providers = _ref10.providers;
	        var viewProviders = _ref10.viewProviders;
	        var queries = _ref10.queries;
	        var viewQueries = _ref10.viewQueries;
	        var precompile = _ref10.precompile;
	        var template = _ref10.template;
	        classCallCheck(this, CompileDirectiveMetadata);

	        this.type = type;
	        this.isComponent = isComponent;
	        this.selector = selector;
	        this.exportAs = exportAs;
	        this.changeDetection = changeDetection;
	        this.inputs = inputs;
	        this.outputs = outputs;
	        this.hostListeners = hostListeners;
	        this.hostProperties = hostProperties;
	        this.hostAttributes = hostAttributes;
	        this.lifecycleHooks = _normalizeArray(lifecycleHooks);
	        this.providers = _normalizeArray(providers);
	        this.viewProviders = _normalizeArray(viewProviders);
	        this.queries = _normalizeArray(queries);
	        this.viewQueries = _normalizeArray(viewQueries);
	        this.precompile = _normalizeArray(precompile);
	        this.template = template;
	    }

	    createClass(CompileDirectiveMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'Directive',
	                'isComponent': this.isComponent,
	                'selector': this.selector,
	                'exportAs': this.exportAs,
	                'type': isPresent$3(this.type) ? this.type.toJson() : this.type,
	                'changeDetection': isPresent$3(this.changeDetection) ? serializeEnum$3(this.changeDetection) : this.changeDetection,
	                'inputs': this.inputs,
	                'outputs': this.outputs,
	                'hostListeners': this.hostListeners,
	                'hostProperties': this.hostProperties,
	                'hostAttributes': this.hostAttributes,
	                'lifecycleHooks': this.lifecycleHooks.map(function (hook) {
	                    return serializeEnum$3(hook);
	                }),
	                'template': isPresent$3(this.template) ? this.template.toJson() : this.template,
	                'providers': _arrayToJson(this.providers),
	                'viewProviders': _arrayToJson(this.viewProviders),
	                'queries': _arrayToJson(this.queries),
	                'viewQueries': _arrayToJson(this.viewQueries),
	                'precompile': _arrayToJson(this.precompile)
	            };
	        }
	    }, {
	        key: 'identifier',
	        get: function get() {
	            return this.type;
	        }
	    }], [{
	        key: 'create',
	        value: function create() {
	            var _ref11 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var type = _ref11.type;
	            var isComponent = _ref11.isComponent;
	            var selector = _ref11.selector;
	            var exportAs = _ref11.exportAs;
	            var changeDetection = _ref11.changeDetection;
	            var inputs = _ref11.inputs;
	            var outputs = _ref11.outputs;
	            var host = _ref11.host;
	            var lifecycleHooks = _ref11.lifecycleHooks;
	            var providers = _ref11.providers;
	            var viewProviders = _ref11.viewProviders;
	            var queries = _ref11.queries;
	            var viewQueries = _ref11.viewQueries;
	            var precompile = _ref11.precompile;
	            var template = _ref11.template;

	            var hostListeners = {};
	            var hostProperties = {};
	            var hostAttributes = {};
	            if (isPresent$3(host)) {
	                StringMapWrapper$3.forEach(host, function (value, key) {
	                    var matches = RegExpWrapper$3.firstMatch(HOST_REG_EXP, key);
	                    if (isBlank$3(matches)) {
	                        hostAttributes[key] = value;
	                    } else if (isPresent$3(matches[1])) {
	                        hostProperties[matches[1]] = value;
	                    } else if (isPresent$3(matches[2])) {
	                        hostListeners[matches[2]] = value;
	                    }
	                });
	            }
	            var inputsMap = {};
	            if (isPresent$3(inputs)) {
	                inputs.forEach(function (bindConfig) {
	                    // canonical syntax: `dirProp: elProp`
	                    // if there is no `:`, use dirProp = elProp
	                    var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
	                    inputsMap[parts[0]] = parts[1];
	                });
	            }
	            var outputsMap = {};
	            if (isPresent$3(outputs)) {
	                outputs.forEach(function (bindConfig) {
	                    // canonical syntax: `dirProp: elProp`
	                    // if there is no `:`, use dirProp = elProp
	                    var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
	                    outputsMap[parts[0]] = parts[1];
	                });
	            }
	            return new CompileDirectiveMetadata({
	                type: type,
	                isComponent: normalizeBool$3(isComponent),
	                selector: selector,
	                exportAs: exportAs,
	                changeDetection: changeDetection,
	                inputs: inputsMap,
	                outputs: outputsMap,
	                hostListeners: hostListeners,
	                hostProperties: hostProperties,
	                hostAttributes: hostAttributes,
	                lifecycleHooks: isPresent$3(lifecycleHooks) ? lifecycleHooks : [],
	                providers: providers,
	                viewProviders: viewProviders,
	                queries: queries,
	                viewQueries: viewQueries,
	                precompile: precompile,
	                template: template
	            });
	        }
	    }, {
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompileDirectiveMetadata({
	                isComponent: data['isComponent'],
	                selector: data['selector'],
	                exportAs: data['exportAs'],
	                type: isPresent$3(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
	                changeDetection: isPresent$3(data['changeDetection']) ? CHANGE_DETECTION_STRATEGY_VALUES$1[data['changeDetection']] : data['changeDetection'],
	                inputs: data['inputs'],
	                outputs: data['outputs'],
	                hostListeners: data['hostListeners'],
	                hostProperties: data['hostProperties'],
	                hostAttributes: data['hostAttributes'],
	                lifecycleHooks: data['lifecycleHooks'].map(function (hookValue) {
	                    return LIFECYCLE_HOOKS_VALUES$1[hookValue];
	                }),
	                template: isPresent$3(data['template']) ? CompileTemplateMetadata.fromJson(data['template']) : data['template'],
	                providers: _arrayFromJson(data['providers'], metadataFromJson),
	                viewProviders: _arrayFromJson(data['viewProviders'], metadataFromJson),
	                queries: _arrayFromJson(data['queries'], CompileQueryMetadata.fromJson),
	                viewQueries: _arrayFromJson(data['viewQueries'], CompileQueryMetadata.fromJson),
	                precompile: _arrayFromJson(data['precompile'], CompileTypeMetadata.fromJson)
	            });
	        }
	    }]);
	    return CompileDirectiveMetadata;
	}();
	/**
	 * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
	 */
	function createHostComponentMeta(componentType, componentSelector) {
	    var template = CssSelector.parse(componentSelector)[0].getMatchingElementTemplate();
	    return CompileDirectiveMetadata.create({
	        type: new CompileTypeMetadata({
	            runtime: Object,
	            name: componentType.name + '_Host',
	            moduleUrl: componentType.moduleUrl,
	            isHost: true
	        }),
	        template: new CompileTemplateMetadata({
	            template: template,
	            templateUrl: '',
	            styles: [],
	            styleUrls: [],
	            ngContentSelectors: [],
	            animations: []
	        }),
	        changeDetection: ChangeDetectionStrategy.Default,
	        inputs: [],
	        outputs: [],
	        host: {},
	        lifecycleHooks: [],
	        isComponent: true,
	        selector: '*',
	        providers: [],
	        viewProviders: [],
	        queries: [],
	        viewQueries: []
	    });
	}
	var CompilePipeMetadata = function () {
	    function CompilePipeMetadata() {
	        var _ref12 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var type = _ref12.type;
	        var name = _ref12.name;
	        var pure = _ref12.pure;
	        var lifecycleHooks = _ref12.lifecycleHooks;
	        classCallCheck(this, CompilePipeMetadata);

	        this.type = type;
	        this.name = name;
	        this.pure = normalizeBool$3(pure);
	        this.lifecycleHooks = _normalizeArray(lifecycleHooks);
	    }

	    createClass(CompilePipeMetadata, [{
	        key: 'toJson',
	        value: function toJson() {
	            return {
	                'class': 'Pipe',
	                'type': isPresent$3(this.type) ? this.type.toJson() : null,
	                'name': this.name,
	                'pure': this.pure
	            };
	        }
	    }, {
	        key: 'identifier',
	        get: function get() {
	            return this.type;
	        }
	    }], [{
	        key: 'fromJson',
	        value: function fromJson(data) {
	            return new CompilePipeMetadata({
	                type: isPresent$3(data['type']) ? CompileTypeMetadata.fromJson(data['type']) : data['type'],
	                name: data['name'],
	                pure: data['pure']
	            });
	        }
	    }]);
	    return CompilePipeMetadata;
	}();
	var _COMPILE_METADATA_FROM_JSON = {
	    'Directive': CompileDirectiveMetadata.fromJson,
	    'Pipe': CompilePipeMetadata.fromJson,
	    'Type': CompileTypeMetadata.fromJson,
	    'Provider': CompileProviderMetadata.fromJson,
	    'Identifier': CompileIdentifierMetadata.fromJson,
	    'Factory': CompileFactoryMetadata.fromJson,
	    'AnimationEntryMetadata': CompileAnimationEntryMetadata.fromJson,
	    'AnimationStateDeclarationMetadata': CompileAnimationStateDeclarationMetadata.fromJson,
	    'AnimationStateTransitionMetadata': CompileAnimationStateTransitionMetadata.fromJson,
	    'AnimationSequenceMetadata': CompileAnimationSequenceMetadata.fromJson,
	    'AnimationGroupMetadata': CompileAnimationGroupMetadata.fromJson,
	    'AnimationAnimateMetadata': CompileAnimationAnimateMetadata.fromJson,
	    'AnimationStyleMetadata': CompileAnimationStyleMetadata.fromJson,
	    'AnimationKeyframesSequenceMetadata': CompileAnimationKeyframesSequenceMetadata.fromJson
	};
	function _arrayFromJson(obj, fn) {
	    return isBlank$3(obj) ? null : obj.map(function (o) {
	        return _objFromJson(o, fn);
	    });
	}
	function _arrayToJson(obj) {
	    return isBlank$3(obj) ? null : obj.map(_objToJson);
	}
	function _objFromJson(obj, fn) {
	    if (isArray$4(obj)) return _arrayFromJson(obj, fn);
	    if (isString$3(obj) || isBlank$3(obj) || isBoolean$3(obj) || isNumber$3(obj)) return obj;
	    return fn(obj);
	}
	function _objToJson(obj) {
	    if (isArray$4(obj)) return _arrayToJson(obj);
	    if (isString$3(obj) || isBlank$3(obj) || isBoolean$3(obj) || isNumber$3(obj)) return obj;
	    return obj.toJson();
	}
	function _normalizeArray(obj) {
	    return isPresent$3(obj) ? obj : [];
	}

	var APP_VIEW_MODULE_URL = assetUrl('core', 'linker/view');
	var VIEW_UTILS_MODULE_URL = assetUrl('core', 'linker/view_utils');
	var CD_MODULE_URL = assetUrl('core', 'change_detection/change_detection');
	// Reassign the imports to different variables so we can
	// define static variables with the name of the import.
	// (only needed for Dart).
	var impViewUtils = ViewUtils$1;
	var impAppView = AppView$1;
	var impDebugAppView = DebugAppView$1;
	var impDebugContext = DebugContext$1;
	var impAppElement = AppElement$1;
	var impElementRef = ElementRef;
	var impViewContainerRef = ViewContainerRef;
	var impChangeDetectorRef = ChangeDetectorRef;
	var impRenderComponentType = RenderComponentType;
	var impQueryList = QueryList;
	var impTemplateRef = TemplateRef;
	var impTemplateRef_ = TemplateRef_$1;
	var impValueUnwrapper = ValueUnwrapper$1;
	var impInjector = Injector;
	var impViewEncapsulation = ViewEncapsulation;
	var impViewType = ViewType$1;
	var impChangeDetectionStrategy = ChangeDetectionStrategy;
	var impStaticNodeDebugInfo = StaticNodeDebugInfo$1;
	var impRenderer = Renderer;
	var impSimpleChange = SimpleChange;
	var impUninitialized = uninitialized$1;
	var impChangeDetectorStatus = ChangeDetectorStatus$1;
	var impFlattenNestedViewRenderNodes = flattenNestedViewRenderNodes$1;
	var impDevModeEqual = devModeEqual$1;
	var impInterpolate = interpolate$1;
	var impCheckBinding = checkBinding$1;
	var impCastByValue = castByValue$1;
	var impEMPTY_ARRAY = EMPTY_ARRAY$1;
	var impEMPTY_MAP = EMPTY_MAP$1;
	var impAnimationGroupPlayer = AnimationGroupPlayer_;
	var impAnimationSequencePlayer = AnimationSequencePlayer_;
	var impAnimationKeyframe = AnimationKeyframe_;
	var impAnimationStyles = AnimationStyles_;
	var impNoOpAnimationPlayer = NoOpAnimationPlayer_;
	var ANIMATION_STYLE_UTIL_ASSET_URL = assetUrl('core', 'animation/animation_style_util');
	var Identifiers = function Identifiers() {
	    classCallCheck(this, Identifiers);
	};
	Identifiers.ViewUtils = new CompileIdentifierMetadata({ name: 'ViewUtils', moduleUrl: assetUrl('core', 'linker/view_utils'), runtime: impViewUtils });
	Identifiers.AppView = new CompileIdentifierMetadata({ name: 'AppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: impAppView });
	Identifiers.DebugAppView = new CompileIdentifierMetadata({ name: 'DebugAppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: impDebugAppView });
	Identifiers.AppElement = new CompileIdentifierMetadata({ name: 'AppElement', moduleUrl: assetUrl('core', 'linker/element'), runtime: impAppElement });
	Identifiers.ElementRef = new CompileIdentifierMetadata({
	    name: 'ElementRef',
	    moduleUrl: assetUrl('core', 'linker/element_ref'),
	    runtime: impElementRef
	});
	Identifiers.ViewContainerRef = new CompileIdentifierMetadata({
	    name: 'ViewContainerRef',
	    moduleUrl: assetUrl('core', 'linker/view_container_ref'),
	    runtime: impViewContainerRef
	});
	Identifiers.ChangeDetectorRef = new CompileIdentifierMetadata({
	    name: 'ChangeDetectorRef',
	    moduleUrl: assetUrl('core', 'change_detection/change_detector_ref'),
	    runtime: impChangeDetectorRef
	});
	Identifiers.RenderComponentType = new CompileIdentifierMetadata({
	    name: 'RenderComponentType',
	    moduleUrl: assetUrl('core', 'render/api'),
	    runtime: impRenderComponentType
	});
	Identifiers.QueryList = new CompileIdentifierMetadata({ name: 'QueryList', moduleUrl: assetUrl('core', 'linker/query_list'), runtime: impQueryList });
	Identifiers.TemplateRef = new CompileIdentifierMetadata({
	    name: 'TemplateRef',
	    moduleUrl: assetUrl('core', 'linker/template_ref'),
	    runtime: impTemplateRef
	});
	Identifiers.TemplateRef_ = new CompileIdentifierMetadata({
	    name: 'TemplateRef_',
	    moduleUrl: assetUrl('core', 'linker/template_ref'),
	    runtime: impTemplateRef_
	});
	Identifiers.CodegenComponentFactoryResolver = new CompileIdentifierMetadata({
	    name: 'CodegenComponentFactoryResolver',
	    moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
	    runtime: CodegenComponentFactoryResolver$1
	});
	Identifiers.ComponentFactoryResolver = new CompileIdentifierMetadata({
	    name: 'ComponentFactoryResolver',
	    moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
	    runtime: ComponentFactoryResolver
	});
	Identifiers.ValueUnwrapper = new CompileIdentifierMetadata({ name: 'ValueUnwrapper', moduleUrl: CD_MODULE_URL, runtime: impValueUnwrapper });
	Identifiers.Injector = new CompileIdentifierMetadata({ name: 'Injector', moduleUrl: assetUrl('core', 'di/injector'), runtime: impInjector });
	Identifiers.ViewEncapsulation = new CompileIdentifierMetadata({
	    name: 'ViewEncapsulation',
	    moduleUrl: assetUrl('core', 'metadata/view'),
	    runtime: impViewEncapsulation
	});
	Identifiers.ViewType = new CompileIdentifierMetadata({ name: 'ViewType', moduleUrl: assetUrl('core', 'linker/view_type'), runtime: impViewType });
	Identifiers.ChangeDetectionStrategy = new CompileIdentifierMetadata({
	    name: 'ChangeDetectionStrategy',
	    moduleUrl: CD_MODULE_URL,
	    runtime: impChangeDetectionStrategy
	});
	Identifiers.StaticNodeDebugInfo = new CompileIdentifierMetadata({
	    name: 'StaticNodeDebugInfo',
	    moduleUrl: assetUrl('core', 'linker/debug_context'),
	    runtime: impStaticNodeDebugInfo
	});
	Identifiers.DebugContext = new CompileIdentifierMetadata({
	    name: 'DebugContext',
	    moduleUrl: assetUrl('core', 'linker/debug_context'),
	    runtime: impDebugContext
	});
	Identifiers.Renderer = new CompileIdentifierMetadata({ name: 'Renderer', moduleUrl: assetUrl('core', 'render/api'), runtime: impRenderer });
	Identifiers.SimpleChange = new CompileIdentifierMetadata({ name: 'SimpleChange', moduleUrl: CD_MODULE_URL, runtime: impSimpleChange });
	Identifiers.uninitialized = new CompileIdentifierMetadata({ name: 'uninitialized', moduleUrl: CD_MODULE_URL, runtime: impUninitialized });
	Identifiers.ChangeDetectorStatus = new CompileIdentifierMetadata({ name: 'ChangeDetectorStatus', moduleUrl: CD_MODULE_URL, runtime: impChangeDetectorStatus });
	Identifiers.checkBinding = new CompileIdentifierMetadata({ name: 'checkBinding', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impCheckBinding });
	Identifiers.flattenNestedViewRenderNodes = new CompileIdentifierMetadata({
	    name: 'flattenNestedViewRenderNodes',
	    moduleUrl: VIEW_UTILS_MODULE_URL,
	    runtime: impFlattenNestedViewRenderNodes
	});
	Identifiers.devModeEqual = new CompileIdentifierMetadata({ name: 'devModeEqual', moduleUrl: CD_MODULE_URL, runtime: impDevModeEqual });
	Identifiers.interpolate = new CompileIdentifierMetadata({ name: 'interpolate', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impInterpolate });
	Identifiers.castByValue = new CompileIdentifierMetadata({ name: 'castByValue', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impCastByValue });
	Identifiers.EMPTY_ARRAY = new CompileIdentifierMetadata({ name: 'EMPTY_ARRAY', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impEMPTY_ARRAY });
	Identifiers.EMPTY_MAP = new CompileIdentifierMetadata({ name: 'EMPTY_MAP', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: impEMPTY_MAP });
	Identifiers.pureProxies = [null, new CompileIdentifierMetadata({ name: 'pureProxy1', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy1$1 }), new CompileIdentifierMetadata({ name: 'pureProxy2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy2$1 }), new CompileIdentifierMetadata({ name: 'pureProxy3', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy3$1 }), new CompileIdentifierMetadata({ name: 'pureProxy4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy4$1 }), new CompileIdentifierMetadata({ name: 'pureProxy5', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy5$1 }), new CompileIdentifierMetadata({ name: 'pureProxy6', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy6$1 }), new CompileIdentifierMetadata({ name: 'pureProxy7', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy7$1 }), new CompileIdentifierMetadata({ name: 'pureProxy8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy8$1 }), new CompileIdentifierMetadata({ name: 'pureProxy9', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy9$1 }), new CompileIdentifierMetadata({ name: 'pureProxy10', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy10$1 })];
	Identifiers.SecurityContext = new CompileIdentifierMetadata({
	    name: 'SecurityContext',
	    moduleUrl: assetUrl('core', 'security'),
	    runtime: SecurityContext$2
	});
	Identifiers.AnimationKeyframe = new CompileIdentifierMetadata({
	    name: 'AnimationKeyframe',
	    moduleUrl: assetUrl('core', 'animation/animation_keyframe'),
	    runtime: impAnimationKeyframe
	});
	Identifiers.AnimationStyles = new CompileIdentifierMetadata({
	    name: 'AnimationStyles',
	    moduleUrl: assetUrl('core', 'animation/animation_styles'),
	    runtime: impAnimationStyles
	});
	Identifiers.NoOpAnimationPlayer = new CompileIdentifierMetadata({
	    name: 'NoOpAnimationPlayer',
	    moduleUrl: assetUrl('core', 'animation/animation_player'),
	    runtime: impNoOpAnimationPlayer
	});
	Identifiers.AnimationGroupPlayer = new CompileIdentifierMetadata({
	    name: 'AnimationGroupPlayer',
	    moduleUrl: assetUrl('core', 'animation/animation_group_player'),
	    runtime: impAnimationGroupPlayer
	});
	Identifiers.AnimationSequencePlayer = new CompileIdentifierMetadata({
	    name: 'AnimationSequencePlayer',
	    moduleUrl: assetUrl('core', 'animation/animation_sequence_player'),
	    runtime: impAnimationSequencePlayer
	});
	Identifiers.prepareFinalAnimationStyles = new CompileIdentifierMetadata({
	    name: 'prepareFinalAnimationStyles',
	    moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	    runtime: impBalanceAnimationStyles
	});
	Identifiers.balanceAnimationKeyframes = new CompileIdentifierMetadata({
	    name: 'balanceAnimationKeyframes',
	    moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	    runtime: impBalanceAnimationKeyframes
	});
	Identifiers.clearStyles = new CompileIdentifierMetadata({ name: 'clearStyles', moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL, runtime: impClearStyles });
	Identifiers.renderStyles = new CompileIdentifierMetadata({ name: 'renderStyles', moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL, runtime: impRenderStyles });
	Identifiers.collectAndResolveStyles = new CompileIdentifierMetadata({
	    name: 'collectAndResolveStyles',
	    moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
	    runtime: impCollectAndResolveStyles
	});
	function identifierToken(identifier) {
	    return new CompileTokenMetadata({ identifier: identifier });
	}

	var ProviderError = function (_ParseError) {
	    inherits(ProviderError, _ParseError);

	    function ProviderError(message, span) {
	        classCallCheck(this, ProviderError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(ProviderError).call(this, span, message));
	    }

	    return ProviderError;
	}(ParseError);
	var ProviderViewContext = function ProviderViewContext(component, sourceSpan) {
	    var _this2 = this;

	    classCallCheck(this, ProviderViewContext);

	    this.component = component;
	    this.sourceSpan = sourceSpan;
	    this.errors = [];
	    this.viewQueries = _getViewQueries(component);
	    this.viewProviders = new CompileTokenMap();
	    _normalizeProviders$1(component.viewProviders, sourceSpan, this.errors).forEach(function (provider) {
	        if (isBlank$3(_this2.viewProviders.get(provider.token))) {
	            _this2.viewProviders.add(provider.token, true);
	        }
	    });
	};
	var ProviderElementContext = function () {
	    function ProviderElementContext(_viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
	        var _this3 = this;

	        classCallCheck(this, ProviderElementContext);

	        this._viewContext = _viewContext;
	        this._parent = _parent;
	        this._isViewRoot = _isViewRoot;
	        this._directiveAsts = _directiveAsts;
	        this._sourceSpan = _sourceSpan;
	        this._transformedProviders = new CompileTokenMap();
	        this._seenProviders = new CompileTokenMap();
	        this._hasViewContainer = false;
	        this._attrs = {};
	        attrs.forEach(function (attrAst) {
	            return _this3._attrs[attrAst.name] = attrAst.value;
	        });
	        var directivesMeta = _directiveAsts.map(function (directiveAst) {
	            return directiveAst.directive;
	        });
	        this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, _viewContext.errors);
	        this._contentQueries = _getContentQueries(directivesMeta);
	        var queriedTokens = new CompileTokenMap();
	        this._allProviders.values().forEach(function (provider) {
	            _this3._addQueryReadsTo(provider.token, queriedTokens);
	        });
	        refs.forEach(function (refAst) {
	            _this3._addQueryReadsTo(new CompileTokenMetadata({ value: refAst.name }), queriedTokens);
	        });
	        if (isPresent$3(queriedTokens.get(identifierToken(Identifiers.ViewContainerRef)))) {
	            this._hasViewContainer = true;
	        }
	        // create the providers that we know are eager first
	        this._allProviders.values().forEach(function (provider) {
	            var eager = provider.eager || isPresent$3(queriedTokens.get(provider.token));
	            if (eager) {
	                _this3._getOrCreateLocalProvider(provider.providerType, provider.token, true);
	            }
	        });
	    }

	    createClass(ProviderElementContext, [{
	        key: 'afterElement',
	        value: function afterElement() {
	            var _this4 = this;

	            // collect lazy providers
	            this._allProviders.values().forEach(function (provider) {
	                _this4._getOrCreateLocalProvider(provider.providerType, provider.token, false);
	            });
	        }
	    }, {
	        key: '_addQueryReadsTo',
	        value: function _addQueryReadsTo(token, queryReadTokens) {
	            this._getQueriesFor(token).forEach(function (query) {
	                var queryReadToken = isPresent$3(query.read) ? query.read : token;
	                if (isBlank$3(queryReadTokens.get(queryReadToken))) {
	                    queryReadTokens.add(queryReadToken, true);
	                }
	            });
	        }
	    }, {
	        key: '_getQueriesFor',
	        value: function _getQueriesFor(token) {
	            var result = [];
	            var currentEl = this;
	            var distance = 0;
	            var queries;
	            while (currentEl !== null) {
	                queries = currentEl._contentQueries.get(token);
	                if (isPresent$3(queries)) {
	                    ListWrapper$3.addAll(result, queries.filter(function (query) {
	                        return query.descendants || distance <= 1;
	                    }));
	                }
	                if (currentEl._directiveAsts.length > 0) {
	                    distance++;
	                }
	                currentEl = currentEl._parent;
	            }
	            queries = this._viewContext.viewQueries.get(token);
	            if (isPresent$3(queries)) {
	                ListWrapper$3.addAll(result, queries);
	            }
	            return result;
	        }
	    }, {
	        key: '_getOrCreateLocalProvider',
	        value: function _getOrCreateLocalProvider(requestingProviderType, token, eager) {
	            var _this5 = this;

	            var resolvedProvider = this._allProviders.get(token);
	            if (isBlank$3(resolvedProvider) || (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.PrivateService || (requestingProviderType === ProviderAstType.PrivateService || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.Builtin) {
	                return null;
	            }
	            var transformedProviderAst = this._transformedProviders.get(token);
	            if (isPresent$3(transformedProviderAst)) {
	                return transformedProviderAst;
	            }
	            if (isPresent$3(this._seenProviders.get(token))) {
	                this._viewContext.errors.push(new ProviderError('Cannot instantiate cyclic dependency! ' + token.name, this._sourceSpan));
	                return null;
	            }
	            this._seenProviders.add(token, true);
	            var transformedProviders = resolvedProvider.providers.map(function (provider) {
	                var transformedUseValue = provider.useValue;
	                var transformedUseExisting = provider.useExisting;
	                var transformedDeps;
	                if (isPresent$3(provider.useExisting)) {
	                    var existingDiDep = _this5._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }), eager);
	                    if (isPresent$3(existingDiDep.token)) {
	                        transformedUseExisting = existingDiDep.token;
	                    } else {
	                        transformedUseExisting = null;
	                        transformedUseValue = existingDiDep.value;
	                    }
	                } else if (isPresent$3(provider.useFactory)) {
	                    var deps = isPresent$3(provider.deps) ? provider.deps : provider.useFactory.diDeps;
	                    transformedDeps = deps.map(function (dep) {
	                        return _this5._getDependency(resolvedProvider.providerType, dep, eager);
	                    });
	                } else if (isPresent$3(provider.useClass)) {
	                    var deps = isPresent$3(provider.deps) ? provider.deps : provider.useClass.diDeps;
	                    transformedDeps = deps.map(function (dep) {
	                        return _this5._getDependency(resolvedProvider.providerType, dep, eager);
	                    });
	                }
	                return _transformProvider(provider, {
	                    useExisting: transformedUseExisting,
	                    useValue: transformedUseValue,
	                    deps: transformedDeps
	                });
	            });
	            transformedProviderAst = _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
	            this._transformedProviders.add(token, transformedProviderAst);
	            return transformedProviderAst;
	        }
	    }, {
	        key: '_getLocalDependency',
	        value: function _getLocalDependency(requestingProviderType, dep) {
	            var eager = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            if (dep.isAttribute) {
	                var attrValue = this._attrs[dep.token.value];
	                return new CompileDiDependencyMetadata({ isValue: true, value: normalizeBlank$3(attrValue) });
	            }
	            if (isPresent$3(dep.query) || isPresent$3(dep.viewQuery)) {
	                return dep;
	            }
	            if (isPresent$3(dep.token)) {
	                // access builtints
	                if (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.Component) {
	                    if (dep.token.equalsTo(identifierToken(Identifiers.Renderer)) || dep.token.equalsTo(identifierToken(Identifiers.ElementRef)) || dep.token.equalsTo(identifierToken(Identifiers.ChangeDetectorRef)) || dep.token.equalsTo(identifierToken(Identifiers.TemplateRef))) {
	                        return dep;
	                    }
	                    if (dep.token.equalsTo(identifierToken(Identifiers.ViewContainerRef))) {
	                        this._hasViewContainer = true;
	                    }
	                }
	                // access the injector
	                if (dep.token.equalsTo(identifierToken(Identifiers.Injector))) {
	                    return dep;
	                }
	                // access providers
	                if (isPresent$3(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
	                    return dep;
	                }
	            }
	            return null;
	        }
	    }, {
	        key: '_getDependency',
	        value: function _getDependency(requestingProviderType, dep) {
	            var eager = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var currElement = this;
	            var currEager = eager;
	            var result = null;
	            if (!dep.isSkipSelf) {
	                result = this._getLocalDependency(requestingProviderType, dep, eager);
	            }
	            if (dep.isSelf) {
	                if (isBlank$3(result) && dep.isOptional) {
	                    result = new CompileDiDependencyMetadata({ isValue: true, value: null });
	                }
	            } else {
	                // check parent elements
	                while (isBlank$3(result) && isPresent$3(currElement._parent)) {
	                    var prevElement = currElement;
	                    currElement = currElement._parent;
	                    if (prevElement._isViewRoot) {
	                        currEager = false;
	                    }
	                    result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);
	                }
	                // check @Host restriction
	                if (isBlank$3(result)) {
	                    if (!dep.isHost || this._viewContext.component.type.isHost || identifierToken(this._viewContext.component.type).equalsTo(dep.token) || isPresent$3(this._viewContext.viewProviders.get(dep.token))) {
	                        result = dep;
	                    } else {
	                        result = dep.isOptional ? result = new CompileDiDependencyMetadata({ isValue: true, value: null }) : null;
	                    }
	                }
	            }
	            if (isBlank$3(result)) {
	                this._viewContext.errors.push(new ProviderError('No provider for ' + dep.token.name, this._sourceSpan));
	            }
	            return result;
	        }
	    }, {
	        key: 'transformProviders',
	        get: function get() {
	            return this._transformedProviders.values();
	        }
	    }, {
	        key: 'transformedDirectiveAsts',
	        get: function get() {
	            var sortedProviderTypes = this._transformedProviders.values().map(function (provider) {
	                return provider.token.identifier;
	            });
	            var sortedDirectives = ListWrapper$3.clone(this._directiveAsts);
	            ListWrapper$3.sort(sortedDirectives, function (dir1, dir2) {
	                return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);
	            });
	            return sortedDirectives;
	        }
	    }, {
	        key: 'transformedHasViewContainer',
	        get: function get() {
	            return this._hasViewContainer;
	        }
	    }]);
	    return ProviderElementContext;
	}();
	function _transformProvider(provider, _ref) {
	    var useExisting = _ref.useExisting;
	    var useValue = _ref.useValue;
	    var deps = _ref.deps;

	    return new CompileProviderMetadata({
	        token: provider.token,
	        useClass: provider.useClass,
	        useExisting: useExisting,
	        useFactory: provider.useFactory,
	        useValue: useValue,
	        deps: deps,
	        multi: provider.multi
	    });
	}
	function _transformProviderAst(provider, _ref2) {
	    var eager = _ref2.eager;
	    var providers = _ref2.providers;

	    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.sourceSpan);
	}
	function _normalizeProviders$1(providers, sourceSpan, targetErrors) {
	    var targetProviders = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	    if (isBlank$3(targetProviders)) {
	        targetProviders = [];
	    }
	    if (isPresent$3(providers)) {
	        providers.forEach(function (provider) {
	            if (isArray$4(provider)) {
	                _normalizeProviders$1(provider, sourceSpan, targetErrors, targetProviders);
	            } else {
	                var normalizeProvider;
	                if (provider instanceof CompileProviderMetadata) {
	                    normalizeProvider = provider;
	                } else if (provider instanceof CompileTypeMetadata) {
	                    normalizeProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: provider }), useClass: provider });
	                } else {
	                    targetErrors.push(new ProviderError('Unknown provider type ' + provider, sourceSpan));
	                }
	                if (isPresent$3(normalizeProvider)) {
	                    targetProviders.push(normalizeProvider);
	                }
	            }
	        });
	    }
	    return targetProviders;
	}
	function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
	    var providersByToken = new CompileTokenMap();
	    directives.forEach(function (directive) {
	        var dirProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: directive.type }), useClass: directive.type });
	        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
	    });
	    // Note: directives need to be able to overwrite providers of a component!
	    var directivesWithComponentFirst = directives.filter(function (dir) {
	        return dir.isComponent;
	    }).concat(directives.filter(function (dir) {
	        return !dir.isComponent;
	    }));
	    directivesWithComponentFirst.forEach(function (directive) {
	        _resolveProviders(_normalizeProviders$1(directive.providers, sourceSpan, targetErrors), ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
	        _resolveProviders(_normalizeProviders$1(directive.viewProviders, sourceSpan, targetErrors), ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
	    });
	    return providersByToken;
	}
	function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
	    providers.forEach(function (provider) {
	        var resolvedProvider = targetProvidersByToken.get(provider.token);
	        if (isPresent$3(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {
	            targetErrors.push(new ProviderError('Mixing multi and non multi provider is not possible for token ' + resolvedProvider.token.name, sourceSpan));
	        }
	        if (isBlank$3(resolvedProvider)) {
	            resolvedProvider = new ProviderAst(provider.token, provider.multi, eager, [provider], providerType, sourceSpan);
	            targetProvidersByToken.add(provider.token, resolvedProvider);
	        } else {
	            if (!provider.multi) {
	                ListWrapper$3.clear(resolvedProvider.providers);
	            }
	            resolvedProvider.providers.push(provider);
	        }
	    });
	}
	function _getViewQueries(component) {
	    var viewQueries = new CompileTokenMap();
	    if (isPresent$3(component.viewQueries)) {
	        component.viewQueries.forEach(function (query) {
	            return _addQueryToTokenMap(viewQueries, query);
	        });
	    }
	    component.type.diDeps.forEach(function (dep) {
	        if (isPresent$3(dep.viewQuery)) {
	            _addQueryToTokenMap(viewQueries, dep.viewQuery);
	        }
	    });
	    return viewQueries;
	}
	function _getContentQueries(directives) {
	    var contentQueries = new CompileTokenMap();
	    directives.forEach(function (directive) {
	        if (isPresent$3(directive.queries)) {
	            directive.queries.forEach(function (query) {
	                return _addQueryToTokenMap(contentQueries, query);
	            });
	        }
	        directive.type.diDeps.forEach(function (dep) {
	            if (isPresent$3(dep.query)) {
	                _addQueryToTokenMap(contentQueries, dep.query);
	            }
	        });
	    });
	    return contentQueries;
	}
	function _addQueryToTokenMap(map, query) {
	    query.selectors.forEach(function (token) {
	        var entry = map.get(token);
	        if (isBlank$3(entry)) {
	            entry = [];
	            map.add(token, entry);
	        }
	        entry.push(query);
	    });
	}

	// Group 1 = "bind-"
	// Group 2 = "var-"
	// Group 3 = "let-"
	// Group 4 = "ref-/#"
	// Group 5 = "on-"
	// Group 6 = "bindon-"
	// Group 7 = "animate-/@"
	// Group 8 = the identifier after "bind-", "var-/#", or "on-"
	// Group 9 = identifier inside [()]
	// Group 10 = identifier inside []
	// Group 11 = identifier inside ()
	var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-)|(let-)|(ref-|#)|(on-)|(bindon-)|(animate-|@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
	var TEMPLATE_ELEMENT = 'template';
	var TEMPLATE_ATTR = 'template';
	var TEMPLATE_ATTR_PREFIX = '*';
	var CLASS_ATTR = 'class';
	var PROPERTY_PARTS_SEPARATOR = '.';
	var ATTRIBUTE_PREFIX = 'attr';
	var CLASS_PREFIX = 'class';
	var STYLE_PREFIX = 'style';
	var TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
	/**
	 * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
	 * parsed templates before compilation is invoked, allowing custom expression syntax
	 * and other advanced transformations.
	 *
	 * This is currently an internal-only feature and not meant for general use.
	 */
	var TEMPLATE_TRANSFORMS = new OpaqueToken('TemplateTransforms');
	var TemplateParseError = function (_ParseError) {
	    inherits(TemplateParseError, _ParseError);

	    function TemplateParseError(message, span, level) {
	        classCallCheck(this, TemplateParseError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(TemplateParseError).call(this, span, message, level));
	    }

	    return TemplateParseError;
	}(ParseError);
	var TemplateParseResult = function TemplateParseResult(templateAst, errors) {
	    classCallCheck(this, TemplateParseResult);

	    this.templateAst = templateAst;
	    this.errors = errors;
	};
	var TemplateParser = function () {
	    function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
	        classCallCheck(this, TemplateParser);

	        this._exprParser = _exprParser;
	        this._schemaRegistry = _schemaRegistry;
	        this._htmlParser = _htmlParser;
	        this._console = _console;
	        this.transforms = transforms;
	    }

	    createClass(TemplateParser, [{
	        key: 'parse',
	        value: function parse(component, template, directives, pipes, templateUrl) {
	            var result = this.tryParse(component, template, directives, pipes, templateUrl);
	            var warnings = result.errors.filter(function (error) {
	                return error.level === ParseErrorLevel.WARNING;
	            });
	            var errors = result.errors.filter(function (error) {
	                return error.level === ParseErrorLevel.FATAL;
	            });
	            if (warnings.length > 0) {
	                this._console.warn('Template parse warnings:\n' + warnings.join('\n'));
	            }
	            if (errors.length > 0) {
	                var errorString = errors.join('\n');
	                throw new BaseException$3('Template parse errors:\n' + errorString);
	            }
	            return result.templateAst;
	        }
	    }, {
	        key: 'tryParse',
	        value: function tryParse(component, template, directives, pipes, templateUrl) {
	            var htmlAstWithErrors = this._htmlParser.parse(template, templateUrl);
	            var errors = htmlAstWithErrors.errors;
	            var result;
	            if (htmlAstWithErrors.rootNodes.length > 0) {
	                var uniqDirectives = removeDuplicates(directives);
	                var uniqPipes = removeDuplicates(pipes);
	                var providerViewContext = new ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
	                var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, uniqPipes, this._exprParser, this._schemaRegistry);
	                result = htmlVisitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
	                errors = errors.concat(parseVisitor.errors).concat(providerViewContext.errors);
	            } else {
	                result = [];
	            }
	            this._assertNoReferenceDuplicationOnTemplate(result, errors);
	            if (errors.length > 0) {
	                return new TemplateParseResult(result, errors);
	            }
	            if (isPresent$3(this.transforms)) {
	                this.transforms.forEach(function (transform) {
	                    result = templateVisitAll(transform, result);
	                });
	            }
	            return new TemplateParseResult(result, errors);
	        }
	        /** @internal */

	    }, {
	        key: '_assertNoReferenceDuplicationOnTemplate',
	        value: function _assertNoReferenceDuplicationOnTemplate(result, errors) {
	            var existingReferences = [];
	            result.filter(function (element) {
	                return !!element.references;
	            }).forEach(function (element) {
	                return element.references.forEach(function (reference /** TODO #???? */) {
	                    var name = reference.name;
	                    if (existingReferences.indexOf(name) < 0) {
	                        existingReferences.push(name);
	                    } else {
	                        var error = new TemplateParseError('Reference "#' + name + '" is defined several times', reference.sourceSpan, ParseErrorLevel.FATAL);
	                        errors.push(error);
	                    }
	                });
	            });
	        }
	    }]);
	    return TemplateParser;
	}();
	/** @nocollapse */
	TemplateParser.decorators = [{ type: Injectable }];
	/** @nocollapse */
	TemplateParser.ctorParameters = [{ type: Parser }, { type: ElementSchemaRegistry }, { type: HtmlParser }, { type: Console$1 }, { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [TEMPLATE_TRANSFORMS] }] }];

	var TemplateParseVisitor = function () {
	    function TemplateParseVisitor(providerViewContext, directives, pipes, _exprParser, _schemaRegistry) {
	        var _this2 = this;

	        classCallCheck(this, TemplateParseVisitor);

	        this.providerViewContext = providerViewContext;
	        this._exprParser = _exprParser;
	        this._schemaRegistry = _schemaRegistry;
	        this.errors = [];
	        this.directivesIndex = new Map();
	        this.ngContentCount = 0;
	        this.selectorMatcher = new SelectorMatcher();
	        var tempMeta = providerViewContext.component.template;
	        if (isPresent$3(tempMeta) && isPresent$3(tempMeta.interpolation)) {
	            this._interpolationConfig = {
	                start: tempMeta.interpolation[0],
	                end: tempMeta.interpolation[1]
	            };
	        }
	        ListWrapper$3.forEachWithIndex(directives, function (directive, index) {
	            var selector = CssSelector.parse(directive.selector);
	            _this2.selectorMatcher.addSelectables(selector, directive);
	            _this2.directivesIndex.set(directive, index);
	        });
	        this.pipesByName = new Map();
	        pipes.forEach(function (pipe) {
	            return _this2.pipesByName.set(pipe.name, pipe);
	        });
	    }

	    createClass(TemplateParseVisitor, [{
	        key: '_reportError',
	        value: function _reportError(message, sourceSpan) {
	            var level = arguments.length <= 2 || arguments[2] === undefined ? ParseErrorLevel.FATAL : arguments[2];

	            this.errors.push(new TemplateParseError(message, sourceSpan, level));
	        }
	    }, {
	        key: '_parseInterpolation',
	        value: function _parseInterpolation(value, sourceSpan) {
	            var sourceInfo = sourceSpan.start.toString();
	            try {
	                var ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);
	                this._checkPipes(ast, sourceSpan);
	                if (isPresent$3(ast) && ast.ast.expressions.length > MAX_INTERPOLATION_VALUES$1) {
	                    throw new BaseException$3('Only support at most ' + MAX_INTERPOLATION_VALUES$1 + ' interpolation values!');
	                }
	                return ast;
	            } catch (e) {
	                this._reportError('' + e, sourceSpan);
	                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	            }
	        }
	    }, {
	        key: '_parseAction',
	        value: function _parseAction(value, sourceSpan) {
	            var sourceInfo = sourceSpan.start.toString();
	            try {
	                var ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
	                this._checkPipes(ast, sourceSpan);
	                return ast;
	            } catch (e) {
	                this._reportError('' + e, sourceSpan);
	                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	            }
	        }
	    }, {
	        key: '_parseBinding',
	        value: function _parseBinding(value, sourceSpan) {
	            var sourceInfo = sourceSpan.start.toString();
	            try {
	                var ast = this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
	                this._checkPipes(ast, sourceSpan);
	                return ast;
	            } catch (e) {
	                this._reportError('' + e, sourceSpan);
	                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
	            }
	        }
	    }, {
	        key: '_parseTemplateBindings',
	        value: function _parseTemplateBindings(value, sourceSpan) {
	            var _this3 = this;

	            var sourceInfo = sourceSpan.start.toString();
	            try {
	                var bindingsResult = this._exprParser.parseTemplateBindings(value, sourceInfo);
	                bindingsResult.templateBindings.forEach(function (binding) {
	                    if (isPresent$3(binding.expression)) {
	                        _this3._checkPipes(binding.expression, sourceSpan);
	                    }
	                });
	                bindingsResult.warnings.forEach(function (warning) {
	                    _this3._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
	                });
	                return bindingsResult.templateBindings;
	            } catch (e) {
	                this._reportError('' + e, sourceSpan);
	                return [];
	            }
	        }
	    }, {
	        key: '_checkPipes',
	        value: function _checkPipes(ast, sourceSpan) {
	            var _this4 = this;

	            if (isPresent$3(ast)) {
	                var collector = new PipeCollector();
	                ast.visit(collector);
	                collector.pipes.forEach(function (pipeName) {
	                    if (!_this4.pipesByName.has(pipeName)) {
	                        _this4._reportError('The pipe \'' + pipeName + '\' could not be found', sourceSpan);
	                    }
	                });
	            }
	        }
	    }, {
	        key: 'visitExpansion',
	        value: function visitExpansion(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitExpansionCase',
	        value: function visitExpansionCase(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, parent) {
	            var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
	            var expr = this._parseInterpolation(ast.value, ast.sourceSpan);
	            if (isPresent$3(expr)) {
	                return new BoundTextAst(expr, ngContentIndex, ast.sourceSpan);
	            } else {
	                return new TextAst(ast.value, ngContentIndex, ast.sourceSpan);
	            }
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, contex) {
	            return new AttrAst(ast.name, ast.value, ast.sourceSpan);
	        }
	    }, {
	        key: 'visitComment',
	        value: function visitComment(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitElement',
	        value: function visitElement(element, parent) {
	            var _this5 = this;

	            var nodeName = element.name;
	            var preparsedElement = preparseElement(element);
	            if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE) {
	                // Skipping <script> for security reasons
	                // Skipping <style> as we already processed them
	                // in the StyleCompiler
	                return null;
	            }
	            if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
	                // Skipping stylesheets with either relative urls or package scheme as we already processed
	                // them in the StyleCompiler
	                return null;
	            }
	            var matchableAttrs = [];
	            var elementOrDirectiveProps = [];
	            var elementOrDirectiveRefs = [];
	            var elementVars = [];
	            var animationProps = [];
	            var events = [];
	            var templateElementOrDirectiveProps = [];
	            var templateMatchableAttrs = [];
	            var templateElementVars = [];
	            var hasInlineTemplates = false;
	            var attrs = [];
	            var lcElName = splitNsName(nodeName.toLowerCase())[1];
	            var isTemplateElement = lcElName == TEMPLATE_ELEMENT;
	            element.attrs.forEach(function (attr) {
	                var hasBinding = _this5._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, animationProps, events, elementOrDirectiveRefs, elementVars);
	                var hasTemplateBinding = _this5._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
	                if (hasTemplateBinding && hasInlineTemplates) {
	                    _this5._reportError('Can\'t have multiple template bindings on one element. Use only one attribute named \'template\' or prefixed with *', attr.sourceSpan);
	                }
	                if (!hasBinding && !hasTemplateBinding) {
	                    // don't include the bindings as attributes as well in the AST
	                    attrs.push(_this5.visitAttr(attr, null));
	                    matchableAttrs.push([attr.name, attr.value]);
	                }
	                if (hasTemplateBinding) {
	                    hasInlineTemplates = true;
	                }
	            });
	            var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
	            var directiveMetas = this._parseDirectives(this.selectorMatcher, elementCssSelector);
	            var references = [];
	            var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
	            var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts).concat(animationProps);
	            var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
	            var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
	            var children = htmlVisitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
	            providerContext.afterElement();
	            // Override the actual selector when the `ngProjectAs` attribute is provided
	            var projectionSelector = isPresent$3(preparsedElement.projectAs) ? CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;
	            var ngContentIndex = parent.findNgContentIndex(projectionSelector);
	            var parsedElement;
	            if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
	                if (isPresent$3(element.children) && element.children.length > 0) {
	                    this._reportError('<ng-content> element cannot have content. <ng-content> must be immediately followed by </ng-content>', element.sourceSpan);
	                }
	                parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
	            } else if (isTemplateElement) {
	                this._assertAllEventsPublishedByDirectives(directiveAsts, events);
	                this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
	                parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
	            } else {
	                this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
	                var _ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
	                parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : _ngContentIndex, element.sourceSpan);
	            }
	            if (hasInlineTemplates) {
	                var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
	                var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector);
	                var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
	                var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
	                this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
	                var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
	                templateProviderContext.afterElement();
	                parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
	            }
	            return parsedElement;
	        }
	    }, {
	        key: '_parseInlineTemplateBinding',
	        value: function _parseInlineTemplateBinding(attr, targetMatchableAttrs, targetProps, targetVars) {
	            var templateBindingsSource = null;
	            if (attr.name == TEMPLATE_ATTR) {
	                templateBindingsSource = attr.value;
	            } else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
	                var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length); // remove the star
	                templateBindingsSource = attr.value.length == 0 ? key : key + ' ' + attr.value;
	            }
	            if (isPresent$3(templateBindingsSource)) {
	                var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceSpan);
	                for (var i = 0; i < bindings.length; i++) {
	                    var binding = bindings[i];
	                    if (binding.keyIsVar) {
	                        targetVars.push(new VariableAst(binding.key, binding.name, attr.sourceSpan));
	                    } else if (isPresent$3(binding.expression)) {
	                        this._parsePropertyAst(binding.key, binding.expression, attr.sourceSpan, targetMatchableAttrs, targetProps);
	                    } else {
	                        targetMatchableAttrs.push([binding.key, '']);
	                        this._parseLiteralAttr(binding.key, null, attr.sourceSpan, targetProps);
	                    }
	                }
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: '_parseAttr',
	        value: function _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetAnimationProps, targetEvents, targetRefs, targetVars) {
	            var attrName = this._normalizeAttributeName(attr.name);
	            var attrValue = attr.value;
	            var bindParts = RegExpWrapper$3.firstMatch(BIND_NAME_REGEXP, attrName);
	            var hasBinding = false;
	            if (isPresent$3(bindParts)) {
	                hasBinding = true;
	                if (isPresent$3(bindParts[1])) {
	                    this._parseProperty(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
	                } else if (isPresent$3(bindParts[2])) {
	                    var identifier = bindParts[8];
	                    if (isTemplateElement) {
	                        this._reportError('"var-" on <template> elements is deprecated. Use "let-" instead!', attr.sourceSpan, ParseErrorLevel.WARNING);
	                        this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
	                    } else {
	                        this._reportError('"var-" on non <template> elements is deprecated. Use "ref-" instead!', attr.sourceSpan, ParseErrorLevel.WARNING);
	                        this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
	                    }
	                } else if (isPresent$3(bindParts[3])) {
	                    if (isTemplateElement) {
	                        var identifier = bindParts[8];
	                        this._parseVariable(identifier, attrValue, attr.sourceSpan, targetVars);
	                    } else {
	                        this._reportError('"let-" is only supported on template elements.', attr.sourceSpan);
	                    }
	                } else if (isPresent$3(bindParts[4])) {
	                    var identifier = bindParts[8];
	                    this._parseReference(identifier, attrValue, attr.sourceSpan, targetRefs);
	                } else if (isPresent$3(bindParts[5])) {
	                    this._parseEvent(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
	                } else if (isPresent$3(bindParts[6])) {
	                    this._parseProperty(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
	                    this._parseAssignmentEvent(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
	                } else if (isPresent$3(bindParts[7])) {
	                    this._parseAnimation(bindParts[8], attrValue, attr.sourceSpan, targetMatchableAttrs, targetAnimationProps);
	                } else if (isPresent$3(bindParts[9])) {
	                    this._parseProperty(bindParts[9], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
	                    this._parseAssignmentEvent(bindParts[9], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
	                } else if (isPresent$3(bindParts[10])) {
	                    this._parseProperty(bindParts[10], attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
	                } else if (isPresent$3(bindParts[11])) {
	                    this._parseEvent(bindParts[11], attrValue, attr.sourceSpan, targetMatchableAttrs, targetEvents);
	                }
	            } else {
	                hasBinding = this._parsePropertyInterpolation(attrName, attrValue, attr.sourceSpan, targetMatchableAttrs, targetProps);
	            }
	            if (!hasBinding) {
	                this._parseLiteralAttr(attrName, attrValue, attr.sourceSpan, targetProps);
	            }
	            return hasBinding;
	        }
	    }, {
	        key: '_normalizeAttributeName',
	        value: function _normalizeAttributeName(attrName) {
	            return attrName.toLowerCase().startsWith('data-') ? attrName.substring(5) : attrName;
	        }
	    }, {
	        key: '_parseVariable',
	        value: function _parseVariable(identifier, value, sourceSpan, targetVars) {
	            if (identifier.indexOf('-') > -1) {
	                this._reportError('"-" is not allowed in variable names', sourceSpan);
	            }
	            targetVars.push(new VariableAst(identifier, value, sourceSpan));
	        }
	    }, {
	        key: '_parseReference',
	        value: function _parseReference(identifier, value, sourceSpan, targetRefs) {
	            if (identifier.indexOf('-') > -1) {
	                this._reportError('"-" is not allowed in reference names', sourceSpan);
	            }
	            targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
	        }
	    }, {
	        key: '_parseProperty',
	        value: function _parseProperty(name, expression, sourceSpan, targetMatchableAttrs, targetProps) {
	            this._parsePropertyAst(name, this._parseBinding(expression, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
	        }
	    }, {
	        key: '_parseAnimation',
	        value: function _parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetAnimationProps) {
	            // This will occur when a @trigger is not paired with an expression.
	            // For animations it is valid to not have an expression since */void
	            // states will be applied by angular when the element is attached/detached
	            if (!isPresent$3(expression) || expression.length == 0) {
	                expression = 'null';
	            }
	            var ast = this._parseBinding(expression, sourceSpan);
	            targetMatchableAttrs.push([name, ast.source]);
	            targetAnimationProps.push(new BoundElementPropertyAst(name, PropertyBindingType.Animation, SecurityContext$2.NONE, ast, null, sourceSpan));
	        }
	    }, {
	        key: '_parsePropertyInterpolation',
	        value: function _parsePropertyInterpolation(name, value, sourceSpan, targetMatchableAttrs, targetProps) {
	            var expr = this._parseInterpolation(value, sourceSpan);
	            if (isPresent$3(expr)) {
	                this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: '_parsePropertyAst',
	        value: function _parsePropertyAst(name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
	            targetMatchableAttrs.push([name, ast.source]);
	            targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceSpan));
	        }
	    }, {
	        key: '_parseAssignmentEvent',
	        value: function _parseAssignmentEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	            this._parseEvent(name + 'Change', expression + '=$event', sourceSpan, targetMatchableAttrs, targetEvents);
	        }
	    }, {
	        key: '_parseEvent',
	        value: function _parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
	            // long format: 'target: eventName'
	            var parts = splitAtColon(name, [null, name]);
	            var target = parts[0];
	            var eventName = parts[1];
	            var ast = this._parseAction(expression, sourceSpan);
	            targetMatchableAttrs.push([name, ast.source]);
	            targetEvents.push(new BoundEventAst(eventName, target, ast, sourceSpan));
	            // Don't detect directives for event names for now,
	            // so don't add the event name to the matchableAttrs
	        }
	    }, {
	        key: '_parseLiteralAttr',
	        value: function _parseLiteralAttr(name, value, sourceSpan, targetProps) {
	            targetProps.push(new BoundElementOrDirectiveProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), true, sourceSpan));
	        }
	    }, {
	        key: '_parseDirectives',
	        value: function _parseDirectives(selectorMatcher, elementCssSelector) {
	            var _this6 = this;

	            // Need to sort the directives so that we get consistent results throughout,
	            // as selectorMatcher uses Maps inside.
	            // Also dedupe directives as they might match more than one time!
	            var directives = ListWrapper$3.createFixedSize(this.directivesIndex.size);
	            selectorMatcher.match(elementCssSelector, function (selector, directive) {
	                directives[_this6.directivesIndex.get(directive)] = directive;
	            });
	            return directives.filter(function (dir) {
	                return isPresent$3(dir);
	            });
	        }
	    }, {
	        key: '_createDirectiveAsts',
	        value: function _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, sourceSpan, targetReferences) {
	            var _this7 = this;

	            var matchedReferences = new Set();
	            var component = null;
	            var directiveAsts = directives.map(function (directive) {
	                if (directive.isComponent) {
	                    component = directive;
	                }
	                var hostProperties = [];
	                var hostEvents = [];
	                var directiveProperties = [];
	                _this7._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceSpan, hostProperties);
	                _this7._createDirectiveHostEventAsts(directive.hostListeners, sourceSpan, hostEvents);
	                _this7._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
	                elementOrDirectiveRefs.forEach(function (elOrDirRef) {
	                    if (elOrDirRef.value.length === 0 && directive.isComponent || directive.exportAs == elOrDirRef.value) {
	                        targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));
	                        matchedReferences.add(elOrDirRef.name);
	                    }
	                });
	                return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
	            });
	            elementOrDirectiveRefs.forEach(function (elOrDirRef) {
	                if (elOrDirRef.value.length > 0) {
	                    if (!SetWrapper$3.has(matchedReferences, elOrDirRef.name)) {
	                        _this7._reportError('There is no directive with "exportAs" set to "' + elOrDirRef.value + '"', elOrDirRef.sourceSpan);
	                    }
	                    ;
	                } else if (isBlank$3(component)) {
	                    var refToken = null;
	                    if (isTemplateElement) {
	                        refToken = identifierToken(Identifiers.TemplateRef);
	                    }
	                    targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
	                }
	            }); // fix syntax highlighting issue: `
	            return directiveAsts;
	        }
	    }, {
	        key: '_createDirectiveHostPropertyAsts',
	        value: function _createDirectiveHostPropertyAsts(elementName, hostProps, sourceSpan, targetPropertyAsts) {
	            var _this8 = this;

	            if (isPresent$3(hostProps)) {
	                StringMapWrapper$3.forEach(hostProps, function (expression, propName) {
	                    var exprAst = _this8._parseBinding(expression, sourceSpan);
	                    targetPropertyAsts.push(_this8._createElementPropertyAst(elementName, propName, exprAst, sourceSpan));
	                });
	            }
	        }
	    }, {
	        key: '_createDirectiveHostEventAsts',
	        value: function _createDirectiveHostEventAsts(hostListeners, sourceSpan, targetEventAsts) {
	            var _this9 = this;

	            if (isPresent$3(hostListeners)) {
	                StringMapWrapper$3.forEach(hostListeners, function (expression, propName) {
	                    _this9._parseEvent(propName, expression, sourceSpan, [], targetEventAsts);
	                });
	            }
	        }
	    }, {
	        key: '_createDirectivePropertyAsts',
	        value: function _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps) {
	            if (isPresent$3(directiveProperties)) {
	                var boundPropsByName = new Map();
	                boundProps.forEach(function (boundProp) {
	                    var prevValue = boundPropsByName.get(boundProp.name);
	                    if (isBlank$3(prevValue) || prevValue.isLiteral) {
	                        // give [a]="b" a higher precedence than a="b" on the same element
	                        boundPropsByName.set(boundProp.name, boundProp);
	                    }
	                });
	                StringMapWrapper$3.forEach(directiveProperties, function (elProp, dirProp) {
	                    var boundProp = boundPropsByName.get(elProp);
	                    // Bindings are optional, so this binding only needs to be set up if an expression is given.
	                    if (isPresent$3(boundProp)) {
	                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
	                    }
	                });
	            }
	        }
	    }, {
	        key: '_createElementPropertyAsts',
	        value: function _createElementPropertyAsts(elementName, props, directives) {
	            var _this10 = this;

	            var boundElementProps = [];
	            var boundDirectivePropsIndex = new Map();
	            directives.forEach(function (directive) {
	                directive.inputs.forEach(function (prop) {
	                    boundDirectivePropsIndex.set(prop.templateName, prop);
	                });
	            });
	            props.forEach(function (prop) {
	                if (!prop.isLiteral && isBlank$3(boundDirectivePropsIndex.get(prop.name))) {
	                    boundElementProps.push(_this10._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceSpan));
	                }
	            });
	            return boundElementProps;
	        }
	    }, {
	        key: '_createElementPropertyAst',
	        value: function _createElementPropertyAst(elementName, name, ast, sourceSpan) {
	            var unit = null;
	            var bindingType;
	            var boundPropertyName;
	            var parts = name.split(PROPERTY_PARTS_SEPARATOR);
	            var securityContext = void 0;
	            if (parts.length === 1) {
	                boundPropertyName = this._schemaRegistry.getMappedPropName(parts[0]);
	                securityContext = this._schemaRegistry.securityContext(elementName, boundPropertyName);
	                bindingType = PropertyBindingType.Property;
	                if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName)) {
	                    this._reportError('Can\'t bind to \'' + boundPropertyName + '\' since it isn\'t a known native property', sourceSpan);
	                }
	            } else {
	                if (parts[0] == ATTRIBUTE_PREFIX) {
	                    boundPropertyName = parts[1];
	                    if (boundPropertyName.toLowerCase().startsWith('on')) {
	                        this._reportError('Binding to event attribute \'' + boundPropertyName + '\' is disallowed ' + ('for security reasons, please use (' + boundPropertyName.slice(2) + ')=...'), sourceSpan);
	                    }
	                    // NB: For security purposes, use the mapped property name, not the attribute name.
	                    securityContext = this._schemaRegistry.securityContext(elementName, this._schemaRegistry.getMappedPropName(boundPropertyName));
	                    var nsSeparatorIdx = boundPropertyName.indexOf(':');
	                    if (nsSeparatorIdx > -1) {
	                        var ns = boundPropertyName.substring(0, nsSeparatorIdx);
	                        var _name = boundPropertyName.substring(nsSeparatorIdx + 1);
	                        boundPropertyName = mergeNsAndName(ns, _name);
	                    }
	                    bindingType = PropertyBindingType.Attribute;
	                } else if (parts[0] == CLASS_PREFIX) {
	                    boundPropertyName = parts[1];
	                    bindingType = PropertyBindingType.Class;
	                    securityContext = SecurityContext$2.NONE;
	                } else if (parts[0] == STYLE_PREFIX) {
	                    unit = parts.length > 2 ? parts[2] : null;
	                    boundPropertyName = parts[1];
	                    bindingType = PropertyBindingType.Style;
	                    securityContext = SecurityContext$2.STYLE;
	                } else {
	                    this._reportError('Invalid property name \'' + name + '\'', sourceSpan);
	                    bindingType = null;
	                    securityContext = null;
	                }
	            }
	            return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContext, ast, unit, sourceSpan);
	        }
	    }, {
	        key: '_findComponentDirectiveNames',
	        value: function _findComponentDirectiveNames(directives) {
	            var componentTypeNames = [];
	            directives.forEach(function (directive) {
	                var typeName = directive.directive.type.name;
	                if (directive.directive.isComponent) {
	                    componentTypeNames.push(typeName);
	                }
	            });
	            return componentTypeNames;
	        }
	    }, {
	        key: '_assertOnlyOneComponent',
	        value: function _assertOnlyOneComponent(directives, sourceSpan) {
	            var componentTypeNames = this._findComponentDirectiveNames(directives);
	            if (componentTypeNames.length > 1) {
	                this._reportError('More than one component: ' + componentTypeNames.join(','), sourceSpan);
	            }
	        }
	    }, {
	        key: '_assertNoComponentsNorElementBindingsOnTemplate',
	        value: function _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {
	            var _this11 = this;

	            var componentTypeNames = this._findComponentDirectiveNames(directives);
	            if (componentTypeNames.length > 0) {
	                this._reportError('Components on an embedded template: ' + componentTypeNames.join(','), sourceSpan);
	            }
	            elementProps.forEach(function (prop) {
	                _this11._reportError('Property binding ' + prop.name + ' not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the "directives" section.', sourceSpan);
	            });
	        }
	    }, {
	        key: '_assertAllEventsPublishedByDirectives',
	        value: function _assertAllEventsPublishedByDirectives(directives, events) {
	            var _this12 = this;

	            var allDirectiveEvents = new Set();
	            directives.forEach(function (directive) {
	                StringMapWrapper$3.forEach(directive.directive.outputs, function (eventName) {
	                    allDirectiveEvents.add(eventName);
	                });
	            });
	            events.forEach(function (event) {
	                if (isPresent$3(event.target) || !SetWrapper$3.has(allDirectiveEvents, event.name)) {
	                    _this12._reportError('Event binding ' + event.fullName + ' not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the "directives" section.', event.sourceSpan);
	                }
	            });
	        }
	    }]);
	    return TemplateParseVisitor;
	}();

	var NonBindableVisitor = function () {
	    function NonBindableVisitor() {
	        classCallCheck(this, NonBindableVisitor);
	    }

	    createClass(NonBindableVisitor, [{
	        key: 'visitElement',
	        value: function visitElement(ast, parent) {
	            var preparsedElement = preparseElement(ast);
	            if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
	                // Skipping <script> for security reasons
	                // Skipping <style> and stylesheets as we already processed them
	                // in the StyleCompiler
	                return null;
	            }
	            var attrNameAndValues = ast.attrs.map(function (attrAst) {
	                return [attrAst.name, attrAst.value];
	            });
	            var selector = createElementCssSelector(ast.name, attrNameAndValues);
	            var ngContentIndex = parent.findNgContentIndex(selector);
	            var children = htmlVisitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
	            return new ElementAst(ast.name, htmlVisitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan);
	        }
	    }, {
	        key: 'visitComment',
	        value: function visitComment(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, context) {
	            return new AttrAst(ast.name, ast.value, ast.sourceSpan);
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, parent) {
	            var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
	            return new TextAst(ast.value, ngContentIndex, ast.sourceSpan);
	        }
	    }, {
	        key: 'visitExpansion',
	        value: function visitExpansion(ast, context) {
	            return ast;
	        }
	    }, {
	        key: 'visitExpansionCase',
	        value: function visitExpansionCase(ast, context) {
	            return ast;
	        }
	    }]);
	    return NonBindableVisitor;
	}();

	var BoundElementOrDirectiveProperty = function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceSpan) {
	    classCallCheck(this, BoundElementOrDirectiveProperty);

	    this.name = name;
	    this.expression = expression;
	    this.isLiteral = isLiteral;
	    this.sourceSpan = sourceSpan;
	};

	var ElementOrDirectiveRef = function ElementOrDirectiveRef(name, value, sourceSpan) {
	    classCallCheck(this, ElementOrDirectiveRef);

	    this.name = name;
	    this.value = value;
	    this.sourceSpan = sourceSpan;
	};

	function splitClasses(classAttrValue) {
	    return StringWrapper$3.split(classAttrValue.trim(), /\s+/g);
	}

	var ElementContext = function () {
	    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
	        classCallCheck(this, ElementContext);

	        this.isTemplateElement = isTemplateElement;
	        this._ngContentIndexMatcher = _ngContentIndexMatcher;
	        this._wildcardNgContentIndex = _wildcardNgContentIndex;
	        this.providerContext = providerContext;
	    }

	    createClass(ElementContext, [{
	        key: 'findNgContentIndex',
	        value: function findNgContentIndex(selector) {
	            var ngContentIndices = [];
	            this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) {
	                ngContentIndices.push(ngContentIndex);
	            });
	            ListWrapper$3.sort(ngContentIndices);
	            if (isPresent$3(this._wildcardNgContentIndex)) {
	                ngContentIndices.push(this._wildcardNgContentIndex);
	            }
	            return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
	        }
	    }], [{
	        key: 'create',
	        value: function create(isTemplateElement, directives, providerContext) {
	            var matcher = new SelectorMatcher();
	            var wildcardNgContentIndex = null;
	            var component = directives.find(function (directive) {
	                return directive.directive.isComponent;
	            });
	            if (isPresent$3(component)) {
	                var ngContentSelectors = component.directive.template.ngContentSelectors;
	                for (var i = 0; i < ngContentSelectors.length; i++) {
	                    var selector = ngContentSelectors[i];
	                    if (StringWrapper$3.equals(selector, '*')) {
	                        wildcardNgContentIndex = i;
	                    } else {
	                        matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
	                    }
	                }
	            }
	            return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
	        }
	    }]);
	    return ElementContext;
	}();

	function createElementCssSelector(elementName, matchableAttrs) {
	    var cssSelector = new CssSelector();
	    var elNameNoNs = splitNsName(elementName)[1];
	    cssSelector.setElement(elNameNoNs);
	    for (var i = 0; i < matchableAttrs.length; i++) {
	        var attrName = matchableAttrs[i][0];
	        var attrNameNoNs = splitNsName(attrName)[1];
	        var attrValue = matchableAttrs[i][1];
	        cssSelector.addAttribute(attrNameNoNs, attrValue);
	        if (attrName.toLowerCase() == CLASS_ATTR) {
	            var classes = splitClasses(attrValue);
	            classes.forEach(function (className) {
	                return cssSelector.addClassName(className);
	            });
	        }
	    }
	    return cssSelector;
	}
	var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
	var NON_BINDABLE_VISITOR = new NonBindableVisitor();
	var PipeCollector = function (_RecursiveAstVisitor) {
	    inherits(PipeCollector, _RecursiveAstVisitor);

	    function PipeCollector() {
	        var _Object$getPrototypeO;

	        classCallCheck(this, PipeCollector);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        var _this13 = possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(PipeCollector)).call.apply(_Object$getPrototypeO, [this].concat(args)));

	        _this13.pipes = new Set();
	        return _this13;
	    }

	    createClass(PipeCollector, [{
	        key: 'visitPipe',
	        value: function visitPipe(ast, context) {
	            this.pipes.add(ast.name);
	            ast.exp.visit(this);
	            this.visitAll(ast.args, context);
	            return null;
	        }
	    }]);
	    return PipeCollector;
	}(RecursiveAstVisitor);
	function removeDuplicates(items) {
	    var res = [];
	    items.forEach(function (item) {
	        var hasMatch = res.filter(function (r) {
	            return r.type.name == item.type.name && r.type.moduleUrl == item.type.moduleUrl && r.type.runtime == item.type.runtime;
	        }).length > 0;
	        if (!hasMatch) {
	            res.push(item);
	        }
	    });
	    return res;
	}

	var CompilerConfig = function () {
	    function CompilerConfig() {
	        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var _ref$renderTypes = _ref.renderTypes;
	        var renderTypes = _ref$renderTypes === undefined ? new DefaultRenderTypes() : _ref$renderTypes;
	        var _ref$defaultEncapsula = _ref.defaultEncapsulation;
	        var defaultEncapsulation = _ref$defaultEncapsula === undefined ? ViewEncapsulation.Emulated : _ref$defaultEncapsula;
	        var genDebugInfo = _ref.genDebugInfo;
	        var logBindingUpdate = _ref.logBindingUpdate;
	        var _ref$useJit = _ref.useJit;
	        var useJit = _ref$useJit === undefined ? true : _ref$useJit;
	        var _ref$platformDirectiv = _ref.platformDirectives;
	        var platformDirectives = _ref$platformDirectiv === undefined ? [] : _ref$platformDirectiv;
	        var _ref$platformPipes = _ref.platformPipes;
	        var platformPipes = _ref$platformPipes === undefined ? [] : _ref$platformPipes;
	        classCallCheck(this, CompilerConfig);

	        this.renderTypes = renderTypes;
	        this.defaultEncapsulation = defaultEncapsulation;
	        this._genDebugInfo = genDebugInfo;
	        this._logBindingUpdate = logBindingUpdate;
	        this.useJit = useJit;
	        this.platformDirectives = platformDirectives;
	        this.platformPipes = platformPipes;
	    }

	    createClass(CompilerConfig, [{
	        key: 'genDebugInfo',
	        get: function get() {
	            return this._genDebugInfo === void 0 ? isDevMode() : this._genDebugInfo;
	        }
	    }, {
	        key: 'logBindingUpdate',
	        get: function get() {
	            return this._logBindingUpdate === void 0 ? isDevMode() : this._logBindingUpdate;
	        }
	    }]);
	    return CompilerConfig;
	}();
	/**
	 * Types used for the renderer.
	 * Can be replaced to specialize the generated output to a specific renderer
	 * to help tree shaking.
	 */
	var RenderTypes = function () {
	    function RenderTypes() {
	        classCallCheck(this, RenderTypes);
	    }

	    createClass(RenderTypes, [{
	        key: 'renderer',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'renderText',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'renderElement',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'renderComment',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'renderNode',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'renderEvent',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }]);
	    return RenderTypes;
	}();
	var DefaultRenderTypes = function DefaultRenderTypes() {
	    classCallCheck(this, DefaultRenderTypes);

	    this.renderer = Identifiers.Renderer;
	    this.renderText = null;
	    this.renderElement = null;
	    this.renderComment = null;
	    this.renderNode = null;
	    this.renderEvent = null;
	};

	//// Types
	var TypeModifier;
	(function (TypeModifier) {
	    TypeModifier[TypeModifier["Const"] = 0] = "Const";
	})(TypeModifier || (TypeModifier = {}));
	var Type$4 = function () {
	    function Type() {
	        var modifiers = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        classCallCheck(this, Type);

	        this.modifiers = modifiers;
	        if (isBlank$3(modifiers)) {
	            this.modifiers = [];
	        }
	    }

	    createClass(Type, [{
	        key: "hasModifier",
	        value: function hasModifier(modifier) {
	            return this.modifiers.indexOf(modifier) !== -1;
	        }
	    }]);
	    return Type;
	}();
	var BuiltinTypeName;
	(function (BuiltinTypeName) {
	    BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
	    BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
	    BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
	    BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
	    BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
	    BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
	})(BuiltinTypeName || (BuiltinTypeName = {}));
	var BuiltinType = function (_Type) {
	    inherits(BuiltinType, _Type);

	    function BuiltinType(name) {
	        var modifiers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, BuiltinType);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BuiltinType).call(this, modifiers));

	        _this.name = name;
	        return _this;
	    }

	    createClass(BuiltinType, [{
	        key: "visitType",
	        value: function visitType(visitor, context) {
	            return visitor.visitBuiltintType(this, context);
	        }
	    }]);
	    return BuiltinType;
	}(Type$4);
	var ExternalType = function (_Type2) {
	    inherits(ExternalType, _Type2);

	    function ExternalType(value) {
	        var typeParams = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var modifiers = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, ExternalType);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(ExternalType).call(this, modifiers));

	        _this2.value = value;
	        _this2.typeParams = typeParams;
	        return _this2;
	    }

	    createClass(ExternalType, [{
	        key: "visitType",
	        value: function visitType(visitor, context) {
	            return visitor.visitExternalType(this, context);
	        }
	    }]);
	    return ExternalType;
	}(Type$4);
	var ArrayType = function (_Type3) {
	    inherits(ArrayType, _Type3);

	    function ArrayType(of) {
	        var modifiers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, ArrayType);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(ArrayType).call(this, modifiers));

	        _this3.of = of;
	        return _this3;
	    }

	    createClass(ArrayType, [{
	        key: "visitType",
	        value: function visitType(visitor, context) {
	            return visitor.visitArrayType(this, context);
	        }
	    }]);
	    return ArrayType;
	}(Type$4);
	var MapType = function (_Type4) {
	    inherits(MapType, _Type4);

	    function MapType(valueType) {
	        var modifiers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, MapType);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(MapType).call(this, modifiers));

	        _this4.valueType = valueType;
	        return _this4;
	    }

	    createClass(MapType, [{
	        key: "visitType",
	        value: function visitType(visitor, context) {
	            return visitor.visitMapType(this, context);
	        }
	    }]);
	    return MapType;
	}(Type$4);
	var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
	var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
	var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
	var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
	var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
	var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
	///// Expressions
	var BinaryOperator;
	(function (BinaryOperator) {
	    BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
	    BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
	    BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
	    BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
	    BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
	    BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
	    BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
	    BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
	    BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
	    BinaryOperator[BinaryOperator["And"] = 9] = "And";
	    BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
	    BinaryOperator[BinaryOperator["Lower"] = 11] = "Lower";
	    BinaryOperator[BinaryOperator["LowerEquals"] = 12] = "LowerEquals";
	    BinaryOperator[BinaryOperator["Bigger"] = 13] = "Bigger";
	    BinaryOperator[BinaryOperator["BiggerEquals"] = 14] = "BiggerEquals";
	})(BinaryOperator || (BinaryOperator = {}));
	var Expression = function () {
	    function Expression(type) {
	        classCallCheck(this, Expression);

	        this.type = type;
	    }

	    createClass(Expression, [{
	        key: "prop",
	        value: function prop(name) {
	            return new ReadPropExpr(this, name);
	        }
	    }, {
	        key: "key",
	        value: function key(index) {
	            var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return new ReadKeyExpr(this, index, type);
	        }
	    }, {
	        key: "callMethod",
	        value: function callMethod(name, params) {
	            return new InvokeMethodExpr(this, name, params);
	        }
	    }, {
	        key: "callFn",
	        value: function callFn(params) {
	            return new InvokeFunctionExpr(this, params);
	        }
	    }, {
	        key: "instantiate",
	        value: function instantiate(params) {
	            var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return new InstantiateExpr(this, params, type);
	        }
	    }, {
	        key: "conditional",
	        value: function conditional(trueCase) {
	            var falseCase = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return new ConditionalExpr(this, trueCase, falseCase);
	        }
	    }, {
	        key: "equals",
	        value: function equals(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
	        }
	    }, {
	        key: "notEquals",
	        value: function notEquals(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
	        }
	    }, {
	        key: "identical",
	        value: function identical(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
	        }
	    }, {
	        key: "notIdentical",
	        value: function notIdentical(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
	        }
	    }, {
	        key: "minus",
	        value: function minus(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
	        }
	    }, {
	        key: "plus",
	        value: function plus(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
	        }
	    }, {
	        key: "divide",
	        value: function divide(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
	        }
	    }, {
	        key: "multiply",
	        value: function multiply(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
	        }
	    }, {
	        key: "modulo",
	        value: function modulo(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
	        }
	    }, {
	        key: "and",
	        value: function and(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
	        }
	    }, {
	        key: "or",
	        value: function or(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
	        }
	    }, {
	        key: "lower",
	        value: function lower(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
	        }
	    }, {
	        key: "lowerEquals",
	        value: function lowerEquals(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
	        }
	    }, {
	        key: "bigger",
	        value: function bigger(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
	        }
	    }, {
	        key: "biggerEquals",
	        value: function biggerEquals(rhs) {
	            return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
	        }
	    }, {
	        key: "isBlank",
	        value: function isBlank() {
	            // Note: We use equals by purpose here to compare to null and undefined in JS.
	            return this.equals(NULL_EXPR);
	        }
	    }, {
	        key: "cast",
	        value: function cast(type) {
	            return new CastExpr(this, type);
	        }
	    }, {
	        key: "toStmt",
	        value: function toStmt() {
	            return new ExpressionStatement(this);
	        }
	    }]);
	    return Expression;
	}();
	var BuiltinVar;
	(function (BuiltinVar) {
	    BuiltinVar[BuiltinVar["This"] = 0] = "This";
	    BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
	    BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
	    BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
	})(BuiltinVar || (BuiltinVar = {}));
	var ReadVarExpr = function (_Expression) {
	    inherits(ReadVarExpr, _Expression);

	    function ReadVarExpr(name) {
	        var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, ReadVarExpr);

	        var _this5 = possibleConstructorReturn(this, Object.getPrototypeOf(ReadVarExpr).call(this, type));

	        if (isString$3(name)) {
	            _this5.name = name;
	            _this5.builtin = null;
	        } else {
	            _this5.name = null;
	            _this5.builtin = name;
	        }
	        return _this5;
	    }

	    createClass(ReadVarExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitReadVarExpr(this, context);
	        }
	    }, {
	        key: "set",
	        value: function set(value) {
	            return new WriteVarExpr(this.name, value);
	        }
	    }]);
	    return ReadVarExpr;
	}(Expression);
	var WriteVarExpr = function (_Expression2) {
	    inherits(WriteVarExpr, _Expression2);

	    function WriteVarExpr(name, value) {
	        var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, WriteVarExpr);

	        var _this6 = possibleConstructorReturn(this, Object.getPrototypeOf(WriteVarExpr).call(this, isPresent$3(type) ? type : value.type));

	        _this6.name = name;
	        _this6.value = value;
	        return _this6;
	    }

	    createClass(WriteVarExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitWriteVarExpr(this, context);
	        }
	    }, {
	        key: "toDeclStmt",
	        value: function toDeclStmt() {
	            var type = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	            var modifiers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return new DeclareVarStmt(this.name, this.value, type, modifiers);
	        }
	    }]);
	    return WriteVarExpr;
	}(Expression);
	var WriteKeyExpr = function (_Expression3) {
	    inherits(WriteKeyExpr, _Expression3);

	    function WriteKeyExpr(receiver, index, value) {
	        var type = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, WriteKeyExpr);

	        var _this7 = possibleConstructorReturn(this, Object.getPrototypeOf(WriteKeyExpr).call(this, isPresent$3(type) ? type : value.type));

	        _this7.receiver = receiver;
	        _this7.index = index;
	        _this7.value = value;
	        return _this7;
	    }

	    createClass(WriteKeyExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitWriteKeyExpr(this, context);
	        }
	    }]);
	    return WriteKeyExpr;
	}(Expression);
	var WritePropExpr = function (_Expression4) {
	    inherits(WritePropExpr, _Expression4);

	    function WritePropExpr(receiver, name, value) {
	        var type = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, WritePropExpr);

	        var _this8 = possibleConstructorReturn(this, Object.getPrototypeOf(WritePropExpr).call(this, isPresent$3(type) ? type : value.type));

	        _this8.receiver = receiver;
	        _this8.name = name;
	        _this8.value = value;
	        return _this8;
	    }

	    createClass(WritePropExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitWritePropExpr(this, context);
	        }
	    }]);
	    return WritePropExpr;
	}(Expression);
	var BuiltinMethod;
	(function (BuiltinMethod) {
	    BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
	    BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
	    BuiltinMethod[BuiltinMethod["bind"] = 2] = "bind";
	})(BuiltinMethod || (BuiltinMethod = {}));
	var InvokeMethodExpr = function (_Expression5) {
	    inherits(InvokeMethodExpr, _Expression5);

	    function InvokeMethodExpr(receiver, method, args) {
	        var type = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, InvokeMethodExpr);

	        var _this9 = possibleConstructorReturn(this, Object.getPrototypeOf(InvokeMethodExpr).call(this, type));

	        _this9.receiver = receiver;
	        _this9.args = args;
	        if (isString$3(method)) {
	            _this9.name = method;
	            _this9.builtin = null;
	        } else {
	            _this9.name = null;
	            _this9.builtin = method;
	        }
	        return _this9;
	    }

	    createClass(InvokeMethodExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitInvokeMethodExpr(this, context);
	        }
	    }]);
	    return InvokeMethodExpr;
	}(Expression);
	var InvokeFunctionExpr = function (_Expression6) {
	    inherits(InvokeFunctionExpr, _Expression6);

	    function InvokeFunctionExpr(fn, args) {
	        var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, InvokeFunctionExpr);

	        var _this10 = possibleConstructorReturn(this, Object.getPrototypeOf(InvokeFunctionExpr).call(this, type));

	        _this10.fn = fn;
	        _this10.args = args;
	        return _this10;
	    }

	    createClass(InvokeFunctionExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitInvokeFunctionExpr(this, context);
	        }
	    }]);
	    return InvokeFunctionExpr;
	}(Expression);
	var InstantiateExpr = function (_Expression7) {
	    inherits(InstantiateExpr, _Expression7);

	    function InstantiateExpr(classExpr, args, type) {
	        classCallCheck(this, InstantiateExpr);

	        var _this11 = possibleConstructorReturn(this, Object.getPrototypeOf(InstantiateExpr).call(this, type));

	        _this11.classExpr = classExpr;
	        _this11.args = args;
	        return _this11;
	    }

	    createClass(InstantiateExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitInstantiateExpr(this, context);
	        }
	    }]);
	    return InstantiateExpr;
	}(Expression);
	var LiteralExpr = function (_Expression8) {
	    inherits(LiteralExpr, _Expression8);

	    function LiteralExpr(value) {
	        var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, LiteralExpr);

	        var _this12 = possibleConstructorReturn(this, Object.getPrototypeOf(LiteralExpr).call(this, type));

	        _this12.value = value;
	        return _this12;
	    }

	    createClass(LiteralExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitLiteralExpr(this, context);
	        }
	    }]);
	    return LiteralExpr;
	}(Expression);
	var ExternalExpr = function (_Expression9) {
	    inherits(ExternalExpr, _Expression9);

	    function ExternalExpr(value) {
	        var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var typeParams = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, ExternalExpr);

	        var _this13 = possibleConstructorReturn(this, Object.getPrototypeOf(ExternalExpr).call(this, type));

	        _this13.value = value;
	        _this13.typeParams = typeParams;
	        return _this13;
	    }

	    createClass(ExternalExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitExternalExpr(this, context);
	        }
	    }]);
	    return ExternalExpr;
	}(Expression);
	var ConditionalExpr = function (_Expression10) {
	    inherits(ConditionalExpr, _Expression10);

	    function ConditionalExpr(condition, trueCase) {
	        var falseCase = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        var type = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, ConditionalExpr);

	        var _this14 = possibleConstructorReturn(this, Object.getPrototypeOf(ConditionalExpr).call(this, isPresent$3(type) ? type : trueCase.type));

	        _this14.condition = condition;
	        _this14.falseCase = falseCase;
	        _this14.trueCase = trueCase;
	        return _this14;
	    }

	    createClass(ConditionalExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitConditionalExpr(this, context);
	        }
	    }]);
	    return ConditionalExpr;
	}(Expression);
	var NotExpr = function (_Expression11) {
	    inherits(NotExpr, _Expression11);

	    function NotExpr(condition) {
	        classCallCheck(this, NotExpr);

	        var _this15 = possibleConstructorReturn(this, Object.getPrototypeOf(NotExpr).call(this, BOOL_TYPE));

	        _this15.condition = condition;
	        return _this15;
	    }

	    createClass(NotExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitNotExpr(this, context);
	        }
	    }]);
	    return NotExpr;
	}(Expression);
	var CastExpr = function (_Expression12) {
	    inherits(CastExpr, _Expression12);

	    function CastExpr(value, type) {
	        classCallCheck(this, CastExpr);

	        var _this16 = possibleConstructorReturn(this, Object.getPrototypeOf(CastExpr).call(this, type));

	        _this16.value = value;
	        return _this16;
	    }

	    createClass(CastExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitCastExpr(this, context);
	        }
	    }]);
	    return CastExpr;
	}(Expression);
	var FnParam = function FnParam(name) {
	    var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    classCallCheck(this, FnParam);

	    this.name = name;
	    this.type = type;
	};
	var FunctionExpr = function (_Expression13) {
	    inherits(FunctionExpr, _Expression13);

	    function FunctionExpr(params, statements) {
	        var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, FunctionExpr);

	        var _this17 = possibleConstructorReturn(this, Object.getPrototypeOf(FunctionExpr).call(this, type));

	        _this17.params = params;
	        _this17.statements = statements;
	        return _this17;
	    }

	    createClass(FunctionExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitFunctionExpr(this, context);
	        }
	    }, {
	        key: "toDeclStmt",
	        value: function toDeclStmt(name) {
	            var modifiers = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
	        }
	    }]);
	    return FunctionExpr;
	}(Expression);
	var BinaryOperatorExpr = function (_Expression14) {
	    inherits(BinaryOperatorExpr, _Expression14);

	    function BinaryOperatorExpr(operator, lhs, rhs) {
	        var type = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, BinaryOperatorExpr);

	        var _this18 = possibleConstructorReturn(this, Object.getPrototypeOf(BinaryOperatorExpr).call(this, isPresent$3(type) ? type : lhs.type));

	        _this18.operator = operator;
	        _this18.rhs = rhs;
	        _this18.lhs = lhs;
	        return _this18;
	    }

	    createClass(BinaryOperatorExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitBinaryOperatorExpr(this, context);
	        }
	    }]);
	    return BinaryOperatorExpr;
	}(Expression);
	var ReadPropExpr = function (_Expression15) {
	    inherits(ReadPropExpr, _Expression15);

	    function ReadPropExpr(receiver, name) {
	        var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, ReadPropExpr);

	        var _this19 = possibleConstructorReturn(this, Object.getPrototypeOf(ReadPropExpr).call(this, type));

	        _this19.receiver = receiver;
	        _this19.name = name;
	        return _this19;
	    }

	    createClass(ReadPropExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitReadPropExpr(this, context);
	        }
	    }, {
	        key: "set",
	        value: function set(value) {
	            return new WritePropExpr(this.receiver, this.name, value);
	        }
	    }]);
	    return ReadPropExpr;
	}(Expression);
	var ReadKeyExpr = function (_Expression16) {
	    inherits(ReadKeyExpr, _Expression16);

	    function ReadKeyExpr(receiver, index) {
	        var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, ReadKeyExpr);

	        var _this20 = possibleConstructorReturn(this, Object.getPrototypeOf(ReadKeyExpr).call(this, type));

	        _this20.receiver = receiver;
	        _this20.index = index;
	        return _this20;
	    }

	    createClass(ReadKeyExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitReadKeyExpr(this, context);
	        }
	    }, {
	        key: "set",
	        value: function set(value) {
	            return new WriteKeyExpr(this.receiver, this.index, value);
	        }
	    }]);
	    return ReadKeyExpr;
	}(Expression);
	var LiteralArrayExpr = function (_Expression17) {
	    inherits(LiteralArrayExpr, _Expression17);

	    function LiteralArrayExpr(entries) {
	        var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, LiteralArrayExpr);

	        var _this21 = possibleConstructorReturn(this, Object.getPrototypeOf(LiteralArrayExpr).call(this, type));

	        _this21.entries = entries;
	        return _this21;
	    }

	    createClass(LiteralArrayExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitLiteralArrayExpr(this, context);
	        }
	    }]);
	    return LiteralArrayExpr;
	}(Expression);
	var LiteralMapExpr = function (_Expression18) {
	    inherits(LiteralMapExpr, _Expression18);

	    function LiteralMapExpr(entries) {
	        var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        classCallCheck(this, LiteralMapExpr);

	        var _this22 = possibleConstructorReturn(this, Object.getPrototypeOf(LiteralMapExpr).call(this, type));

	        _this22.entries = entries;
	        _this22.valueType = null;
	        if (isPresent$3(type)) {
	            _this22.valueType = type.valueType;
	        }
	        return _this22;
	    }

	    createClass(LiteralMapExpr, [{
	        key: "visitExpression",
	        value: function visitExpression(visitor, context) {
	            return visitor.visitLiteralMapExpr(this, context);
	        }
	    }]);
	    return LiteralMapExpr;
	}(Expression);
	var THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
	var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
	var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
	var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
	var NULL_EXPR = new LiteralExpr(null, null);
	//// Statements
	var StmtModifier;
	(function (StmtModifier) {
	    StmtModifier[StmtModifier["Final"] = 0] = "Final";
	    StmtModifier[StmtModifier["Private"] = 1] = "Private";
	})(StmtModifier || (StmtModifier = {}));
	var Statement = function () {
	    function Statement() {
	        var modifiers = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        classCallCheck(this, Statement);

	        this.modifiers = modifiers;
	        if (isBlank$3(modifiers)) {
	            this.modifiers = [];
	        }
	    }

	    createClass(Statement, [{
	        key: "hasModifier",
	        value: function hasModifier(modifier) {
	            return this.modifiers.indexOf(modifier) !== -1;
	        }
	    }]);
	    return Statement;
	}();
	var DeclareVarStmt = function (_Statement) {
	    inherits(DeclareVarStmt, _Statement);

	    function DeclareVarStmt(name, value) {
	        var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        var modifiers = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, DeclareVarStmt);

	        var _this23 = possibleConstructorReturn(this, Object.getPrototypeOf(DeclareVarStmt).call(this, modifiers));

	        _this23.name = name;
	        _this23.value = value;
	        _this23.type = isPresent$3(type) ? type : value.type;
	        return _this23;
	    }

	    createClass(DeclareVarStmt, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitDeclareVarStmt(this, context);
	        }
	    }]);
	    return DeclareVarStmt;
	}(Statement);
	var DeclareFunctionStmt = function (_Statement2) {
	    inherits(DeclareFunctionStmt, _Statement2);

	    function DeclareFunctionStmt(name, params, statements) {
	        var type = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        var modifiers = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
	        classCallCheck(this, DeclareFunctionStmt);

	        var _this24 = possibleConstructorReturn(this, Object.getPrototypeOf(DeclareFunctionStmt).call(this, modifiers));

	        _this24.name = name;
	        _this24.params = params;
	        _this24.statements = statements;
	        _this24.type = type;
	        return _this24;
	    }

	    createClass(DeclareFunctionStmt, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitDeclareFunctionStmt(this, context);
	        }
	    }]);
	    return DeclareFunctionStmt;
	}(Statement);
	var ExpressionStatement = function (_Statement3) {
	    inherits(ExpressionStatement, _Statement3);

	    function ExpressionStatement(expr) {
	        classCallCheck(this, ExpressionStatement);

	        var _this25 = possibleConstructorReturn(this, Object.getPrototypeOf(ExpressionStatement).call(this));

	        _this25.expr = expr;
	        return _this25;
	    }

	    createClass(ExpressionStatement, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitExpressionStmt(this, context);
	        }
	    }]);
	    return ExpressionStatement;
	}(Statement);
	var ReturnStatement = function (_Statement4) {
	    inherits(ReturnStatement, _Statement4);

	    function ReturnStatement(value) {
	        classCallCheck(this, ReturnStatement);

	        var _this26 = possibleConstructorReturn(this, Object.getPrototypeOf(ReturnStatement).call(this));

	        _this26.value = value;
	        return _this26;
	    }

	    createClass(ReturnStatement, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitReturnStmt(this, context);
	        }
	    }]);
	    return ReturnStatement;
	}(Statement);
	var AbstractClassPart = function () {
	    function AbstractClassPart() {
	        var type = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var modifiers = arguments[1];
	        classCallCheck(this, AbstractClassPart);

	        this.type = type;
	        this.modifiers = modifiers;
	        if (isBlank$3(modifiers)) {
	            this.modifiers = [];
	        }
	    }

	    createClass(AbstractClassPart, [{
	        key: "hasModifier",
	        value: function hasModifier(modifier) {
	            return this.modifiers.indexOf(modifier) !== -1;
	        }
	    }]);
	    return AbstractClassPart;
	}();
	var ClassField = function (_AbstractClassPart) {
	    inherits(ClassField, _AbstractClassPart);

	    function ClassField(name) {
	        var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var modifiers = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, ClassField);

	        var _this27 = possibleConstructorReturn(this, Object.getPrototypeOf(ClassField).call(this, type, modifiers));

	        _this27.name = name;
	        return _this27;
	    }

	    return ClassField;
	}(AbstractClassPart);
	var ClassMethod = function (_AbstractClassPart2) {
	    inherits(ClassMethod, _AbstractClassPart2);

	    function ClassMethod(name, params, body) {
	        var type = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        var modifiers = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];
	        classCallCheck(this, ClassMethod);

	        var _this28 = possibleConstructorReturn(this, Object.getPrototypeOf(ClassMethod).call(this, type, modifiers));

	        _this28.name = name;
	        _this28.params = params;
	        _this28.body = body;
	        return _this28;
	    }

	    return ClassMethod;
	}(AbstractClassPart);
	var ClassGetter = function (_AbstractClassPart3) {
	    inherits(ClassGetter, _AbstractClassPart3);

	    function ClassGetter(name, body) {
	        var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        var modifiers = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, ClassGetter);

	        var _this29 = possibleConstructorReturn(this, Object.getPrototypeOf(ClassGetter).call(this, type, modifiers));

	        _this29.name = name;
	        _this29.body = body;
	        return _this29;
	    }

	    return ClassGetter;
	}(AbstractClassPart);
	var ClassStmt = function (_Statement5) {
	    inherits(ClassStmt, _Statement5);

	    function ClassStmt(name, parent, fields, getters, constructorMethod, methods) {
	        var modifiers = arguments.length <= 6 || arguments[6] === undefined ? null : arguments[6];
	        classCallCheck(this, ClassStmt);

	        var _this30 = possibleConstructorReturn(this, Object.getPrototypeOf(ClassStmt).call(this, modifiers));

	        _this30.name = name;
	        _this30.parent = parent;
	        _this30.fields = fields;
	        _this30.getters = getters;
	        _this30.constructorMethod = constructorMethod;
	        _this30.methods = methods;
	        return _this30;
	    }

	    createClass(ClassStmt, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitDeclareClassStmt(this, context);
	        }
	    }]);
	    return ClassStmt;
	}(Statement);
	var IfStmt = function (_Statement6) {
	    inherits(IfStmt, _Statement6);

	    function IfStmt(condition, trueCase) {
	        var falseCase = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
	        classCallCheck(this, IfStmt);

	        var _this31 = possibleConstructorReturn(this, Object.getPrototypeOf(IfStmt).call(this));

	        _this31.condition = condition;
	        _this31.trueCase = trueCase;
	        _this31.falseCase = falseCase;
	        return _this31;
	    }

	    createClass(IfStmt, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitIfStmt(this, context);
	        }
	    }]);
	    return IfStmt;
	}(Statement);
	var CommentStmt = function (_Statement7) {
	    inherits(CommentStmt, _Statement7);

	    function CommentStmt(comment) {
	        classCallCheck(this, CommentStmt);

	        var _this32 = possibleConstructorReturn(this, Object.getPrototypeOf(CommentStmt).call(this));

	        _this32.comment = comment;
	        return _this32;
	    }

	    createClass(CommentStmt, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitCommentStmt(this, context);
	        }
	    }]);
	    return CommentStmt;
	}(Statement);
	var TryCatchStmt = function (_Statement8) {
	    inherits(TryCatchStmt, _Statement8);

	    function TryCatchStmt(bodyStmts, catchStmts) {
	        classCallCheck(this, TryCatchStmt);

	        var _this33 = possibleConstructorReturn(this, Object.getPrototypeOf(TryCatchStmt).call(this));

	        _this33.bodyStmts = bodyStmts;
	        _this33.catchStmts = catchStmts;
	        return _this33;
	    }

	    createClass(TryCatchStmt, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitTryCatchStmt(this, context);
	        }
	    }]);
	    return TryCatchStmt;
	}(Statement);
	var ThrowStmt = function (_Statement9) {
	    inherits(ThrowStmt, _Statement9);

	    function ThrowStmt(error) {
	        classCallCheck(this, ThrowStmt);

	        var _this34 = possibleConstructorReturn(this, Object.getPrototypeOf(ThrowStmt).call(this));

	        _this34.error = error;
	        return _this34;
	    }

	    createClass(ThrowStmt, [{
	        key: "visitStatement",
	        value: function visitStatement(visitor, context) {
	            return visitor.visitThrowStmt(this, context);
	        }
	    }]);
	    return ThrowStmt;
	}(Statement);
	var ExpressionTransformer = function () {
	    function ExpressionTransformer() {
	        classCallCheck(this, ExpressionTransformer);
	    }

	    createClass(ExpressionTransformer, [{
	        key: "visitReadVarExpr",
	        value: function visitReadVarExpr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: "visitWriteVarExpr",
	        value: function visitWriteVarExpr(expr, context) {
	            return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
	        }
	    }, {
	        key: "visitWriteKeyExpr",
	        value: function visitWriteKeyExpr(expr, context) {
	            return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
	        }
	    }, {
	        key: "visitWritePropExpr",
	        value: function visitWritePropExpr(expr, context) {
	            return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
	        }
	    }, {
	        key: "visitInvokeMethodExpr",
	        value: function visitInvokeMethodExpr(ast, context) {
	            var method = isPresent$3(ast.builtin) ? ast.builtin : ast.name;
	            return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
	        }
	    }, {
	        key: "visitInvokeFunctionExpr",
	        value: function visitInvokeFunctionExpr(ast, context) {
	            return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
	        }
	    }, {
	        key: "visitInstantiateExpr",
	        value: function visitInstantiateExpr(ast, context) {
	            return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
	        }
	    }, {
	        key: "visitLiteralExpr",
	        value: function visitLiteralExpr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: "visitExternalExpr",
	        value: function visitExternalExpr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: "visitConditionalExpr",
	        value: function visitConditionalExpr(ast, context) {
	            return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
	        }
	    }, {
	        key: "visitNotExpr",
	        value: function visitNotExpr(ast, context) {
	            return new NotExpr(ast.condition.visitExpression(this, context));
	        }
	    }, {
	        key: "visitCastExpr",
	        value: function visitCastExpr(ast, context) {
	            return new CastExpr(ast.value.visitExpression(this, context), context);
	        }
	    }, {
	        key: "visitFunctionExpr",
	        value: function visitFunctionExpr(ast, context) {
	            // Don't descend into nested functions
	            return ast;
	        }
	    }, {
	        key: "visitBinaryOperatorExpr",
	        value: function visitBinaryOperatorExpr(ast, context) {
	            return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
	        }
	    }, {
	        key: "visitReadPropExpr",
	        value: function visitReadPropExpr(ast, context) {
	            return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
	        }
	    }, {
	        key: "visitReadKeyExpr",
	        value: function visitReadKeyExpr(ast, context) {
	            return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
	        }
	    }, {
	        key: "visitLiteralArrayExpr",
	        value: function visitLiteralArrayExpr(ast, context) {
	            return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
	        }
	    }, {
	        key: "visitLiteralMapExpr",
	        value: function visitLiteralMapExpr(ast, context) {
	            var _this35 = this;

	            return new LiteralMapExpr(ast.entries.map(function (entry) {
	                return [entry[0], entry[1].visitExpression(_this35, context)];
	            }));
	        }
	    }, {
	        key: "visitAllExpressions",
	        value: function visitAllExpressions(exprs, context) {
	            var _this36 = this;

	            return exprs.map(function (expr) {
	                return expr.visitExpression(_this36, context);
	            });
	        }
	    }, {
	        key: "visitDeclareVarStmt",
	        value: function visitDeclareVarStmt(stmt, context) {
	            return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
	        }
	    }, {
	        key: "visitDeclareFunctionStmt",
	        value: function visitDeclareFunctionStmt(stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        }
	    }, {
	        key: "visitExpressionStmt",
	        value: function visitExpressionStmt(stmt, context) {
	            return new ExpressionStatement(stmt.expr.visitExpression(this, context));
	        }
	    }, {
	        key: "visitReturnStmt",
	        value: function visitReturnStmt(stmt, context) {
	            return new ReturnStatement(stmt.value.visitExpression(this, context));
	        }
	    }, {
	        key: "visitDeclareClassStmt",
	        value: function visitDeclareClassStmt(stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        }
	    }, {
	        key: "visitIfStmt",
	        value: function visitIfStmt(stmt, context) {
	            return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
	        }
	    }, {
	        key: "visitTryCatchStmt",
	        value: function visitTryCatchStmt(stmt, context) {
	            return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
	        }
	    }, {
	        key: "visitThrowStmt",
	        value: function visitThrowStmt(stmt, context) {
	            return new ThrowStmt(stmt.error.visitExpression(this, context));
	        }
	    }, {
	        key: "visitCommentStmt",
	        value: function visitCommentStmt(stmt, context) {
	            return stmt;
	        }
	    }, {
	        key: "visitAllStatements",
	        value: function visitAllStatements(stmts, context) {
	            var _this37 = this;

	            return stmts.map(function (stmt) {
	                return stmt.visitStatement(_this37, context);
	            });
	        }
	    }]);
	    return ExpressionTransformer;
	}();
	var RecursiveExpressionVisitor = function () {
	    function RecursiveExpressionVisitor() {
	        classCallCheck(this, RecursiveExpressionVisitor);
	    }

	    createClass(RecursiveExpressionVisitor, [{
	        key: "visitReadVarExpr",
	        value: function visitReadVarExpr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: "visitWriteVarExpr",
	        value: function visitWriteVarExpr(expr, context) {
	            expr.value.visitExpression(this, context);
	            return expr;
	        }
	    }, {
	        key: "visitWriteKeyExpr",
	        value: function visitWriteKeyExpr(expr, context) {
	            expr.receiver.visitExpression(this, context);
	            expr.index.visitExpression(this, context);
	            expr.value.visitExpression(this, context);
	            return expr;
	        }
	    }, {
	        key: "visitWritePropExpr",
	        value: function visitWritePropExpr(expr, context) {
	            expr.receiver.visitExpression(this, context);
	            expr.value.visitExpression(this, context);
	            return expr;
	        }
	    }, {
	        key: "visitInvokeMethodExpr",
	        value: function visitInvokeMethodExpr(ast, context) {
	            ast.receiver.visitExpression(this, context);
	            this.visitAllExpressions(ast.args, context);
	            return ast;
	        }
	    }, {
	        key: "visitInvokeFunctionExpr",
	        value: function visitInvokeFunctionExpr(ast, context) {
	            ast.fn.visitExpression(this, context);
	            this.visitAllExpressions(ast.args, context);
	            return ast;
	        }
	    }, {
	        key: "visitInstantiateExpr",
	        value: function visitInstantiateExpr(ast, context) {
	            ast.classExpr.visitExpression(this, context);
	            this.visitAllExpressions(ast.args, context);
	            return ast;
	        }
	    }, {
	        key: "visitLiteralExpr",
	        value: function visitLiteralExpr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: "visitExternalExpr",
	        value: function visitExternalExpr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: "visitConditionalExpr",
	        value: function visitConditionalExpr(ast, context) {
	            ast.condition.visitExpression(this, context);
	            ast.trueCase.visitExpression(this, context);
	            ast.falseCase.visitExpression(this, context);
	            return ast;
	        }
	    }, {
	        key: "visitNotExpr",
	        value: function visitNotExpr(ast, context) {
	            ast.condition.visitExpression(this, context);
	            return ast;
	        }
	    }, {
	        key: "visitCastExpr",
	        value: function visitCastExpr(ast, context) {
	            ast.value.visitExpression(this, context);
	            return ast;
	        }
	    }, {
	        key: "visitFunctionExpr",
	        value: function visitFunctionExpr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: "visitBinaryOperatorExpr",
	        value: function visitBinaryOperatorExpr(ast, context) {
	            ast.lhs.visitExpression(this, context);
	            ast.rhs.visitExpression(this, context);
	            return ast;
	        }
	    }, {
	        key: "visitReadPropExpr",
	        value: function visitReadPropExpr(ast, context) {
	            ast.receiver.visitExpression(this, context);
	            return ast;
	        }
	    }, {
	        key: "visitReadKeyExpr",
	        value: function visitReadKeyExpr(ast, context) {
	            ast.receiver.visitExpression(this, context);
	            ast.index.visitExpression(this, context);
	            return ast;
	        }
	    }, {
	        key: "visitLiteralArrayExpr",
	        value: function visitLiteralArrayExpr(ast, context) {
	            this.visitAllExpressions(ast.entries, context);
	            return ast;
	        }
	    }, {
	        key: "visitLiteralMapExpr",
	        value: function visitLiteralMapExpr(ast, context) {
	            var _this38 = this;

	            ast.entries.forEach(function (entry) {
	                return entry[1].visitExpression(_this38, context);
	            });
	            return ast;
	        }
	    }, {
	        key: "visitAllExpressions",
	        value: function visitAllExpressions(exprs, context) {
	            var _this39 = this;

	            exprs.forEach(function (expr) {
	                return expr.visitExpression(_this39, context);
	            });
	        }
	    }, {
	        key: "visitDeclareVarStmt",
	        value: function visitDeclareVarStmt(stmt, context) {
	            stmt.value.visitExpression(this, context);
	            return stmt;
	        }
	    }, {
	        key: "visitDeclareFunctionStmt",
	        value: function visitDeclareFunctionStmt(stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        }
	    }, {
	        key: "visitExpressionStmt",
	        value: function visitExpressionStmt(stmt, context) {
	            stmt.expr.visitExpression(this, context);
	            return stmt;
	        }
	    }, {
	        key: "visitReturnStmt",
	        value: function visitReturnStmt(stmt, context) {
	            stmt.value.visitExpression(this, context);
	            return stmt;
	        }
	    }, {
	        key: "visitDeclareClassStmt",
	        value: function visitDeclareClassStmt(stmt, context) {
	            // Don't descend into nested functions
	            return stmt;
	        }
	    }, {
	        key: "visitIfStmt",
	        value: function visitIfStmt(stmt, context) {
	            stmt.condition.visitExpression(this, context);
	            this.visitAllStatements(stmt.trueCase, context);
	            this.visitAllStatements(stmt.falseCase, context);
	            return stmt;
	        }
	    }, {
	        key: "visitTryCatchStmt",
	        value: function visitTryCatchStmt(stmt, context) {
	            this.visitAllStatements(stmt.bodyStmts, context);
	            this.visitAllStatements(stmt.catchStmts, context);
	            return stmt;
	        }
	    }, {
	        key: "visitThrowStmt",
	        value: function visitThrowStmt(stmt, context) {
	            stmt.error.visitExpression(this, context);
	            return stmt;
	        }
	    }, {
	        key: "visitCommentStmt",
	        value: function visitCommentStmt(stmt, context) {
	            return stmt;
	        }
	    }, {
	        key: "visitAllStatements",
	        value: function visitAllStatements(stmts, context) {
	            var _this40 = this;

	            stmts.forEach(function (stmt) {
	                return stmt.visitStatement(_this40, context);
	            });
	        }
	    }]);
	    return RecursiveExpressionVisitor;
	}();
	function replaceVarInExpression(varName, newValue, expression) {
	    var transformer = new _ReplaceVariableTransformer(varName, newValue);
	    return expression.visitExpression(transformer, null);
	}

	var _ReplaceVariableTransformer = function (_ExpressionTransforme) {
	    inherits(_ReplaceVariableTransformer, _ExpressionTransforme);

	    function _ReplaceVariableTransformer(_varName, _newValue) {
	        classCallCheck(this, _ReplaceVariableTransformer);

	        var _this41 = possibleConstructorReturn(this, Object.getPrototypeOf(_ReplaceVariableTransformer).call(this));

	        _this41._varName = _varName;
	        _this41._newValue = _newValue;
	        return _this41;
	    }

	    createClass(_ReplaceVariableTransformer, [{
	        key: "visitReadVarExpr",
	        value: function visitReadVarExpr(ast, context) {
	            return ast.name == this._varName ? this._newValue : ast;
	        }
	    }]);
	    return _ReplaceVariableTransformer;
	}(ExpressionTransformer);

	function findReadVarNames(stmts) {
	    var finder = new _VariableFinder();
	    finder.visitAllStatements(stmts, null);
	    return finder.varNames;
	}

	var _VariableFinder = function (_RecursiveExpressionV) {
	    inherits(_VariableFinder, _RecursiveExpressionV);

	    function _VariableFinder() {
	        var _Object$getPrototypeO;

	        classCallCheck(this, _VariableFinder);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        var _this42 = possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(_VariableFinder)).call.apply(_Object$getPrototypeO, [this].concat(args)));

	        _this42.varNames = new Set();
	        return _this42;
	    }

	    createClass(_VariableFinder, [{
	        key: "visitReadVarExpr",
	        value: function visitReadVarExpr(ast, context) {
	            this.varNames.add(ast.name);
	            return null;
	        }
	    }]);
	    return _VariableFinder;
	}(RecursiveExpressionVisitor);

	function variable(name) {
	    var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return new ReadVarExpr(name, type);
	}
	function importExpr(id) {
	    var typeParams = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return new ExternalExpr(id, null, typeParams);
	}
	function importType(id) {
	    var typeParams = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var typeModifiers = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	    return isPresent$3(id) ? new ExternalType(id, typeParams, typeModifiers) : null;
	}
	function literal(value) {
	    var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return new LiteralExpr(value, type);
	}
	function literalArr(values) {
	    var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return new LiteralArrayExpr(values, type);
	}
	function literalMap(values) {
	    var type = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return new LiteralMapExpr(values, type);
	}
	function not(expr) {
	    return new NotExpr(expr);
	}
	function fn(params, body) {
	    var type = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	    return new FunctionExpr(params, body, type);
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var AnimationAst = function AnimationAst() {
	    classCallCheck(this, AnimationAst);

	    this.startTime = 0;
	    this.playTime = 0;
	};
	var AnimationStateAst = function (_AnimationAst) {
	    inherits(AnimationStateAst, _AnimationAst);

	    function AnimationStateAst() {
	        classCallCheck(this, AnimationStateAst);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStateAst).apply(this, arguments));
	    }

	    return AnimationStateAst;
	}(AnimationAst);
	var AnimationEntryAst = function (_AnimationAst2) {
	    inherits(AnimationEntryAst, _AnimationAst2);

	    function AnimationEntryAst(name, stateDeclarations, stateTransitions) {
	        classCallCheck(this, AnimationEntryAst);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationEntryAst).call(this));

	        _this2.name = name;
	        _this2.stateDeclarations = stateDeclarations;
	        _this2.stateTransitions = stateTransitions;
	        return _this2;
	    }

	    createClass(AnimationEntryAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationEntry(this, context);
	        }
	    }]);
	    return AnimationEntryAst;
	}(AnimationAst);
	var AnimationStateDeclarationAst = function (_AnimationStateAst) {
	    inherits(AnimationStateDeclarationAst, _AnimationStateAst);

	    function AnimationStateDeclarationAst(stateName, styles) {
	        classCallCheck(this, AnimationStateDeclarationAst);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStateDeclarationAst).call(this));

	        _this3.stateName = stateName;
	        _this3.styles = styles;
	        return _this3;
	    }

	    createClass(AnimationStateDeclarationAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationStateDeclaration(this, context);
	        }
	    }]);
	    return AnimationStateDeclarationAst;
	}(AnimationStateAst);
	var AnimationStateTransitionExpression = function AnimationStateTransitionExpression(fromState, toState) {
	    classCallCheck(this, AnimationStateTransitionExpression);

	    this.fromState = fromState;
	    this.toState = toState;
	};
	var AnimationStateTransitionAst = function (_AnimationStateAst2) {
	    inherits(AnimationStateTransitionAst, _AnimationStateAst2);

	    function AnimationStateTransitionAst(stateChanges, animation) {
	        classCallCheck(this, AnimationStateTransitionAst);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStateTransitionAst).call(this));

	        _this4.stateChanges = stateChanges;
	        _this4.animation = animation;
	        return _this4;
	    }

	    createClass(AnimationStateTransitionAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationStateTransition(this, context);
	        }
	    }]);
	    return AnimationStateTransitionAst;
	}(AnimationStateAst);
	var AnimationStepAst = function (_AnimationAst3) {
	    inherits(AnimationStepAst, _AnimationAst3);

	    function AnimationStepAst(startingStyles, keyframes, duration, delay, easing) {
	        classCallCheck(this, AnimationStepAst);

	        var _this5 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStepAst).call(this));

	        _this5.startingStyles = startingStyles;
	        _this5.keyframes = keyframes;
	        _this5.duration = duration;
	        _this5.delay = delay;
	        _this5.easing = easing;
	        return _this5;
	    }

	    createClass(AnimationStepAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationStep(this, context);
	        }
	    }]);
	    return AnimationStepAst;
	}(AnimationAst);
	var AnimationStylesAst = function (_AnimationAst4) {
	    inherits(AnimationStylesAst, _AnimationAst4);

	    function AnimationStylesAst(styles) {
	        classCallCheck(this, AnimationStylesAst);

	        var _this6 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationStylesAst).call(this));

	        _this6.styles = styles;
	        return _this6;
	    }

	    createClass(AnimationStylesAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationStyles(this, context);
	        }
	    }]);
	    return AnimationStylesAst;
	}(AnimationAst);
	var AnimationKeyframeAst = function (_AnimationAst5) {
	    inherits(AnimationKeyframeAst, _AnimationAst5);

	    function AnimationKeyframeAst(offset, styles) {
	        classCallCheck(this, AnimationKeyframeAst);

	        var _this7 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationKeyframeAst).call(this));

	        _this7.offset = offset;
	        _this7.styles = styles;
	        return _this7;
	    }

	    createClass(AnimationKeyframeAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationKeyframe(this, context);
	        }
	    }]);
	    return AnimationKeyframeAst;
	}(AnimationAst);
	var AnimationWithStepsAst = function (_AnimationAst6) {
	    inherits(AnimationWithStepsAst, _AnimationAst6);

	    function AnimationWithStepsAst(steps) {
	        classCallCheck(this, AnimationWithStepsAst);

	        var _this8 = possibleConstructorReturn(this, Object.getPrototypeOf(AnimationWithStepsAst).call(this));

	        _this8.steps = steps;
	        return _this8;
	    }

	    return AnimationWithStepsAst;
	}(AnimationAst);
	var AnimationGroupAst = function (_AnimationWithStepsAs) {
	    inherits(AnimationGroupAst, _AnimationWithStepsAs);

	    function AnimationGroupAst(steps) {
	        classCallCheck(this, AnimationGroupAst);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(AnimationGroupAst).call(this, steps));
	    }

	    createClass(AnimationGroupAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationGroup(this, context);
	        }
	    }]);
	    return AnimationGroupAst;
	}(AnimationWithStepsAst);
	var AnimationSequenceAst = function (_AnimationWithStepsAs2) {
	    inherits(AnimationSequenceAst, _AnimationWithStepsAs2);

	    function AnimationSequenceAst(steps) {
	        classCallCheck(this, AnimationSequenceAst);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(AnimationSequenceAst).call(this, steps));
	    }

	    createClass(AnimationSequenceAst, [{
	        key: "visit",
	        value: function visit(visitor, context) {
	            return visitor.visitAnimationSequence(this, context);
	        }
	    }]);
	    return AnimationSequenceAst;
	}(AnimationWithStepsAst);

	var Math$6 = global$4.Math;
	var NaN$2 = typeof NaN$2 === 'undefined' ? 'undefined' : _typeof(NaN$2);

	var StylesCollectionEntry = function () {
	    function StylesCollectionEntry(time, value) {
	        classCallCheck(this, StylesCollectionEntry);

	        this.time = time;
	        this.value = value;
	    }

	    createClass(StylesCollectionEntry, [{
	        key: 'matches',
	        value: function matches(time, value) {
	            return time == this.time && value == this.value;
	        }
	    }]);
	    return StylesCollectionEntry;
	}();
	var StylesCollection = function () {
	    function StylesCollection() {
	        classCallCheck(this, StylesCollection);

	        this.styles = {};
	    }

	    createClass(StylesCollection, [{
	        key: 'insertAtTime',
	        value: function insertAtTime(property, time, value) {
	            var tuple = new StylesCollectionEntry(time, value);
	            var entries = this.styles[property];
	            if (!isPresent$3(entries)) {
	                entries = this.styles[property] = [];
	            }
	            // insert this at the right stop in the array
	            // this way we can keep it sorted
	            var insertionIndex = 0;
	            for (var i = entries.length - 1; i >= 0; i--) {
	                if (entries[i].time <= time) {
	                    insertionIndex = i + 1;
	                    break;
	                }
	            }
	            ListWrapper$3.insert(entries, insertionIndex, tuple);
	        }
	    }, {
	        key: 'getByIndex',
	        value: function getByIndex(property, index) {
	            var items = this.styles[property];
	            if (isPresent$3(items)) {
	                return index >= items.length ? null : items[index];
	            }
	            return null;
	        }
	    }, {
	        key: 'indexOfAtOrBeforeTime',
	        value: function indexOfAtOrBeforeTime(property, time) {
	            var entries = this.styles[property];
	            if (isPresent$3(entries)) {
	                for (var i = entries.length - 1; i >= 0; i--) {
	                    if (entries[i].time <= time) return i;
	                }
	            }
	            return null;
	        }
	    }]);
	    return StylesCollection;
	}();

	var _INITIAL_KEYFRAME = 0;
	var _TERMINAL_KEYFRAME = 1;
	var _ONE_SECOND = 1000;
	var AnimationParseError = function (_ParseError) {
	    inherits(AnimationParseError, _ParseError);

	    function AnimationParseError(message /** TODO #9100 */) {
	        classCallCheck(this, AnimationParseError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(AnimationParseError).call(this, null, message));
	    }

	    createClass(AnimationParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return '' + this.msg;
	        }
	    }]);
	    return AnimationParseError;
	}(ParseError);
	var ParsedAnimationResult = function ParsedAnimationResult(ast, errors) {
	    classCallCheck(this, ParsedAnimationResult);

	    this.ast = ast;
	    this.errors = errors;
	};
	function parseAnimationEntry(entry) {
	    var errors = [];
	    var stateStyles = {};
	    var transitions = [];
	    var stateDeclarationAsts = [];
	    entry.definitions.forEach(function (def) {
	        if (def instanceof CompileAnimationStateDeclarationMetadata) {
	            _parseAnimationDeclarationStates(def, errors).forEach(function (ast) {
	                stateDeclarationAsts.push(ast);
	                stateStyles[ast.stateName] = ast.styles;
	            });
	        } else {
	            transitions.push(def);
	        }
	    });
	    var stateTransitionAsts = transitions.map(function (transDef) {
	        return _parseAnimationStateTransition(transDef, stateStyles, errors);
	    });
	    var ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);
	    return new ParsedAnimationResult(ast, errors);
	}
	function _parseAnimationDeclarationStates(stateMetadata, errors) {
	    var styleValues = [];
	    stateMetadata.styles.styles.forEach(function (stylesEntry) {
	        // TODO (matsko): change this when we get CSS class integration support
	        if (isStringMap$3(stylesEntry)) {
	            styleValues.push(stylesEntry);
	        } else {
	            errors.push(new AnimationParseError('State based animations cannot contain references to other states'));
	        }
	    });
	    var defStyles = new AnimationStylesAst(styleValues);
	    var states = stateMetadata.stateNameExpr.split(/\s*,\s*/);
	    return states.map(function (state) {
	        return new AnimationStateDeclarationAst(state, defStyles);
	    });
	}
	function _parseAnimationStateTransition(transitionStateMetadata, stateStyles, errors) {
	    var styles = new StylesCollection();
	    var transitionExprs = [];
	    var transitionStates = transitionStateMetadata.stateChangeExpr.split(/\s*,\s*/);
	    transitionStates.forEach(function (expr) {
	        _parseAnimationTransitionExpr(expr, errors).forEach(function (transExpr) {
	            transitionExprs.push(transExpr);
	        });
	    });
	    var entry = _normalizeAnimationEntry(transitionStateMetadata.steps);
	    var animation = _normalizeStyleSteps(entry, stateStyles, errors);
	    var animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);
	    if (errors.length == 0) {
	        _fillAnimationAstStartingKeyframes(animationAst, styles, errors);
	    }
	    var sequenceAst = animationAst instanceof AnimationSequenceAst ? animationAst : new AnimationSequenceAst([animationAst]);
	    return new AnimationStateTransitionAst(transitionExprs, sequenceAst);
	}
	function _parseAnimationTransitionExpr(eventStr, errors) {
	    var expressions = [];
	    var match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
	    if (!isPresent$3(match) || match.length < 4) {
	        errors.push(new AnimationParseError('the provided ' + eventStr + ' is not of a supported format'));
	        return expressions;
	    }
	    var fromState = match[1];
	    var separator = match[2];
	    var toState = match[3];
	    expressions.push(new AnimationStateTransitionExpression(fromState, toState));
	    var isFullAnyStateExpr = fromState == ANY_STATE$1 && toState == ANY_STATE$1;
	    if (separator[0] == '<' && !isFullAnyStateExpr) {
	        expressions.push(new AnimationStateTransitionExpression(toState, fromState));
	    }
	    return expressions;
	}
	function _normalizeAnimationEntry(entry) {
	    return isArray$4(entry) ? new CompileAnimationSequenceMetadata(entry) : entry;
	}
	function _normalizeStyleMetadata(entry, stateStyles, errors) {
	    var normalizedStyles = [];
	    entry.styles.forEach(function (styleEntry) {
	        if (isString$3(styleEntry)) {
	            ListWrapper$3.addAll(normalizedStyles, _resolveStylesFromState(styleEntry, stateStyles, errors));
	        } else {
	            normalizedStyles.push(styleEntry);
	        }
	    });
	    return normalizedStyles;
	}
	function _normalizeStyleSteps(entry, stateStyles, errors) {
	    var steps = _normalizeStyleStepEntry(entry, stateStyles, errors);
	    return new CompileAnimationSequenceMetadata(steps);
	}
	function _mergeAnimationStyles(stylesList, newItem) {
	    if (isStringMap$3(newItem) && stylesList.length > 0) {
	        var lastIndex = stylesList.length - 1;
	        var lastItem = stylesList[lastIndex];
	        if (isStringMap$3(lastItem)) {
	            stylesList[lastIndex] = StringMapWrapper$3.merge(lastItem, newItem);
	            return;
	        }
	    }
	    stylesList.push(newItem);
	}
	function _normalizeStyleStepEntry(entry, stateStyles, errors) {
	    var steps;
	    if (entry instanceof CompileAnimationWithStepsMetadata) {
	        steps = entry.steps;
	    } else {
	        return [entry];
	    }
	    var newSteps = [];
	    var combinedStyles;
	    steps.forEach(function (step) {
	        if (step instanceof CompileAnimationStyleMetadata) {
	            // this occurs when a style step is followed by a previous style step
	            // or when the first style step is run. We want to concatenate all subsequent
	            // style steps together into a single style step such that we have the correct
	            // starting keyframe data to pass into the animation player.
	            if (!isPresent$3(combinedStyles)) {
	                combinedStyles = [];
	            }
	            _normalizeStyleMetadata(step, stateStyles, errors).forEach(function (entry) {
	                _mergeAnimationStyles(combinedStyles, entry);
	            });
	        } else {
	            // it is important that we create a metadata entry of the combined styles
	            // before we go on an process the animate, sequence or group metadata steps.
	            // This will ensure that the AST will have the previous styles painted on
	            // screen before any further animations that use the styles take place.
	            if (isPresent$3(combinedStyles)) {
	                newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
	                combinedStyles = null;
	            }
	            if (step instanceof CompileAnimationAnimateMetadata) {
	                // we do not recurse into CompileAnimationAnimateMetadata since
	                // those style steps are not going to be squashed
	                var animateStyleValue = step.styles;
	                if (animateStyleValue instanceof CompileAnimationStyleMetadata) {
	                    animateStyleValue.styles = _normalizeStyleMetadata(animateStyleValue, stateStyles, errors);
	                } else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {
	                    animateStyleValue.steps.forEach(function (step) {
	                        step.styles = _normalizeStyleMetadata(step, stateStyles, errors);
	                    });
	                }
	            } else if (step instanceof CompileAnimationWithStepsMetadata) {
	                var innerSteps = _normalizeStyleStepEntry(step, stateStyles, errors);
	                step = step instanceof CompileAnimationGroupMetadata ? new CompileAnimationGroupMetadata(innerSteps) : new CompileAnimationSequenceMetadata(innerSteps);
	            }
	            newSteps.push(step);
	        }
	    });
	    // this happens when only styles were animated within the sequence
	    if (isPresent$3(combinedStyles)) {
	        newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
	    }
	    return newSteps;
	}
	function _resolveStylesFromState(stateName, stateStyles, errors) {
	    var styles = [];
	    if (stateName[0] != ':') {
	        errors.push(new AnimationParseError('Animation states via styles must be prefixed with a ":"'));
	    } else {
	        var normalizedStateName = stateName.substring(1);
	        var value = stateStyles[normalizedStateName];
	        if (!isPresent$3(value)) {
	            errors.push(new AnimationParseError('Unable to apply styles due to missing a state: "' + normalizedStateName + '"'));
	        } else {
	            value.styles.forEach(function (stylesEntry) {
	                if (isStringMap$3(stylesEntry)) {
	                    styles.push(stylesEntry);
	                }
	            });
	        }
	    }
	    return styles;
	}

	var _AnimationTimings = function _AnimationTimings(duration, delay, easing) {
	    classCallCheck(this, _AnimationTimings);

	    this.duration = duration;
	    this.delay = delay;
	    this.easing = easing;
	};

	function _parseAnimationKeyframes(keyframeSequence, currentTime, collectedStyles, stateStyles, errors) {
	    var totalEntries = keyframeSequence.steps.length;
	    var totalOffsets = 0;
	    keyframeSequence.steps.forEach(function (step) {
	        return totalOffsets += isPresent$3(step.offset) ? 1 : 0;
	    });
	    if (totalOffsets > 0 && totalOffsets < totalEntries) {
	        errors.push(new AnimationParseError('Not all style() entries contain an offset for the provided keyframe()'));
	        totalOffsets = totalEntries;
	    }
	    var limit = totalEntries - 1;
	    var margin = totalOffsets == 0 ? 1 / limit : 0;
	    var rawKeyframes = [];
	    var index = 0;
	    var doSortKeyframes = false;
	    var lastOffset = 0;
	    keyframeSequence.steps.forEach(function (styleMetadata) {
	        var offset = styleMetadata.offset;
	        var keyframeStyles = {};
	        styleMetadata.styles.forEach(function (entry) {
	            StringMapWrapper$3.forEach(entry, function (value /** TODO #9100 */, prop /** TODO #9100 */) {
	                if (prop != 'offset') {
	                    keyframeStyles[prop] = value;
	                }
	            });
	        });
	        if (isPresent$3(offset)) {
	            doSortKeyframes = doSortKeyframes || offset < lastOffset;
	        } else {
	            offset = index == limit ? _TERMINAL_KEYFRAME : margin * index;
	        }
	        rawKeyframes.push([offset, keyframeStyles]);
	        lastOffset = offset;
	        index++;
	    });
	    if (doSortKeyframes) {
	        ListWrapper$3.sort(rawKeyframes, function (a, b) {
	            return a[0] <= b[0] ? -1 : 1;
	        });
	    }
	    var i;
	    var firstKeyframe = rawKeyframes[0];
	    if (firstKeyframe[0] != _INITIAL_KEYFRAME) {
	        ListWrapper$3.insert(rawKeyframes, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);
	    }
	    var firstKeyframeStyles = firstKeyframe[1];
	    var limit = rawKeyframes.length - 1;
	    var lastKeyframe = rawKeyframes[limit];
	    if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {
	        rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);
	        limit++;
	    }
	    var lastKeyframeStyles = lastKeyframe[1];
	    for (i = 1; i <= limit; i++) {
	        var entry = rawKeyframes[i];
	        var styles = entry[1];
	        StringMapWrapper$3.forEach(styles, function (value /** TODO #9100 */, prop /** TODO #9100 */) {
	            if (!isPresent$3(firstKeyframeStyles[prop])) {
	                firstKeyframeStyles[prop] = FILL_STYLE_FLAG$1;
	            }
	        });
	    }
	    for (i = limit - 1; i >= 0; i--) {
	        var _entry = rawKeyframes[i];
	        var _styles = _entry[1];
	        StringMapWrapper$3.forEach(_styles, function (value /** TODO #9100 */, prop /** TODO #9100 */) {
	            if (!isPresent$3(lastKeyframeStyles[prop])) {
	                lastKeyframeStyles[prop] = value;
	            }
	        });
	    }
	    return rawKeyframes.map(function (entry) {
	        return new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]]));
	    });
	}
	function _parseTransitionAnimation(entry, currentTime, collectedStyles, stateStyles, errors) {
	    var ast;
	    var playTime = 0;
	    var startingTime = currentTime;
	    if (entry instanceof CompileAnimationWithStepsMetadata) {
	        var maxDuration = 0;
	        var steps = [];
	        var isGroup = entry instanceof CompileAnimationGroupMetadata;
	        var previousStyles;
	        entry.steps.forEach(function (entry) {
	            // these will get picked up by the next step...
	            var time = isGroup ? startingTime : currentTime;
	            if (entry instanceof CompileAnimationStyleMetadata) {
	                entry.styles.forEach(function (stylesEntry) {
	                    // by this point we know that we only have stringmap values
	                    var map = stylesEntry;
	                    StringMapWrapper$3.forEach(map, function (value /** TODO #9100 */, prop /** TODO #9100 */) {
	                        collectedStyles.insertAtTime(prop, time, value);
	                    });
	                });
	                previousStyles = entry.styles;
	                return;
	            }
	            var innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);
	            if (isPresent$3(previousStyles)) {
	                if (entry instanceof CompileAnimationWithStepsMetadata) {
	                    var startingStyles = new AnimationStylesAst(previousStyles);
	                    steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
	                } else {
	                    var innerStep = innerAst;
	                    ListWrapper$3.addAll(innerStep.startingStyles.styles, previousStyles);
	                }
	                previousStyles = null;
	            }
	            var astDuration = innerAst.playTime;
	            currentTime += astDuration;
	            playTime += astDuration;
	            maxDuration = Math$6.max(astDuration, maxDuration);
	            steps.push(innerAst);
	        });
	        if (isPresent$3(previousStyles)) {
	            var startingStyles = new AnimationStylesAst(previousStyles);
	            steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
	        }
	        if (isGroup) {
	            ast = new AnimationGroupAst(steps);
	            playTime = maxDuration;
	            currentTime = startingTime + playTime;
	        } else {
	            ast = new AnimationSequenceAst(steps);
	        }
	    } else if (entry instanceof CompileAnimationAnimateMetadata) {
	        var timings = _parseTimeExpression(entry.timings, errors);
	        var styles = entry.styles;
	        var keyframes;
	        if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {
	            keyframes = _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);
	        } else {
	            var styleData = styles;
	            var offset = _TERMINAL_KEYFRAME;
	            var styleAst = new AnimationStylesAst(styleData.styles);
	            var keyframe = new AnimationKeyframeAst(offset, styleAst);
	            keyframes = [keyframe];
	        }
	        ast = new AnimationStepAst(new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);
	        playTime = timings.duration + timings.delay;
	        currentTime += playTime;
	        keyframes.forEach(function (keyframe /** TODO #9100 */) {
	            return keyframe.styles.styles.forEach(function (entry /** TODO #9100 */) {
	                return StringMapWrapper$3.forEach(entry, function (value /** TODO #9100 */, prop /** TODO #9100 */) {
	                    return collectedStyles.insertAtTime(prop, currentTime, value);
	                });
	            });
	        });
	    } else {
	        // if the code reaches this stage then an error
	        // has already been populated within the _normalizeStyleSteps()
	        // operation...
	        ast = new AnimationStepAst(null, [], 0, 0, '');
	    }
	    ast.playTime = playTime;
	    ast.startTime = startingTime;
	    return ast;
	}
	function _fillAnimationAstStartingKeyframes(ast, collectedStyles, errors) {
	    // steps that only contain style will not be filled
	    if (ast instanceof AnimationStepAst && ast.keyframes.length > 0) {
	        var keyframes = ast.keyframes;
	        if (keyframes.length == 1) {
	            var endKeyframe = keyframes[0];
	            var startKeyframe = _createStartKeyframeFromEndKeyframe(endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);
	            ast.keyframes = [startKeyframe, endKeyframe];
	        }
	    } else if (ast instanceof AnimationWithStepsAst) {
	        ast.steps.forEach(function (entry) {
	            return _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors);
	        });
	    }
	}
	function _parseTimeExpression(exp, errors) {
	    var regex = /^([\.\d]+)(m?s)(?:\s+([\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?/gi;
	    var duration;
	    var delay = 0;
	    var easing = null;
	    if (isString$3(exp)) {
	        var matches = RegExpWrapper$3.firstMatch(regex, exp);
	        if (!isPresent$3(matches)) {
	            errors.push(new AnimationParseError('The provided timing value "' + exp + '" is invalid.'));
	            return new _AnimationTimings(0, 0, null);
	        }
	        var durationMatch = NumberWrapper$3.parseFloat(matches[1]);
	        var durationUnit = matches[2];
	        if (durationUnit == 's') {
	            durationMatch *= _ONE_SECOND;
	        }
	        duration = Math$6.floor(durationMatch);
	        var delayMatch = matches[3];
	        var delayUnit = matches[4];
	        if (isPresent$3(delayMatch)) {
	            var delayVal = NumberWrapper$3.parseFloat(delayMatch);
	            if (isPresent$3(delayUnit) && delayUnit == 's') {
	                delayVal *= _ONE_SECOND;
	            }
	            delay = Math$6.floor(delayVal);
	        }
	        var easingVal = matches[5];
	        if (!isBlank$3(easingVal)) {
	            easing = easingVal;
	        }
	    } else {
	        duration = exp;
	    }
	    return new _AnimationTimings(duration, delay, easing);
	}
	function _createStartKeyframeFromEndKeyframe(endKeyframe, startTime, duration, collectedStyles, errors) {
	    var values = {};
	    var endTime = startTime + duration;
	    endKeyframe.styles.styles.forEach(function (styleData) {
	        StringMapWrapper$3.forEach(styleData, function (val /** TODO #9100 */, prop /** TODO #9100 */) {
	            if (prop == 'offset') return;
	            var resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);
	            var resultEntry /** TODO #9100 */, nextEntry /** TODO #9100 */, value;
	            if (isPresent$3(resultIndex)) {
	                resultEntry = collectedStyles.getByIndex(prop, resultIndex);
	                value = resultEntry.value;
	                nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);
	            } else {
	                // this is a flag that the runtime code uses to pass
	                // in a value either from the state declaration styles
	                // or using the AUTO_STYLE value (e.g. getComputedStyle)
	                value = FILL_STYLE_FLAG$1;
	            }
	            if (isPresent$3(nextEntry) && !nextEntry.matches(endTime, val)) {
	                errors.push(new AnimationParseError('The animated CSS property "' + prop + '" unexpectedly changes between steps "' + resultEntry.time + 'ms" and "' + endTime + 'ms" at "' + nextEntry.time + 'ms"'));
	            }
	            values[prop] = value;
	        });
	    });
	    return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));
	}

	var CompiledAnimation = function CompiledAnimation(name, statesMapStatement, statesVariableName, fnStatement, fnVariable) {
	    classCallCheck(this, CompiledAnimation);

	    this.name = name;
	    this.statesMapStatement = statesMapStatement;
	    this.statesVariableName = statesVariableName;
	    this.fnStatement = fnStatement;
	    this.fnVariable = fnVariable;
	};
	var AnimationCompiler = function () {
	    function AnimationCompiler() {
	        classCallCheck(this, AnimationCompiler);
	    }

	    createClass(AnimationCompiler, [{
	        key: 'compileComponent',
	        value: function compileComponent(component) {
	            var compiledAnimations = [];
	            var index = 0;
	            component.template.animations.forEach(function (entry) {
	                var result = parseAnimationEntry(entry);
	                if (result.errors.length > 0) {
	                    var errorMessage = '';
	                    result.errors.forEach(function (error) {
	                        errorMessage += '\n- ' + error.msg;
	                    });
	                    // todo (matsko): include the component name when throwing
	                    throw new BaseException$3('Unable to parse the animation sequence for "' + entry.name + '" due to the following errors: ' + errorMessage);
	                }
	                var factoryName = component.type.name + '_' + entry.name + '_' + index;
	                index++;
	                var visitor = new _AnimationBuilder(entry.name, factoryName);
	                compiledAnimations.push(visitor.build(result.ast));
	            });
	            return compiledAnimations;
	        }
	    }]);
	    return AnimationCompiler;
	}();
	var _ANIMATION_FACTORY_ELEMENT_VAR = variable('element');
	var _ANIMATION_DEFAULT_STATE_VAR = variable('defaultStateStyles');
	var _ANIMATION_FACTORY_VIEW_VAR = variable('view');
	var _ANIMATION_FACTORY_RENDERER_VAR = _ANIMATION_FACTORY_VIEW_VAR.prop('renderer');
	var _ANIMATION_CURRENT_STATE_VAR = variable('currentState');
	var _ANIMATION_NEXT_STATE_VAR = variable('nextState');
	var _ANIMATION_PLAYER_VAR = variable('player');
	var _ANIMATION_START_STATE_STYLES_VAR = variable('startStateStyles');
	var _ANIMATION_END_STATE_STYLES_VAR = variable('endStateStyles');
	var _ANIMATION_COLLECTED_STYLES = variable('collectedStyles');
	var EMPTY_MAP$2 = literalMap([]);

	var _AnimationBuilder = function () {
	    function _AnimationBuilder(animationName, factoryName) {
	        classCallCheck(this, _AnimationBuilder);

	        this.animationName = animationName;
	        this._fnVarName = factoryName + '_factory';
	        this._statesMapVarName = factoryName + '_states';
	        this._statesMapVar = variable(this._statesMapVarName);
	    }

	    createClass(_AnimationBuilder, [{
	        key: 'visitAnimationStyles',
	        value: function visitAnimationStyles(ast, context) {
	            var stylesArr = [];
	            if (context.isExpectingFirstStyleStep) {
	                stylesArr.push(_ANIMATION_START_STATE_STYLES_VAR);
	                context.isExpectingFirstStyleStep = false;
	            }
	            ast.styles.forEach(function (entry) {
	                stylesArr.push(literalMap(StringMapWrapper$3.keys(entry).map(function (key) {
	                    return [key, literal(entry[key])];
	                })));
	            });
	            return importExpr(Identifiers.AnimationStyles).instantiate([importExpr(Identifiers.collectAndResolveStyles).callFn([_ANIMATION_COLLECTED_STYLES, literalArr(stylesArr)])]);
	        }
	    }, {
	        key: 'visitAnimationKeyframe',
	        value: function visitAnimationKeyframe(ast, context) {
	            return importExpr(Identifiers.AnimationKeyframe).instantiate([literal(ast.offset), ast.styles.visit(this, context)]);
	        }
	    }, {
	        key: 'visitAnimationStep',
	        value: function visitAnimationStep(ast, context) {
	            var _this = this;

	            if (context.endStateAnimateStep === ast) {
	                return this._visitEndStateAnimation(ast, context);
	            }
	            var startingStylesExpr = ast.startingStyles.visit(this, context);
	            var keyframeExpressions = ast.keyframes.map(function (keyframeEntry) {
	                return keyframeEntry.visit(_this, context);
	            });
	            return this._callAnimateMethod(ast, startingStylesExpr, literalArr(keyframeExpressions));
	        }
	        /** @internal */

	    }, {
	        key: '_visitEndStateAnimation',
	        value: function _visitEndStateAnimation(ast, context) {
	            var _this2 = this;

	            var startingStylesExpr = ast.startingStyles.visit(this, context);
	            var keyframeExpressions = ast.keyframes.map(function (keyframe) {
	                return keyframe.visit(_this2, context);
	            });
	            var keyframesExpr = importExpr(Identifiers.balanceAnimationKeyframes).callFn([_ANIMATION_COLLECTED_STYLES, _ANIMATION_END_STATE_STYLES_VAR, literalArr(keyframeExpressions)]);
	            return this._callAnimateMethod(ast, startingStylesExpr, keyframesExpr);
	        }
	        /** @internal */

	    }, {
	        key: '_callAnimateMethod',
	        value: function _callAnimateMethod(ast, startingStylesExpr, keyframesExpr) {
	            return _ANIMATION_FACTORY_RENDERER_VAR.callMethod('animate', [_ANIMATION_FACTORY_ELEMENT_VAR, startingStylesExpr, keyframesExpr, literal(ast.duration), literal(ast.delay), literal(ast.easing)]);
	        }
	    }, {
	        key: 'visitAnimationSequence',
	        value: function visitAnimationSequence(ast, context) {
	            var _this3 = this;

	            var playerExprs = ast.steps.map(function (step) {
	                return step.visit(_this3, context);
	            });
	            return importExpr(Identifiers.AnimationSequencePlayer).instantiate([literalArr(playerExprs)]);
	        }
	    }, {
	        key: 'visitAnimationGroup',
	        value: function visitAnimationGroup(ast, context) {
	            var _this4 = this;

	            var playerExprs = ast.steps.map(function (step) {
	                return step.visit(_this4, context);
	            });
	            return importExpr(Identifiers.AnimationGroupPlayer).instantiate([literalArr(playerExprs)]);
	        }
	    }, {
	        key: 'visitAnimationStateDeclaration',
	        value: function visitAnimationStateDeclaration(ast, context) {
	            var flatStyles = {};
	            _getStylesArray(ast).forEach(function (entry) {
	                StringMapWrapper$3.forEach(entry, function (value, key) {
	                    flatStyles[key] = value;
	                });
	            });
	            context.stateMap.registerState(ast.stateName, flatStyles);
	        }
	    }, {
	        key: 'visitAnimationStateTransition',
	        value: function visitAnimationStateTransition(ast, context) {
	            var steps = ast.animation.steps;
	            var lastStep = steps[steps.length - 1];
	            if (_isEndStateAnimateStep(lastStep)) {
	                context.endStateAnimateStep = lastStep;
	            }
	            context.isExpectingFirstStyleStep = true;
	            var stateChangePreconditions = [];
	            ast.stateChanges.forEach(function (stateChange) {
	                stateChangePreconditions.push(_compareToAnimationStateExpr(_ANIMATION_CURRENT_STATE_VAR, stateChange.fromState).and(_compareToAnimationStateExpr(_ANIMATION_NEXT_STATE_VAR, stateChange.toState)));
	                if (stateChange.fromState != ANY_STATE$1) {
	                    context.stateMap.registerState(stateChange.fromState);
	                }
	                if (stateChange.toState != ANY_STATE$1) {
	                    context.stateMap.registerState(stateChange.toState);
	                }
	            });
	            var animationPlayerExpr = ast.animation.visit(this, context);
	            var reducedStateChangesPrecondition = stateChangePreconditions.reduce(function (a, b) {
	                return a.or(b);
	            });
	            var precondition = _ANIMATION_PLAYER_VAR.equals(NULL_EXPR).and(reducedStateChangesPrecondition);
	            return new IfStmt(precondition, [_ANIMATION_PLAYER_VAR.set(animationPlayerExpr).toStmt()]);
	        }
	    }, {
	        key: 'visitAnimationEntry',
	        value: function visitAnimationEntry(ast, context) {
	            var _this5 = this;

	            // visit each of the declarations first to build the context state map
	            ast.stateDeclarations.forEach(function (def) {
	                return def.visit(_this5, context);
	            });
	            // this should always be defined even if the user overrides it
	            context.stateMap.registerState(DEFAULT_STATE$1, {});
	            var statements = [];
	            statements.push(_ANIMATION_FACTORY_VIEW_VAR.callMethod('cancelActiveAnimation', [_ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName), _ANIMATION_NEXT_STATE_VAR.equals(literal(EMPTY_ANIMATION_STATE))]).toStmt());
	            statements.push(_ANIMATION_COLLECTED_STYLES.set(EMPTY_MAP$2).toDeclStmt());
	            statements.push(_ANIMATION_PLAYER_VAR.set(NULL_EXPR).toDeclStmt());
	            statements.push(_ANIMATION_DEFAULT_STATE_VAR.set(this._statesMapVar.key(literal(DEFAULT_STATE$1))).toDeclStmt());
	            statements.push(_ANIMATION_START_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_CURRENT_STATE_VAR)).toDeclStmt());
	            statements.push(new IfStmt(_ANIMATION_START_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_START_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
	            statements.push(_ANIMATION_END_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_NEXT_STATE_VAR)).toDeclStmt());
	            statements.push(new IfStmt(_ANIMATION_END_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_END_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
	            var RENDER_STYLES_FN = importExpr(Identifiers.renderStyles);
	            // before we start any animation we want to clear out the starting
	            // styles from the element's style property (since they were placed
	            // there at the end of the last animation
	            statements.push(RENDER_STYLES_FN.callFn([_ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR, importExpr(Identifiers.clearStyles).callFn([_ANIMATION_START_STATE_STYLES_VAR])]).toStmt());
	            ast.stateTransitions.forEach(function (transAst) {
	                return statements.push(transAst.visit(_this5, context));
	            });
	            // this check ensures that the animation factory always returns a player
	            // so that the onDone callback can be used for tracking
	            statements.push(new IfStmt(_ANIMATION_PLAYER_VAR.equals(NULL_EXPR), [_ANIMATION_PLAYER_VAR.set(importExpr(Identifiers.NoOpAnimationPlayer).instantiate([])).toStmt()]));
	            // once complete we want to apply the styles on the element
	            // since the destination state's values should persist once
	            // the animation sequence has completed.
	            statements.push(_ANIMATION_PLAYER_VAR.callMethod('onDone', [fn([], [RENDER_STYLES_FN.callFn([_ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR, importExpr(Identifiers.prepareFinalAnimationStyles).callFn([_ANIMATION_START_STATE_STYLES_VAR, _ANIMATION_END_STATE_STYLES_VAR])]).toStmt()])]).toStmt());
	            statements.push(_ANIMATION_FACTORY_VIEW_VAR.callMethod('registerAndStartAnimation', [_ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName), _ANIMATION_PLAYER_VAR]).toStmt());
	            return fn([new FnParam(_ANIMATION_FACTORY_VIEW_VAR.name, importType(Identifiers.AppView, [DYNAMIC_TYPE])), new FnParam(_ANIMATION_FACTORY_ELEMENT_VAR.name, DYNAMIC_TYPE), new FnParam(_ANIMATION_CURRENT_STATE_VAR.name, DYNAMIC_TYPE), new FnParam(_ANIMATION_NEXT_STATE_VAR.name, DYNAMIC_TYPE)], statements);
	        }
	    }, {
	        key: 'build',
	        value: function build(ast) {
	            var context = new _AnimationBuilderContext();
	            var fnStatement = ast.visit(this, context).toDeclStmt(this._fnVarName);
	            var fnVariable = variable(this._fnVarName);
	            var lookupMap = [];
	            StringMapWrapper$3.forEach(context.stateMap.states, function (value, stateName) {
	                var variableValue = EMPTY_MAP$2;
	                if (isPresent$3(value)) {
	                    (function () {
	                        var styleMap = [];
	                        StringMapWrapper$3.forEach(value, function (value, key) {
	                            styleMap.push([key, literal(value)]);
	                        });
	                        variableValue = literalMap(styleMap);
	                    })();
	                }
	                lookupMap.push([stateName, variableValue]);
	            });
	            var compiledStatesMapExpr = this._statesMapVar.set(literalMap(lookupMap)).toDeclStmt();
	            return new CompiledAnimation(this.animationName, compiledStatesMapExpr, this._statesMapVarName, fnStatement, fnVariable);
	        }
	    }]);
	    return _AnimationBuilder;
	}();

	var _AnimationBuilderContext = function _AnimationBuilderContext() {
	    classCallCheck(this, _AnimationBuilderContext);

	    this.stateMap = new _AnimationBuilderStateMap();
	    this.endStateAnimateStep = null;
	    this.isExpectingFirstStyleStep = false;
	};

	var _AnimationBuilderStateMap = function () {
	    function _AnimationBuilderStateMap() {
	        classCallCheck(this, _AnimationBuilderStateMap);

	        this._states = {};
	    }

	    createClass(_AnimationBuilderStateMap, [{
	        key: 'registerState',
	        value: function registerState(name) {
	            var value = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var existingEntry = this._states[name];
	            if (isBlank$3(existingEntry)) {
	                this._states[name] = value;
	            }
	        }
	    }, {
	        key: 'states',
	        get: function get() {
	            return this._states;
	        }
	    }]);
	    return _AnimationBuilderStateMap;
	}();

	function _compareToAnimationStateExpr(value, animationState) {
	    var emptyStateLiteral = literal(EMPTY_ANIMATION_STATE);
	    switch (animationState) {
	        case EMPTY_ANIMATION_STATE:
	            return value.equals(emptyStateLiteral);
	        case ANY_STATE$1:
	            return literal(true);
	        default:
	            return value.equals(literal(animationState));
	    }
	}
	function _isEndStateAnimateStep(step) {
	    // the final animation step is characterized by having only TWO
	    // keyframe values and it must have zero styles for both keyframes
	    if (step instanceof AnimationStepAst && step.duration > 0 && step.keyframes.length == 2) {
	        var styles1 = _getStylesArray(step.keyframes[0])[0];
	        var styles2 = _getStylesArray(step.keyframes[1])[0];
	        return StringMapWrapper$3.isEmpty(styles1) && StringMapWrapper$3.isEmpty(styles2);
	    }
	    return false;
	}
	function _getStylesArray(obj) {
	    return obj.styles.styles;
	}

	function _enumExpression(classIdentifier, value) {
	    if (isBlank$3(value)) return NULL_EXPR;
	    var name = resolveEnumToken$3(classIdentifier.runtime, value);
	    return importExpr(new CompileIdentifierMetadata({
	        name: classIdentifier.name + '.' + name,
	        moduleUrl: classIdentifier.moduleUrl,
	        runtime: value
	    }));
	}
	var ViewTypeEnum = function () {
	    function ViewTypeEnum() {
	        classCallCheck(this, ViewTypeEnum);
	    }

	    createClass(ViewTypeEnum, null, [{
	        key: 'fromValue',
	        value: function fromValue(value) {
	            return _enumExpression(Identifiers.ViewType, value);
	        }
	    }]);
	    return ViewTypeEnum;
	}();
	ViewTypeEnum.HOST = ViewTypeEnum.fromValue(ViewType$1.HOST);
	ViewTypeEnum.COMPONENT = ViewTypeEnum.fromValue(ViewType$1.COMPONENT);
	ViewTypeEnum.EMBEDDED = ViewTypeEnum.fromValue(ViewType$1.EMBEDDED);
	var ViewEncapsulationEnum = function () {
	    function ViewEncapsulationEnum() {
	        classCallCheck(this, ViewEncapsulationEnum);
	    }

	    createClass(ViewEncapsulationEnum, null, [{
	        key: 'fromValue',
	        value: function fromValue(value) {
	            return _enumExpression(Identifiers.ViewEncapsulation, value);
	        }
	    }]);
	    return ViewEncapsulationEnum;
	}();
	ViewEncapsulationEnum.Emulated = ViewEncapsulationEnum.fromValue(ViewEncapsulation.Emulated);
	ViewEncapsulationEnum.Native = ViewEncapsulationEnum.fromValue(ViewEncapsulation.Native);
	ViewEncapsulationEnum.None = ViewEncapsulationEnum.fromValue(ViewEncapsulation.None);
	var ChangeDetectionStrategyEnum = function () {
	    function ChangeDetectionStrategyEnum() {
	        classCallCheck(this, ChangeDetectionStrategyEnum);
	    }

	    createClass(ChangeDetectionStrategyEnum, null, [{
	        key: 'fromValue',
	        value: function fromValue(value) {
	            return _enumExpression(Identifiers.ChangeDetectionStrategy, value);
	        }
	    }]);
	    return ChangeDetectionStrategyEnum;
	}();
	ChangeDetectionStrategyEnum.OnPush = ChangeDetectionStrategyEnum.fromValue(ChangeDetectionStrategy.OnPush);
	ChangeDetectionStrategyEnum.Default = ChangeDetectionStrategyEnum.fromValue(ChangeDetectionStrategy.Default);
	var ChangeDetectorStatusEnum = function () {
	    function ChangeDetectorStatusEnum() {
	        classCallCheck(this, ChangeDetectorStatusEnum);
	    }

	    createClass(ChangeDetectorStatusEnum, null, [{
	        key: 'fromValue',
	        value: function fromValue(value) {
	            return _enumExpression(Identifiers.ChangeDetectorStatus, value);
	        }
	    }]);
	    return ChangeDetectorStatusEnum;
	}();
	ChangeDetectorStatusEnum.CheckOnce = ChangeDetectorStatusEnum.fromValue(ChangeDetectorStatus$1.CheckOnce);
	ChangeDetectorStatusEnum.Checked = ChangeDetectorStatusEnum.fromValue(ChangeDetectorStatus$1.Checked);
	ChangeDetectorStatusEnum.CheckAlways = ChangeDetectorStatusEnum.fromValue(ChangeDetectorStatus$1.CheckAlways);
	ChangeDetectorStatusEnum.Detached = ChangeDetectorStatusEnum.fromValue(ChangeDetectorStatus$1.Detached);
	ChangeDetectorStatusEnum.Errored = ChangeDetectorStatusEnum.fromValue(ChangeDetectorStatus$1.Errored);
	ChangeDetectorStatusEnum.Destroyed = ChangeDetectorStatusEnum.fromValue(ChangeDetectorStatus$1.Destroyed);
	var ViewConstructorVars = function ViewConstructorVars() {
	    classCallCheck(this, ViewConstructorVars);
	};
	ViewConstructorVars.viewUtils = variable('viewUtils');
	ViewConstructorVars.parentInjector = variable('parentInjector');
	ViewConstructorVars.declarationEl = variable('declarationEl');
	var ViewProperties = function ViewProperties() {
	    classCallCheck(this, ViewProperties);
	};
	ViewProperties.renderer = THIS_EXPR.prop('renderer');
	ViewProperties.projectableNodes = THIS_EXPR.prop('projectableNodes');
	ViewProperties.viewUtils = THIS_EXPR.prop('viewUtils');
	var EventHandlerVars = function EventHandlerVars() {
	    classCallCheck(this, EventHandlerVars);
	};
	EventHandlerVars.event = variable('$event');
	var InjectMethodVars = function InjectMethodVars() {
	    classCallCheck(this, InjectMethodVars);
	};
	InjectMethodVars.token = variable('token');
	InjectMethodVars.requestNodeIndex = variable('requestNodeIndex');
	InjectMethodVars.notFoundResult = variable('notFoundResult');
	var DetectChangesVars = function DetectChangesVars() {
	    classCallCheck(this, DetectChangesVars);
	};
	DetectChangesVars.throwOnChange = variable('throwOnChange');
	DetectChangesVars.changes = variable('changes');
	DetectChangesVars.changed = variable('changed');
	DetectChangesVars.valUnwrapper = variable('valUnwrapper');

	function getPropertyInView(property, callingView, definedView) {
	    if (callingView === definedView) {
	        return property;
	    } else {
	        var viewProp = THIS_EXPR;
	        var currView = callingView;
	        while (currView !== definedView && isPresent$3(currView.declarationElement.view)) {
	            currView = currView.declarationElement.view;
	            viewProp = viewProp.prop('parent');
	        }
	        if (currView !== definedView) {
	            throw new BaseException$3('Internal error: Could not calculate a property in a parent view: ' + property);
	        }
	        if (property instanceof ReadPropExpr) {
	            (function () {
	                var readPropExpr = property;
	                // Note: Don't cast for members of the AppView base class...
	                if (definedView.fields.some(function (field) {
	                    return field.name == readPropExpr.name;
	                }) || definedView.getters.some(function (field) {
	                    return field.name == readPropExpr.name;
	                })) {
	                    viewProp = viewProp.cast(definedView.classType);
	                }
	            })();
	        }
	        return replaceVarInExpression(THIS_EXPR.name, viewProp, property);
	    }
	}
	function injectFromViewParentInjector(token, optional) {
	    var args = [createDiTokenExpression(token)];
	    if (optional) {
	        args.push(NULL_EXPR);
	    }
	    return THIS_EXPR.prop('parentInjector').callMethod('get', args);
	}
	function getViewFactoryName(component, embeddedTemplateIndex) {
	    return 'viewFactory_' + component.type.name + embeddedTemplateIndex;
	}
	function createDiTokenExpression(token) {
	    if (isPresent$3(token.value)) {
	        return literal(token.value);
	    } else if (token.identifierIsInstance) {
	        return importExpr(token.identifier).instantiate([], importType(token.identifier, [], [TypeModifier.Const]));
	    } else {
	        return importExpr(token.identifier);
	    }
	}
	function createFlatArray(expressions) {
	    var lastNonArrayExpressions = [];
	    var result = literalArr([]);
	    for (var i = 0; i < expressions.length; i++) {
	        var expr = expressions[i];
	        if (expr.type instanceof ArrayType) {
	            if (lastNonArrayExpressions.length > 0) {
	                result = result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
	                lastNonArrayExpressions = [];
	            }
	            result = result.callMethod(BuiltinMethod.ConcatArray, [expr]);
	        } else {
	            lastNonArrayExpressions.push(expr);
	        }
	    }
	    if (lastNonArrayExpressions.length > 0) {
	        result = result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
	    }
	    return result;
	}
	function createPureProxy(fn, argCount, pureProxyProp, view) {
	    view.fields.push(new ClassField(pureProxyProp.name, null));
	    var pureProxyId = argCount < Identifiers.pureProxies.length ? Identifiers.pureProxies[argCount] : null;
	    if (isBlank$3(pureProxyId)) {
	        throw new BaseException$3('Unsupported number of argument for pure functions: ' + argCount);
	    }
	    view.createMethod.addStmt(THIS_EXPR.prop(pureProxyProp.name).set(importExpr(pureProxyId).callFn([fn])).toStmt());
	}

	var ViewQueryValues = function ViewQueryValues(view, values) {
	    classCallCheck(this, ViewQueryValues);

	    this.view = view;
	    this.values = values;
	};

	var CompileQuery = function () {
	    function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
	        classCallCheck(this, CompileQuery);

	        this.meta = meta;
	        this.queryList = queryList;
	        this.ownerDirectiveExpression = ownerDirectiveExpression;
	        this.view = view;
	        this._values = new ViewQueryValues(view, []);
	    }

	    createClass(CompileQuery, [{
	        key: 'addValue',
	        value: function addValue(value, view) {
	            var currentView = view;
	            var elPath = [];
	            while (isPresent$3(currentView) && currentView !== this.view) {
	                var parentEl = currentView.declarationElement;
	                elPath.unshift(parentEl);
	                currentView = parentEl.view;
	            }
	            var queryListForDirtyExpr = getPropertyInView(this.queryList, view, this.view);
	            var viewValues = this._values;
	            elPath.forEach(function (el) {
	                var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
	                if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
	                    viewValues = last;
	                } else {
	                    var newViewValues = new ViewQueryValues(el.embeddedView, []);
	                    viewValues.values.push(newViewValues);
	                    viewValues = newViewValues;
	                }
	            });
	            viewValues.values.push(value);
	            if (elPath.length > 0) {
	                view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
	            }
	        }
	    }, {
	        key: '_isStatic',
	        value: function _isStatic() {
	            return !this._values.values.some(function (value) {
	                return value instanceof ViewQueryValues;
	            });
	        }
	    }, {
	        key: 'afterChildren',
	        value: function afterChildren(targetStaticMethod /** TODO #9100 */, targetDynamicMethod) {
	            var values = createQueryValues(this._values);
	            var updateStmts = [this.queryList.callMethod('reset', [literalArr(values)]).toStmt()];
	            if (isPresent$3(this.ownerDirectiveExpression)) {
	                var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
	                updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
	            }
	            if (!this.meta.first) {
	                updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
	            }
	            if (this.meta.first && this._isStatic()) {
	                // for queries that don't change and the user asked for a single element,
	                // set it immediately. That is e.g. needed for querying for ViewContainerRefs, ...
	                // we don't do this for QueryLists for now as this would break the timing when
	                // we call QueryList listeners...
	                targetStaticMethod.addStmts(updateStmts);
	            } else {
	                targetDynamicMethod.addStmt(new IfStmt(this.queryList.prop('dirty'), updateStmts));
	            }
	        }
	    }]);
	    return CompileQuery;
	}();
	function createQueryValues(viewValues) {
	    return ListWrapper$3.flatten(viewValues.values.map(function (entry) {
	        if (entry instanceof ViewQueryValues) {
	            return mapNestedViews(entry.view.declarationElement.appElement, entry.view, createQueryValues(entry));
	        } else {
	            return entry;
	        }
	    }));
	}
	function mapNestedViews(declarationAppElement, view, expressions) {
	    var adjustedExpressions = expressions.map(function (expr) {
	        return replaceVarInExpression(THIS_EXPR.name, variable('nestedView'), expr);
	    });
	    return declarationAppElement.callMethod('mapNestedViews', [variable(view.className), fn([new FnParam('nestedView', view.classType)], [new ReturnStatement(literalArr(adjustedExpressions))])]);
	}
	function createQueryList(query, directiveInstance, propertyName, compileView) {
	    compileView.fields.push(new ClassField(propertyName, importType(Identifiers.QueryList, [DYNAMIC_TYPE])));
	    var expr = THIS_EXPR.prop(propertyName);
	    compileView.createMethod.addStmt(THIS_EXPR.prop(propertyName).set(importExpr(Identifiers.QueryList, [DYNAMIC_TYPE]).instantiate([])).toStmt());
	    return expr;
	}
	function addQueryToTokenMap(map, query) {
	    query.meta.selectors.forEach(function (selector) {
	        var entry = map.get(selector);
	        if (isBlank$3(entry)) {
	            entry = [];
	            map.add(selector, entry);
	        }
	        entry.push(query);
	    });
	}

	var _DebugState = function _DebugState(nodeIndex, sourceAst) {
	    classCallCheck(this, _DebugState);

	    this.nodeIndex = nodeIndex;
	    this.sourceAst = sourceAst;
	};

	var NULL_DEBUG_STATE = new _DebugState(null, null);
	var CompileMethod = function () {
	    function CompileMethod(_view) {
	        classCallCheck(this, CompileMethod);

	        this._view = _view;
	        this._newState = NULL_DEBUG_STATE;
	        this._currState = NULL_DEBUG_STATE;
	        this._bodyStatements = [];
	        this._debugEnabled = this._view.genConfig.genDebugInfo;
	    }

	    createClass(CompileMethod, [{
	        key: '_updateDebugContextIfNeeded',
	        value: function _updateDebugContextIfNeeded() {
	            if (this._newState.nodeIndex !== this._currState.nodeIndex || this._newState.sourceAst !== this._currState.sourceAst) {
	                var expr = this._updateDebugContext(this._newState);
	                if (isPresent$3(expr)) {
	                    this._bodyStatements.push(expr.toStmt());
	                }
	            }
	        }
	    }, {
	        key: '_updateDebugContext',
	        value: function _updateDebugContext(newState) {
	            this._currState = this._newState = newState;
	            if (this._debugEnabled) {
	                var sourceLocation = isPresent$3(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;
	                return THIS_EXPR.callMethod('debug', [literal(newState.nodeIndex), isPresent$3(sourceLocation) ? literal(sourceLocation.line) : NULL_EXPR, isPresent$3(sourceLocation) ? literal(sourceLocation.col) : NULL_EXPR]);
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'resetDebugInfoExpr',
	        value: function resetDebugInfoExpr(nodeIndex, templateAst) {
	            var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
	            return isPresent$3(res) ? res : NULL_EXPR;
	        }
	    }, {
	        key: 'resetDebugInfo',
	        value: function resetDebugInfo(nodeIndex, templateAst) {
	            this._newState = new _DebugState(nodeIndex, templateAst);
	        }
	    }, {
	        key: 'addStmt',
	        value: function addStmt(stmt) {
	            this._updateDebugContextIfNeeded();
	            this._bodyStatements.push(stmt);
	        }
	    }, {
	        key: 'addStmts',
	        value: function addStmts(stmts) {
	            this._updateDebugContextIfNeeded();
	            ListWrapper$3.addAll(this._bodyStatements, stmts);
	        }
	    }, {
	        key: 'finish',
	        value: function finish() {
	            return this._bodyStatements;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty() {
	            return this._bodyStatements.length === 0;
	        }
	    }]);
	    return CompileMethod;
	}();

	var CompileNode = function () {
	    function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
	        classCallCheck(this, CompileNode);

	        this.parent = parent;
	        this.view = view;
	        this.nodeIndex = nodeIndex;
	        this.renderNode = renderNode;
	        this.sourceAst = sourceAst;
	    }

	    createClass(CompileNode, [{
	        key: 'isNull',
	        value: function isNull() {
	            return isBlank$3(this.renderNode);
	        }
	    }, {
	        key: 'isRootElement',
	        value: function isRootElement() {
	            return this.view != this.parent.view;
	        }
	    }]);
	    return CompileNode;
	}();
	var CompileElement = function (_CompileNode) {
	    inherits(CompileElement, _CompileNode);

	    function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references) {
	        classCallCheck(this, CompileElement);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(CompileElement).call(this, parent, view, nodeIndex, renderNode, sourceAst));

	        _this.component = component;
	        _this._directives = _directives;
	        _this._resolvedProvidersArray = _resolvedProvidersArray;
	        _this.hasViewContainer = hasViewContainer;
	        _this.hasEmbeddedView = hasEmbeddedView;
	        _this._compViewExpr = null;
	        _this._instances = new CompileTokenMap();
	        _this._queryCount = 0;
	        _this._queries = new CompileTokenMap();
	        _this._componentConstructorViewQueryLists = [];
	        _this.contentNodesByNgContentIndex = null;
	        _this.referenceTokens = {};
	        references.forEach(function (ref) {
	            return _this.referenceTokens[ref.name] = ref.value;
	        });
	        _this.elementRef = importExpr(Identifiers.ElementRef).instantiate([_this.renderNode]);
	        _this._instances.add(identifierToken(Identifiers.ElementRef), _this.elementRef);
	        _this.injector = THIS_EXPR.callMethod('injector', [literal(_this.nodeIndex)]);
	        _this._instances.add(identifierToken(Identifiers.Injector), _this.injector);
	        _this._instances.add(identifierToken(Identifiers.Renderer), THIS_EXPR.prop('renderer'));
	        if (_this.hasViewContainer || _this.hasEmbeddedView || isPresent$3(_this.component)) {
	            _this._createAppElement();
	        }
	        return _this;
	    }

	    createClass(CompileElement, [{
	        key: '_createAppElement',
	        value: function _createAppElement() {
	            var fieldName = '_appEl_' + this.nodeIndex;
	            var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
	            // private is fine here as no child view will reference an AppElement
	            this.view.fields.push(new ClassField(fieldName, importType(Identifiers.AppElement), [StmtModifier.Private]));
	            var statement = THIS_EXPR.prop(fieldName).set(importExpr(Identifiers.AppElement).instantiate([literal(this.nodeIndex), literal(parentNodeIndex), THIS_EXPR, this.renderNode])).toStmt();
	            this.view.createMethod.addStmt(statement);
	            this.appElement = THIS_EXPR.prop(fieldName);
	            this._instances.add(identifierToken(Identifiers.AppElement), this.appElement);
	        }
	    }, {
	        key: 'createComponentFactoryResolver',
	        value: function createComponentFactoryResolver(precompileComponent) {
	            if (!precompileComponent || precompileComponent.length === 0) {
	                return;
	            }
	            var createComponentFactoryResolverExpr = importExpr(Identifiers.CodegenComponentFactoryResolver).instantiate([literalArr(precompileComponent.map(function (precompiledComponent) {
	                return importExpr(precompiledComponent);
	            })), injectFromViewParentInjector(identifierToken(Identifiers.ComponentFactoryResolver), false)]);
	            var provider = new CompileProviderMetadata({
	                token: identifierToken(Identifiers.ComponentFactoryResolver),
	                useValue: createComponentFactoryResolverExpr
	            });
	            // Add ComponentFactoryResolver as first provider as it does not have deps on other providers
	            // ProviderAstType.PrivateService as only the component and its view can see it,
	            // but nobody else
	            this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], ProviderAstType.PrivateService, this.sourceAst.sourceSpan));
	        }
	    }, {
	        key: 'setComponentView',
	        value: function setComponentView(compViewExpr) {
	            this._compViewExpr = compViewExpr;
	            this.contentNodesByNgContentIndex = ListWrapper$3.createFixedSize(this.component.template.ngContentSelectors.length);
	            for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
	                this.contentNodesByNgContentIndex[i] = [];
	            }
	        }
	    }, {
	        key: 'setEmbeddedView',
	        value: function setEmbeddedView(embeddedView) {
	            this.embeddedView = embeddedView;
	            if (isPresent$3(embeddedView)) {
	                var createTemplateRefExpr = importExpr(Identifiers.TemplateRef_).instantiate([this.appElement, this.embeddedView.viewFactory]);
	                var provider = new CompileProviderMetadata({ token: identifierToken(Identifiers.TemplateRef), useValue: createTemplateRefExpr });
	                // Add TemplateRef as first provider as it does not have deps on other providers
	                this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], ProviderAstType.Builtin, this.sourceAst.sourceSpan));
	            }
	        }
	    }, {
	        key: 'beforeChildren',
	        value: function beforeChildren() {
	            var _this2 = this;

	            if (this.hasViewContainer) {
	                this._instances.add(identifierToken(Identifiers.ViewContainerRef), this.appElement.prop('vcRef'));
	            }
	            this._resolvedProviders = new CompileTokenMap();
	            this._resolvedProvidersArray.forEach(function (provider) {
	                return _this2._resolvedProviders.add(provider.token, provider);
	            });
	            // create all the provider instances, some in the view constructor,
	            // some as getters. We rely on the fact that they are already sorted topologically.
	            this._resolvedProviders.values().forEach(function (resolvedProvider) {
	                var providerValueExpressions = resolvedProvider.providers.map(function (provider) {
	                    if (isPresent$3(provider.useExisting)) {
	                        return _this2._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }));
	                    } else if (isPresent$3(provider.useFactory)) {
	                        var deps = isPresent$3(provider.deps) ? provider.deps : provider.useFactory.diDeps;
	                        var depsExpr = deps.map(function (dep) {
	                            return _this2._getDependency(resolvedProvider.providerType, dep);
	                        });
	                        return importExpr(provider.useFactory).callFn(depsExpr);
	                    } else if (isPresent$3(provider.useClass)) {
	                        var deps = isPresent$3(provider.deps) ? provider.deps : provider.useClass.diDeps;
	                        var depsExpr = deps.map(function (dep) {
	                            return _this2._getDependency(resolvedProvider.providerType, dep);
	                        });
	                        return importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));
	                    } else {
	                        return _convertValueToOutputAst(provider.useValue);
	                    }
	                });
	                var propName = '_' + resolvedProvider.token.name + '_' + _this2.nodeIndex + '_' + _this2._instances.size;
	                var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this2);
	                _this2._instances.add(resolvedProvider.token, instance);
	            });
	            this.directiveInstances = this._directives.map(function (directive) {
	                return _this2._instances.get(identifierToken(directive.type));
	            });
	            for (var i = 0; i < this.directiveInstances.length; i++) {
	                var directiveInstance = this.directiveInstances[i];
	                var directive = this._directives[i];
	                directive.queries.forEach(function (queryMeta) {
	                    _this2._addQuery(queryMeta, directiveInstance);
	                });
	            }
	            var queriesWithReads = [];
	            this._resolvedProviders.values().forEach(function (resolvedProvider) {
	                var queriesForProvider = _this2._getQueriesFor(resolvedProvider.token);
	                ListWrapper$3.addAll(queriesWithReads, queriesForProvider.map(function (query) {
	                    return new _QueryWithRead(query, resolvedProvider.token);
	                }));
	            });
	            StringMapWrapper$3.forEach(this.referenceTokens, function (_, varName) {
	                var token = _this2.referenceTokens[varName];
	                var varValue;
	                if (isPresent$3(token)) {
	                    varValue = _this2._instances.get(token);
	                } else {
	                    varValue = _this2.renderNode;
	                }
	                _this2.view.locals.set(varName, varValue);
	                var varToken = new CompileTokenMetadata({ value: varName });
	                ListWrapper$3.addAll(queriesWithReads, _this2._getQueriesFor(varToken).map(function (query) {
	                    return new _QueryWithRead(query, varToken);
	                }));
	            });
	            queriesWithReads.forEach(function (queryWithRead) {
	                var value;
	                if (isPresent$3(queryWithRead.read.identifier)) {
	                    // query for an identifier
	                    value = _this2._instances.get(queryWithRead.read);
	                } else {
	                    // query for a reference
	                    var token = _this2.referenceTokens[queryWithRead.read.value];
	                    if (isPresent$3(token)) {
	                        value = _this2._instances.get(token);
	                    } else {
	                        value = _this2.elementRef;
	                    }
	                }
	                if (isPresent$3(value)) {
	                    queryWithRead.query.addValue(value, _this2.view);
	                }
	            });
	            if (isPresent$3(this.component)) {
	                var componentConstructorViewQueryList = isPresent$3(this.component) ? literalArr(this._componentConstructorViewQueryLists) : NULL_EXPR;
	                var compExpr = isPresent$3(this.getComponent()) ? this.getComponent() : NULL_EXPR;
	                this.view.createMethod.addStmt(this.appElement.callMethod('initComponent', [compExpr, componentConstructorViewQueryList, this._compViewExpr]).toStmt());
	            }
	        }
	    }, {
	        key: 'afterChildren',
	        value: function afterChildren(childNodeCount) {
	            var _this3 = this;

	            this._resolvedProviders.values().forEach(function (resolvedProvider) {
	                // Note: afterChildren is called after recursing into children.
	                // This is good so that an injector match in an element that is closer to a requesting element
	                // matches first.
	                var providerExpr = _this3._instances.get(resolvedProvider.token);
	                // Note: view providers are only visible on the injector of that element.
	                // This is not fully correct as the rules during codegen don't allow a directive
	                // to get hold of a view provdier on the same element. We still do this semantic
	                // as it simplifies our model to having only one runtime injector per element.
	                var providerChildNodeCount = resolvedProvider.providerType === ProviderAstType.PrivateService ? 0 : childNodeCount;
	                _this3.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this3.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
	            });
	            this._queries.values().forEach(function (queries) {
	                return queries.forEach(function (query) {
	                    return query.afterChildren(_this3.view.createMethod, _this3.view.updateContentQueriesMethod);
	                });
	            });
	        }
	    }, {
	        key: 'addContentNode',
	        value: function addContentNode(ngContentIndex, nodeExpr) {
	            this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
	        }
	    }, {
	        key: 'getComponent',
	        value: function getComponent() {
	            return isPresent$3(this.component) ? this._instances.get(identifierToken(this.component.type)) : null;
	        }
	    }, {
	        key: 'getProviderTokens',
	        value: function getProviderTokens() {
	            return this._resolvedProviders.values().map(function (resolvedProvider) {
	                return createDiTokenExpression(resolvedProvider.token);
	            });
	        }
	    }, {
	        key: '_getQueriesFor',
	        value: function _getQueriesFor(token) {
	            var result = [];
	            var currentEl = this;
	            var distance = 0;
	            var queries;
	            while (!currentEl.isNull()) {
	                queries = currentEl._queries.get(token);
	                if (isPresent$3(queries)) {
	                    ListWrapper$3.addAll(result, queries.filter(function (query) {
	                        return query.meta.descendants || distance <= 1;
	                    }));
	                }
	                if (currentEl._directives.length > 0) {
	                    distance++;
	                }
	                currentEl = currentEl.parent;
	            }
	            queries = this.view.componentView.viewQueries.get(token);
	            if (isPresent$3(queries)) {
	                ListWrapper$3.addAll(result, queries);
	            }
	            return result;
	        }
	    }, {
	        key: '_addQuery',
	        value: function _addQuery(queryMeta, directiveInstance) {
	            var propName = '_query_' + queryMeta.selectors[0].name + '_' + this.nodeIndex + '_' + this._queryCount++;
	            var queryList = createQueryList(queryMeta, directiveInstance, propName, this.view);
	            var query = new CompileQuery(queryMeta, queryList, directiveInstance, this.view);
	            addQueryToTokenMap(this._queries, query);
	            return query;
	        }
	    }, {
	        key: '_getLocalDependency',
	        value: function _getLocalDependency(requestingProviderType, dep) {
	            var result = null;
	            // constructor content query
	            if (isBlank$3(result) && isPresent$3(dep.query)) {
	                result = this._addQuery(dep.query, null).queryList;
	            }
	            // constructor view query
	            if (isBlank$3(result) && isPresent$3(dep.viewQuery)) {
	                result = createQueryList(dep.viewQuery, null, '_viewQuery_' + dep.viewQuery.selectors[0].name + '_' + this.nodeIndex + '_' + this._componentConstructorViewQueryLists.length, this.view);
	                this._componentConstructorViewQueryLists.push(result);
	            }
	            if (isPresent$3(dep.token)) {
	                // access builtins with special visibility
	                if (isBlank$3(result)) {
	                    if (dep.token.equalsTo(identifierToken(Identifiers.ChangeDetectorRef))) {
	                        if (requestingProviderType === ProviderAstType.Component) {
	                            return this._compViewExpr.prop('ref');
	                        } else {
	                            return getPropertyInView(THIS_EXPR.prop('ref'), this.view, this.view.componentView);
	                        }
	                    }
	                }
	                // access regular providers on the element
	                if (isBlank$3(result)) {
	                    var resolvedProvider = this._resolvedProviders.get(dep.token);
	                    // don't allow directives / public services to access private services.
	                    // only components and private services can access private services.
	                    if (resolvedProvider && (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.PrivateService) {
	                        return null;
	                    }
	                    result = this._instances.get(dep.token);
	                }
	            }
	            return result;
	        }
	    }, {
	        key: '_getDependency',
	        value: function _getDependency(requestingProviderType, dep) {
	            var currElement = this;
	            var result = null;
	            if (dep.isValue) {
	                result = literal(dep.value);
	            }
	            if (isBlank$3(result) && !dep.isSkipSelf) {
	                result = this._getLocalDependency(requestingProviderType, dep);
	            }
	            // check parent elements
	            while (isBlank$3(result) && !currElement.parent.isNull()) {
	                currElement = currElement.parent;
	                result = currElement._getLocalDependency(ProviderAstType.PublicService, new CompileDiDependencyMetadata({ token: dep.token }));
	            }
	            if (isBlank$3(result)) {
	                result = injectFromViewParentInjector(dep.token, dep.isOptional);
	            }
	            if (isBlank$3(result)) {
	                result = NULL_EXPR;
	            }
	            return getPropertyInView(result, this.view, currElement.view);
	        }
	    }], [{
	        key: 'createNull',
	        value: function createNull() {
	            return new CompileElement(null, null, null, null, null, null, [], [], false, false, []);
	        }
	    }]);
	    return CompileElement;
	}(CompileNode);
	function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
	    var indexCondition;
	    if (childNodeCount > 0) {
	        indexCondition = literal(nodeIndex).lowerEquals(InjectMethodVars.requestNodeIndex).and(InjectMethodVars.requestNodeIndex.lowerEquals(literal(nodeIndex + childNodeCount)));
	    } else {
	        indexCondition = literal(nodeIndex).identical(InjectMethodVars.requestNodeIndex);
	    }
	    return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(provider.token)).and(indexCondition), [new ReturnStatement(providerExpr)]);
	}
	function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {
	    var view = compileElement.view;
	    var resolvedProviderValueExpr;
	    var type;
	    if (isMulti) {
	        resolvedProviderValueExpr = literalArr(providerValueExpressions);
	        type = new ArrayType(DYNAMIC_TYPE);
	    } else {
	        resolvedProviderValueExpr = providerValueExpressions[0];
	        type = providerValueExpressions[0].type;
	    }
	    if (isBlank$3(type)) {
	        type = DYNAMIC_TYPE;
	    }
	    if (isEager) {
	        view.fields.push(new ClassField(propName, type));
	        view.createMethod.addStmt(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
	    } else {
	        var internalField = '_' + propName;
	        view.fields.push(new ClassField(internalField, type));
	        var getter = new CompileMethod(view);
	        getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	        // Note: Equals is important for JS so that it also checks the undefined case!
	        getter.addStmt(new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
	        getter.addStmt(new ReturnStatement(THIS_EXPR.prop(internalField)));
	        view.getters.push(new ClassGetter(propName, getter.finish(), type));
	    }
	    return THIS_EXPR.prop(propName);
	}

	var _QueryWithRead = function _QueryWithRead(query, match) {
	    classCallCheck(this, _QueryWithRead);

	    this.query = query;
	    this.read = isPresent$3(query.meta.read) ? query.meta.read : match;
	};

	function _convertValueToOutputAst(value) {
	    return visitValue(value, new _ValueOutputAstTransformer(), null);
	}

	var _ValueOutputAstTransformer = function (_ValueTransformer) {
	    inherits(_ValueOutputAstTransformer, _ValueTransformer);

	    function _ValueOutputAstTransformer() {
	        classCallCheck(this, _ValueOutputAstTransformer);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(_ValueOutputAstTransformer).apply(this, arguments));
	    }

	    createClass(_ValueOutputAstTransformer, [{
	        key: 'visitArray',
	        value: function visitArray(arr, context) {
	            var _this5 = this;

	            return literalArr(arr.map(function (value) {
	                return visitValue(value, _this5, context);
	            }));
	        }
	    }, {
	        key: 'visitStringMap',
	        value: function visitStringMap(map, context) {
	            var _this6 = this;

	            var entries = [];
	            StringMapWrapper$3.forEach(map, function (value, key) {
	                entries.push([key, visitValue(value, _this6, context)]);
	            });
	            return literalMap(entries);
	        }
	    }, {
	        key: 'visitPrimitive',
	        value: function visitPrimitive(value, context) {
	            return literal(value);
	        }
	    }, {
	        key: 'visitOther',
	        value: function visitOther(value, context) {
	            if (value instanceof CompileIdentifierMetadata) {
	                return importExpr(value);
	            } else if (value instanceof Expression) {
	                return value;
	            } else {
	                throw new BaseException('Illegal state: Don\'t now how to compile value ' + value);
	            }
	        }
	    }]);
	    return _ValueOutputAstTransformer;
	}(ValueTransformer);

	var _PurePipeProxy = function _PurePipeProxy(view, instance, argCount) {
	    classCallCheck(this, _PurePipeProxy);

	    this.view = view;
	    this.instance = instance;
	    this.argCount = argCount;
	};

	var CompilePipe = function () {
	    function CompilePipe(view, meta) {
	        classCallCheck(this, CompilePipe);

	        this.view = view;
	        this.meta = meta;
	        this._purePipeProxies = [];
	        this.instance = THIS_EXPR.prop('_pipe_' + meta.name + '_' + view.pipeCount++);
	    }

	    createClass(CompilePipe, [{
	        key: 'create',
	        value: function create() {
	            var _this = this;

	            var deps = this.meta.type.diDeps.map(function (diDep) {
	                if (diDep.token.equalsTo(identifierToken(Identifiers.ChangeDetectorRef))) {
	                    return getPropertyInView(THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
	                }
	                return injectFromViewParentInjector(diDep.token, false);
	            });
	            this.view.fields.push(new ClassField(this.instance.name, importType(this.meta.type)));
	            this.view.createMethod.resetDebugInfo(null, null);
	            this.view.createMethod.addStmt(THIS_EXPR.prop(this.instance.name).set(importExpr(this.meta.type).instantiate(deps)).toStmt());
	            this._purePipeProxies.forEach(function (purePipeProxy) {
	                var pipeInstanceSeenFromPureProxy = getPropertyInView(_this.instance, purePipeProxy.view, _this.view);
	                createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform').callMethod(BuiltinMethod.bind, [pipeInstanceSeenFromPureProxy]), purePipeProxy.argCount, purePipeProxy.instance, purePipeProxy.view);
	            });
	        }
	    }, {
	        key: '_call',
	        value: function _call(callingView, args) {
	            if (this.meta.pure) {
	                // PurePipeProxies live on the view that called them.
	                var purePipeProxy = new _PurePipeProxy(callingView, THIS_EXPR.prop(this.instance.name + '_' + this._purePipeProxies.length), args.length);
	                this._purePipeProxies.push(purePipeProxy);
	                return importExpr(Identifiers.castByValue).callFn([purePipeProxy.instance, getPropertyInView(this.instance.prop('transform'), callingView, this.view)]).callFn(args);
	            } else {
	                return getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
	            }
	        }
	    }, {
	        key: 'pure',
	        get: function get() {
	            return this.meta.pure;
	        }
	    }], [{
	        key: 'call',
	        value: function call(view, name, args) {
	            var compView = view.componentView;
	            var meta = _findPipeMeta(compView, name);
	            var pipe;
	            if (meta.pure) {
	                // pure pipes live on the component view
	                pipe = compView.purePipes.get(name);
	                if (isBlank$3(pipe)) {
	                    pipe = new CompilePipe(compView, meta);
	                    compView.purePipes.set(name, pipe);
	                    compView.pipes.push(pipe);
	                }
	            } else {
	                // Non pure pipes live on the view that called it
	                pipe = new CompilePipe(view, meta);
	                view.pipes.push(pipe);
	            }
	            return pipe._call(view, args);
	        }
	    }]);
	    return CompilePipe;
	}();
	function _findPipeMeta(view, name) {
	    var pipeMeta = null;
	    for (var i = view.pipeMetas.length - 1; i >= 0; i--) {
	        var localPipeMeta = view.pipeMetas[i];
	        if (localPipeMeta.name == name) {
	            pipeMeta = localPipeMeta;
	            break;
	        }
	    }
	    if (isBlank$3(pipeMeta)) {
	        throw new BaseException$3('Illegal state: Could not find pipe ' + name + ' although the parser should have detected this error!');
	    }
	    return pipeMeta;
	}

	var CompileView = function () {
	    function CompileView(component, genConfig, pipeMetas, styles, animations, viewIndex, declarationElement, templateVariableBindings) {
	        var _this = this;

	        classCallCheck(this, CompileView);

	        this.component = component;
	        this.genConfig = genConfig;
	        this.pipeMetas = pipeMetas;
	        this.styles = styles;
	        this.viewIndex = viewIndex;
	        this.declarationElement = declarationElement;
	        this.templateVariableBindings = templateVariableBindings;
	        this.nodes = [];
	        // root nodes or AppElements for ViewContainers
	        this.rootNodesOrAppElements = [];
	        this.bindings = [];
	        this.classStatements = [];
	        this.eventHandlerMethods = [];
	        this.fields = [];
	        this.getters = [];
	        this.disposables = [];
	        this.subscriptions = [];
	        this.purePipes = new Map();
	        this.pipes = [];
	        this.locals = new Map();
	        this.literalArrayCount = 0;
	        this.literalMapCount = 0;
	        this.pipeCount = 0;
	        this.animations = new Map();
	        animations.forEach(function (entry) {
	            return _this.animations.set(entry.name, entry);
	        });
	        this.createMethod = new CompileMethod(this);
	        this.injectorGetMethod = new CompileMethod(this);
	        this.updateContentQueriesMethod = new CompileMethod(this);
	        this.dirtyParentQueriesMethod = new CompileMethod(this);
	        this.updateViewQueriesMethod = new CompileMethod(this);
	        this.detectChangesInInputsMethod = new CompileMethod(this);
	        this.detectChangesRenderPropertiesMethod = new CompileMethod(this);
	        this.afterContentLifecycleCallbacksMethod = new CompileMethod(this);
	        this.afterViewLifecycleCallbacksMethod = new CompileMethod(this);
	        this.destroyMethod = new CompileMethod(this);
	        this.detachMethod = new CompileMethod(this);
	        this.viewType = getViewType(component, viewIndex);
	        this.className = '_View_' + component.type.name + viewIndex;
	        this.classType = importType(new CompileIdentifierMetadata({ name: this.className }));
	        this.viewFactory = variable(getViewFactoryName(component, viewIndex));
	        if (this.viewType === ViewType$1.COMPONENT || this.viewType === ViewType$1.HOST) {
	            this.componentView = this;
	        } else {
	            this.componentView = this.declarationElement.view.componentView;
	        }
	        this.componentContext = getPropertyInView(THIS_EXPR.prop('context'), this, this.componentView);
	        var viewQueries = new CompileTokenMap();
	        if (this.viewType === ViewType$1.COMPONENT) {
	            var directiveInstance = THIS_EXPR.prop('context');
	            ListWrapper$3.forEachWithIndex(this.component.viewQueries, function (queryMeta, queryIndex) {
	                var propName = '_viewQuery_' + queryMeta.selectors[0].name + '_' + queryIndex;
	                var queryList = createQueryList(queryMeta, directiveInstance, propName, _this);
	                var query = new CompileQuery(queryMeta, queryList, directiveInstance, _this);
	                addQueryToTokenMap(viewQueries, query);
	            });
	            var constructorViewQueryCount = 0;
	            this.component.type.diDeps.forEach(function (dep) {
	                if (isPresent$3(dep.viewQuery)) {
	                    var queryList = THIS_EXPR.prop('declarationAppElement').prop('componentConstructorViewQueries').key(literal(constructorViewQueryCount++));
	                    var query = new CompileQuery(dep.viewQuery, queryList, null, _this);
	                    addQueryToTokenMap(viewQueries, query);
	                }
	            });
	        }
	        this.viewQueries = viewQueries;
	        templateVariableBindings.forEach(function (entry) {
	            _this.locals.set(entry[1], THIS_EXPR.prop('context').prop(entry[0]));
	        });
	        if (!this.declarationElement.isNull()) {
	            this.declarationElement.setEmbeddedView(this);
	        }
	    }

	    createClass(CompileView, [{
	        key: 'callPipe',
	        value: function callPipe(name, input, args) {
	            return CompilePipe.call(this, name, [input].concat(args));
	        }
	    }, {
	        key: 'getLocal',
	        value: function getLocal(name) {
	            if (name == EventHandlerVars.event.name) {
	                return EventHandlerVars.event;
	            }
	            var currView = this;
	            var result = currView.locals.get(name);
	            while (isBlank$3(result) && isPresent$3(currView.declarationElement.view)) {
	                currView = currView.declarationElement.view;
	                result = currView.locals.get(name);
	            }
	            if (isPresent$3(result)) {
	                return getPropertyInView(result, this, currView);
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'createLiteralArray',
	        value: function createLiteralArray(values) {
	            if (values.length === 0) {
	                return importExpr(Identifiers.EMPTY_ARRAY);
	            }
	            var proxyExpr = THIS_EXPR.prop('_arr_' + this.literalArrayCount++);
	            var proxyParams = [];
	            var proxyReturnEntries = [];
	            for (var i = 0; i < values.length; i++) {
	                var paramName = 'p' + i;
	                proxyParams.push(new FnParam(paramName));
	                proxyReturnEntries.push(variable(paramName));
	            }
	            createPureProxy(fn(proxyParams, [new ReturnStatement(literalArr(proxyReturnEntries))], new ArrayType(DYNAMIC_TYPE)), values.length, proxyExpr, this);
	            return proxyExpr.callFn(values);
	        }
	    }, {
	        key: 'createLiteralMap',
	        value: function createLiteralMap(entries) {
	            if (entries.length === 0) {
	                return importExpr(Identifiers.EMPTY_MAP);
	            }
	            var proxyExpr = THIS_EXPR.prop('_map_' + this.literalMapCount++);
	            var proxyParams = [];
	            var proxyReturnEntries = [];
	            var values = [];
	            for (var i = 0; i < entries.length; i++) {
	                var paramName = 'p' + i;
	                proxyParams.push(new FnParam(paramName));
	                proxyReturnEntries.push([entries[i][0], variable(paramName)]);
	                values.push(entries[i][1]);
	            }
	            createPureProxy(fn(proxyParams, [new ReturnStatement(literalMap(proxyReturnEntries))], new MapType(DYNAMIC_TYPE)), entries.length, proxyExpr, this);
	            return proxyExpr.callFn(values);
	        }
	    }, {
	        key: 'afterNodes',
	        value: function afterNodes() {
	            var _this2 = this;

	            this.pipes.forEach(function (pipe) {
	                return pipe.create();
	            });
	            this.viewQueries.values().forEach(function (queries) {
	                return queries.forEach(function (query) {
	                    return query.afterChildren(_this2.createMethod, _this2.updateViewQueriesMethod);
	                });
	            });
	        }
	    }]);
	    return CompileView;
	}();
	function getViewType(component, embeddedTemplateIndex) {
	    if (embeddedTemplateIndex > 0) {
	        return ViewType$1.EMBEDDED;
	    } else if (component.type.isHost) {
	        return ViewType$1.HOST;
	    } else {
	        return ViewType$1.COMPONENT;
	    }
	}

	var IMPLICIT_RECEIVER = variable('#implicit');
	var ExpressionWithWrappedValueInfo = function ExpressionWithWrappedValueInfo(expression, needsValueUnwrapper) {
	    classCallCheck(this, ExpressionWithWrappedValueInfo);

	    this.expression = expression;
	    this.needsValueUnwrapper = needsValueUnwrapper;
	};
	function convertCdExpressionToIr(nameResolver, implicitReceiver, expression, valueUnwrapper) {
	    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, valueUnwrapper);
	    var irAst = expression.visit(visitor, _Mode.Expression);
	    return new ExpressionWithWrappedValueInfo(irAst, visitor.needsValueUnwrapper);
	}
	function convertCdStatementToIr(nameResolver, implicitReceiver, stmt) {
	    var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, null);
	    var statements = [];
	    flattenStatements(stmt.visit(visitor, _Mode.Statement), statements);
	    return statements;
	}
	var _Mode;
	(function (_Mode) {
	    _Mode[_Mode["Statement"] = 0] = "Statement";
	    _Mode[_Mode["Expression"] = 1] = "Expression";
	})(_Mode || (_Mode = {}));
	function ensureStatementMode(mode, ast) {
	    if (mode !== _Mode.Statement) {
	        throw new BaseException$3('Expected a statement, but saw ' + ast);
	    }
	}
	function ensureExpressionMode(mode, ast) {
	    if (mode !== _Mode.Expression) {
	        throw new BaseException$3('Expected an expression, but saw ' + ast);
	    }
	}
	function convertToStatementIfNeeded(mode, expr) {
	    if (mode === _Mode.Statement) {
	        return expr.toStmt();
	    } else {
	        return expr;
	    }
	}

	var _AstToIrVisitor = function () {
	    function _AstToIrVisitor(_nameResolver, _implicitReceiver, _valueUnwrapper) {
	        classCallCheck(this, _AstToIrVisitor);

	        this._nameResolver = _nameResolver;
	        this._implicitReceiver = _implicitReceiver;
	        this._valueUnwrapper = _valueUnwrapper;
	        this.needsValueUnwrapper = false;
	    }

	    createClass(_AstToIrVisitor, [{
	        key: 'visitBinary',
	        value: function visitBinary(ast, mode) {
	            var op;
	            switch (ast.operation) {
	                case '+':
	                    op = BinaryOperator.Plus;
	                    break;
	                case '-':
	                    op = BinaryOperator.Minus;
	                    break;
	                case '*':
	                    op = BinaryOperator.Multiply;
	                    break;
	                case '/':
	                    op = BinaryOperator.Divide;
	                    break;
	                case '%':
	                    op = BinaryOperator.Modulo;
	                    break;
	                case '&&':
	                    op = BinaryOperator.And;
	                    break;
	                case '||':
	                    op = BinaryOperator.Or;
	                    break;
	                case '==':
	                    op = BinaryOperator.Equals;
	                    break;
	                case '!=':
	                    op = BinaryOperator.NotEquals;
	                    break;
	                case '===':
	                    op = BinaryOperator.Identical;
	                    break;
	                case '!==':
	                    op = BinaryOperator.NotIdentical;
	                    break;
	                case '<':
	                    op = BinaryOperator.Lower;
	                    break;
	                case '>':
	                    op = BinaryOperator.Bigger;
	                    break;
	                case '<=':
	                    op = BinaryOperator.LowerEquals;
	                    break;
	                case '>=':
	                    op = BinaryOperator.BiggerEquals;
	                    break;
	                default:
	                    throw new BaseException$3('Unsupported operation ' + ast.operation);
	            }
	            return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, ast.left.visit(this, _Mode.Expression), ast.right.visit(this, _Mode.Expression)));
	        }
	    }, {
	        key: 'visitChain',
	        value: function visitChain(ast, mode) {
	            ensureStatementMode(mode, ast);
	            return this.visitAll(ast.expressions, mode);
	        }
	    }, {
	        key: 'visitConditional',
	        value: function visitConditional(ast, mode) {
	            var value = ast.condition.visit(this, _Mode.Expression);
	            return convertToStatementIfNeeded(mode, value.conditional(ast.trueExp.visit(this, _Mode.Expression), ast.falseExp.visit(this, _Mode.Expression)));
	        }
	    }, {
	        key: 'visitPipe',
	        value: function visitPipe(ast, mode) {
	            var input = ast.exp.visit(this, _Mode.Expression);
	            var args = this.visitAll(ast.args, _Mode.Expression);
	            var value = this._nameResolver.callPipe(ast.name, input, args);
	            this.needsValueUnwrapper = true;
	            return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
	        }
	    }, {
	        key: 'visitFunctionCall',
	        value: function visitFunctionCall(ast, mode) {
	            return convertToStatementIfNeeded(mode, ast.target.visit(this, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));
	        }
	    }, {
	        key: 'visitImplicitReceiver',
	        value: function visitImplicitReceiver(ast, mode) {
	            ensureExpressionMode(mode, ast);
	            return IMPLICIT_RECEIVER;
	        }
	    }, {
	        key: 'visitInterpolation',
	        value: function visitInterpolation(ast, mode) {
	            ensureExpressionMode(mode, ast);
	            var args = [literal(ast.expressions.length)];
	            for (var i = 0; i < ast.strings.length - 1; i++) {
	                args.push(literal(ast.strings[i]));
	                args.push(ast.expressions[i].visit(this, _Mode.Expression));
	            }
	            args.push(literal(ast.strings[ast.strings.length - 1]));
	            return importExpr(Identifiers.interpolate).callFn(args);
	        }
	    }, {
	        key: 'visitKeyedRead',
	        value: function visitKeyedRead(ast, mode) {
	            return convertToStatementIfNeeded(mode, ast.obj.visit(this, _Mode.Expression).key(ast.key.visit(this, _Mode.Expression)));
	        }
	    }, {
	        key: 'visitKeyedWrite',
	        value: function visitKeyedWrite(ast, mode) {
	            var obj = ast.obj.visit(this, _Mode.Expression);
	            var key = ast.key.visit(this, _Mode.Expression);
	            var value = ast.value.visit(this, _Mode.Expression);
	            return convertToStatementIfNeeded(mode, obj.key(key).set(value));
	        }
	    }, {
	        key: 'visitLiteralArray',
	        value: function visitLiteralArray(ast, mode) {
	            return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralArray(this.visitAll(ast.expressions, mode)));
	        }
	    }, {
	        key: 'visitLiteralMap',
	        value: function visitLiteralMap(ast, mode) {
	            var parts = [];
	            for (var i = 0; i < ast.keys.length; i++) {
	                parts.push([ast.keys[i], ast.values[i].visit(this, _Mode.Expression)]);
	            }
	            return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralMap(parts));
	        }
	    }, {
	        key: 'visitLiteralPrimitive',
	        value: function visitLiteralPrimitive(ast, mode) {
	            return convertToStatementIfNeeded(mode, literal(ast.value));
	        }
	    }, {
	        key: 'visitMethodCall',
	        value: function visitMethodCall(ast, mode) {
	            var args = this.visitAll(ast.args, _Mode.Expression);
	            var result = null;
	            var receiver = ast.receiver.visit(this, _Mode.Expression);
	            if (receiver === IMPLICIT_RECEIVER) {
	                var varExpr = this._nameResolver.getLocal(ast.name);
	                if (isPresent$3(varExpr)) {
	                    result = varExpr.callFn(args);
	                } else {
	                    receiver = this._implicitReceiver;
	                }
	            }
	            if (isBlank$3(result)) {
	                result = receiver.callMethod(ast.name, args);
	            }
	            return convertToStatementIfNeeded(mode, result);
	        }
	    }, {
	        key: 'visitPrefixNot',
	        value: function visitPrefixNot(ast, mode) {
	            return convertToStatementIfNeeded(mode, not(ast.expression.visit(this, _Mode.Expression)));
	        }
	    }, {
	        key: 'visitPropertyRead',
	        value: function visitPropertyRead(ast, mode) {
	            var result = null;
	            var receiver = ast.receiver.visit(this, _Mode.Expression);
	            if (receiver === IMPLICIT_RECEIVER) {
	                result = this._nameResolver.getLocal(ast.name);
	                if (isBlank$3(result)) {
	                    receiver = this._implicitReceiver;
	                }
	            }
	            if (isBlank$3(result)) {
	                result = receiver.prop(ast.name);
	            }
	            return convertToStatementIfNeeded(mode, result);
	        }
	    }, {
	        key: 'visitPropertyWrite',
	        value: function visitPropertyWrite(ast, mode) {
	            var receiver = ast.receiver.visit(this, _Mode.Expression);
	            if (receiver === IMPLICIT_RECEIVER) {
	                var varExpr = this._nameResolver.getLocal(ast.name);
	                if (isPresent$3(varExpr)) {
	                    throw new BaseException$3('Cannot assign to a reference or variable!');
	                }
	                receiver = this._implicitReceiver;
	            }
	            return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(ast.value.visit(this, _Mode.Expression)));
	        }
	    }, {
	        key: 'visitSafePropertyRead',
	        value: function visitSafePropertyRead(ast, mode) {
	            var receiver = ast.receiver.visit(this, _Mode.Expression);
	            return convertToStatementIfNeeded(mode, receiver.isBlank().conditional(NULL_EXPR, receiver.prop(ast.name)));
	        }
	    }, {
	        key: 'visitSafeMethodCall',
	        value: function visitSafeMethodCall(ast, mode) {
	            var receiver = ast.receiver.visit(this, _Mode.Expression);
	            var args = this.visitAll(ast.args, _Mode.Expression);
	            return convertToStatementIfNeeded(mode, receiver.isBlank().conditional(NULL_EXPR, receiver.callMethod(ast.name, args)));
	        }
	    }, {
	        key: 'visitAll',
	        value: function visitAll(asts, mode) {
	            var _this = this;

	            return asts.map(function (ast) {
	                return ast.visit(_this, mode);
	            });
	        }
	    }, {
	        key: 'visitQuote',
	        value: function visitQuote(ast, mode) {
	            throw new BaseException$3('Quotes are not supported for evaluation!');
	        }
	    }]);
	    return _AstToIrVisitor;
	}();

	function flattenStatements(arg, output) {
	    if (isArray$4(arg)) {
	        arg.forEach(function (entry) {
	            return flattenStatements(entry, output);
	        });
	    } else {
	        output.push(arg);
	    }
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var CompileBinding = function CompileBinding(node, sourceAst) {
	    classCallCheck(this, CompileBinding);

	    this.node = node;
	    this.sourceAst = sourceAst;
	};

	function createBindFieldExpr(exprIndex) {
	    return THIS_EXPR.prop('_expr_' + exprIndex);
	}
	function createCurrValueExpr(exprIndex) {
	    return variable('currVal_' + exprIndex); // fix syntax highlighting: `
	}
	function bind$1(view, currValExpr, fieldExpr, parsedExpression, context, actions, method) {
	    var checkExpression = convertCdExpressionToIr(view, context, parsedExpression, DetectChangesVars.valUnwrapper);
	    if (isBlank$3(checkExpression.expression)) {
	        // e.g. an empty expression was given
	        return;
	    }
	    // private is fine here as no child view will reference the cached value...
	    view.fields.push(new ClassField(fieldExpr.name, null, [StmtModifier.Private]));
	    view.createMethod.addStmt(THIS_EXPR.prop(fieldExpr.name).set(importExpr(Identifiers.uninitialized)).toStmt());
	    if (checkExpression.needsValueUnwrapper) {
	        var initValueUnwrapperStmt = DetectChangesVars.valUnwrapper.callMethod('reset', []).toStmt();
	        method.addStmt(initValueUnwrapperStmt);
	    }
	    method.addStmt(currValExpr.set(checkExpression.expression).toDeclStmt(null, [StmtModifier.Final]));
	    var condition = importExpr(Identifiers.checkBinding).callFn([DetectChangesVars.throwOnChange, fieldExpr, currValExpr]);
	    if (checkExpression.needsValueUnwrapper) {
	        condition = DetectChangesVars.valUnwrapper.prop('hasWrappedValue').or(condition);
	    }
	    method.addStmt(new IfStmt(condition, actions.concat([THIS_EXPR.prop(fieldExpr.name).set(currValExpr).toStmt()])));
	}
	function bindRenderText(boundText, compileNode, view) {
	    var bindingIndex = view.bindings.length;
	    view.bindings.push(new CompileBinding(compileNode, boundText));
	    var currValExpr = createCurrValueExpr(bindingIndex);
	    var valueField = createBindFieldExpr(bindingIndex);
	    view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
	    bind$1(view, currValExpr, valueField, boundText.value, view.componentContext, [THIS_EXPR.prop('renderer').callMethod('setText', [compileNode.renderNode, currValExpr]).toStmt()], view.detectChangesRenderPropertiesMethod);
	}
	function bindAndWriteToRenderer(boundProps, context, compileElement) {
	    var view = compileElement.view;
	    var renderNode = compileElement.renderNode;
	    boundProps.forEach(function (boundProp) {
	        var bindingIndex = view.bindings.length;
	        view.bindings.push(new CompileBinding(compileElement, boundProp));
	        view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
	        var fieldExpr = createBindFieldExpr(bindingIndex);
	        var currValExpr = createCurrValueExpr(bindingIndex);
	        var renderMethod;
	        var oldRenderValue = sanitizedValue(boundProp, fieldExpr);
	        var renderValue = sanitizedValue(boundProp, currValExpr);
	        var updateStmts = [];
	        switch (boundProp.type) {
	            case PropertyBindingType.Property:
	                if (view.genConfig.logBindingUpdate) {
	                    updateStmts.push(logBindingUpdateStmt(renderNode, boundProp.name, renderValue));
	                }
	                updateStmts.push(THIS_EXPR.prop('renderer').callMethod('setElementProperty', [renderNode, literal(boundProp.name), renderValue]).toStmt());
	                break;
	            case PropertyBindingType.Attribute:
	                renderValue = renderValue.isBlank().conditional(NULL_EXPR, renderValue.callMethod('toString', []));
	                updateStmts.push(THIS_EXPR.prop('renderer').callMethod('setElementAttribute', [renderNode, literal(boundProp.name), renderValue]).toStmt());
	                break;
	            case PropertyBindingType.Class:
	                updateStmts.push(THIS_EXPR.prop('renderer').callMethod('setElementClass', [renderNode, literal(boundProp.name), renderValue]).toStmt());
	                break;
	            case PropertyBindingType.Style:
	                var strValue = renderValue.callMethod('toString', []);
	                if (isPresent$3(boundProp.unit)) {
	                    strValue = strValue.plus(literal(boundProp.unit));
	                }
	                renderValue = renderValue.isBlank().conditional(NULL_EXPR, strValue);
	                updateStmts.push(THIS_EXPR.prop('renderer').callMethod('setElementStyle', [renderNode, literal(boundProp.name), renderValue]).toStmt());
	                break;
	            case PropertyBindingType.Animation:
	                var animationName = boundProp.name;
	                var animation = view.componentView.animations.get(animationName);
	                if (!isPresent$3(animation)) {
	                    throw new BaseException('Internal Error: couldn\'t find an animation entry for ' + boundProp.name);
	                }
	                // it's important to normalize the void value as `void` explicitly
	                // so that the styles data can be obtained from the stringmap
	                var emptyStateValue = literal(EMPTY_ANIMATION_STATE);
	                // void => ...
	                var oldRenderVar = variable('oldRenderVar');
	                updateStmts.push(oldRenderVar.set(oldRenderValue).toDeclStmt());
	                updateStmts.push(new IfStmt(oldRenderVar.equals(importExpr(Identifiers.uninitialized)), [oldRenderVar.set(emptyStateValue).toStmt()]));
	                // ... => void
	                var newRenderVar = variable('newRenderVar');
	                updateStmts.push(newRenderVar.set(renderValue).toDeclStmt());
	                updateStmts.push(new IfStmt(newRenderVar.equals(importExpr(Identifiers.uninitialized)), [newRenderVar.set(emptyStateValue).toStmt()]));
	                updateStmts.push(animation.fnVariable.callFn([THIS_EXPR, renderNode, oldRenderVar, newRenderVar]).toStmt());
	                view.detachMethod.addStmt(animation.fnVariable.callFn([THIS_EXPR, renderNode, oldRenderValue, emptyStateValue]).toStmt());
	                break;
	        }
	        bind$1(view, currValExpr, fieldExpr, boundProp.value, context, updateStmts, view.detectChangesRenderPropertiesMethod);
	    });
	}
	function sanitizedValue(boundProp, renderValue) {
	    var enumValue = void 0;
	    switch (boundProp.securityContext) {
	        case SecurityContext$2.NONE:
	            return renderValue; // No sanitization needed.
	        case SecurityContext$2.HTML:
	            enumValue = 'HTML';
	            break;
	        case SecurityContext$2.STYLE:
	            enumValue = 'STYLE';
	            break;
	        case SecurityContext$2.SCRIPT:
	            enumValue = 'SCRIPT';
	            break;
	        case SecurityContext$2.URL:
	            enumValue = 'URL';
	            break;
	        case SecurityContext$2.RESOURCE_URL:
	            enumValue = 'RESOURCE_URL';
	            break;
	        default:
	            throw new Error('internal error, unexpected SecurityContext ' + boundProp.securityContext + '.');
	    }
	    var ctx = ViewProperties.viewUtils.prop('sanitizer');
	    var args = [importExpr(Identifiers.SecurityContext).prop(enumValue), renderValue];
	    return ctx.callMethod('sanitize', args);
	}
	function bindRenderInputs(boundProps, compileElement) {
	    bindAndWriteToRenderer(boundProps, compileElement.view.componentContext, compileElement);
	}
	function bindDirectiveHostProps(directiveAst, directiveInstance, compileElement) {
	    bindAndWriteToRenderer(directiveAst.hostProperties, directiveInstance, compileElement);
	}
	function bindDirectiveInputs(directiveAst, directiveInstance, compileElement) {
	    if (directiveAst.inputs.length === 0) {
	        return;
	    }
	    var view = compileElement.view;
	    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
	    detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	    var lifecycleHooks = directiveAst.directive.lifecycleHooks;
	    var calcChangesMap = lifecycleHooks.indexOf(LifecycleHooks$1.OnChanges) !== -1;
	    var isOnPushComp = directiveAst.directive.isComponent && !isDefaultChangeDetectionStrategy$1(directiveAst.directive.changeDetection);
	    if (calcChangesMap) {
	        detectChangesInInputsMethod.addStmt(DetectChangesVars.changes.set(NULL_EXPR).toStmt());
	    }
	    if (isOnPushComp) {
	        detectChangesInInputsMethod.addStmt(DetectChangesVars.changed.set(literal(false)).toStmt());
	    }
	    directiveAst.inputs.forEach(function (input) {
	        var bindingIndex = view.bindings.length;
	        view.bindings.push(new CompileBinding(compileElement, input));
	        detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
	        var fieldExpr = createBindFieldExpr(bindingIndex);
	        var currValExpr = createCurrValueExpr(bindingIndex);
	        var statements = [directiveInstance.prop(input.directiveName).set(currValExpr).toStmt()];
	        if (calcChangesMap) {
	            statements.push(new IfStmt(DetectChangesVars.changes.identical(NULL_EXPR), [DetectChangesVars.changes.set(literalMap([], new MapType(importType(Identifiers.SimpleChange)))).toStmt()]));
	            statements.push(DetectChangesVars.changes.key(literal(input.directiveName)).set(importExpr(Identifiers.SimpleChange).instantiate([fieldExpr, currValExpr])).toStmt());
	        }
	        if (isOnPushComp) {
	            statements.push(DetectChangesVars.changed.set(literal(true)).toStmt());
	        }
	        if (view.genConfig.logBindingUpdate) {
	            statements.push(logBindingUpdateStmt(compileElement.renderNode, input.directiveName, currValExpr));
	        }
	        bind$1(view, currValExpr, fieldExpr, input.value, view.componentContext, statements, detectChangesInInputsMethod);
	    });
	    if (isOnPushComp) {
	        detectChangesInInputsMethod.addStmt(new IfStmt(DetectChangesVars.changed, [compileElement.appElement.prop('componentView').callMethod('markAsCheckOnce', []).toStmt()]));
	    }
	}
	function logBindingUpdateStmt(renderNode, propName, value) {
	    return THIS_EXPR.prop('renderer').callMethod('setBindingDebugInfo', [renderNode, literal('ng-reflect-' + camelCaseToDashCase$1(propName)), value.isBlank().conditional(NULL_EXPR, value.callMethod('toString', []))]).toStmt();
	}

	var CompileEventListener = function () {
	    function CompileEventListener(compileElement, eventTarget, eventName, listenerIndex) {
	        classCallCheck(this, CompileEventListener);

	        this.compileElement = compileElement;
	        this.eventTarget = eventTarget;
	        this.eventName = eventName;
	        this._hasComponentHostListener = false;
	        this._actionResultExprs = [];
	        this._method = new CompileMethod(compileElement.view);
	        this._methodName = '_handle_' + santitizeEventName(eventName) + '_' + compileElement.nodeIndex + '_' + listenerIndex;
	        this._eventParam = new FnParam(EventHandlerVars.event.name, importType(this.compileElement.view.genConfig.renderTypes.renderEvent));
	    }

	    createClass(CompileEventListener, [{
	        key: 'addAction',
	        value: function addAction(hostEvent, directive, directiveInstance) {
	            if (isPresent$3(directive) && directive.isComponent) {
	                this._hasComponentHostListener = true;
	            }
	            this._method.resetDebugInfo(this.compileElement.nodeIndex, hostEvent);
	            var context = isPresent$3(directiveInstance) ? directiveInstance : this.compileElement.view.componentContext;
	            var actionStmts = convertCdStatementToIr(this.compileElement.view, context, hostEvent.handler);
	            var lastIndex = actionStmts.length - 1;
	            if (lastIndex >= 0) {
	                var lastStatement = actionStmts[lastIndex];
	                var returnExpr = convertStmtIntoExpression(lastStatement);
	                var preventDefaultVar = variable('pd_' + this._actionResultExprs.length);
	                this._actionResultExprs.push(preventDefaultVar);
	                if (isPresent$3(returnExpr)) {
	                    // Note: We need to cast the result of the method call to dynamic,
	                    // as it might be a void method!
	                    actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false))).toDeclStmt(null, [StmtModifier.Final]);
	                }
	            }
	            this._method.addStmts(actionStmts);
	        }
	    }, {
	        key: 'finishMethod',
	        value: function finishMethod() {
	            var markPathToRootStart = this._hasComponentHostListener ? this.compileElement.appElement.prop('componentView') : THIS_EXPR;
	            var resultExpr = literal(true);
	            this._actionResultExprs.forEach(function (expr) {
	                resultExpr = resultExpr.and(expr);
	            });
	            var stmts = [markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt()].concat(this._method.finish()).concat([new ReturnStatement(resultExpr)]);
	            // private is fine here as no child view will reference the event handler...
	            this.compileElement.view.eventHandlerMethods.push(new ClassMethod(this._methodName, [this._eventParam], stmts, BOOL_TYPE, [StmtModifier.Private]));
	        }
	    }, {
	        key: 'listenToRenderer',
	        value: function listenToRenderer() {
	            var listenExpr;
	            var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.bind, [THIS_EXPR])]);
	            if (isPresent$3(this.eventTarget)) {
	                listenExpr = ViewProperties.renderer.callMethod('listenGlobal', [literal(this.eventTarget), literal(this.eventName), eventListener]);
	            } else {
	                listenExpr = ViewProperties.renderer.callMethod('listen', [this.compileElement.renderNode, literal(this.eventName), eventListener]);
	            }
	            var disposable = variable('disposable_' + this.compileElement.view.disposables.length);
	            this.compileElement.view.disposables.push(disposable);
	            // private is fine here as no child view will reference the event handler...
	            this.compileElement.view.createMethod.addStmt(disposable.set(listenExpr).toDeclStmt(FUNCTION_TYPE, [StmtModifier.Private]));
	        }
	    }, {
	        key: 'listenToDirective',
	        value: function listenToDirective(directiveInstance, observablePropName) {
	            var subscription = variable('subscription_' + this.compileElement.view.subscriptions.length);
	            this.compileElement.view.subscriptions.push(subscription);
	            var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.bind, [THIS_EXPR])]);
	            this.compileElement.view.createMethod.addStmt(subscription.set(directiveInstance.prop(observablePropName).callMethod(BuiltinMethod.SubscribeObservable, [eventListener])).toDeclStmt(null, [StmtModifier.Final]));
	        }
	    }], [{
	        key: 'getOrCreate',
	        value: function getOrCreate(compileElement, eventTarget, eventName, targetEventListeners) {
	            var listener = targetEventListeners.find(function (listener) {
	                return listener.eventTarget == eventTarget && listener.eventName == eventName;
	            });
	            if (isBlank$3(listener)) {
	                listener = new CompileEventListener(compileElement, eventTarget, eventName, targetEventListeners.length);
	                targetEventListeners.push(listener);
	            }
	            return listener;
	        }
	    }]);
	    return CompileEventListener;
	}();
	function collectEventListeners(hostEvents, dirs, compileElement) {
	    var eventListeners = [];
	    hostEvents.forEach(function (hostEvent) {
	        compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
	        var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
	        listener.addAction(hostEvent, null, null);
	    });
	    ListWrapper$3.forEachWithIndex(dirs, function (directiveAst, i) {
	        var directiveInstance = compileElement.directiveInstances[i];
	        directiveAst.hostEvents.forEach(function (hostEvent) {
	            compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
	            var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, eventListeners);
	            listener.addAction(hostEvent, directiveAst.directive, directiveInstance);
	        });
	    });
	    eventListeners.forEach(function (listener) {
	        return listener.finishMethod();
	    });
	    return eventListeners;
	}
	function bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners) {
	    StringMapWrapper$3.forEach(directiveAst.directive.outputs, function (eventName /** TODO #9100 */, observablePropName /** TODO #9100 */) {
	        eventListeners.filter(function (listener) {
	            return listener.eventName == eventName;
	        }).forEach(function (listener) {
	            listener.listenToDirective(directiveInstance, observablePropName);
	        });
	    });
	}
	function bindRenderOutputs(eventListeners) {
	    eventListeners.forEach(function (listener) {
	        return listener.listenToRenderer();
	    });
	}
	function convertStmtIntoExpression(stmt) {
	    if (stmt instanceof ExpressionStatement) {
	        return stmt.expr;
	    } else if (stmt instanceof ReturnStatement) {
	        return stmt.value;
	    }
	    return null;
	}
	function santitizeEventName(name) {
	    return StringWrapper$3.replaceAll(name, /[^a-zA-Z_]/g, '_');
	}

	var STATE_IS_NEVER_CHECKED = THIS_EXPR.prop('numberOfChecks').identical(new LiteralExpr(0));
	var NOT_THROW_ON_CHANGES = not(DetectChangesVars.throwOnChange);
	function bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement) {
	    var view = compileElement.view;
	    var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
	    var lifecycleHooks = directiveAst.directive.lifecycleHooks;
	    if (lifecycleHooks.indexOf(LifecycleHooks$1.OnChanges) !== -1 && directiveAst.inputs.length > 0) {
	        detectChangesInInputsMethod.addStmt(new IfStmt(DetectChangesVars.changes.notIdentical(NULL_EXPR), [directiveInstance.callMethod('ngOnChanges', [DetectChangesVars.changes]).toStmt()]));
	    }
	    if (lifecycleHooks.indexOf(LifecycleHooks$1.OnInit) !== -1) {
	        detectChangesInInputsMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED.and(NOT_THROW_ON_CHANGES), [directiveInstance.callMethod('ngOnInit', []).toStmt()]));
	    }
	    if (lifecycleHooks.indexOf(LifecycleHooks$1.DoCheck) !== -1) {
	        detectChangesInInputsMethod.addStmt(new IfStmt(NOT_THROW_ON_CHANGES, [directiveInstance.callMethod('ngDoCheck', []).toStmt()]));
	    }
	}
	function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
	    var view = compileElement.view;
	    var lifecycleHooks = directiveMeta.lifecycleHooks;
	    var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
	    afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	    if (lifecycleHooks.indexOf(LifecycleHooks$1.AfterContentInit) !== -1) {
	        afterContentLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
	    }
	    if (lifecycleHooks.indexOf(LifecycleHooks$1.AfterContentChecked) !== -1) {
	        afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
	    }
	}
	function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
	    var view = compileElement.view;
	    var lifecycleHooks = directiveMeta.lifecycleHooks;
	    var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
	    afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	    if (lifecycleHooks.indexOf(LifecycleHooks$1.AfterViewInit) !== -1) {
	        afterViewLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
	    }
	    if (lifecycleHooks.indexOf(LifecycleHooks$1.AfterViewChecked) !== -1) {
	        afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
	    }
	}
	function bindDirectiveDestroyLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
	    var onDestroyMethod = compileElement.view.destroyMethod;
	    onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
	    if (directiveMeta.lifecycleHooks.indexOf(LifecycleHooks$1.OnDestroy) !== -1) {
	        onDestroyMethod.addStmt(directiveInstance.callMethod('ngOnDestroy', []).toStmt());
	    }
	}
	function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
	    var onDestroyMethod = view.destroyMethod;
	    if (pipeMeta.lifecycleHooks.indexOf(LifecycleHooks$1.OnDestroy) !== -1) {
	        onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
	    }
	}

	function bindView(view, parsedTemplate) {
	    var visitor = new ViewBinderVisitor(view);
	    templateVisitAll(visitor, parsedTemplate);
	    view.pipes.forEach(function (pipe) {
	        bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view);
	    });
	}

	var ViewBinderVisitor = function () {
	    function ViewBinderVisitor(view) {
	        classCallCheck(this, ViewBinderVisitor);

	        this.view = view;
	        this._nodeIndex = 0;
	    }

	    createClass(ViewBinderVisitor, [{
	        key: 'visitBoundText',
	        value: function visitBoundText(ast, parent) {
	            var node = this.view.nodes[this._nodeIndex++];
	            bindRenderText(ast, node, this.view);
	            return null;
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, parent) {
	            this._nodeIndex++;
	            return null;
	        }
	    }, {
	        key: 'visitNgContent',
	        value: function visitNgContent(ast, parent) {
	            return null;
	        }
	    }, {
	        key: 'visitElement',
	        value: function visitElement(ast, parent) {
	            var compileElement = this.view.nodes[this._nodeIndex++];
	            var eventListeners = collectEventListeners(ast.outputs, ast.directives, compileElement);
	            bindRenderInputs(ast.inputs, compileElement);
	            bindRenderOutputs(eventListeners);
	            ListWrapper$3.forEachWithIndex(ast.directives, function (directiveAst, index) {
	                var directiveInstance = compileElement.directiveInstances[index];
	                bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
	                bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
	                bindDirectiveHostProps(directiveAst, directiveInstance, compileElement);
	                bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
	            });
	            templateVisitAll(this, ast.children, compileElement);
	            // afterContent and afterView lifecycles need to be called bottom up
	            // so that children are notified before parents
	            ListWrapper$3.forEachWithIndex(ast.directives, function (directiveAst, index) {
	                var directiveInstance = compileElement.directiveInstances[index];
	                bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveDestroyLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	            });
	            return null;
	        }
	    }, {
	        key: 'visitEmbeddedTemplate',
	        value: function visitEmbeddedTemplate(ast, parent) {
	            var compileElement = this.view.nodes[this._nodeIndex++];
	            var eventListeners = collectEventListeners(ast.outputs, ast.directives, compileElement);
	            ListWrapper$3.forEachWithIndex(ast.directives, function (directiveAst, index) {
	                var directiveInstance = compileElement.directiveInstances[index];
	                bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
	                bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
	                bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
	                bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	                bindDirectiveDestroyLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
	            });
	            bindView(compileElement.embeddedView, ast.children);
	            return null;
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitDirective',
	        value: function visitDirective(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitEvent',
	        value: function visitEvent(ast, eventTargetAndNames) {
	            return null;
	        }
	    }, {
	        key: 'visitReference',
	        value: function visitReference(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitVariable',
	        value: function visitVariable(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitDirectiveProperty',
	        value: function visitDirectiveProperty(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitElementProperty',
	        value: function visitElementProperty(ast, context) {
	            return null;
	        }
	    }]);
	    return ViewBinderVisitor;
	}();

	var IMPLICIT_TEMPLATE_VAR = '\$implicit';
	var CLASS_ATTR$1 = 'class';
	var STYLE_ATTR = 'style';
	var NG_CONTAINER_TAG = 'ng-container';
	var parentRenderNodeVar = variable('parentRenderNode');
	var rootSelectorVar = variable('rootSelector');
	var ViewFactoryDependency = function ViewFactoryDependency(comp, placeholder) {
	    classCallCheck(this, ViewFactoryDependency);

	    this.comp = comp;
	    this.placeholder = placeholder;
	};
	var ComponentFactoryDependency = function ComponentFactoryDependency(comp, placeholder) {
	    classCallCheck(this, ComponentFactoryDependency);

	    this.comp = comp;
	    this.placeholder = placeholder;
	};
	function buildView(view, template, targetDependencies) {
	    var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
	    templateVisitAll(builderVisitor, template, view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent);
	    return builderVisitor.nestedViewCount;
	}
	function finishView(view, targetStatements) {
	    view.afterNodes();
	    createViewTopLevelStmts(view, targetStatements);
	    view.nodes.forEach(function (node) {
	        if (node instanceof CompileElement && node.hasEmbeddedView) {
	            finishView(node.embeddedView, targetStatements);
	        }
	    });
	}

	var ViewBuilderVisitor = function () {
	    function ViewBuilderVisitor(view, targetDependencies) {
	        classCallCheck(this, ViewBuilderVisitor);

	        this.view = view;
	        this.targetDependencies = targetDependencies;
	        this.nestedViewCount = 0;
	        this._animationCompiler = new AnimationCompiler();
	    }

	    createClass(ViewBuilderVisitor, [{
	        key: '_isRootNode',
	        value: function _isRootNode(parent) {
	            return parent.view !== this.view;
	        }
	    }, {
	        key: '_addRootNodeAndProject',
	        value: function _addRootNodeAndProject(node) {
	            var projectedNode = _getOuterContainerOrSelf(node);
	            var parent = projectedNode.parent;
	            var ngContentIndex = projectedNode.sourceAst.ngContentIndex;
	            var vcAppEl = node instanceof CompileElement && node.hasViewContainer ? node.appElement : null;
	            if (this._isRootNode(parent)) {
	                // store appElement as root node only for ViewContainers
	                if (this.view.viewType !== ViewType$1.COMPONENT) {
	                    this.view.rootNodesOrAppElements.push(isPresent$3(vcAppEl) ? vcAppEl : node.renderNode);
	                }
	            } else if (isPresent$3(parent.component) && isPresent$3(ngContentIndex)) {
	                parent.addContentNode(ngContentIndex, isPresent$3(vcAppEl) ? vcAppEl : node.renderNode);
	            }
	        }
	    }, {
	        key: '_getParentRenderNode',
	        value: function _getParentRenderNode(parent) {
	            parent = _getOuterContainerParentOrSelf(parent);
	            if (this._isRootNode(parent)) {
	                if (this.view.viewType === ViewType$1.COMPONENT) {
	                    return parentRenderNodeVar;
	                } else {
	                    // root node of an embedded/host view
	                    return NULL_EXPR;
	                }
	            } else {
	                return isPresent$3(parent.component) && parent.component.template.encapsulation !== ViewEncapsulation.Native ? NULL_EXPR : parent.renderNode;
	            }
	        }
	    }, {
	        key: 'visitBoundText',
	        value: function visitBoundText(ast, parent) {
	            return this._visitText(ast, '', parent);
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, parent) {
	            return this._visitText(ast, ast.value, parent);
	        }
	    }, {
	        key: '_visitText',
	        value: function _visitText(ast, value, parent) {
	            var fieldName = '_text_' + this.view.nodes.length;
	            this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderText)));
	            var renderNode = THIS_EXPR.prop(fieldName);
	            var compileNode = new CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
	            var createRenderNode = THIS_EXPR.prop(fieldName).set(ViewProperties.renderer.callMethod('createText', [this._getParentRenderNode(parent), literal(value), this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)])).toStmt();
	            this.view.nodes.push(compileNode);
	            this.view.createMethod.addStmt(createRenderNode);
	            this._addRootNodeAndProject(compileNode);
	            return renderNode;
	        }
	    }, {
	        key: 'visitNgContent',
	        value: function visitNgContent(ast, parent) {
	            // the projected nodes originate from a different view, so we don't
	            // have debug information for them...
	            this.view.createMethod.resetDebugInfo(null, ast);
	            var parentRenderNode = this._getParentRenderNode(parent);
	            var nodesExpression = ViewProperties.projectableNodes.key(literal(ast.index), new ArrayType(importType(this.view.genConfig.renderTypes.renderNode)));
	            if (parentRenderNode !== NULL_EXPR) {
	                this.view.createMethod.addStmt(ViewProperties.renderer.callMethod('projectNodes', [parentRenderNode, importExpr(Identifiers.flattenNestedViewRenderNodes).callFn([nodesExpression])]).toStmt());
	            } else if (this._isRootNode(parent)) {
	                if (this.view.viewType !== ViewType$1.COMPONENT) {
	                    // store root nodes only for embedded/host views
	                    this.view.rootNodesOrAppElements.push(nodesExpression);
	                }
	            } else {
	                if (isPresent$3(parent.component) && isPresent$3(ast.ngContentIndex)) {
	                    parent.addContentNode(ast.ngContentIndex, nodesExpression);
	                }
	            }
	            return null;
	        }
	    }, {
	        key: 'visitElement',
	        value: function visitElement(ast, parent) {
	            var _this = this;

	            var nodeIndex = this.view.nodes.length;
	            var createRenderNodeExpr;
	            var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
	            if (nodeIndex === 0 && this.view.viewType === ViewType$1.HOST) {
	                createRenderNodeExpr = THIS_EXPR.callMethod('selectOrCreateHostElement', [literal(ast.name), rootSelectorVar, debugContextExpr]);
	            } else {
	                if (ast.name === NG_CONTAINER_TAG) {
	                    createRenderNodeExpr = ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), debugContextExpr]);
	                } else {
	                    createRenderNodeExpr = ViewProperties.renderer.callMethod('createElement', [this._getParentRenderNode(parent), literal(ast.name), debugContextExpr]);
	                }
	            }
	            var fieldName = '_el_' + nodeIndex;
	            this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderElement)));
	            this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
	            var renderNode = THIS_EXPR.prop(fieldName);
	            var directives = ast.directives.map(function (directiveAst) {
	                return directiveAst.directive;
	            });
	            var component = directives.find(function (directive) {
	                return directive.isComponent;
	            });
	            var htmlAttrs = _readHtmlAttrs(ast.attrs);
	            var attrNameAndValues = _mergeHtmlAndDirectiveAttrs(htmlAttrs, directives);
	            for (var i = 0; i < attrNameAndValues.length; i++) {
	                var attrName = attrNameAndValues[i][0];
	                var attrValue = attrNameAndValues[i][1];
	                this.view.createMethod.addStmt(ViewProperties.renderer.callMethod('setElementAttribute', [renderNode, literal(attrName), literal(attrValue)]).toStmt());
	            }
	            var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references);
	            this.view.nodes.push(compileElement);
	            var compViewExpr = null;
	            if (isPresent$3(component)) {
	                var nestedComponentIdentifier = new CompileIdentifierMetadata({ name: getViewFactoryName(component, 0) });
	                this.targetDependencies.push(new ViewFactoryDependency(component.type, nestedComponentIdentifier));
	                var precompileComponentIdentifiers = component.precompile.map(function (precompileComp) {
	                    var id = new CompileIdentifierMetadata({ name: precompileComp.name });
	                    _this.targetDependencies.push(new ComponentFactoryDependency(precompileComp, id));
	                    return id;
	                });
	                compileElement.createComponentFactoryResolver(precompileComponentIdentifiers);
	                compViewExpr = variable('compView_' + nodeIndex); // fix highlighting: `
	                compileElement.setComponentView(compViewExpr);
	                this.view.createMethod.addStmt(compViewExpr.set(importExpr(nestedComponentIdentifier).callFn([ViewProperties.viewUtils, compileElement.injector, compileElement.appElement])).toDeclStmt());
	            }
	            compileElement.beforeChildren();
	            this._addRootNodeAndProject(compileElement);
	            templateVisitAll(this, ast.children, compileElement);
	            compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
	            if (isPresent$3(compViewExpr)) {
	                var codeGenContentNodes;
	                if (this.view.component.type.isHost) {
	                    codeGenContentNodes = ViewProperties.projectableNodes;
	                } else {
	                    codeGenContentNodes = literalArr(compileElement.contentNodesByNgContentIndex.map(function (nodes) {
	                        return createFlatArray(nodes);
	                    }));
	                }
	                this.view.createMethod.addStmt(compViewExpr.callMethod('create', [compileElement.getComponent(), codeGenContentNodes, NULL_EXPR]).toStmt());
	            }
	            return null;
	        }
	    }, {
	        key: 'visitEmbeddedTemplate',
	        value: function visitEmbeddedTemplate(ast, parent) {
	            var nodeIndex = this.view.nodes.length;
	            var fieldName = '_anchor_' + nodeIndex;
	            this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderComment)));
	            this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)])).toStmt());
	            var renderNode = THIS_EXPR.prop(fieldName);
	            var templateVariableBindings = ast.variables.map(function (varAst) {
	                return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name];
	            });
	            var directives = ast.directives.map(function (directiveAst) {
	                return directiveAst.directive;
	            });
	            var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references);
	            this.view.nodes.push(compileElement);
	            var compiledAnimations = this._animationCompiler.compileComponent(this.view.component);
	            this.nestedViewCount++;
	            var embeddedView = new CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, NULL_EXPR, compiledAnimations, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);
	            this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
	            compileElement.beforeChildren();
	            this._addRootNodeAndProject(compileElement);
	            compileElement.afterChildren(0);
	            return null;
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitDirective',
	        value: function visitDirective(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitEvent',
	        value: function visitEvent(ast, eventTargetAndNames) {
	            return null;
	        }
	    }, {
	        key: 'visitReference',
	        value: function visitReference(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitVariable',
	        value: function visitVariable(ast, ctx) {
	            return null;
	        }
	    }, {
	        key: 'visitDirectiveProperty',
	        value: function visitDirectiveProperty(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitElementProperty',
	        value: function visitElementProperty(ast, context) {
	            return null;
	        }
	    }]);
	    return ViewBuilderVisitor;
	}();
	/**
	 * Walks up the nodes while the direct parent is a container.
	 *
	 * Returns the outer container or the node itself when it is not a direct child of a container.
	 *
	 * @internal
	 */


	function _getOuterContainerOrSelf(node) {
	    var view = node.view;
	    while (_isNgContainer(node.parent, view)) {
	        node = node.parent;
	    }
	    return node;
	}
	/**
	 * Walks up the nodes while they are container and returns the first parent which is not.
	 *
	 * Returns the parent of the outer container or the node itself when it is not a container.
	 *
	 * @internal
	 */
	function _getOuterContainerParentOrSelf(el) {
	    var view = el.view;
	    while (_isNgContainer(el, view)) {
	        el = el.parent;
	    }
	    return el;
	}
	function _isNgContainer(node, view) {
	    return !node.isNull() && node.sourceAst.name === NG_CONTAINER_TAG && node.view === view;
	}
	function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
	    var result = {};
	    StringMapWrapper$3.forEach(declaredHtmlAttrs, function (value, key) {
	        result[key] = value;
	    });
	    directives.forEach(function (directiveMeta) {
	        StringMapWrapper$3.forEach(directiveMeta.hostAttributes, function (value, name) {
	            var prevValue = result[name];
	            result[name] = isPresent$3(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
	        });
	    });
	    return mapToKeyValueArray(result);
	}
	function _readHtmlAttrs(attrs) {
	    var htmlAttrs = {};
	    attrs.forEach(function (ast) {
	        htmlAttrs[ast.name] = ast.value;
	    });
	    return htmlAttrs;
	}
	function mergeAttributeValue(attrName, attrValue1, attrValue2) {
	    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
	        return attrValue1 + ' ' + attrValue2;
	    } else {
	        return attrValue2;
	    }
	}
	function mapToKeyValueArray(data) {
	    var entryArray = [];
	    StringMapWrapper$3.forEach(data, function (value, name) {
	        entryArray.push([name, value]);
	    });
	    // We need to sort to get a defined output order
	    // for tests and for caching generated artifacts...
	    ListWrapper$3.sort(entryArray, function (entry1, entry2) {
	        return StringWrapper$3.compare(entry1[0], entry2[0]);
	    });
	    return entryArray;
	}
	function createViewTopLevelStmts(view, targetStatements) {
	    var nodeDebugInfosVar = NULL_EXPR;
	    if (view.genConfig.genDebugInfo) {
	        nodeDebugInfosVar = variable('nodeDebugInfos_' + view.component.type.name + view.viewIndex); // fix highlighting: `
	        targetStatements.push(nodeDebugInfosVar.set(literalArr(view.nodes.map(createStaticNodeDebugInfo), new ArrayType(new ExternalType(Identifiers.StaticNodeDebugInfo), [TypeModifier.Const]))).toDeclStmt(null, [StmtModifier.Final]));
	    }
	    var renderCompTypeVar = variable('renderType_' + view.component.type.name); // fix highlighting: `
	    if (view.viewIndex === 0) {
	        targetStatements.push(renderCompTypeVar.set(NULL_EXPR).toDeclStmt(importType(Identifiers.RenderComponentType)));
	    }
	    var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
	    targetStatements.push(viewClass);
	    targetStatements.push(createViewFactory(view, viewClass, renderCompTypeVar));
	}
	function createStaticNodeDebugInfo(node) {
	    var compileElement = node instanceof CompileElement ? node : null;
	    var providerTokens = [];
	    var componentToken = NULL_EXPR;
	    var varTokenEntries = [];
	    if (isPresent$3(compileElement)) {
	        providerTokens = compileElement.getProviderTokens();
	        if (isPresent$3(compileElement.component)) {
	            componentToken = createDiTokenExpression(identifierToken(compileElement.component.type));
	        }
	        StringMapWrapper$3.forEach(compileElement.referenceTokens, function (token, varName) {
	            varTokenEntries.push([varName, isPresent$3(token) ? createDiTokenExpression(token) : NULL_EXPR]);
	        });
	    }
	    return importExpr(Identifiers.StaticNodeDebugInfo).instantiate([literalArr(providerTokens, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])), componentToken, literalMap(varTokenEntries, new MapType(DYNAMIC_TYPE, [TypeModifier.Const]))], importType(Identifiers.StaticNodeDebugInfo, null, [TypeModifier.Const]));
	}
	function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
	    var viewConstructorArgs = [new FnParam(ViewConstructorVars.viewUtils.name, importType(Identifiers.ViewUtils)), new FnParam(ViewConstructorVars.parentInjector.name, importType(Identifiers.Injector)), new FnParam(ViewConstructorVars.declarationEl.name, importType(Identifiers.AppElement))];
	    var superConstructorArgs = [variable(view.className), renderCompTypeVar, ViewTypeEnum.fromValue(view.viewType), ViewConstructorVars.viewUtils, ViewConstructorVars.parentInjector, ViewConstructorVars.declarationEl, ChangeDetectorStatusEnum.fromValue(getChangeDetectionMode(view))];
	    if (view.genConfig.genDebugInfo) {
	        superConstructorArgs.push(nodeDebugInfosVar);
	    }
	    var viewConstructor = new ClassMethod(null, viewConstructorArgs, [SUPER_EXPR.callFn(superConstructorArgs).toStmt()]);
	    var viewMethods = [new ClassMethod('createInternal', [new FnParam(rootSelectorVar.name, STRING_TYPE)], generateCreateMethod(view), importType(Identifiers.AppElement)), new ClassMethod('injectorGetInternal', [new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),
	    // Note: Can't use o.INT_TYPE here as the method in AppView uses number
	    new FnParam(InjectMethodVars.requestNodeIndex.name, NUMBER_TYPE), new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), InjectMethodVars.notFoundResult), DYNAMIC_TYPE), new ClassMethod('detectChangesInternal', [new FnParam(DetectChangesVars.throwOnChange.name, BOOL_TYPE)], generateDetectChangesMethod(view)), new ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()), new ClassMethod('destroyInternal', [], view.destroyMethod.finish()), new ClassMethod('detachInternal', [], view.detachMethod.finish())].concat(view.eventHandlerMethods);
	    var superClass = view.genConfig.genDebugInfo ? Identifiers.DebugAppView : Identifiers.AppView;
	    var viewClass = new ClassStmt(view.className, importExpr(superClass, [getContextType(view)]), view.fields, view.getters, viewConstructor, viewMethods.filter(function (method) {
	        return method.body.length > 0;
	    }));
	    return viewClass;
	}
	function createViewFactory(view, viewClass, renderCompTypeVar) {
	    var viewFactoryArgs = [new FnParam(ViewConstructorVars.viewUtils.name, importType(Identifiers.ViewUtils)), new FnParam(ViewConstructorVars.parentInjector.name, importType(Identifiers.Injector)), new FnParam(ViewConstructorVars.declarationEl.name, importType(Identifiers.AppElement))];
	    var initRenderCompTypeStmts = [];
	    var templateUrlInfo;
	    if (view.component.template.templateUrl == view.component.type.moduleUrl) {
	        templateUrlInfo = view.component.type.moduleUrl + ' class ' + view.component.type.name + ' - inline template';
	    } else {
	        templateUrlInfo = view.component.template.templateUrl;
	    }
	    if (view.viewIndex === 0) {
	        initRenderCompTypeStmts = [new IfStmt(renderCompTypeVar.identical(NULL_EXPR), [renderCompTypeVar.set(ViewConstructorVars.viewUtils.callMethod('createRenderComponentType', [literal(templateUrlInfo), literal(view.component.template.ngContentSelectors.length), ViewEncapsulationEnum.fromValue(view.component.template.encapsulation), view.styles])).toStmt()])];
	    }
	    return fn(viewFactoryArgs, initRenderCompTypeStmts.concat([new ReturnStatement(variable(viewClass.name).instantiate(viewClass.constructorMethod.params.map(function (param) {
	        return variable(param.name);
	    })))]), importType(Identifiers.AppView, [getContextType(view)])).toDeclStmt(view.viewFactory.name, [StmtModifier.Final]);
	}
	function generateCreateMethod(view) {
	    var parentRenderNodeExpr = NULL_EXPR;
	    var parentRenderNodeStmts = [];
	    if (view.viewType === ViewType$1.COMPONENT) {
	        parentRenderNodeExpr = ViewProperties.renderer.callMethod('createViewRoot', [THIS_EXPR.prop('declarationAppElement').prop('nativeElement')]);
	        parentRenderNodeStmts = [parentRenderNodeVar.set(parentRenderNodeExpr).toDeclStmt(importType(view.genConfig.renderTypes.renderNode), [StmtModifier.Final])];
	    }
	    var resultExpr;
	    if (view.viewType === ViewType$1.HOST) {
	        resultExpr = view.nodes[0].appElement;
	    } else {
	        resultExpr = NULL_EXPR;
	    }
	    return parentRenderNodeStmts.concat(view.createMethod.finish(), [THIS_EXPR.callMethod('init', [createFlatArray(view.rootNodesOrAppElements), literalArr(view.nodes.map(function (node) {
	        return node.renderNode;
	    })), literalArr(view.disposables), literalArr(view.subscriptions)]).toStmt(), new ReturnStatement(resultExpr)]);
	}
	function generateDetectChangesMethod(view) {
	    var stmts = [];
	    if (view.detectChangesInInputsMethod.isEmpty() && view.updateContentQueriesMethod.isEmpty() && view.afterContentLifecycleCallbacksMethod.isEmpty() && view.detectChangesRenderPropertiesMethod.isEmpty() && view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty()) {
	        return stmts;
	    }
	    ListWrapper$3.addAll(stmts, view.detectChangesInInputsMethod.finish());
	    stmts.push(THIS_EXPR.callMethod('detectContentChildrenChanges', [DetectChangesVars.throwOnChange]).toStmt());
	    var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
	    if (afterContentStmts.length > 0) {
	        stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterContentStmts));
	    }
	    ListWrapper$3.addAll(stmts, view.detectChangesRenderPropertiesMethod.finish());
	    stmts.push(THIS_EXPR.callMethod('detectViewChildrenChanges', [DetectChangesVars.throwOnChange]).toStmt());
	    var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
	    if (afterViewStmts.length > 0) {
	        stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterViewStmts));
	    }
	    var varStmts = [];
	    var readVars = findReadVarNames(stmts);
	    if (SetWrapper$3.has(readVars, DetectChangesVars.changed.name)) {
	        varStmts.push(DetectChangesVars.changed.set(literal(true)).toDeclStmt(BOOL_TYPE));
	    }
	    if (SetWrapper$3.has(readVars, DetectChangesVars.changes.name)) {
	        varStmts.push(DetectChangesVars.changes.set(NULL_EXPR).toDeclStmt(new MapType(importType(Identifiers.SimpleChange))));
	    }
	    if (SetWrapper$3.has(readVars, DetectChangesVars.valUnwrapper.name)) {
	        varStmts.push(DetectChangesVars.valUnwrapper.set(importExpr(Identifiers.ValueUnwrapper).instantiate([])).toDeclStmt(null, [StmtModifier.Final]));
	    }
	    return varStmts.concat(stmts);
	}
	function addReturnValuefNotEmpty(statements, value) {
	    if (statements.length > 0) {
	        return statements.concat([new ReturnStatement(value)]);
	    } else {
	        return statements;
	    }
	}
	function getContextType(view) {
	    if (view.viewType === ViewType$1.COMPONENT) {
	        return importType(view.component.type);
	    }
	    return DYNAMIC_TYPE;
	}
	function getChangeDetectionMode(view) {
	    var mode;
	    if (view.viewType === ViewType$1.COMPONENT) {
	        mode = isDefaultChangeDetectionStrategy$1(view.component.changeDetection) ? ChangeDetectorStatus$1.CheckAlways : ChangeDetectorStatus$1.CheckOnce;
	    } else {
	        mode = ChangeDetectorStatus$1.CheckAlways;
	    }
	    return mode;
	}

	var ViewCompileResult = function ViewCompileResult(statements, viewFactoryVar, dependencies) {
	    classCallCheck(this, ViewCompileResult);

	    this.statements = statements;
	    this.viewFactoryVar = viewFactoryVar;
	    this.dependencies = dependencies;
	};
	var ViewCompiler = function () {
	    function ViewCompiler(_genConfig) {
	        classCallCheck(this, ViewCompiler);

	        this._genConfig = _genConfig;
	        this._animationCompiler = new AnimationCompiler();
	    }

	    createClass(ViewCompiler, [{
	        key: 'compileComponent',
	        value: function compileComponent(component, template, styles, pipes) {
	            var dependencies = [];
	            var compiledAnimations = this._animationCompiler.compileComponent(component);
	            var statements = [];
	            compiledAnimations.map(function (entry) {
	                statements.push(entry.statesMapStatement);
	                statements.push(entry.fnStatement);
	            });
	            var view = new CompileView(component, this._genConfig, pipes, styles, compiledAnimations, 0, CompileElement.createNull(), []);
	            buildView(view, template, dependencies);
	            // Need to separate binding from creation to be able to refer to
	            // variables that have been declared after usage.
	            bindView(view, template);
	            finishView(view, statements);
	            return new ViewCompileResult(statements, view.viewFactory.name, dependencies);
	        }
	    }]);
	    return ViewCompiler;
	}();
	/** @nocollapse */
	ViewCompiler.decorators = [{ type: Injectable }];
	/** @nocollapse */
	ViewCompiler.ctorParameters = [{ type: CompilerConfig }];

	var _COMPONENT_FACTORY_IDENTIFIER = new CompileIdentifierMetadata({
	    name: 'ComponentFactory',
	    runtime: ComponentFactory,
	    moduleUrl: assetUrl('core', 'linker/component_factory')
	});
	var SourceModule = function SourceModule(moduleUrl, source) {
	    classCallCheck(this, SourceModule);

	    this.moduleUrl = moduleUrl;
	    this.source = source;
	};
	var OfflineCompiler = function () {
	    function OfflineCompiler(_directiveNormalizer, _templateParser, _styleCompiler, _viewCompiler, _outputEmitter) {
	        classCallCheck(this, OfflineCompiler);

	        this._directiveNormalizer = _directiveNormalizer;
	        this._templateParser = _templateParser;
	        this._styleCompiler = _styleCompiler;
	        this._viewCompiler = _viewCompiler;
	        this._outputEmitter = _outputEmitter;
	    }

	    createClass(OfflineCompiler, [{
	        key: 'normalizeDirectiveMetadata',
	        value: function normalizeDirectiveMetadata(directive) {
	            return this._directiveNormalizer.normalizeDirective(directive).asyncResult;
	        }
	    }, {
	        key: 'compileTemplates',
	        value: function compileTemplates(components) {
	            var _this = this;

	            if (components.length === 0) {
	                throw new BaseException$3('No components given');
	            }
	            var statements = [];
	            var exportedVars = [];
	            var moduleUrl = _ngfactoryModuleUrl(components[0].component.type);
	            var outputSourceModules = [];
	            components.forEach(function (componentWithDirs) {
	                var compMeta = componentWithDirs.component;
	                _assertComponent(compMeta);
	                var fileSuffix = _splitLastSuffix(compMeta.type.moduleUrl)[1];
	                var stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);
	                stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {
	                    outputSourceModules.push(_this._codgenStyles(compiledStyleSheet, fileSuffix));
	                });
	                var compViewFactoryVar = _this._compileComponent(compMeta, componentWithDirs.directives, componentWithDirs.pipes, stylesCompileResults.componentStylesheet, fileSuffix, statements);
	                exportedVars.push(compViewFactoryVar);
	                var hostMeta = createHostComponentMeta(compMeta.type, compMeta.selector);
	                var hostViewFactoryVar = _this._compileComponent(hostMeta, [compMeta], [], null, fileSuffix, statements);
	                var compFactoryVar = _componentFactoryName(compMeta.type);
	                statements.push(variable(compFactoryVar).set(importExpr(_COMPONENT_FACTORY_IDENTIFIER, [importType(compMeta.type)]).instantiate([literal(compMeta.selector), variable(hostViewFactoryVar), importExpr(compMeta.type)], importType(_COMPONENT_FACTORY_IDENTIFIER, [importType(compMeta.type)], [TypeModifier.Const]))).toDeclStmt(null, [StmtModifier.Final]));
	                exportedVars.push(compFactoryVar);
	            });
	            outputSourceModules.unshift(this._codegenSourceModule(moduleUrl, statements, exportedVars));
	            return outputSourceModules;
	        }
	    }, {
	        key: '_compileComponent',
	        value: function _compileComponent(compMeta, directives, pipes, componentStyles, fileSuffix, targetStatements) {
	            var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, compMeta.type.name);
	            var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);
	            var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, pipes);
	            if (componentStyles) {
	                ListWrapper$3.addAll(targetStatements, _resolveStyleStatements(componentStyles, fileSuffix));
	            }
	            ListWrapper$3.addAll(targetStatements, _resolveViewStatements(viewResult));
	            return viewResult.viewFactoryVar;
	        }
	    }, {
	        key: '_codgenStyles',
	        value: function _codgenStyles(stylesCompileResult, fileSuffix) {
	            _resolveStyleStatements(stylesCompileResult, fileSuffix);
	            return this._codegenSourceModule(_stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
	        }
	    }, {
	        key: '_codegenSourceModule',
	        value: function _codegenSourceModule(moduleUrl, statements, exportedVars) {
	            return new SourceModule(moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));
	        }
	    }]);
	    return OfflineCompiler;
	}();
	function _resolveViewStatements(compileResult) {
	    compileResult.dependencies.forEach(function (dep) {
	        if (dep instanceof ViewFactoryDependency) {
	            var vfd = dep;
	            vfd.placeholder.moduleUrl = _ngfactoryModuleUrl(vfd.comp);
	        } else if (dep instanceof ComponentFactoryDependency) {
	            var cfd = dep;
	            cfd.placeholder.name = _componentFactoryName(cfd.comp);
	            cfd.placeholder.moduleUrl = _ngfactoryModuleUrl(cfd.comp);
	        }
	    });
	    return compileResult.statements;
	}
	function _resolveStyleStatements(compileResult, fileSuffix) {
	    compileResult.dependencies.forEach(function (dep) {
	        dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix);
	    });
	    return compileResult.statements;
	}
	function _ngfactoryModuleUrl(comp) {
	    var urlWithSuffix = _splitLastSuffix(comp.moduleUrl);
	    return urlWithSuffix[0] + '.ngfactory' + urlWithSuffix[1];
	}
	function _componentFactoryName(comp) {
	    return comp.name + 'NgFactory';
	}
	function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
	    return shim ? stylesheetUrl + '.shim' + suffix : '' + stylesheetUrl + suffix;
	}
	function _assertComponent(meta) {
	    if (!meta.isComponent) {
	        throw new BaseException$3('Could not compile \'' + meta.type.name + '\' because it is not a component.');
	    }
	}
	function _splitLastSuffix(path) {
	    var lastDot = path.lastIndexOf('.');
	    if (lastDot !== -1) {
	        return [path.substring(0, lastDot), path.substring(lastDot)];
	    } else {
	        return [path, ''];
	    }
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PromiseCompleter$3 = function PromiseCompleter() {
	    var _this = this;

	    classCallCheck(this, PromiseCompleter);

	    this.promise = new Promise(function (res, rej) {
	        _this.resolve = res;
	        _this.reject = rej;
	    });
	};
	var PromiseWrapper$3 = function () {
	    function PromiseWrapper() {
	        classCallCheck(this, PromiseWrapper);
	    }

	    createClass(PromiseWrapper, null, [{
	        key: "resolve",
	        value: function resolve(obj) {
	            return Promise.resolve(obj);
	        }
	    }, {
	        key: "reject",
	        value: function reject(obj, _) {
	            return Promise.reject(obj);
	        }
	        // Note: We can't rename this method into `catch`, as this is not a valid
	        // method name in Dart.

	    }, {
	        key: "catchError",
	        value: function catchError(promise, onError) {
	            return promise.catch(onError);
	        }
	    }, {
	        key: "all",
	        value: function all(promises) {
	            if (promises.length == 0) return Promise.resolve([]);
	            return Promise.all(promises);
	        }
	    }, {
	        key: "then",
	        value: function then(promise, success, rejection) {
	            return promise.then(success, rejection);
	        }
	    }, {
	        key: "wrap",
	        value: function wrap(computation) {
	            return new Promise(function (res, rej) {
	                try {
	                    res(computation());
	                } catch (e) {
	                    rej(e);
	                }
	            });
	        }
	    }, {
	        key: "scheduleMicrotask",
	        value: function scheduleMicrotask(computation) {
	            PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) {});
	        }
	    }, {
	        key: "completer",
	        value: function completer() {
	            return new PromiseCompleter$3();
	        }
	    }]);
	    return PromiseWrapper;
	}();

	var TimerWrapper$3 = function () {
	    function TimerWrapper() {
	        classCallCheck(this, TimerWrapper);
	    }

	    createClass(TimerWrapper, null, [{
	        key: 'setTimeout',
	        value: function setTimeout(fn, millis) {
	            return global$4.setTimeout(fn, millis);
	        }
	    }, {
	        key: 'clearTimeout',
	        value: function clearTimeout(id) {
	            global$4.clearTimeout(id);
	        }
	    }, {
	        key: 'setInterval',
	        value: function setInterval(fn, millis) {
	            return global$4.setInterval(fn, millis);
	        }
	    }, {
	        key: 'clearInterval',
	        value: function clearInterval(id) {
	            global$4.clearInterval(id);
	        }
	    }]);
	    return TimerWrapper;
	}();
	var ObservableWrapper$3 = function () {
	    function ObservableWrapper() {
	        classCallCheck(this, ObservableWrapper);
	    }

	    createClass(ObservableWrapper, null, [{
	        key: 'subscribe',

	        // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	        value: function subscribe(emitter, onNext, onError) {
	            var onComplete = arguments.length <= 3 || arguments[3] === undefined ? function () {} : arguments[3];

	            onError = typeof onError === 'function' && onError || noop$3;
	            onComplete = typeof onComplete === 'function' && onComplete || noop$3;
	            return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
	        }
	    }, {
	        key: 'isObservable',
	        value: function isObservable(obs) {
	            return !!obs.subscribe;
	        }
	        /**
	         * Returns whether `obs` has any subscribers listening to events.
	         */

	    }, {
	        key: 'hasSubscribers',
	        value: function hasSubscribers(obs) {
	            return obs.observers.length > 0;
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {
	            subscription.unsubscribe();
	        }
	        /**
	         * @deprecated - use callEmit() instead
	         */

	    }, {
	        key: 'callNext',
	        value: function callNext(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callEmit',
	        value: function callEmit(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callError',
	        value: function callError(emitter, error) {
	            emitter.error(error);
	        }
	    }, {
	        key: 'callComplete',
	        value: function callComplete(emitter) {
	            emitter.complete();
	        }
	    }, {
	        key: 'fromPromise',
	        value: function fromPromise(promise) {
	            return PromiseObservable.create(promise);
	        }
	    }, {
	        key: 'toPromise',
	        value: function toPromise(obj) {
	            return _toPromise.call(obj);
	        }
	    }]);
	    return ObservableWrapper;
	}();
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter$3 = function (_Subject) {
	    inherits(EventEmitter, _Subject);

	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */

	    function EventEmitter() {
	        var isAsync = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	        classCallCheck(this, EventEmitter);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EventEmitter).call(this));

	        _this.__isAsync = isAsync;
	        return _this;
	    }

	    createClass(EventEmitter, [{
	        key: 'emit',
	        value: function emit(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	        /**
	         * @deprecated - use .emit(value) instead
	         */

	    }, {
	        key: 'next',
	        value: function next(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	    }, {
	        key: 'subscribe',
	        value: function subscribe(generatorOrNext, error, complete) {
	            var schedulerFn = void 0;
	            var errorFn = function errorFn(err) {
	                return null;
	            };
	            var completeFn = function completeFn() {
	                return null;
	            };
	            if (generatorOrNext && (typeof generatorOrNext === 'undefined' ? 'undefined' : _typeof(generatorOrNext)) === 'object') {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext.next(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext.next(value);
	                };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return generatorOrNext.error(err);
	                        });
	                    } : function (err) {
	                        generatorOrNext.error(err);
	                    };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return generatorOrNext.complete();
	                        });
	                    } : function () {
	                        generatorOrNext.complete();
	                    };
	                }
	            } else {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext(value);
	                };
	                if (error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return error(err);
	                        });
	                    } : function (err) {
	                        error(err);
	                    };
	                }
	                if (complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return complete();
	                        });
	                    } : function () {
	                        complete();
	                    };
	                }
	            }
	            return get(Object.getPrototypeOf(EventEmitter.prototype), 'subscribe', this).call(this, schedulerFn, errorFn, completeFn);
	        }
	    }]);
	    return EventEmitter;
	}(Subject);

	/**
	 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
	 *
	 * Please make sure to keep to edits in sync with the source file.
	 *
	 * Source:
	 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
	 *
	 * The original file level comment is reproduced below
	 */
	/*
	  This is a limited shim for ShadowDOM css styling.
	  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

	  The intention here is to support only the styling features which can be
	  relatively simply implemented. The goal is to allow users to avoid the
	  most obvious pitfalls and do so without compromising performance significantly.
	  For ShadowDOM styling that's not covered here, a set of best practices
	  can be provided that should allow users to accomplish more complex styling.

	  The following is a list of specific ShadowDOM styling features and a brief
	  discussion of the approach used to shim.

	  Shimmed features:

	  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
	  element using the :host rule. To shim this feature, the :host styles are
	  reformatted and prefixed with a given scope name and promoted to a
	  document level stylesheet.
	  For example, given a scope name of .foo, a rule like this:

	    :host {
	        background: red;
	      }
	    }

	  becomes:

	    .foo {
	      background: red;
	    }

	  * encapsultion: Styles defined within ShadowDOM, apply only to
	  dom inside the ShadowDOM. Polymer uses one of two techniques to implement
	  this feature.

	  By default, rules are prefixed with the host element tag name
	  as a descendant selector. This ensures styling does not leak out of the 'top'
	  of the element's ShadowDOM. For example,

	  div {
	      font-weight: bold;
	    }

	  becomes:

	  x-foo div {
	      font-weight: bold;
	    }

	  becomes:


	  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
	  selectors are scoped by adding an attribute selector suffix to each
	  simple selector that contains the host element tag name. Each element
	  in the element's ShadowDOM template is also given the scope attribute.
	  Thus, these rules match only elements that have the scope attribute.
	  For example, given a scope name of x-foo, a rule like this:

	    div {
	      font-weight: bold;
	    }

	  becomes:

	    div[x-foo] {
	      font-weight: bold;
	    }

	  Note that elements that are dynamically added to a scope must have the scope
	  selector added to them manually.

	  * upper/lower bound encapsulation: Styles which are defined outside a
	  shadowRoot should not cross the ShadowDOM boundary and should not apply
	  inside a shadowRoot.

	  This styling behavior is not emulated. Some possible ways to do this that
	  were rejected due to complexity and/or performance concerns include: (1) reset
	  every possible property for every possible selector for a given scope name;
	  (2) re-implement css in javascript.

	  As an alternative, users should make sure to use selectors
	  specific to the scope in which they are working.

	  * ::distributed: This behavior is not emulated. It's often not necessary
	  to style the contents of a specific insertion point and instead, descendants
	  of the host element can be styled selectively. Users can also create an
	  extra node around an insertion point and style that node's contents
	  via descendent selectors. For example, with a shadowRoot like this:

	    <style>
	      ::content(div) {
	        background: red;
	      }
	    </style>
	    <content></content>

	  could become:

	    <style>
	      / *@polyfill .content-container div * /
	      ::content(div) {
	        background: red;
	      }
	    </style>
	    <div class="content-container">
	      <content></content>
	    </div>

	  Note the use of @polyfill in the comment above a ShadowDOM specific style
	  declaration. This is a directive to the styling shim to use the selector
	  in comments in lieu of the next selector when running under polyfill.
	*/
	var ShadowCss = function () {
	    function ShadowCss() {
	        classCallCheck(this, ShadowCss);

	        this.strictStyling = true;
	    }
	    /*
	    * Shim some cssText with the given selector. Returns cssText that can
	    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
	    *
	    * When strictStyling is true:
	    * - selector is the attribute added to all elements inside the host,
	    * - hostSelector is the attribute added to the host itself.
	    */


	    createClass(ShadowCss, [{
	        key: 'shimCssText',
	        value: function shimCssText(cssText, selector) {
	            var hostSelector = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];

	            cssText = stripComments(cssText);
	            cssText = this._insertDirectives(cssText);
	            return this._scopeCssText(cssText, selector, hostSelector);
	        }
	    }, {
	        key: '_insertDirectives',
	        value: function _insertDirectives(cssText) {
	            cssText = this._insertPolyfillDirectivesInCssText(cssText);
	            return this._insertPolyfillRulesInCssText(cssText);
	        }
	        /*
	         * Process styles to convert native ShadowDOM rules that will trip
	         * up the css parser; we rely on decorating the stylesheet with inert rules.
	         *
	         * For example, we convert this rule:
	         *
	         * polyfill-next-selector { content: ':host menu-item'; }
	         * ::content menu-item {
	         *
	         * to this:
	         *
	         * scopeName menu-item {
	         *
	        **/

	    }, {
	        key: '_insertPolyfillDirectivesInCssText',
	        value: function _insertPolyfillDirectivesInCssText(cssText) {
	            // Difference with webcomponents.js: does not handle comments
	            return StringWrapper$3.replaceAllMapped(cssText, _cssContentNextSelectorRe, function (m /** TODO #9100 */) {
	                return m[1] + '{';
	            });
	        }
	        /*
	         * Process styles to add rules which will only apply under the polyfill
	         *
	         * For example, we convert this rule:
	         *
	         * polyfill-rule {
	         *   content: ':host menu-item';
	         * ...
	         * }
	         *
	         * to this:
	         *
	         * scopeName menu-item {...}
	         *
	        **/

	    }, {
	        key: '_insertPolyfillRulesInCssText',
	        value: function _insertPolyfillRulesInCssText(cssText) {
	            // Difference with webcomponents.js: does not handle comments
	            return StringWrapper$3.replaceAllMapped(cssText, _cssContentRuleRe, function (m /** TODO #9100 */) {
	                var rule = m[0];
	                rule = StringWrapper$3.replace(rule, m[1], '');
	                rule = StringWrapper$3.replace(rule, m[2], '');
	                return m[3] + rule;
	            });
	        }
	        /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
	         *
	         *  .foo {... }
	         *
	         *  and converts this to
	         *
	         *  scopeName .foo { ... }
	        */

	    }, {
	        key: '_scopeCssText',
	        value: function _scopeCssText(cssText, scopeSelector, hostSelector) {
	            var unscoped = this._extractUnscopedRulesFromCssText(cssText);
	            cssText = this._insertPolyfillHostInCssText(cssText);
	            cssText = this._convertColonHost(cssText);
	            cssText = this._convertColonHostContext(cssText);
	            cssText = this._convertShadowDOMSelectors(cssText);
	            if (isPresent$3(scopeSelector)) {
	                cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
	            }
	            cssText = cssText + '\n' + unscoped;
	            return cssText.trim();
	        }
	        /*
	         * Process styles to add rules which will only apply under the polyfill
	         * and do not process via CSSOM. (CSSOM is destructive to rules on rare
	         * occasions, e.g. -webkit-calc on Safari.)
	         * For example, we convert this rule:
	         *
	         * @polyfill-unscoped-rule {
	         *   content: 'menu-item';
	         * ... }
	         *
	         * to this:
	         *
	         * menu-item {...}
	         *
	        **/

	    }, {
	        key: '_extractUnscopedRulesFromCssText',
	        value: function _extractUnscopedRulesFromCssText(cssText) {
	            // Difference with webcomponents.js: does not handle comments
	            var r = '',
	                m;
	            var matcher = RegExpWrapper$3.matcher(_cssContentUnscopedRuleRe, cssText);
	            while (isPresent$3(m = RegExpMatcherWrapper$3.next(matcher))) {
	                var rule = m[0];
	                rule = StringWrapper$3.replace(rule, m[2], '');
	                rule = StringWrapper$3.replace(rule, m[1], m[3]);
	                r += rule + '\n\n';
	            }
	            return r;
	        }
	        /*
	         * convert a rule like :host(.foo) > .bar { }
	         *
	         * to
	         *
	         * scopeName.foo > .bar
	        */

	    }, {
	        key: '_convertColonHost',
	        value: function _convertColonHost(cssText) {
	            return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
	        }
	        /*
	         * convert a rule like :host-context(.foo) > .bar { }
	         *
	         * to
	         *
	         * scopeName.foo > .bar, .foo scopeName > .bar { }
	         *
	         * and
	         *
	         * :host-context(.foo:host) .bar { ... }
	         *
	         * to
	         *
	         * scopeName.foo .bar { ... }
	        */

	    }, {
	        key: '_convertColonHostContext',
	        value: function _convertColonHostContext(cssText) {
	            return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
	        }
	    }, {
	        key: '_convertColonRule',
	        value: function _convertColonRule(cssText, regExp, partReplacer) {
	            // p1 = :host, p2 = contents of (), p3 rest of rule
	            return StringWrapper$3.replaceAllMapped(cssText, regExp, function (m /** TODO #9100 */) {
	                if (isPresent$3(m[2])) {
	                    var parts = m[2].split(','),
	                        r = [];
	                    for (var i = 0; i < parts.length; i++) {
	                        var p = parts[i];
	                        if (isBlank$3(p)) break;
	                        p = p.trim();
	                        r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
	                    }
	                    return r.join(',');
	                } else {
	                    return _polyfillHostNoCombinator + m[3];
	                }
	            });
	        }
	    }, {
	        key: '_colonHostContextPartReplacer',
	        value: function _colonHostContextPartReplacer(host, part, suffix) {
	            if (StringWrapper$3.contains(part, _polyfillHost)) {
	                return this._colonHostPartReplacer(host, part, suffix);
	            } else {
	                return host + part + suffix + ', ' + part + ' ' + host + suffix;
	            }
	        }
	    }, {
	        key: '_colonHostPartReplacer',
	        value: function _colonHostPartReplacer(host, part, suffix) {
	            return host + StringWrapper$3.replace(part, _polyfillHost, '') + suffix;
	        }
	        /*
	         * Convert combinators like ::shadow and pseudo-elements like ::content
	         * by replacing with space.
	        */

	    }, {
	        key: '_convertShadowDOMSelectors',
	        value: function _convertShadowDOMSelectors(cssText) {
	            for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
	                cssText = StringWrapper$3.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
	            }
	            return cssText;
	        }
	        // change a selector like 'div' to 'name div'

	    }, {
	        key: '_scopeSelectors',
	        value: function _scopeSelectors(cssText, scopeSelector, hostSelector) {
	            var _this = this;

	            return processRules(cssText, function (rule) {
	                var selector = rule.selector;
	                var content = rule.content;
	                if (rule.selector[0] != '@' || rule.selector.startsWith('@page')) {
	                    selector = _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
	                } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports')) {
	                    content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
	                }
	                return new CssRule(selector, content);
	            });
	        }
	    }, {
	        key: '_scopeSelector',
	        value: function _scopeSelector(selector, scopeSelector, hostSelector, strict) {
	            var r = [],
	                parts = selector.split(',');
	            for (var i = 0; i < parts.length; i++) {
	                var p = parts[i].trim();
	                var deepParts = StringWrapper$3.split(p, _shadowDeepSelectors);
	                var shallowPart = deepParts[0];
	                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
	                    deepParts[0] = strict && !StringWrapper$3.contains(shallowPart, _polyfillHostNoCombinator) ? this._applyStrictSelectorScope(shallowPart, scopeSelector) : this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
	                }
	                // replace /deep/ with a space for child selectors
	                r.push(deepParts.join(' '));
	            }
	            return r.join(', ');
	        }
	    }, {
	        key: '_selectorNeedsScoping',
	        value: function _selectorNeedsScoping(selector, scopeSelector) {
	            var re = this._makeScopeMatcher(scopeSelector);
	            return !isPresent$3(RegExpWrapper$3.firstMatch(re, selector));
	        }
	    }, {
	        key: '_makeScopeMatcher',
	        value: function _makeScopeMatcher(scopeSelector) {
	            var lre = /\[/g;
	            var rre = /\]/g;
	            scopeSelector = StringWrapper$3.replaceAll(scopeSelector, lre, '\\[');
	            scopeSelector = StringWrapper$3.replaceAll(scopeSelector, rre, '\\]');
	            return RegExpWrapper$3.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
	        }
	    }, {
	        key: '_applySelectorScope',
	        value: function _applySelectorScope(selector, scopeSelector, hostSelector) {
	            // Difference from webcomponentsjs: scopeSelector could not be an array
	            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
	        }
	        // scope via name and [is=name]

	    }, {
	        key: '_applySimpleSelectorScope',
	        value: function _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
	            if (isPresent$3(RegExpWrapper$3.firstMatch(_polyfillHostRe, selector))) {
	                var replaceBy = this.strictStyling ? '[' + hostSelector + ']' : scopeSelector;
	                selector = StringWrapper$3.replace(selector, _polyfillHostNoCombinator, replaceBy);
	                return StringWrapper$3.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
	            } else {
	                return scopeSelector + ' ' + selector;
	            }
	        }
	        // return a selector with [name] suffix on each simple selector
	        // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */

	    }, {
	        key: '_applyStrictSelectorScope',
	        value: function _applyStrictSelectorScope(selector, scopeSelector) {
	            var isRe = /\[is=([^\]]*)\]/g;
	            scopeSelector = StringWrapper$3.replaceAllMapped(scopeSelector, isRe, function (m /** TODO #9100 */) {
	                return m[1];
	            });
	            var splits = [' ', '>', '+', '~'],
	                scoped = selector,
	                attrName = '[' + scopeSelector + ']';
	            for (var i = 0; i < splits.length; i++) {
	                var sep = splits[i];
	                var parts = scoped.split(sep);
	                scoped = parts.map(function (p) {
	                    // remove :host since it should be unnecessary
	                    var t = StringWrapper$3.replaceAll(p.trim(), _polyfillHostRe, '');
	                    if (t.length > 0 && !ListWrapper$3.contains(splits, t) && !StringWrapper$3.contains(t, attrName)) {
	                        var re = /([^:]*)(:*)(.*)/g;
	                        var m = RegExpWrapper$3.firstMatch(re, t);
	                        if (isPresent$3(m)) {
	                            p = m[1] + attrName + m[2] + m[3];
	                        }
	                    }
	                    return p;
	                }).join(sep);
	            }
	            return scoped;
	        }
	    }, {
	        key: '_insertPolyfillHostInCssText',
	        value: function _insertPolyfillHostInCssText(selector) {
	            selector = StringWrapper$3.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
	            selector = StringWrapper$3.replaceAll(selector, _colonHostRe, _polyfillHost);
	            return selector;
	        }
	    }]);
	    return ShadowCss;
	}();
	var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
	var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
	var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
	var _polyfillHost = '-shadowcsshost';
	// note: :host-context pre-processed to -shadowcsshostcontext.
	var _polyfillHostContext = '-shadowcsscontext';
	var _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
	var _cssColonHostRe = RegExpWrapper$3.create('(' + _polyfillHost + _parenSuffix, 'im');
	var _cssColonHostContextRe = RegExpWrapper$3.create('(' + _polyfillHostContext + _parenSuffix, 'im');
	var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
	var _shadowDOMSelectorsRe = [/::shadow/g, /::content/g,
	// Deprecated selectors
	// TODO(vicb): see https://github.com/angular/clang-format/issues/16
	// clang-format off
	/\/shadow-deep\//g, /\/shadow\//g];
	var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
	var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
	var _polyfillHostRe = RegExpWrapper$3.create(_polyfillHost, 'im');
	var _colonHostRe = /:host/gim;
	var _colonHostContextRe = /:host-context/gim;
	var _commentRe = /\/\*[\s\S]*?\*\//g;
	function stripComments(input) {
	    return StringWrapper$3.replaceAllMapped(input, _commentRe, function (_ /** TODO #9100 */) {
	        return '';
	    });
	}
	var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
	var _curlyRe = /([{}])/g;
	var OPEN_CURLY = '{';
	var CLOSE_CURLY = '}';
	var BLOCK_PLACEHOLDER = '%BLOCK%';
	var CssRule = function CssRule(selector, content) {
	    classCallCheck(this, CssRule);

	    this.selector = selector;
	    this.content = content;
	};
	function processRules(input, ruleCallback) {
	    var inputWithEscapedBlocks = escapeBlocks(input);
	    var nextBlockIndex = 0;
	    return StringWrapper$3.replaceAllMapped(inputWithEscapedBlocks.escapedString, _ruleRe, function (m /** TODO #9100 */) {
	        var selector = m[2];
	        var content = '';
	        var suffix = m[4];
	        var contentPrefix = '';
	        if (isPresent$3(m[4]) && m[4].startsWith('{' + BLOCK_PLACEHOLDER)) {
	            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
	            suffix = m[4].substring(BLOCK_PLACEHOLDER.length + 1);
	            contentPrefix = '{';
	        }
	        var rule = ruleCallback(new CssRule(selector, content));
	        return '' + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
	    });
	}

	var StringWithEscapedBlocks = function StringWithEscapedBlocks(escapedString, blocks) {
	    classCallCheck(this, StringWithEscapedBlocks);

	    this.escapedString = escapedString;
	    this.blocks = blocks;
	};

	function escapeBlocks(input) {
	    var inputParts = StringWrapper$3.split(input, _curlyRe);
	    var resultParts = [];
	    var escapedBlocks = [];
	    var bracketCount = 0;
	    var currentBlockParts = [];
	    for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
	        var part = inputParts[partIndex];
	        if (part == CLOSE_CURLY) {
	            bracketCount--;
	        }
	        if (bracketCount > 0) {
	            currentBlockParts.push(part);
	        } else {
	            if (currentBlockParts.length > 0) {
	                escapedBlocks.push(currentBlockParts.join(''));
	                resultParts.push(BLOCK_PLACEHOLDER);
	                currentBlockParts = [];
	            }
	            resultParts.push(part);
	        }
	        if (part == OPEN_CURLY) {
	            bracketCount++;
	        }
	    }
	    if (currentBlockParts.length > 0) {
	        escapedBlocks.push(currentBlockParts.join(''));
	        resultParts.push(BLOCK_PLACEHOLDER);
	    }
	    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
	}

	var COMPONENT_VARIABLE$1 = '%COMP%';
	var HOST_ATTR$1 = '_nghost-' + COMPONENT_VARIABLE$1;
	var CONTENT_ATTR$1 = '_ngcontent-' + COMPONENT_VARIABLE$1;
	var StylesCompileDependency = function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {
	    classCallCheck(this, StylesCompileDependency);

	    this.moduleUrl = moduleUrl;
	    this.isShimmed = isShimmed;
	    this.valuePlaceholder = valuePlaceholder;
	};
	var StylesCompileResult = function StylesCompileResult(componentStylesheet, externalStylesheets) {
	    classCallCheck(this, StylesCompileResult);

	    this.componentStylesheet = componentStylesheet;
	    this.externalStylesheets = externalStylesheets;
	};
	var CompiledStylesheet = function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {
	    classCallCheck(this, CompiledStylesheet);

	    this.statements = statements;
	    this.stylesVar = stylesVar;
	    this.dependencies = dependencies;
	    this.isShimmed = isShimmed;
	    this.meta = meta;
	};
	var StyleCompiler = function () {
	    function StyleCompiler(_urlResolver) {
	        classCallCheck(this, StyleCompiler);

	        this._urlResolver = _urlResolver;
	        this._shadowCss = new ShadowCss();
	    }

	    createClass(StyleCompiler, [{
	        key: 'compileComponent',
	        value: function compileComponent(comp) {
	            var _this = this;

	            var shim = comp.template.encapsulation === ViewEncapsulation.Emulated;
	            var externalStylesheets = [];
	            var componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({
	                styles: comp.template.styles,
	                styleUrls: comp.template.styleUrls,
	                moduleUrl: comp.type.moduleUrl
	            }), true);
	            comp.template.externalStylesheets.forEach(function (stylesheetMeta) {
	                var compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);
	                externalStylesheets.push(compiledStylesheet);
	            });
	            return new StylesCompileResult(componentStylesheet, externalStylesheets);
	        }
	    }, {
	        key: '_compileStyles',
	        value: function _compileStyles(comp, stylesheet, isComponentStylesheet) {
	            var _this2 = this;

	            var shim = comp.template.encapsulation === ViewEncapsulation.Emulated;
	            var styleExpressions = stylesheet.styles.map(function (plainStyle) {
	                return literal(_this2._shimIfNeeded(plainStyle, shim));
	            });
	            var dependencies = [];
	            for (var i = 0; i < stylesheet.styleUrls.length; i++) {
	                var identifier = new CompileIdentifierMetadata({ name: getStylesVarName(null) });
	                dependencies.push(new StylesCompileDependency(stylesheet.styleUrls[i], shim, identifier));
	                styleExpressions.push(new ExternalExpr(identifier));
	            }
	            // styles variable contains plain strings and arrays of other styles arrays (recursive),
	            // so we set its type to dynamic.
	            var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
	            var stmt = variable(stylesVar).set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const]))).toDeclStmt(null, [StmtModifier.Final]);
	            return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);
	        }
	    }, {
	        key: '_shimIfNeeded',
	        value: function _shimIfNeeded(style, shim) {
	            return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR$1, HOST_ATTR$1) : style;
	        }
	    }]);
	    return StyleCompiler;
	}();
	/** @nocollapse */
	StyleCompiler.decorators = [{ type: Injectable }];
	/** @nocollapse */
	StyleCompiler.ctorParameters = [{ type: UrlResolver }];
	function getStylesVarName(component) {
	    var result = 'styles';
	    if (component) {
	        result += '_' + component.type.name;
	    }
	    return result;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	// TODO: vsavkin rename it into TemplateLoader
	/**
	 * An interface for retrieving documents by URL that the compiler uses
	 * to load templates.
	 */
	var XHR = function () {
	  function XHR() {
	    classCallCheck(this, XHR);
	  }

	  createClass(XHR, [{
	    key: "get",
	    value: function get(url) {
	      return null;
	    }
	  }]);
	  return XHR;
	}();

	var NormalizeDirectiveResult = function NormalizeDirectiveResult(syncResult, asyncResult) {
	    classCallCheck(this, NormalizeDirectiveResult);

	    this.syncResult = syncResult;
	    this.asyncResult = asyncResult;
	};
	var DirectiveNormalizer = function () {
	    function DirectiveNormalizer(_xhr, _urlResolver, _htmlParser, _config) {
	        classCallCheck(this, DirectiveNormalizer);

	        this._xhr = _xhr;
	        this._urlResolver = _urlResolver;
	        this._htmlParser = _htmlParser;
	        this._config = _config;
	        this._xhrCache = new Map();
	    }

	    createClass(DirectiveNormalizer, [{
	        key: 'clearCache',
	        value: function clearCache() {
	            this._xhrCache.clear();
	        }
	    }, {
	        key: 'clearCacheFor',
	        value: function clearCacheFor(normalizedDirective) {
	            var _this = this;

	            if (!normalizedDirective.isComponent) {
	                return;
	            }
	            this._xhrCache.delete(normalizedDirective.template.templateUrl);
	            normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) {
	                _this._xhrCache.delete(stylesheet.moduleUrl);
	            });
	        }
	    }, {
	        key: '_fetch',
	        value: function _fetch(url) {
	            var result = this._xhrCache.get(url);
	            if (!result) {
	                result = this._xhr.get(url);
	                this._xhrCache.set(url, result);
	            }
	            return result;
	        }
	    }, {
	        key: 'normalizeDirective',
	        value: function normalizeDirective(directive) {
	            var _this2 = this;

	            if (!directive.isComponent) {
	                // For non components there is nothing to be normalized yet.
	                return new NormalizeDirectiveResult(directive, Promise.resolve(directive));
	            }
	            var normalizedTemplateSync = null;
	            var normalizedTemplateAsync = void 0;
	            if (isPresent$3(directive.template.template)) {
	                normalizedTemplateSync = this.normalizeTemplateSync(directive.type, directive.template);
	                normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);
	            } else if (directive.template.templateUrl) {
	                normalizedTemplateAsync = this.normalizeTemplateAsync(directive.type, directive.template);
	            } else {
	                throw new BaseException$3('No template specified for component ' + directive.type.name);
	            }
	            if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {
	                // sync case
	                var normalizedDirective = _cloneDirectiveWithTemplate(directive, normalizedTemplateSync);
	                return new NormalizeDirectiveResult(normalizedDirective, Promise.resolve(normalizedDirective));
	            } else {
	                // async case
	                return new NormalizeDirectiveResult(null, normalizedTemplateAsync.then(function (normalizedTemplate) {
	                    return _this2.normalizeExternalStylesheets(normalizedTemplate);
	                }).then(function (normalizedTemplate) {
	                    return _cloneDirectiveWithTemplate(directive, normalizedTemplate);
	                }));
	            }
	        }
	    }, {
	        key: 'normalizeTemplateSync',
	        value: function normalizeTemplateSync(directiveType, template) {
	            return this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl);
	        }
	    }, {
	        key: 'normalizeTemplateAsync',
	        value: function normalizeTemplateAsync(directiveType, template) {
	            var _this3 = this;

	            var templateUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
	            return this._fetch(templateUrl).then(function (value) {
	                return _this3.normalizeLoadedTemplate(directiveType, template, value, templateUrl);
	            });
	        }
	    }, {
	        key: 'normalizeLoadedTemplate',
	        value: function normalizeLoadedTemplate(directiveType, templateMeta, template, templateAbsUrl) {
	            var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name);
	            if (rootNodesAndErrors.errors.length > 0) {
	                var errorString = rootNodesAndErrors.errors.join('\n');
	                throw new BaseException$3('Template parse errors:\n' + errorString);
	            }
	            var templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({
	                styles: templateMeta.styles,
	                styleUrls: templateMeta.styleUrls,
	                moduleUrl: directiveType.moduleUrl
	            }));
	            var visitor = new TemplatePreparseVisitor();
	            htmlVisitAll(visitor, rootNodesAndErrors.rootNodes);
	            var templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));
	            var allStyles = templateMetadataStyles.styles.concat(templateStyles.styles);
	            var allStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
	            var encapsulation = templateMeta.encapsulation;
	            if (isBlank$3(encapsulation)) {
	                encapsulation = this._config.defaultEncapsulation;
	            }
	            if (encapsulation === ViewEncapsulation.Emulated && allStyles.length === 0 && allStyleUrls.length === 0) {
	                encapsulation = ViewEncapsulation.None;
	            }
	            return new CompileTemplateMetadata({
	                encapsulation: encapsulation,
	                template: template,
	                templateUrl: templateAbsUrl,
	                styles: allStyles,
	                styleUrls: allStyleUrls,
	                externalStylesheets: templateMeta.externalStylesheets,
	                ngContentSelectors: visitor.ngContentSelectors,
	                animations: templateMeta.animations,
	                interpolation: templateMeta.interpolation
	            });
	        }
	    }, {
	        key: 'normalizeExternalStylesheets',
	        value: function normalizeExternalStylesheets(templateMeta) {
	            return this._loadMissingExternalStylesheets(templateMeta.styleUrls).then(function (externalStylesheets) {
	                return new CompileTemplateMetadata({
	                    encapsulation: templateMeta.encapsulation,
	                    template: templateMeta.template,
	                    templateUrl: templateMeta.templateUrl,
	                    styles: templateMeta.styles,
	                    styleUrls: templateMeta.styleUrls,
	                    externalStylesheets: externalStylesheets,
	                    ngContentSelectors: templateMeta.ngContentSelectors,
	                    animations: templateMeta.animations,
	                    interpolation: templateMeta.interpolation
	                });
	            });
	        }
	    }, {
	        key: '_loadMissingExternalStylesheets',
	        value: function _loadMissingExternalStylesheets(styleUrls) {
	            var _this4 = this;

	            var loadedStylesheets = arguments.length <= 1 || arguments[1] === undefined ? new Map() : arguments[1];

	            return Promise.all(styleUrls.filter(function (styleUrl) {
	                return !loadedStylesheets.has(styleUrl);
	            }).map(function (styleUrl) {
	                return _this4._fetch(styleUrl).then(function (loadedStyle) {
	                    var stylesheet = _this4.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));
	                    loadedStylesheets.set(styleUrl, stylesheet);
	                    return _this4._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
	                });
	            })).then(function (_) {
	                return MapWrapper$3.values(loadedStylesheets);
	            });
	        }
	    }, {
	        key: 'normalizeStylesheet',
	        value: function normalizeStylesheet(stylesheet) {
	            var _this5 = this;

	            var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable).map(function (url) {
	                return _this5._urlResolver.resolve(stylesheet.moduleUrl, url);
	            });
	            var allStyles = stylesheet.styles.map(function (style) {
	                var styleWithImports = extractStyleUrls(_this5._urlResolver, stylesheet.moduleUrl, style);
	                allStyleUrls.push.apply(allStyleUrls, toConsumableArray(styleWithImports.styleUrls));
	                return styleWithImports.style;
	            });
	            return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });
	        }
	    }]);
	    return DirectiveNormalizer;
	}();
	/** @nocollapse */
	DirectiveNormalizer.decorators = [{ type: Injectable }];
	/** @nocollapse */
	DirectiveNormalizer.ctorParameters = [{ type: XHR }, { type: UrlResolver }, { type: HtmlParser }, { type: CompilerConfig }];

	var TemplatePreparseVisitor = function () {
	    function TemplatePreparseVisitor() {
	        classCallCheck(this, TemplatePreparseVisitor);

	        this.ngContentSelectors = [];
	        this.styles = [];
	        this.styleUrls = [];
	        this.ngNonBindableStackCount = 0;
	    }

	    createClass(TemplatePreparseVisitor, [{
	        key: 'visitElement',
	        value: function visitElement(ast, context) {
	            var preparsedElement = preparseElement(ast);
	            switch (preparsedElement.type) {
	                case PreparsedElementType.NG_CONTENT:
	                    if (this.ngNonBindableStackCount === 0) {
	                        this.ngContentSelectors.push(preparsedElement.selectAttr);
	                    }
	                    break;
	                case PreparsedElementType.STYLE:
	                    var textContent = '';
	                    ast.children.forEach(function (child) {
	                        if (child instanceof HtmlTextAst) {
	                            textContent += child.value;
	                        }
	                    });
	                    this.styles.push(textContent);
	                    break;
	                case PreparsedElementType.STYLESHEET:
	                    this.styleUrls.push(preparsedElement.hrefAttr);
	                    break;
	                default:
	                    // DDC reports this as error. See:
	                    // https://github.com/dart-lang/dev_compiler/issues/428
	                    break;
	            }
	            if (preparsedElement.nonBindable) {
	                this.ngNonBindableStackCount++;
	            }
	            htmlVisitAll(this, ast.children);
	            if (preparsedElement.nonBindable) {
	                this.ngNonBindableStackCount--;
	            }
	            return null;
	        }
	    }, {
	        key: 'visitComment',
	        value: function visitComment(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitExpansion',
	        value: function visitExpansion(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitExpansionCase',
	        value: function visitExpansionCase(ast, context) {
	            return null;
	        }
	    }]);
	    return TemplatePreparseVisitor;
	}();

	function _cloneDirectiveWithTemplate(directive, template) {
	    return new CompileDirectiveMetadata({
	        type: directive.type,
	        isComponent: directive.isComponent,
	        selector: directive.selector,
	        exportAs: directive.exportAs,
	        changeDetection: directive.changeDetection,
	        inputs: directive.inputs,
	        outputs: directive.outputs,
	        hostListeners: directive.hostListeners,
	        hostProperties: directive.hostProperties,
	        hostAttributes: directive.hostAttributes,
	        lifecycleHooks: directive.lifecycleHooks,
	        providers: directive.providers,
	        viewProviders: directive.viewProviders,
	        queries: directive.queries,
	        viewQueries: directive.viewQueries,
	        precompile: directive.precompile,
	        template: template
	    });
	}

	function assertArrayOfStrings(identifier, value) {
	    if (!isDevMode() || isBlank$3(value)) {
	        return;
	    }
	    if (!isArray$4(value)) {
	        throw new BaseException$3('Expected \'' + identifier + '\' to be an array of strings.');
	    }
	    for (var i = 0; i < value.length; i += 1) {
	        if (!isString$3(value[i])) {
	            throw new BaseException$3('Expected \'' + identifier + '\' to be an array of strings.');
	        }
	    }
	}
	var INTERPOLATION_BLACKLIST_REGEXPS = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i];
	function assertInterpolationSymbols(identifier, value) {
	    if (isDevMode() && !isBlank$3(value) && (!isArray$4(value) || value.length != 2)) {
	        throw new BaseException$3('Expected \'' + identifier + '\' to be an array, [start, end].');
	    } else if (isDevMode() && !isBlank$3(value)) {
	        (function () {
	            var start = value[0];
	            var end = value[1];
	            // black list checking
	            INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {
	                if (regexp.test(start) || regexp.test(end)) {
	                    throw new BaseException$3('[\'' + start + '\', \'' + end + '\'] contains unusable interpolation symbol.');
	                }
	            });
	        })();
	    }
	}

	var LIFECYCLE_INTERFACES = MapWrapper$3.createFromPairs([[LifecycleHooks$1.OnInit, OnInit], [LifecycleHooks$1.OnDestroy, OnDestroy], [LifecycleHooks$1.DoCheck, DoCheck], [LifecycleHooks$1.OnChanges, OnChanges], [LifecycleHooks$1.AfterContentInit, AfterContentInit], [LifecycleHooks$1.AfterContentChecked, AfterContentChecked], [LifecycleHooks$1.AfterViewInit, AfterViewInit], [LifecycleHooks$1.AfterViewChecked, AfterViewChecked]]);
	var LIFECYCLE_PROPS = MapWrapper$3.createFromPairs([[LifecycleHooks$1.OnInit, 'ngOnInit'], [LifecycleHooks$1.OnDestroy, 'ngOnDestroy'], [LifecycleHooks$1.DoCheck, 'ngDoCheck'], [LifecycleHooks$1.OnChanges, 'ngOnChanges'], [LifecycleHooks$1.AfterContentInit, 'ngAfterContentInit'], [LifecycleHooks$1.AfterContentChecked, 'ngAfterContentChecked'], [LifecycleHooks$1.AfterViewInit, 'ngAfterViewInit'], [LifecycleHooks$1.AfterViewChecked, 'ngAfterViewChecked']]);
	function hasLifecycleHook(hook, token) {
	    var lcInterface = LIFECYCLE_INTERFACES.get(hook);
	    var lcProp = LIFECYCLE_PROPS.get(hook);
	    return reflector$2.hasLifecycleHook(token, lcInterface, lcProp);
	}

	function _isDirectiveMetadata(type) {
	    return type instanceof DirectiveMetadata;
	}
	var DirectiveResolver = function () {
	    function DirectiveResolver() {
	        var _reflector = arguments.length <= 0 || arguments[0] === undefined ? reflector$2 : arguments[0];

	        classCallCheck(this, DirectiveResolver);

	        this._reflector = _reflector;
	    }
	    /**
	     * Return {@link DirectiveMetadata} for a given `Type`.
	     */


	    createClass(DirectiveResolver, [{
	        key: 'resolve',
	        value: function resolve(type) {
	            var typeMetadata = this._reflector.annotations(resolveForwardRef(type));
	            if (isPresent$3(typeMetadata)) {
	                var metadata = typeMetadata.find(_isDirectiveMetadata);
	                if (isPresent$3(metadata)) {
	                    var propertyMetadata = this._reflector.propMetadata(type);
	                    return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
	                }
	            }
	            throw new BaseException$3('No Directive annotation found on ' + stringify$3(type));
	        }
	    }, {
	        key: '_mergeWithPropertyMetadata',
	        value: function _mergeWithPropertyMetadata(dm, propertyMetadata, directiveType) {
	            var inputs = [];
	            var outputs = [];
	            var host = {};
	            var queries = {};
	            StringMapWrapper$3.forEach(propertyMetadata, function (metadata, propName) {
	                metadata.forEach(function (a) {
	                    if (a instanceof InputMetadata) {
	                        if (isPresent$3(a.bindingPropertyName)) {
	                            inputs.push(propName + ': ' + a.bindingPropertyName);
	                        } else {
	                            inputs.push(propName);
	                        }
	                    }
	                    if (a instanceof OutputMetadata) {
	                        if (isPresent$3(a.bindingPropertyName)) {
	                            outputs.push(propName + ': ' + a.bindingPropertyName);
	                        } else {
	                            outputs.push(propName);
	                        }
	                    }
	                    if (a instanceof HostBindingMetadata) {
	                        if (isPresent$3(a.hostPropertyName)) {
	                            host['[' + a.hostPropertyName + ']'] = propName;
	                        } else {
	                            host['[' + propName + ']'] = propName;
	                        }
	                    }
	                    if (a instanceof HostListenerMetadata) {
	                        var args = isPresent$3(a.args) ? a.args.join(', ') : '';
	                        host['(' + a.eventName + ')'] = propName + '(' + args + ')';
	                    }
	                    if (a instanceof QueryMetadata) {
	                        queries[propName] = a;
	                    }
	                });
	            });
	            return this._merge(dm, inputs, outputs, host, queries, directiveType);
	        }
	    }, {
	        key: '_merge',
	        value: function _merge(dm, inputs, outputs, host, queries, directiveType) {
	            var mergedInputs = isPresent$3(dm.inputs) ? ListWrapper$3.concat(dm.inputs, inputs) : inputs;
	            var mergedOutputs;
	            if (isPresent$3(dm.outputs)) {
	                dm.outputs.forEach(function (propName) {
	                    if (ListWrapper$3.contains(outputs, propName)) {
	                        throw new BaseException$3('Output event \'' + propName + '\' defined multiple times in \'' + stringify$3(directiveType) + '\'');
	                    }
	                });
	                mergedOutputs = ListWrapper$3.concat(dm.outputs, outputs);
	            } else {
	                mergedOutputs = outputs;
	            }
	            var mergedHost = isPresent$3(dm.host) ? StringMapWrapper$3.merge(dm.host, host) : host;
	            var mergedQueries = isPresent$3(dm.queries) ? StringMapWrapper$3.merge(dm.queries, queries) : queries;
	            if (dm instanceof ComponentMetadata) {
	                return new ComponentMetadata({
	                    selector: dm.selector,
	                    inputs: mergedInputs,
	                    outputs: mergedOutputs,
	                    host: mergedHost,
	                    exportAs: dm.exportAs,
	                    moduleId: dm.moduleId,
	                    queries: mergedQueries,
	                    changeDetection: dm.changeDetection,
	                    providers: dm.providers,
	                    viewProviders: dm.viewProviders,
	                    precompile: dm.precompile
	                });
	            } else {
	                return new DirectiveMetadata({
	                    selector: dm.selector,
	                    inputs: mergedInputs,
	                    outputs: mergedOutputs,
	                    host: mergedHost,
	                    exportAs: dm.exportAs,
	                    queries: mergedQueries,
	                    providers: dm.providers
	                });
	            }
	        }
	    }]);
	    return DirectiveResolver;
	}();
	/** @nocollapse */
	DirectiveResolver.decorators = [{ type: Injectable }];
	/** @nocollapse */
	DirectiveResolver.ctorParameters = [{ type: ReflectorReader$1 }];
	var CODEGEN_DIRECTIVE_RESOLVER = new DirectiveResolver(reflector$2);

	function _isPipeMetadata(type) {
	    return type instanceof PipeMetadata;
	}
	var PipeResolver = function () {
	    function PipeResolver() {
	        var _reflector = arguments.length <= 0 || arguments[0] === undefined ? reflector$2 : arguments[0];

	        classCallCheck(this, PipeResolver);

	        this._reflector = _reflector;
	    }
	    /**
	     * Return {@link PipeMetadata} for a given `Type`.
	     */


	    createClass(PipeResolver, [{
	        key: 'resolve',
	        value: function resolve(type) {
	            var metas = this._reflector.annotations(resolveForwardRef(type));
	            if (isPresent$3(metas)) {
	                var annotation = metas.find(_isPipeMetadata);
	                if (isPresent$3(annotation)) {
	                    return annotation;
	                }
	            }
	            throw new BaseException$3('No Pipe decorator found on ' + stringify$3(type));
	        }
	    }]);
	    return PipeResolver;
	}();
	/** @nocollapse */
	PipeResolver.decorators = [{ type: Injectable }];
	/** @nocollapse */
	PipeResolver.ctorParameters = [{ type: ReflectorReader$1 }];

	var ViewResolver = function () {
	    function ViewResolver() {
	        var _reflector = arguments.length <= 0 || arguments[0] === undefined ? reflector$2 : arguments[0];

	        classCallCheck(this, ViewResolver);

	        this._reflector = _reflector;
	    }

	    createClass(ViewResolver, [{
	        key: 'resolve',
	        value: function resolve(component) {
	            var compMeta;
	            this._reflector.annotations(component).forEach(function (m) {
	                if (m instanceof ComponentMetadata) {
	                    compMeta = m;
	                }
	            });
	            if (isPresent$3(compMeta)) {
	                if (isBlank$3(compMeta.template) && isBlank$3(compMeta.templateUrl)) {
	                    throw new BaseException$3('Component \'' + stringify$3(component) + '\' must have either \'template\' or \'templateUrl\' set.');
	                } else {
	                    return new ViewMetadata({
	                        templateUrl: compMeta.templateUrl,
	                        template: compMeta.template,
	                        directives: compMeta.directives,
	                        pipes: compMeta.pipes,
	                        encapsulation: compMeta.encapsulation,
	                        styles: compMeta.styles,
	                        styleUrls: compMeta.styleUrls,
	                        animations: compMeta.animations,
	                        interpolation: compMeta.interpolation
	                    });
	                }
	            } else {
	                throw new BaseException$3('Could not compile \'' + stringify$3(component) + '\' because it is not a component.');
	            }
	        }
	    }]);
	    return ViewResolver;
	}();
	/** @nocollapse */
	ViewResolver.decorators = [{ type: Injectable }];
	/** @nocollapse */
	ViewResolver.ctorParameters = [{ type: ReflectorReader$1 }];

	var CompileMetadataResolver = function () {
	    function CompileMetadataResolver(_directiveResolver, _pipeResolver, _viewResolver, _config) {
	        var _reflector = arguments.length <= 4 || arguments[4] === undefined ? reflector$2 : arguments[4];

	        classCallCheck(this, CompileMetadataResolver);

	        this._directiveResolver = _directiveResolver;
	        this._pipeResolver = _pipeResolver;
	        this._viewResolver = _viewResolver;
	        this._config = _config;
	        this._reflector = _reflector;
	        this._directiveCache = new Map();
	        this._pipeCache = new Map();
	        this._anonymousTypes = new Map();
	        this._anonymousTypeIndex = 0;
	    }

	    createClass(CompileMetadataResolver, [{
	        key: 'sanitizeTokenName',
	        value: function sanitizeTokenName(token) {
	            var identifier = stringify$3(token);
	            if (identifier.indexOf('(') >= 0) {
	                // case: anonymous functions!
	                var found = this._anonymousTypes.get(token);
	                if (isBlank$3(found)) {
	                    this._anonymousTypes.set(token, this._anonymousTypeIndex++);
	                    found = this._anonymousTypes.get(token);
	                }
	                identifier = 'anonymous_token_' + found + '_';
	            }
	            return sanitizeIdentifier(identifier);
	        }
	    }, {
	        key: 'clearCacheFor',
	        value: function clearCacheFor(compType) {
	            this._directiveCache.delete(compType);
	            this._pipeCache.delete(compType);
	        }
	    }, {
	        key: 'clearCache',
	        value: function clearCache() {
	            this._directiveCache.clear();
	            this._pipeCache.clear();
	        }
	    }, {
	        key: 'getAnimationEntryMetadata',
	        value: function getAnimationEntryMetadata(entry) {
	            var _this = this;

	            var defs = entry.definitions.map(function (def) {
	                return _this.getAnimationStateMetadata(def);
	            });
	            return new CompileAnimationEntryMetadata(entry.name, defs);
	        }
	    }, {
	        key: 'getAnimationStateMetadata',
	        value: function getAnimationStateMetadata(value) {
	            if (value instanceof AnimationStateDeclarationMetadata) {
	                var styles = this.getAnimationStyleMetadata(value.styles);
	                return new CompileAnimationStateDeclarationMetadata(value.stateNameExpr, styles);
	            } else if (value instanceof AnimationStateTransitionMetadata) {
	                return new CompileAnimationStateTransitionMetadata(value.stateChangeExpr, this.getAnimationMetadata(value.steps));
	            }
	            return null;
	        }
	    }, {
	        key: 'getAnimationStyleMetadata',
	        value: function getAnimationStyleMetadata(value) {
	            return new CompileAnimationStyleMetadata(value.offset, value.styles);
	        }
	    }, {
	        key: 'getAnimationMetadata',
	        value: function getAnimationMetadata(value) {
	            var _this2 = this;

	            if (value instanceof AnimationStyleMetadata) {
	                return this.getAnimationStyleMetadata(value);
	            } else if (value instanceof AnimationKeyframesSequenceMetadata) {
	                return new CompileAnimationKeyframesSequenceMetadata(value.steps.map(function (entry) {
	                    return _this2.getAnimationStyleMetadata(entry);
	                }));
	            } else if (value instanceof AnimationAnimateMetadata) {
	                var animateData = this.getAnimationMetadata(value.styles);
	                return new CompileAnimationAnimateMetadata(value.timings, animateData);
	            } else if (value instanceof AnimationWithStepsMetadata) {
	                var steps = value.steps.map(function (step) {
	                    return _this2.getAnimationMetadata(step);
	                });
	                if (value instanceof AnimationGroupMetadata) {
	                    return new CompileAnimationGroupMetadata(steps);
	                } else {
	                    return new CompileAnimationSequenceMetadata(steps);
	                }
	            }
	            return null;
	        }
	    }, {
	        key: 'getDirectiveMetadata',
	        value: function getDirectiveMetadata(directiveType) {
	            var _this3 = this;

	            var meta = this._directiveCache.get(directiveType);
	            if (isBlank$3(meta)) {
	                var dirMeta = this._directiveResolver.resolve(directiveType);
	                var templateMeta = null;
	                var changeDetectionStrategy = null;
	                var viewProviders = [];
	                var moduleUrl = staticTypeModuleUrl(directiveType);
	                var precompileTypes = [];
	                if (dirMeta instanceof ComponentMetadata) {
	                    var cmpMeta = dirMeta;
	                    var viewMeta = this._viewResolver.resolve(directiveType);
	                    assertArrayOfStrings('styles', viewMeta.styles);
	                    assertInterpolationSymbols('interpolation', viewMeta.interpolation);
	                    var animations = isPresent$3(viewMeta.animations) ? viewMeta.animations.map(function (e) {
	                        return _this3.getAnimationEntryMetadata(e);
	                    }) : null;
	                    assertArrayOfStrings('styles', viewMeta.styles);
	                    assertArrayOfStrings('styleUrls', viewMeta.styleUrls);
	                    templateMeta = new CompileTemplateMetadata({
	                        encapsulation: viewMeta.encapsulation,
	                        template: viewMeta.template,
	                        templateUrl: viewMeta.templateUrl,
	                        styles: viewMeta.styles,
	                        styleUrls: viewMeta.styleUrls,
	                        animations: animations,
	                        interpolation: viewMeta.interpolation
	                    });
	                    changeDetectionStrategy = cmpMeta.changeDetection;
	                    if (isPresent$3(dirMeta.viewProviders)) {
	                        viewProviders = this.getProvidersMetadata(verifyNonBlankProviders(directiveType, dirMeta.viewProviders, 'viewProviders'));
	                    }
	                    moduleUrl = componentModuleUrl(this._reflector, directiveType, cmpMeta);
	                    if (cmpMeta.precompile) {
	                        precompileTypes = flattenArray(cmpMeta.precompile).map(function (cmp) {
	                            return _this3.getTypeMetadata(cmp, staticTypeModuleUrl(cmp));
	                        });
	                    }
	                }
	                var providers = [];
	                if (isPresent$3(dirMeta.providers)) {
	                    providers = this.getProvidersMetadata(verifyNonBlankProviders(directiveType, dirMeta.providers, 'providers'));
	                }
	                var queries = [];
	                var viewQueries = [];
	                if (isPresent$3(dirMeta.queries)) {
	                    queries = this.getQueriesMetadata(dirMeta.queries, false, directiveType);
	                    viewQueries = this.getQueriesMetadata(dirMeta.queries, true, directiveType);
	                }
	                meta = CompileDirectiveMetadata.create({
	                    selector: dirMeta.selector,
	                    exportAs: dirMeta.exportAs,
	                    isComponent: isPresent$3(templateMeta),
	                    type: this.getTypeMetadata(directiveType, moduleUrl),
	                    template: templateMeta,
	                    changeDetection: changeDetectionStrategy,
	                    inputs: dirMeta.inputs,
	                    outputs: dirMeta.outputs,
	                    host: dirMeta.host,
	                    lifecycleHooks: LIFECYCLE_HOOKS_VALUES$1.filter(function (hook) {
	                        return hasLifecycleHook(hook, directiveType);
	                    }),
	                    providers: providers,
	                    viewProviders: viewProviders,
	                    queries: queries,
	                    viewQueries: viewQueries,
	                    precompile: precompileTypes
	                });
	                this._directiveCache.set(directiveType, meta);
	            }
	            return meta;
	        }
	        /**
	         * @param someType a symbol which may or may not be a directive type
	         * @returns {cpl.CompileDirectiveMetadata} if possible, otherwise null.
	         */

	    }, {
	        key: 'maybeGetDirectiveMetadata',
	        value: function maybeGetDirectiveMetadata(someType) {
	            try {
	                return this.getDirectiveMetadata(someType);
	            } catch (e) {
	                if (e.message.indexOf('No Directive annotation') !== -1) {
	                    return null;
	                }
	                throw e;
	            }
	        }
	    }, {
	        key: 'getTypeMetadata',
	        value: function getTypeMetadata(type, moduleUrl) {
	            var dependencies = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return new CompileTypeMetadata({
	                name: this.sanitizeTokenName(type),
	                moduleUrl: moduleUrl,
	                runtime: type,
	                diDeps: this.getDependenciesMetadata(type, dependencies)
	            });
	        }
	    }, {
	        key: 'getFactoryMetadata',
	        value: function getFactoryMetadata(factory, moduleUrl) {
	            var dependencies = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return new CompileFactoryMetadata({
	                name: this.sanitizeTokenName(factory),
	                moduleUrl: moduleUrl,
	                runtime: factory,
	                diDeps: this.getDependenciesMetadata(factory, dependencies)
	            });
	        }
	    }, {
	        key: 'getPipeMetadata',
	        value: function getPipeMetadata(pipeType) {
	            var meta = this._pipeCache.get(pipeType);
	            if (isBlank$3(meta)) {
	                var pipeMeta = this._pipeResolver.resolve(pipeType);
	                meta = new CompilePipeMetadata({
	                    type: this.getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),
	                    name: pipeMeta.name,
	                    pure: pipeMeta.pure,
	                    lifecycleHooks: LIFECYCLE_HOOKS_VALUES$1.filter(function (hook) {
	                        return hasLifecycleHook(hook, pipeType);
	                    })
	                });
	                this._pipeCache.set(pipeType, meta);
	            }
	            return meta;
	        }
	    }, {
	        key: 'getViewDirectivesMetadata',
	        value: function getViewDirectivesMetadata(component) {
	            var _this4 = this;

	            var view = this._viewResolver.resolve(component);
	            var directives = flattenDirectives(view, this._config.platformDirectives);
	            for (var i = 0; i < directives.length; i++) {
	                if (!isValidType(directives[i])) {
	                    throw new BaseException$3('Unexpected directive value \'' + stringify$3(directives[i]) + '\' on the View of component \'' + stringify$3(component) + '\'');
	                }
	            }
	            return directives.map(function (type) {
	                return _this4.getDirectiveMetadata(type);
	            });
	        }
	    }, {
	        key: 'getViewPipesMetadata',
	        value: function getViewPipesMetadata(component) {
	            var _this5 = this;

	            var view = this._viewResolver.resolve(component);
	            var pipes = flattenPipes(view, this._config.platformPipes);
	            for (var i = 0; i < pipes.length; i++) {
	                if (!isValidType(pipes[i])) {
	                    throw new BaseException$3('Unexpected piped value \'' + stringify$3(pipes[i]) + '\' on the View of component \'' + stringify$3(component) + '\'');
	                }
	            }
	            return pipes.map(function (type) {
	                return _this5.getPipeMetadata(type);
	            });
	        }
	    }, {
	        key: 'getDependenciesMetadata',
	        value: function getDependenciesMetadata(typeOrFunc, dependencies) {
	            var _this6 = this;

	            var hasUnknownDeps = false;
	            var params = isPresent$3(dependencies) ? dependencies : this._reflector.parameters(typeOrFunc);
	            if (isBlank$3(params)) {
	                params = [];
	            }
	            var dependenciesMetadata = params.map(function (param) {
	                var isAttribute = false;
	                var isHost = false;
	                var isSelf = false;
	                var isSkipSelf = false;
	                var isOptional = false;
	                var query = null;
	                var viewQuery = null;
	                var token = null;
	                if (isArray$4(param)) {
	                    param.forEach(function (paramEntry) {
	                        if (paramEntry instanceof HostMetadata) {
	                            isHost = true;
	                        } else if (paramEntry instanceof SelfMetadata) {
	                            isSelf = true;
	                        } else if (paramEntry instanceof SkipSelfMetadata) {
	                            isSkipSelf = true;
	                        } else if (paramEntry instanceof OptionalMetadata) {
	                            isOptional = true;
	                        } else if (paramEntry instanceof AttributeMetadata) {
	                            isAttribute = true;
	                            token = paramEntry.attributeName;
	                        } else if (paramEntry instanceof QueryMetadata) {
	                            if (paramEntry.isViewQuery) {
	                                viewQuery = paramEntry;
	                            } else {
	                                query = paramEntry;
	                            }
	                        } else if (paramEntry instanceof InjectMetadata) {
	                            token = paramEntry.token;
	                        } else if (isValidType(paramEntry) && isBlank$3(token)) {
	                            token = paramEntry;
	                        }
	                    });
	                } else {
	                    token = param;
	                }
	                if (isBlank$3(token)) {
	                    hasUnknownDeps = true;
	                    return null;
	                }
	                return new CompileDiDependencyMetadata({
	                    isAttribute: isAttribute,
	                    isHost: isHost,
	                    isSelf: isSelf,
	                    isSkipSelf: isSkipSelf,
	                    isOptional: isOptional,
	                    query: isPresent$3(query) ? _this6.getQueryMetadata(query, null, typeOrFunc) : null,
	                    viewQuery: isPresent$3(viewQuery) ? _this6.getQueryMetadata(viewQuery, null, typeOrFunc) : null,
	                    token: _this6.getTokenMetadata(token)
	                });
	            });
	            if (hasUnknownDeps) {
	                var depsTokens = dependenciesMetadata.map(function (dep) {
	                    return dep ? stringify$3(dep.token) : '?';
	                }).join(', ');
	                throw new BaseException$3('Can\'t resolve all parameters for ' + stringify$3(typeOrFunc) + ': (' + depsTokens + ').');
	            }
	            return dependenciesMetadata;
	        }
	    }, {
	        key: 'getTokenMetadata',
	        value: function getTokenMetadata(token) {
	            token = resolveForwardRef(token);
	            var compileToken;
	            if (isString$3(token)) {
	                compileToken = new CompileTokenMetadata({ value: token });
	            } else {
	                compileToken = new CompileTokenMetadata({
	                    identifier: new CompileIdentifierMetadata({
	                        runtime: token,
	                        name: this.sanitizeTokenName(token),
	                        moduleUrl: staticTypeModuleUrl(token)
	                    })
	                });
	            }
	            return compileToken;
	        }
	    }, {
	        key: 'getProvidersMetadata',
	        value: function getProvidersMetadata(providers) {
	            var _this7 = this;

	            return providers.map(function (provider) {
	                provider = resolveForwardRef(provider);
	                if (isArray$4(provider)) {
	                    return _this7.getProvidersMetadata(provider);
	                } else if (provider instanceof Provider) {
	                    return _this7.getProviderMetadata(provider);
	                } else if (isProviderLiteral$1(provider)) {
	                    return _this7.getProviderMetadata(createProvider$1(provider));
	                } else {
	                    return _this7.getTypeMetadata(provider, staticTypeModuleUrl(provider));
	                }
	            });
	        }
	    }, {
	        key: 'getProviderMetadata',
	        value: function getProviderMetadata(provider) {
	            var compileDeps;
	            var compileTypeMetadata = null;
	            var compileFactoryMetadata = null;
	            if (isPresent$3(provider.useClass)) {
	                compileTypeMetadata = this.getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass), provider.dependencies);
	                compileDeps = compileTypeMetadata.diDeps;
	            } else if (isPresent$3(provider.useFactory)) {
	                compileFactoryMetadata = this.getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory), provider.dependencies);
	                compileDeps = compileFactoryMetadata.diDeps;
	            }
	            return new CompileProviderMetadata({
	                token: this.getTokenMetadata(provider.token),
	                useClass: compileTypeMetadata,
	                useValue: convertToCompileValue(provider.useValue),
	                useFactory: compileFactoryMetadata,
	                useExisting: isPresent$3(provider.useExisting) ? this.getTokenMetadata(provider.useExisting) : null,
	                deps: compileDeps,
	                multi: provider.multi
	            });
	        }
	    }, {
	        key: 'getQueriesMetadata',
	        value: function getQueriesMetadata(queries, isViewQuery, directiveType) {
	            var _this8 = this;

	            var compileQueries = [];
	            StringMapWrapper$3.forEach(queries, function (query /** TODO #9100 */, propertyName /** TODO #9100 */) {
	                if (query.isViewQuery === isViewQuery) {
	                    compileQueries.push(_this8.getQueryMetadata(query, propertyName, directiveType));
	                }
	            });
	            return compileQueries;
	        }
	    }, {
	        key: 'getQueryMetadata',
	        value: function getQueryMetadata(q, propertyName, typeOrFunc) {
	            var _this9 = this;

	            var selectors;
	            if (q.isVarBindingQuery) {
	                selectors = q.varBindings.map(function (varName) {
	                    return _this9.getTokenMetadata(varName);
	                });
	            } else {
	                if (!isPresent$3(q.selector)) {
	                    throw new BaseException$3('Can\'t construct a query for the property "' + propertyName + '" of "' + stringify$3(typeOrFunc) + '" since the query selector wasn\'t defined.');
	                }
	                selectors = [this.getTokenMetadata(q.selector)];
	            }
	            return new CompileQueryMetadata({
	                selectors: selectors,
	                first: q.first,
	                descendants: q.descendants,
	                propertyName: propertyName,
	                read: isPresent$3(q.read) ? this.getTokenMetadata(q.read) : null
	            });
	        }
	    }]);
	    return CompileMetadataResolver;
	}();
	/** @nocollapse */
	CompileMetadataResolver.decorators = [{ type: Injectable }];
	/** @nocollapse */
	CompileMetadataResolver.ctorParameters = [{ type: DirectiveResolver }, { type: PipeResolver }, { type: ViewResolver }, { type: CompilerConfig }, { type: ReflectorReader$1 }];
	function flattenDirectives(view, platformDirectives) {
	    var directives = [];
	    if (isPresent$3(platformDirectives)) {
	        flattenArray(platformDirectives, directives);
	    }
	    if (isPresent$3(view.directives)) {
	        flattenArray(view.directives, directives);
	    }
	    return directives;
	}
	function flattenPipes(view, platformPipes) {
	    var pipes = [];
	    if (isPresent$3(platformPipes)) {
	        flattenArray(platformPipes, pipes);
	    }
	    if (isPresent$3(view.pipes)) {
	        flattenArray(view.pipes, pipes);
	    }
	    return pipes;
	}
	function flattenArray(tree) {
	    var out = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

	    for (var i = 0; i < tree.length; i++) {
	        var item = resolveForwardRef(tree[i]);
	        if (isArray$4(item)) {
	            flattenArray(item, out);
	        } else {
	            out.push(item);
	        }
	    }
	    return out;
	}
	function verifyNonBlankProviders(directiveType, providersTree, providersType) {
	    var flat = [];
	    var errMsg;
	    flattenArray(providersTree, flat);
	    for (var i = 0; i < flat.length; i++) {
	        if (isBlank$3(flat[i])) {
	            errMsg = flat.map(function (provider) {
	                return isBlank$3(provider) ? '?' : stringify$3(provider);
	            }).join(', ');
	            throw new BaseException$3('One or more of ' + providersType + ' for "' + stringify$3(directiveType) + '" were not defined: [' + errMsg + '].');
	        }
	    }
	    return providersTree;
	}
	function isStaticType(value) {
	    return isStringMap$3(value) && isPresent$3(value['name']) && isPresent$3(value['filePath']);
	}
	function isValidType(value) {
	    return isStaticType(value) || value instanceof Type$3;
	}
	function staticTypeModuleUrl(value) {
	    return isStaticType(value) ? value['filePath'] : null;
	}
	function componentModuleUrl(reflector, type, cmpMetadata) {
	    if (isStaticType(type)) {
	        return staticTypeModuleUrl(type);
	    }
	    if (isPresent$3(cmpMetadata.moduleId)) {
	        var moduleId = cmpMetadata.moduleId;
	        var scheme = getUrlScheme(moduleId);
	        return isPresent$3(scheme) && scheme.length > 0 ? moduleId : 'package:' + moduleId + MODULE_SUFFIX;
	    }
	    return reflector.importUri(type);
	}
	// Only fill CompileIdentifierMetadata.runtime if needed...
	function convertToCompileValue(value) {
	    return visitValue(value, new _CompileValueConverter(), null);
	}

	var _CompileValueConverter = function (_ValueTransformer) {
	    inherits(_CompileValueConverter, _ValueTransformer);

	    function _CompileValueConverter() {
	        classCallCheck(this, _CompileValueConverter);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(_CompileValueConverter).apply(this, arguments));
	    }

	    createClass(_CompileValueConverter, [{
	        key: 'visitOther',
	        value: function visitOther(value, context) {
	            if (isStaticType(value)) {
	                return new CompileIdentifierMetadata({ name: value['name'], moduleUrl: staticTypeModuleUrl(value) });
	            } else {
	                return new CompileIdentifierMetadata({ runtime: value });
	            }
	        }
	    }]);
	    return _CompileValueConverter;
	}(ValueTransformer);

	var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
	var CATCH_ERROR_VAR$1 = variable('error');
	var CATCH_STACK_VAR$1 = variable('stack');
	var _EmittedLine = function _EmittedLine(indent) {
	    classCallCheck(this, _EmittedLine);

	    this.indent = indent;
	    this.parts = [];
	};

	var EmitterVisitorContext = function () {
	    function EmitterVisitorContext(_exportedVars, _indent) {
	        classCallCheck(this, EmitterVisitorContext);

	        this._exportedVars = _exportedVars;
	        this._indent = _indent;
	        this._classes = [];
	        this._lines = [new _EmittedLine(_indent)];
	    }

	    createClass(EmitterVisitorContext, [{
	        key: 'isExportedVar',
	        value: function isExportedVar(varName) {
	            return this._exportedVars.indexOf(varName) !== -1;
	        }
	    }, {
	        key: 'println',
	        value: function println() {
	            var lastPart = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	            this.print(lastPart, true);
	        }
	    }, {
	        key: 'lineIsEmpty',
	        value: function lineIsEmpty() {
	            return this._currentLine.parts.length === 0;
	        }
	    }, {
	        key: 'print',
	        value: function print(part) {
	            var newLine = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

	            if (part.length > 0) {
	                this._currentLine.parts.push(part);
	            }
	            if (newLine) {
	                this._lines.push(new _EmittedLine(this._indent));
	            }
	        }
	    }, {
	        key: 'removeEmptyLastLine',
	        value: function removeEmptyLastLine() {
	            if (this.lineIsEmpty()) {
	                this._lines.pop();
	            }
	        }
	    }, {
	        key: 'incIndent',
	        value: function incIndent() {
	            this._indent++;
	            this._currentLine.indent = this._indent;
	        }
	    }, {
	        key: 'decIndent',
	        value: function decIndent() {
	            this._indent--;
	            this._currentLine.indent = this._indent;
	        }
	    }, {
	        key: 'pushClass',
	        value: function pushClass(clazz) {
	            this._classes.push(clazz);
	        }
	    }, {
	        key: 'popClass',
	        value: function popClass() {
	            return this._classes.pop();
	        }
	    }, {
	        key: 'toSource',
	        value: function toSource() {
	            var lines = this._lines;
	            if (lines[lines.length - 1].parts.length === 0) {
	                lines = lines.slice(0, lines.length - 1);
	            }
	            return lines.map(function (line) {
	                if (line.parts.length > 0) {
	                    return _createIndent(line.indent) + line.parts.join('');
	                } else {
	                    return '';
	                }
	            }).join('\n');
	        }
	    }, {
	        key: '_currentLine',
	        get: function get() {
	            return this._lines[this._lines.length - 1];
	        }
	    }, {
	        key: 'currentClass',
	        get: function get() {
	            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
	        }
	    }], [{
	        key: 'createRoot',
	        value: function createRoot(exportedVars) {
	            return new EmitterVisitorContext(exportedVars, 0);
	        }
	    }]);
	    return EmitterVisitorContext;
	}();
	var AbstractEmitterVisitor = function () {
	    function AbstractEmitterVisitor(_escapeDollarInStrings) {
	        classCallCheck(this, AbstractEmitterVisitor);

	        this._escapeDollarInStrings = _escapeDollarInStrings;
	    }

	    createClass(AbstractEmitterVisitor, [{
	        key: 'visitExpressionStmt',
	        value: function visitExpressionStmt(stmt, ctx) {
	            stmt.expr.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        }
	    }, {
	        key: 'visitReturnStmt',
	        value: function visitReturnStmt(stmt, ctx) {
	            ctx.print('return ');
	            stmt.value.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        }
	    }, {
	        key: 'visitIfStmt',
	        value: function visitIfStmt(stmt, ctx) {
	            ctx.print('if (');
	            stmt.condition.visitExpression(this, ctx);
	            ctx.print(') {');
	            var hasElseCase = isPresent$3(stmt.falseCase) && stmt.falseCase.length > 0;
	            if (stmt.trueCase.length <= 1 && !hasElseCase) {
	                ctx.print(' ');
	                this.visitAllStatements(stmt.trueCase, ctx);
	                ctx.removeEmptyLastLine();
	                ctx.print(' ');
	            } else {
	                ctx.println();
	                ctx.incIndent();
	                this.visitAllStatements(stmt.trueCase, ctx);
	                ctx.decIndent();
	                if (hasElseCase) {
	                    ctx.println('} else {');
	                    ctx.incIndent();
	                    this.visitAllStatements(stmt.falseCase, ctx);
	                    ctx.decIndent();
	                }
	            }
	            ctx.println('}');
	            return null;
	        }
	    }, {
	        key: 'visitThrowStmt',
	        value: function visitThrowStmt(stmt, ctx) {
	            ctx.print('throw ');
	            stmt.error.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        }
	    }, {
	        key: 'visitCommentStmt',
	        value: function visitCommentStmt(stmt, ctx) {
	            var lines = stmt.comment.split('\n');
	            lines.forEach(function (line) {
	                ctx.println('// ' + line);
	            });
	            return null;
	        }
	    }, {
	        key: 'visitWriteVarExpr',
	        value: function visitWriteVarExpr(expr, ctx) {
	            var lineWasEmpty = ctx.lineIsEmpty();
	            if (!lineWasEmpty) {
	                ctx.print('(');
	            }
	            ctx.print(expr.name + ' = ');
	            expr.value.visitExpression(this, ctx);
	            if (!lineWasEmpty) {
	                ctx.print(')');
	            }
	            return null;
	        }
	    }, {
	        key: 'visitWriteKeyExpr',
	        value: function visitWriteKeyExpr(expr, ctx) {
	            var lineWasEmpty = ctx.lineIsEmpty();
	            if (!lineWasEmpty) {
	                ctx.print('(');
	            }
	            expr.receiver.visitExpression(this, ctx);
	            ctx.print('[');
	            expr.index.visitExpression(this, ctx);
	            ctx.print('] = ');
	            expr.value.visitExpression(this, ctx);
	            if (!lineWasEmpty) {
	                ctx.print(')');
	            }
	            return null;
	        }
	    }, {
	        key: 'visitWritePropExpr',
	        value: function visitWritePropExpr(expr, ctx) {
	            var lineWasEmpty = ctx.lineIsEmpty();
	            if (!lineWasEmpty) {
	                ctx.print('(');
	            }
	            expr.receiver.visitExpression(this, ctx);
	            ctx.print('.' + expr.name + ' = ');
	            expr.value.visitExpression(this, ctx);
	            if (!lineWasEmpty) {
	                ctx.print(')');
	            }
	            return null;
	        }
	    }, {
	        key: 'visitInvokeMethodExpr',
	        value: function visitInvokeMethodExpr(expr, ctx) {
	            expr.receiver.visitExpression(this, ctx);
	            var name = expr.name;
	            if (isPresent$3(expr.builtin)) {
	                name = this.getBuiltinMethodName(expr.builtin);
	                if (isBlank$3(name)) {
	                    // some builtins just mean to skip the call.
	                    // e.g. `bind` in Dart.
	                    return null;
	                }
	            }
	            ctx.print('.' + name + '(');
	            this.visitAllExpressions(expr.args, ctx, ',');
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitInvokeFunctionExpr',
	        value: function visitInvokeFunctionExpr(expr, ctx) {
	            expr.fn.visitExpression(this, ctx);
	            ctx.print('(');
	            this.visitAllExpressions(expr.args, ctx, ',');
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitReadVarExpr',
	        value: function visitReadVarExpr(ast, ctx) {
	            var varName = ast.name;
	            if (isPresent$3(ast.builtin)) {
	                switch (ast.builtin) {
	                    case BuiltinVar.Super:
	                        varName = 'super';
	                        break;
	                    case BuiltinVar.This:
	                        varName = 'this';
	                        break;
	                    case BuiltinVar.CatchError:
	                        varName = CATCH_ERROR_VAR$1.name;
	                        break;
	                    case BuiltinVar.CatchStack:
	                        varName = CATCH_STACK_VAR$1.name;
	                        break;
	                    default:
	                        throw new BaseException$3('Unknown builtin variable ' + ast.builtin);
	                }
	            }
	            ctx.print(varName);
	            return null;
	        }
	    }, {
	        key: 'visitInstantiateExpr',
	        value: function visitInstantiateExpr(ast, ctx) {
	            ctx.print('new ');
	            ast.classExpr.visitExpression(this, ctx);
	            ctx.print('(');
	            this.visitAllExpressions(ast.args, ctx, ',');
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitLiteralExpr',
	        value: function visitLiteralExpr(ast, ctx) {
	            var value = ast.value;
	            if (isString$3(value)) {
	                ctx.print(escapeSingleQuoteString(value, this._escapeDollarInStrings));
	            } else if (isBlank$3(value)) {
	                ctx.print('null');
	            } else {
	                ctx.print('' + value);
	            }
	            return null;
	        }
	    }, {
	        key: 'visitConditionalExpr',
	        value: function visitConditionalExpr(ast, ctx) {
	            ctx.print('(');
	            ast.condition.visitExpression(this, ctx);
	            ctx.print('? ');
	            ast.trueCase.visitExpression(this, ctx);
	            ctx.print(': ');
	            ast.falseCase.visitExpression(this, ctx);
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitNotExpr',
	        value: function visitNotExpr(ast, ctx) {
	            ctx.print('!');
	            ast.condition.visitExpression(this, ctx);
	            return null;
	        }
	    }, {
	        key: 'visitBinaryOperatorExpr',
	        value: function visitBinaryOperatorExpr(ast, ctx) {
	            var opStr;
	            switch (ast.operator) {
	                case BinaryOperator.Equals:
	                    opStr = '==';
	                    break;
	                case BinaryOperator.Identical:
	                    opStr = '===';
	                    break;
	                case BinaryOperator.NotEquals:
	                    opStr = '!=';
	                    break;
	                case BinaryOperator.NotIdentical:
	                    opStr = '!==';
	                    break;
	                case BinaryOperator.And:
	                    opStr = '&&';
	                    break;
	                case BinaryOperator.Or:
	                    opStr = '||';
	                    break;
	                case BinaryOperator.Plus:
	                    opStr = '+';
	                    break;
	                case BinaryOperator.Minus:
	                    opStr = '-';
	                    break;
	                case BinaryOperator.Divide:
	                    opStr = '/';
	                    break;
	                case BinaryOperator.Multiply:
	                    opStr = '*';
	                    break;
	                case BinaryOperator.Modulo:
	                    opStr = '%';
	                    break;
	                case BinaryOperator.Lower:
	                    opStr = '<';
	                    break;
	                case BinaryOperator.LowerEquals:
	                    opStr = '<=';
	                    break;
	                case BinaryOperator.Bigger:
	                    opStr = '>';
	                    break;
	                case BinaryOperator.BiggerEquals:
	                    opStr = '>=';
	                    break;
	                default:
	                    throw new BaseException$3('Unknown operator ' + ast.operator);
	            }
	            ctx.print('(');
	            ast.lhs.visitExpression(this, ctx);
	            ctx.print(' ' + opStr + ' ');
	            ast.rhs.visitExpression(this, ctx);
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitReadPropExpr',
	        value: function visitReadPropExpr(ast, ctx) {
	            ast.receiver.visitExpression(this, ctx);
	            ctx.print('.');
	            ctx.print(ast.name);
	            return null;
	        }
	    }, {
	        key: 'visitReadKeyExpr',
	        value: function visitReadKeyExpr(ast, ctx) {
	            ast.receiver.visitExpression(this, ctx);
	            ctx.print('[');
	            ast.index.visitExpression(this, ctx);
	            ctx.print(']');
	            return null;
	        }
	    }, {
	        key: 'visitLiteralArrayExpr',
	        value: function visitLiteralArrayExpr(ast, ctx) {
	            var useNewLine = ast.entries.length > 1;
	            ctx.print('[', useNewLine);
	            ctx.incIndent();
	            this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
	            ctx.decIndent();
	            ctx.print(']', useNewLine);
	            return null;
	        }
	    }, {
	        key: 'visitLiteralMapExpr',
	        value: function visitLiteralMapExpr(ast, ctx) {
	            var _this = this;

	            var useNewLine = ast.entries.length > 1;
	            ctx.print('{', useNewLine);
	            ctx.incIndent();
	            this.visitAllObjects(function (entry /** TODO #9100 */) {
	                ctx.print(escapeSingleQuoteString(entry[0], _this._escapeDollarInStrings) + ': ');
	                entry[1].visitExpression(_this, ctx);
	            }, ast.entries, ctx, ',', useNewLine);
	            ctx.decIndent();
	            ctx.print('}', useNewLine);
	            return null;
	        }
	    }, {
	        key: 'visitAllExpressions',
	        value: function visitAllExpressions(expressions, ctx, separator) {
	            var _this2 = this;

	            var newLine = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

	            this.visitAllObjects(function (expr /** TODO #9100 */) {
	                return expr.visitExpression(_this2, ctx);
	            }, expressions, ctx, separator, newLine);
	        }
	    }, {
	        key: 'visitAllObjects',
	        value: function visitAllObjects(handler, expressions, ctx, separator) {
	            var newLine = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

	            for (var i = 0; i < expressions.length; i++) {
	                if (i > 0) {
	                    ctx.print(separator, newLine);
	                }
	                handler(expressions[i]);
	            }
	            if (newLine) {
	                ctx.println();
	            }
	        }
	    }, {
	        key: 'visitAllStatements',
	        value: function visitAllStatements(statements, ctx) {
	            var _this3 = this;

	            statements.forEach(function (stmt) {
	                return stmt.visitStatement(_this3, ctx);
	            });
	        }
	    }]);
	    return AbstractEmitterVisitor;
	}();
	function escapeSingleQuoteString(input, escapeDollar) {
	    if (isBlank$3(input)) {
	        return null;
	    }
	    var body = StringWrapper$3.replaceAllMapped(input, _SINGLE_QUOTE_ESCAPE_STRING_RE, function (match /** TODO #9100 */) {
	        if (match[0] == '$') {
	            return escapeDollar ? '\\$' : '$';
	        } else if (match[0] == '\n') {
	            return '\\n';
	        } else if (match[0] == '\r') {
	            return '\\r';
	        } else {
	            return '\\' + match[0];
	        }
	    });
	    return '\'' + body + '\'';
	}
	function _createIndent(count) {
	    var res = '';
	    for (var i = 0; i < count; i++) {
	        res += '  ';
	    }
	    return res;
	}

	var AbstractJsEmitterVisitor = function (_AbstractEmitterVisit) {
	    inherits(AbstractJsEmitterVisitor, _AbstractEmitterVisit);

	    function AbstractJsEmitterVisitor() {
	        classCallCheck(this, AbstractJsEmitterVisitor);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(AbstractJsEmitterVisitor).call(this, false));
	    }

	    createClass(AbstractJsEmitterVisitor, [{
	        key: 'visitDeclareClassStmt',
	        value: function visitDeclareClassStmt(stmt, ctx) {
	            var _this2 = this;

	            ctx.pushClass(stmt);
	            this._visitClassConstructor(stmt, ctx);
	            if (isPresent$3(stmt.parent)) {
	                ctx.print(stmt.name + '.prototype = Object.create(');
	                stmt.parent.visitExpression(this, ctx);
	                ctx.println('.prototype);');
	            }
	            stmt.getters.forEach(function (getter) {
	                return _this2._visitClassGetter(stmt, getter, ctx);
	            });
	            stmt.methods.forEach(function (method) {
	                return _this2._visitClassMethod(stmt, method, ctx);
	            });
	            ctx.popClass();
	            return null;
	        }
	    }, {
	        key: '_visitClassConstructor',
	        value: function _visitClassConstructor(stmt, ctx) {
	            ctx.print('function ' + stmt.name + '(');
	            if (isPresent$3(stmt.constructorMethod)) {
	                this._visitParams(stmt.constructorMethod.params, ctx);
	            }
	            ctx.println(') {');
	            ctx.incIndent();
	            if (isPresent$3(stmt.constructorMethod)) {
	                if (stmt.constructorMethod.body.length > 0) {
	                    ctx.println('var self = this;');
	                    this.visitAllStatements(stmt.constructorMethod.body, ctx);
	                }
	            }
	            ctx.decIndent();
	            ctx.println('}');
	        }
	    }, {
	        key: '_visitClassGetter',
	        value: function _visitClassGetter(stmt, getter, ctx) {
	            ctx.println('Object.defineProperty(' + stmt.name + '.prototype, \'' + getter.name + '\', { get: function() {');
	            ctx.incIndent();
	            if (getter.body.length > 0) {
	                ctx.println('var self = this;');
	                this.visitAllStatements(getter.body, ctx);
	            }
	            ctx.decIndent();
	            ctx.println('}});');
	        }
	    }, {
	        key: '_visitClassMethod',
	        value: function _visitClassMethod(stmt, method, ctx) {
	            ctx.print(stmt.name + '.prototype.' + method.name + ' = function(');
	            this._visitParams(method.params, ctx);
	            ctx.println(') {');
	            ctx.incIndent();
	            if (method.body.length > 0) {
	                ctx.println('var self = this;');
	                this.visitAllStatements(method.body, ctx);
	            }
	            ctx.decIndent();
	            ctx.println('};');
	        }
	    }, {
	        key: 'visitReadVarExpr',
	        value: function visitReadVarExpr(ast, ctx) {
	            if (ast.builtin === BuiltinVar.This) {
	                ctx.print('self');
	            } else if (ast.builtin === BuiltinVar.Super) {
	                throw new BaseException$3('\'super\' needs to be handled at a parent ast node, not at the variable level!');
	            } else {
	                get(Object.getPrototypeOf(AbstractJsEmitterVisitor.prototype), 'visitReadVarExpr', this).call(this, ast, ctx);
	            }
	            return null;
	        }
	    }, {
	        key: 'visitDeclareVarStmt',
	        value: function visitDeclareVarStmt(stmt, ctx) {
	            ctx.print('var ' + stmt.name + ' = ');
	            stmt.value.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        }
	    }, {
	        key: 'visitCastExpr',
	        value: function visitCastExpr(ast, ctx) {
	            ast.value.visitExpression(this, ctx);
	            return null;
	        }
	    }, {
	        key: 'visitInvokeFunctionExpr',
	        value: function visitInvokeFunctionExpr(expr, ctx) {
	            var fnExpr = expr.fn;
	            if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
	                ctx.currentClass.parent.visitExpression(this, ctx);
	                ctx.print('.call(this');
	                if (expr.args.length > 0) {
	                    ctx.print(', ');
	                    this.visitAllExpressions(expr.args, ctx, ',');
	                }
	                ctx.print(')');
	            } else {
	                get(Object.getPrototypeOf(AbstractJsEmitterVisitor.prototype), 'visitInvokeFunctionExpr', this).call(this, expr, ctx);
	            }
	            return null;
	        }
	    }, {
	        key: 'visitFunctionExpr',
	        value: function visitFunctionExpr(ast, ctx) {
	            ctx.print('function(');
	            this._visitParams(ast.params, ctx);
	            ctx.println(') {');
	            ctx.incIndent();
	            this.visitAllStatements(ast.statements, ctx);
	            ctx.decIndent();
	            ctx.print('}');
	            return null;
	        }
	    }, {
	        key: 'visitDeclareFunctionStmt',
	        value: function visitDeclareFunctionStmt(stmt, ctx) {
	            ctx.print('function ' + stmt.name + '(');
	            this._visitParams(stmt.params, ctx);
	            ctx.println(') {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.statements, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	            return null;
	        }
	    }, {
	        key: 'visitTryCatchStmt',
	        value: function visitTryCatchStmt(stmt, ctx) {
	            ctx.println('try {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.bodyStmts, ctx);
	            ctx.decIndent();
	            ctx.println('} catch (' + CATCH_ERROR_VAR$1.name + ') {');
	            ctx.incIndent();
	            var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);
	            this.visitAllStatements(catchStmts, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	            return null;
	        }
	    }, {
	        key: '_visitParams',
	        value: function _visitParams(params, ctx) {
	            this.visitAllObjects(function (param /** TODO #9100 */) {
	                return ctx.print(param.name);
	            }, params, ctx, ',');
	        }
	    }, {
	        key: 'getBuiltinMethodName',
	        value: function getBuiltinMethodName(method) {
	            var name;
	            switch (method) {
	                case BuiltinMethod.ConcatArray:
	                    name = 'concat';
	                    break;
	                case BuiltinMethod.SubscribeObservable:
	                    name = 'subscribe';
	                    break;
	                case BuiltinMethod.bind:
	                    name = 'bind';
	                    break;
	                default:
	                    throw new BaseException$3('Unknown builtin method: ' + method);
	            }
	            return name;
	        }
	    }]);
	    return AbstractJsEmitterVisitor;
	}(AbstractEmitterVisitor);

	function jitStatements(sourceUrl, statements, resultVar) {
	    var converter = new JitEmitterVisitor();
	    var ctx = EmitterVisitorContext.createRoot([resultVar]);
	    converter.visitAllStatements(statements, ctx);
	    return evalExpression$3(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
	}

	var JitEmitterVisitor = function (_AbstractJsEmitterVis) {
	    inherits(JitEmitterVisitor, _AbstractJsEmitterVis);

	    function JitEmitterVisitor() {
	        var _Object$getPrototypeO;

	        classCallCheck(this, JitEmitterVisitor);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        var _this = possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(JitEmitterVisitor)).call.apply(_Object$getPrototypeO, [this].concat(args)));

	        _this._evalArgNames = [];
	        _this._evalArgValues = [];
	        return _this;
	    }

	    createClass(JitEmitterVisitor, [{
	        key: 'getArgs',
	        value: function getArgs() {
	            var result = {};
	            for (var i = 0; i < this._evalArgNames.length; i++) {
	                result[this._evalArgNames[i]] = this._evalArgValues[i];
	            }
	            return result;
	        }
	    }, {
	        key: 'visitExternalExpr',
	        value: function visitExternalExpr(ast, ctx) {
	            var value = ast.value.runtime;
	            var id = this._evalArgValues.indexOf(value);
	            if (id === -1) {
	                id = this._evalArgValues.length;
	                this._evalArgValues.push(value);
	                var name = isPresent$3(ast.value.name) ? sanitizeIdentifier(ast.value.name) : 'val';
	                this._evalArgNames.push(sanitizeIdentifier('jit_' + name + id));
	            }
	            ctx.print(this._evalArgNames[id]);
	            return null;
	        }
	    }]);
	    return JitEmitterVisitor;
	}(AbstractJsEmitterVisitor);

	var _debugModuleUrl = 'asset://debug/lib';
	function debugOutputAstAsDart(ast) {
	    var converter = new _DartEmitterVisitor(_debugModuleUrl);
	    var ctx = EmitterVisitorContext.createRoot([]);
	    var asts;
	    if (isArray$4(ast)) {
	        asts = ast;
	    } else {
	        asts = [ast];
	    }
	    asts.forEach(function (ast) {
	        if (ast instanceof Statement) {
	            ast.visitStatement(converter, ctx);
	        } else if (ast instanceof Expression) {
	            ast.visitExpression(converter, ctx);
	        } else if (ast instanceof Type$4) {
	            ast.visitType(converter, ctx);
	        } else {
	            throw new BaseException$3('Don\'t know how to print debug info for ' + ast);
	        }
	    });
	    return ctx.toSource();
	}
	var DartEmitter = function () {
	    function DartEmitter(_importGenerator) {
	        classCallCheck(this, DartEmitter);

	        this._importGenerator = _importGenerator;
	    }

	    createClass(DartEmitter, [{
	        key: 'emitStatements',
	        value: function emitStatements(moduleUrl, stmts, exportedVars) {
	            var _this = this;

	            var srcParts = [];
	            // Note: We are not creating a library here as Dart does not need it.
	            // Dart analzyer might complain about it though.
	            var converter = new _DartEmitterVisitor(moduleUrl);
	            var ctx = EmitterVisitorContext.createRoot(exportedVars);
	            converter.visitAllStatements(stmts, ctx);
	            converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
	                srcParts.push('import \'' + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + '\' as ' + prefix + ';');
	            });
	            srcParts.push(ctx.toSource());
	            return srcParts.join('\n');
	        }
	    }]);
	    return DartEmitter;
	}();

	var _DartEmitterVisitor = function (_AbstractEmitterVisit) {
	    inherits(_DartEmitterVisitor, _AbstractEmitterVisit);

	    function _DartEmitterVisitor(_moduleUrl) {
	        classCallCheck(this, _DartEmitterVisitor);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(_DartEmitterVisitor).call(this, true));

	        _this2._moduleUrl = _moduleUrl;
	        _this2.importsWithPrefixes = new Map();
	        return _this2;
	    }

	    createClass(_DartEmitterVisitor, [{
	        key: 'visitExternalExpr',
	        value: function visitExternalExpr(ast, ctx) {
	            this._visitIdentifier(ast.value, ast.typeParams, ctx);
	            return null;
	        }
	    }, {
	        key: 'visitDeclareVarStmt',
	        value: function visitDeclareVarStmt(stmt, ctx) {
	            if (stmt.hasModifier(StmtModifier.Final)) {
	                if (isConstType(stmt.type)) {
	                    ctx.print('const ');
	                } else {
	                    ctx.print('final ');
	                }
	            } else if (isBlank$3(stmt.type)) {
	                ctx.print('var ');
	            }
	            if (isPresent$3(stmt.type)) {
	                stmt.type.visitType(this, ctx);
	                ctx.print(' ');
	            }
	            ctx.print(stmt.name + ' = ');
	            stmt.value.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        }
	    }, {
	        key: 'visitCastExpr',
	        value: function visitCastExpr(ast, ctx) {
	            ctx.print('(');
	            ast.value.visitExpression(this, ctx);
	            ctx.print(' as ');
	            ast.type.visitType(this, ctx);
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitDeclareClassStmt',
	        value: function visitDeclareClassStmt(stmt, ctx) {
	            var _this3 = this;

	            ctx.pushClass(stmt);
	            ctx.print('class ' + stmt.name);
	            if (isPresent$3(stmt.parent)) {
	                ctx.print(' extends ');
	                stmt.parent.visitExpression(this, ctx);
	            }
	            ctx.println(' {');
	            ctx.incIndent();
	            stmt.fields.forEach(function (field) {
	                return _this3._visitClassField(field, ctx);
	            });
	            if (isPresent$3(stmt.constructorMethod)) {
	                this._visitClassConstructor(stmt, ctx);
	            }
	            stmt.getters.forEach(function (getter) {
	                return _this3._visitClassGetter(getter, ctx);
	            });
	            stmt.methods.forEach(function (method) {
	                return _this3._visitClassMethod(method, ctx);
	            });
	            ctx.decIndent();
	            ctx.println('}');
	            ctx.popClass();
	            return null;
	        }
	    }, {
	        key: '_visitClassField',
	        value: function _visitClassField(field, ctx) {
	            if (field.hasModifier(StmtModifier.Final)) {
	                ctx.print('final ');
	            } else if (isBlank$3(field.type)) {
	                ctx.print('var ');
	            }
	            if (isPresent$3(field.type)) {
	                field.type.visitType(this, ctx);
	                ctx.print(' ');
	            }
	            ctx.println(field.name + ';');
	        }
	    }, {
	        key: '_visitClassGetter',
	        value: function _visitClassGetter(getter, ctx) {
	            if (isPresent$3(getter.type)) {
	                getter.type.visitType(this, ctx);
	                ctx.print(' ');
	            }
	            ctx.println('get ' + getter.name + ' {');
	            ctx.incIndent();
	            this.visitAllStatements(getter.body, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	        }
	    }, {
	        key: '_visitClassConstructor',
	        value: function _visitClassConstructor(stmt, ctx) {
	            ctx.print(stmt.name + '(');
	            this._visitParams(stmt.constructorMethod.params, ctx);
	            ctx.print(')');
	            var ctorStmts = stmt.constructorMethod.body;
	            var superCtorExpr = ctorStmts.length > 0 ? getSuperConstructorCallExpr(ctorStmts[0]) : null;
	            if (isPresent$3(superCtorExpr)) {
	                ctx.print(': ');
	                superCtorExpr.visitExpression(this, ctx);
	                ctorStmts = ctorStmts.slice(1);
	            }
	            ctx.println(' {');
	            ctx.incIndent();
	            this.visitAllStatements(ctorStmts, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	        }
	    }, {
	        key: '_visitClassMethod',
	        value: function _visitClassMethod(method, ctx) {
	            if (isPresent$3(method.type)) {
	                method.type.visitType(this, ctx);
	            } else {
	                ctx.print('void');
	            }
	            ctx.print(' ' + method.name + '(');
	            this._visitParams(method.params, ctx);
	            ctx.println(') {');
	            ctx.incIndent();
	            this.visitAllStatements(method.body, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	        }
	    }, {
	        key: 'visitFunctionExpr',
	        value: function visitFunctionExpr(ast, ctx) {
	            ctx.print('(');
	            this._visitParams(ast.params, ctx);
	            ctx.println(') {');
	            ctx.incIndent();
	            this.visitAllStatements(ast.statements, ctx);
	            ctx.decIndent();
	            ctx.print('}');
	            return null;
	        }
	    }, {
	        key: 'visitDeclareFunctionStmt',
	        value: function visitDeclareFunctionStmt(stmt, ctx) {
	            if (isPresent$3(stmt.type)) {
	                stmt.type.visitType(this, ctx);
	            } else {
	                ctx.print('void');
	            }
	            ctx.print(' ' + stmt.name + '(');
	            this._visitParams(stmt.params, ctx);
	            ctx.println(') {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.statements, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	            return null;
	        }
	    }, {
	        key: 'getBuiltinMethodName',
	        value: function getBuiltinMethodName(method) {
	            var name;
	            switch (method) {
	                case BuiltinMethod.ConcatArray:
	                    name = '.addAll';
	                    break;
	                case BuiltinMethod.SubscribeObservable:
	                    name = 'listen';
	                    break;
	                case BuiltinMethod.bind:
	                    name = null;
	                    break;
	                default:
	                    throw new BaseException$3('Unknown builtin method: ' + method);
	            }
	            return name;
	        }
	    }, {
	        key: 'visitTryCatchStmt',
	        value: function visitTryCatchStmt(stmt, ctx) {
	            ctx.println('try {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.bodyStmts, ctx);
	            ctx.decIndent();
	            ctx.println('} catch (' + CATCH_ERROR_VAR$1.name + ', ' + CATCH_STACK_VAR$1.name + ') {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.catchStmts, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	            return null;
	        }
	    }, {
	        key: 'visitBinaryOperatorExpr',
	        value: function visitBinaryOperatorExpr(ast, ctx) {
	            switch (ast.operator) {
	                case BinaryOperator.Identical:
	                    ctx.print('identical(');
	                    ast.lhs.visitExpression(this, ctx);
	                    ctx.print(', ');
	                    ast.rhs.visitExpression(this, ctx);
	                    ctx.print(')');
	                    break;
	                case BinaryOperator.NotIdentical:
	                    ctx.print('!identical(');
	                    ast.lhs.visitExpression(this, ctx);
	                    ctx.print(', ');
	                    ast.rhs.visitExpression(this, ctx);
	                    ctx.print(')');
	                    break;
	                default:
	                    get(Object.getPrototypeOf(_DartEmitterVisitor.prototype), 'visitBinaryOperatorExpr', this).call(this, ast, ctx);
	            }
	            return null;
	        }
	    }, {
	        key: 'visitLiteralArrayExpr',
	        value: function visitLiteralArrayExpr(ast, ctx) {
	            if (isConstType(ast.type)) {
	                ctx.print('const ');
	            }
	            return get(Object.getPrototypeOf(_DartEmitterVisitor.prototype), 'visitLiteralArrayExpr', this).call(this, ast, ctx);
	        }
	    }, {
	        key: 'visitLiteralMapExpr',
	        value: function visitLiteralMapExpr(ast, ctx) {
	            if (isConstType(ast.type)) {
	                ctx.print('const ');
	            }
	            if (isPresent$3(ast.valueType)) {
	                ctx.print('<String, ');
	                ast.valueType.visitType(this, ctx);
	                ctx.print('>');
	            }
	            return get(Object.getPrototypeOf(_DartEmitterVisitor.prototype), 'visitLiteralMapExpr', this).call(this, ast, ctx);
	        }
	    }, {
	        key: 'visitInstantiateExpr',
	        value: function visitInstantiateExpr(ast, ctx) {
	            ctx.print(isConstType(ast.type) ? 'const' : 'new');
	            ctx.print(' ');
	            ast.classExpr.visitExpression(this, ctx);
	            ctx.print('(');
	            this.visitAllExpressions(ast.args, ctx, ',');
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitBuiltintType',
	        value: function visitBuiltintType(type, ctx) {
	            var typeStr;
	            switch (type.name) {
	                case BuiltinTypeName.Bool:
	                    typeStr = 'bool';
	                    break;
	                case BuiltinTypeName.Dynamic:
	                    typeStr = 'dynamic';
	                    break;
	                case BuiltinTypeName.Function:
	                    typeStr = 'Function';
	                    break;
	                case BuiltinTypeName.Number:
	                    typeStr = 'num';
	                    break;
	                case BuiltinTypeName.Int:
	                    typeStr = 'int';
	                    break;
	                case BuiltinTypeName.String:
	                    typeStr = 'String';
	                    break;
	                default:
	                    throw new BaseException$3('Unsupported builtin type ' + type.name);
	            }
	            ctx.print(typeStr);
	            return null;
	        }
	    }, {
	        key: 'visitExternalType',
	        value: function visitExternalType(ast, ctx) {
	            this._visitIdentifier(ast.value, ast.typeParams, ctx);
	            return null;
	        }
	    }, {
	        key: 'visitArrayType',
	        value: function visitArrayType(type, ctx) {
	            ctx.print('List<');
	            if (isPresent$3(type.of)) {
	                type.of.visitType(this, ctx);
	            } else {
	                ctx.print('dynamic');
	            }
	            ctx.print('>');
	            return null;
	        }
	    }, {
	        key: 'visitMapType',
	        value: function visitMapType(type, ctx) {
	            ctx.print('Map<String, ');
	            if (isPresent$3(type.valueType)) {
	                type.valueType.visitType(this, ctx);
	            } else {
	                ctx.print('dynamic');
	            }
	            ctx.print('>');
	            return null;
	        }
	    }, {
	        key: '_visitParams',
	        value: function _visitParams(params, ctx) {
	            var _this4 = this;

	            this.visitAllObjects(function (param /** TODO #9100 */) {
	                if (isPresent$3(param.type)) {
	                    param.type.visitType(_this4, ctx);
	                    ctx.print(' ');
	                }
	                ctx.print(param.name);
	            }, params, ctx, ',');
	        }
	    }, {
	        key: '_visitIdentifier',
	        value: function _visitIdentifier(value, typeParams, ctx) {
	            var _this5 = this;

	            if (isBlank$3(value.name)) {
	                throw new BaseException$3('Internal error: unknown identifier ' + value);
	            }
	            if (isPresent$3(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
	                var prefix = this.importsWithPrefixes.get(value.moduleUrl);
	                if (isBlank$3(prefix)) {
	                    prefix = 'import' + this.importsWithPrefixes.size;
	                    this.importsWithPrefixes.set(value.moduleUrl, prefix);
	                }
	                ctx.print(prefix + '.');
	            }
	            ctx.print(value.name);
	            if (isPresent$3(typeParams) && typeParams.length > 0) {
	                ctx.print('<');
	                this.visitAllObjects(function (type /** TODO #9100 */) {
	                    return type.visitType(_this5, ctx);
	                }, typeParams, ctx, ',');
	                ctx.print('>');
	            }
	        }
	    }]);
	    return _DartEmitterVisitor;
	}(AbstractEmitterVisitor);

	function getSuperConstructorCallExpr(stmt) {
	    if (stmt instanceof ExpressionStatement) {
	        var expr = stmt.expr;
	        if (expr instanceof InvokeFunctionExpr) {
	            var fn = expr.fn;
	            if (fn instanceof ReadVarExpr) {
	                if (fn.builtin === BuiltinVar.Super) {
	                    return expr;
	                }
	            }
	        }
	    }
	    return null;
	}
	function isConstType(type) {
	    return isPresent$3(type) && type.hasModifier(TypeModifier.Const);
	}

	var _debugModuleUrl$1 = 'asset://debug/lib';
	function debugOutputAstAsTypeScript(ast) {
	    var converter = new _TsEmitterVisitor(_debugModuleUrl$1);
	    var ctx = EmitterVisitorContext.createRoot([]);
	    var asts;
	    if (isArray$4(ast)) {
	        asts = ast;
	    } else {
	        asts = [ast];
	    }
	    asts.forEach(function (ast) {
	        if (ast instanceof Statement) {
	            ast.visitStatement(converter, ctx);
	        } else if (ast instanceof Expression) {
	            ast.visitExpression(converter, ctx);
	        } else if (ast instanceof Type$4) {
	            ast.visitType(converter, ctx);
	        } else {
	            throw new BaseException$3('Don\'t know how to print debug info for ' + ast);
	        }
	    });
	    return ctx.toSource();
	}
	var TypeScriptEmitter = function () {
	    function TypeScriptEmitter(_importGenerator) {
	        classCallCheck(this, TypeScriptEmitter);

	        this._importGenerator = _importGenerator;
	    }

	    createClass(TypeScriptEmitter, [{
	        key: 'emitStatements',
	        value: function emitStatements(moduleUrl, stmts, exportedVars) {
	            var _this = this;

	            var converter = new _TsEmitterVisitor(moduleUrl);
	            var ctx = EmitterVisitorContext.createRoot(exportedVars);
	            converter.visitAllStatements(stmts, ctx);
	            var srcParts = [];
	            converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
	                // Note: can't write the real word for import as it screws up system.js auto detection...
	                srcParts.push('imp' + ('ort * as ' + prefix + ' from \'' + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + '\';'));
	            });
	            srcParts.push(ctx.toSource());
	            return srcParts.join('\n');
	        }
	    }]);
	    return TypeScriptEmitter;
	}();

	var _TsEmitterVisitor = function (_AbstractEmitterVisit) {
	    inherits(_TsEmitterVisitor, _AbstractEmitterVisit);

	    function _TsEmitterVisitor(_moduleUrl) {
	        classCallCheck(this, _TsEmitterVisitor);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(_TsEmitterVisitor).call(this, false));

	        _this2._moduleUrl = _moduleUrl;
	        _this2.importsWithPrefixes = new Map();
	        return _this2;
	    }

	    createClass(_TsEmitterVisitor, [{
	        key: 'visitType',
	        value: function visitType(t, ctx) {
	            var defaultType = arguments.length <= 2 || arguments[2] === undefined ? 'any' : arguments[2];

	            if (isPresent$3(t)) {
	                t.visitType(this, ctx);
	            } else {
	                ctx.print(defaultType);
	            }
	        }
	    }, {
	        key: 'visitExternalExpr',
	        value: function visitExternalExpr(ast, ctx) {
	            this._visitIdentifier(ast.value, ast.typeParams, ctx);
	            return null;
	        }
	    }, {
	        key: 'visitDeclareVarStmt',
	        value: function visitDeclareVarStmt(stmt, ctx) {
	            if (ctx.isExportedVar(stmt.name)) {
	                ctx.print('export ');
	            }
	            if (stmt.hasModifier(StmtModifier.Final)) {
	                ctx.print('const');
	            } else {
	                ctx.print('var');
	            }
	            ctx.print(' ' + stmt.name + ':');
	            this.visitType(stmt.type, ctx);
	            ctx.print(' = ');
	            stmt.value.visitExpression(this, ctx);
	            ctx.println(';');
	            return null;
	        }
	    }, {
	        key: 'visitCastExpr',
	        value: function visitCastExpr(ast, ctx) {
	            ctx.print('(<');
	            ast.type.visitType(this, ctx);
	            ctx.print('>');
	            ast.value.visitExpression(this, ctx);
	            ctx.print(')');
	            return null;
	        }
	    }, {
	        key: 'visitDeclareClassStmt',
	        value: function visitDeclareClassStmt(stmt, ctx) {
	            var _this3 = this;

	            ctx.pushClass(stmt);
	            if (ctx.isExportedVar(stmt.name)) {
	                ctx.print('export ');
	            }
	            ctx.print('class ' + stmt.name);
	            if (isPresent$3(stmt.parent)) {
	                ctx.print(' extends ');
	                stmt.parent.visitExpression(this, ctx);
	            }
	            ctx.println(' {');
	            ctx.incIndent();
	            stmt.fields.forEach(function (field) {
	                return _this3._visitClassField(field, ctx);
	            });
	            if (isPresent$3(stmt.constructorMethod)) {
	                this._visitClassConstructor(stmt, ctx);
	            }
	            stmt.getters.forEach(function (getter) {
	                return _this3._visitClassGetter(getter, ctx);
	            });
	            stmt.methods.forEach(function (method) {
	                return _this3._visitClassMethod(method, ctx);
	            });
	            ctx.decIndent();
	            ctx.println('}');
	            ctx.popClass();
	            return null;
	        }
	    }, {
	        key: '_visitClassField',
	        value: function _visitClassField(field, ctx) {
	            if (field.hasModifier(StmtModifier.Private)) {
	                ctx.print('private ');
	            }
	            ctx.print(field.name);
	            ctx.print(':');
	            this.visitType(field.type, ctx);
	            ctx.println(';');
	        }
	    }, {
	        key: '_visitClassGetter',
	        value: function _visitClassGetter(getter, ctx) {
	            if (getter.hasModifier(StmtModifier.Private)) {
	                ctx.print('private ');
	            }
	            ctx.print('get ' + getter.name + '()');
	            ctx.print(':');
	            this.visitType(getter.type, ctx);
	            ctx.println(' {');
	            ctx.incIndent();
	            this.visitAllStatements(getter.body, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	        }
	    }, {
	        key: '_visitClassConstructor',
	        value: function _visitClassConstructor(stmt, ctx) {
	            ctx.print('constructor(');
	            this._visitParams(stmt.constructorMethod.params, ctx);
	            ctx.println(') {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.constructorMethod.body, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	        }
	    }, {
	        key: '_visitClassMethod',
	        value: function _visitClassMethod(method, ctx) {
	            if (method.hasModifier(StmtModifier.Private)) {
	                ctx.print('private ');
	            }
	            ctx.print(method.name + '(');
	            this._visitParams(method.params, ctx);
	            ctx.print('):');
	            this.visitType(method.type, ctx, 'void');
	            ctx.println(' {');
	            ctx.incIndent();
	            this.visitAllStatements(method.body, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	        }
	    }, {
	        key: 'visitFunctionExpr',
	        value: function visitFunctionExpr(ast, ctx) {
	            ctx.print('(');
	            this._visitParams(ast.params, ctx);
	            ctx.print('):');
	            this.visitType(ast.type, ctx, 'void');
	            ctx.println(' => {');
	            ctx.incIndent();
	            this.visitAllStatements(ast.statements, ctx);
	            ctx.decIndent();
	            ctx.print('}');
	            return null;
	        }
	    }, {
	        key: 'visitDeclareFunctionStmt',
	        value: function visitDeclareFunctionStmt(stmt, ctx) {
	            if (ctx.isExportedVar(stmt.name)) {
	                ctx.print('export ');
	            }
	            ctx.print('function ' + stmt.name + '(');
	            this._visitParams(stmt.params, ctx);
	            ctx.print('):');
	            this.visitType(stmt.type, ctx, 'void');
	            ctx.println(' {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.statements, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	            return null;
	        }
	    }, {
	        key: 'visitTryCatchStmt',
	        value: function visitTryCatchStmt(stmt, ctx) {
	            ctx.println('try {');
	            ctx.incIndent();
	            this.visitAllStatements(stmt.bodyStmts, ctx);
	            ctx.decIndent();
	            ctx.println('} catch (' + CATCH_ERROR_VAR$1.name + ') {');
	            ctx.incIndent();
	            var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);
	            this.visitAllStatements(catchStmts, ctx);
	            ctx.decIndent();
	            ctx.println('}');
	            return null;
	        }
	    }, {
	        key: 'visitBuiltintType',
	        value: function visitBuiltintType(type, ctx) {
	            var typeStr;
	            switch (type.name) {
	                case BuiltinTypeName.Bool:
	                    typeStr = 'boolean';
	                    break;
	                case BuiltinTypeName.Dynamic:
	                    typeStr = 'any';
	                    break;
	                case BuiltinTypeName.Function:
	                    typeStr = 'Function';
	                    break;
	                case BuiltinTypeName.Number:
	                    typeStr = 'number';
	                    break;
	                case BuiltinTypeName.Int:
	                    typeStr = 'number';
	                    break;
	                case BuiltinTypeName.String:
	                    typeStr = 'string';
	                    break;
	                default:
	                    throw new BaseException$3('Unsupported builtin type ' + type.name);
	            }
	            ctx.print(typeStr);
	            return null;
	        }
	    }, {
	        key: 'visitExternalType',
	        value: function visitExternalType(ast, ctx) {
	            this._visitIdentifier(ast.value, ast.typeParams, ctx);
	            return null;
	        }
	    }, {
	        key: 'visitArrayType',
	        value: function visitArrayType(type, ctx) {
	            this.visitType(type.of, ctx);
	            ctx.print('[]');
	            return null;
	        }
	    }, {
	        key: 'visitMapType',
	        value: function visitMapType(type, ctx) {
	            ctx.print('{[key: string]:');
	            this.visitType(type.valueType, ctx);
	            ctx.print('}');
	            return null;
	        }
	    }, {
	        key: 'getBuiltinMethodName',
	        value: function getBuiltinMethodName(method) {
	            var name;
	            switch (method) {
	                case BuiltinMethod.ConcatArray:
	                    name = 'concat';
	                    break;
	                case BuiltinMethod.SubscribeObservable:
	                    name = 'subscribe';
	                    break;
	                case BuiltinMethod.bind:
	                    name = 'bind';
	                    break;
	                default:
	                    throw new BaseException$3('Unknown builtin method: ' + method);
	            }
	            return name;
	        }
	    }, {
	        key: '_visitParams',
	        value: function _visitParams(params, ctx) {
	            var _this4 = this;

	            this.visitAllObjects(function (param /** TODO #9100 */) {
	                ctx.print(param.name);
	                ctx.print(':');
	                _this4.visitType(param.type, ctx);
	            }, params, ctx, ',');
	        }
	    }, {
	        key: '_visitIdentifier',
	        value: function _visitIdentifier(value, typeParams, ctx) {
	            var _this5 = this;

	            if (isBlank$3(value.name)) {
	                throw new BaseException$3('Internal error: unknown identifier ' + value);
	            }
	            if (isPresent$3(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
	                var prefix = this.importsWithPrefixes.get(value.moduleUrl);
	                if (isBlank$3(prefix)) {
	                    prefix = 'import' + this.importsWithPrefixes.size;
	                    this.importsWithPrefixes.set(value.moduleUrl, prefix);
	                }
	                ctx.print(prefix + '.');
	            }
	            ctx.print(value.name);
	            if (isPresent$3(typeParams) && typeParams.length > 0) {
	                ctx.print('<');
	                this.visitAllObjects(function (type /** TODO #9100 */) {
	                    return type.visitType(_this5, ctx);
	                }, typeParams, ctx, ',');
	                ctx.print('>');
	            }
	        }
	    }]);
	    return _TsEmitterVisitor;
	}(AbstractEmitterVisitor);

	function interpretStatements(statements, resultVar, instanceFactory) {
	    var stmtsWithReturn = statements.concat([new ReturnStatement(variable(resultVar))]);
	    var ctx = new _ExecutionContext(null, null, null, null, new Map(), new Map(), new Map(), new Map(), instanceFactory);
	    var visitor = new StatementInterpreter();
	    var result = visitor.visitAllStatements(stmtsWithReturn, ctx);
	    return isPresent$3(result) ? result.value : null;
	}
	var DynamicInstance = function () {
	    function DynamicInstance() {
	        classCallCheck(this, DynamicInstance);
	    }

	    createClass(DynamicInstance, [{
	        key: 'props',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'getters',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'methods',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }, {
	        key: 'clazz',
	        get: function get() {
	            return unimplemented$3();
	        }
	    }]);
	    return DynamicInstance;
	}();
	function isDynamicInstance(instance) {
	    if (IS_DART$3) {
	        return instance instanceof DynamicInstance;
	    } else {
	        return isPresent$3(instance) && isPresent$3(instance.props) && isPresent$3(instance.getters) && isPresent$3(instance.methods);
	    }
	}
	function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
	    var childCtx = ctx.createChildWihtLocalVars();
	    for (var i = 0; i < varNames.length; i++) {
	        childCtx.vars.set(varNames[i], varValues[i]);
	    }
	    var result = visitor.visitAllStatements(statements, childCtx);
	    return isPresent$3(result) ? result.value : null;
	}

	var _ExecutionContext = function () {
	    function _ExecutionContext(parent, superClass, superInstance, className, vars, props, getters, methods, instanceFactory) {
	        classCallCheck(this, _ExecutionContext);

	        this.parent = parent;
	        this.superClass = superClass;
	        this.superInstance = superInstance;
	        this.className = className;
	        this.vars = vars;
	        this.props = props;
	        this.getters = getters;
	        this.methods = methods;
	        this.instanceFactory = instanceFactory;
	    }

	    createClass(_ExecutionContext, [{
	        key: 'createChildWihtLocalVars',
	        value: function createChildWihtLocalVars() {
	            return new _ExecutionContext(this, this.superClass, this.superInstance, this.className, new Map(), this.props, this.getters, this.methods, this.instanceFactory);
	        }
	    }]);
	    return _ExecutionContext;
	}();

	var ReturnValue = function ReturnValue(value) {
	    classCallCheck(this, ReturnValue);

	    this.value = value;
	};

	var _DynamicClass = function () {
	    function _DynamicClass(_classStmt, _ctx, _visitor) {
	        classCallCheck(this, _DynamicClass);

	        this._classStmt = _classStmt;
	        this._ctx = _ctx;
	        this._visitor = _visitor;
	    }

	    createClass(_DynamicClass, [{
	        key: 'instantiate',
	        value: function instantiate(args) {
	            var _this = this;

	            var props = new Map();
	            var getters = new Map();
	            var methods = new Map();
	            var superClass = this._classStmt.parent.visitExpression(this._visitor, this._ctx);
	            var instanceCtx = new _ExecutionContext(this._ctx, superClass, null, this._classStmt.name, this._ctx.vars, props, getters, methods, this._ctx.instanceFactory);
	            this._classStmt.fields.forEach(function (field) {
	                props.set(field.name, null);
	            });
	            this._classStmt.getters.forEach(function (getter) {
	                getters.set(getter.name, function () {
	                    return _executeFunctionStatements([], [], getter.body, instanceCtx, _this._visitor);
	                });
	            });
	            this._classStmt.methods.forEach(function (method) {
	                var paramNames = method.params.map(function (param) {
	                    return param.name;
	                });
	                methods.set(method.name, _declareFn(paramNames, method.body, instanceCtx, _this._visitor));
	            });
	            var ctorParamNames = this._classStmt.constructorMethod.params.map(function (param) {
	                return param.name;
	            });
	            _executeFunctionStatements(ctorParamNames, args, this._classStmt.constructorMethod.body, instanceCtx, this._visitor);
	            return instanceCtx.superInstance;
	        }
	    }, {
	        key: 'debugAst',
	        value: function debugAst() {
	            return this._visitor.debugAst(this._classStmt);
	        }
	    }]);
	    return _DynamicClass;
	}();

	var StatementInterpreter = function () {
	    function StatementInterpreter() {
	        classCallCheck(this, StatementInterpreter);
	    }

	    createClass(StatementInterpreter, [{
	        key: 'debugAst',
	        value: function debugAst(ast) {
	            return IS_DART$3 ? debugOutputAstAsDart(ast) : debugOutputAstAsTypeScript(ast);
	        }
	    }, {
	        key: 'visitDeclareVarStmt',
	        value: function visitDeclareVarStmt(stmt, ctx) {
	            ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
	            return null;
	        }
	    }, {
	        key: 'visitWriteVarExpr',
	        value: function visitWriteVarExpr(expr, ctx) {
	            var value = expr.value.visitExpression(this, ctx);
	            var currCtx = ctx;
	            while (currCtx != null) {
	                if (currCtx.vars.has(expr.name)) {
	                    currCtx.vars.set(expr.name, value);
	                    return value;
	                }
	                currCtx = currCtx.parent;
	            }
	            throw new BaseException$3('Not declared variable ' + expr.name);
	        }
	    }, {
	        key: 'visitReadVarExpr',
	        value: function visitReadVarExpr(ast, ctx) {
	            var varName = ast.name;
	            if (isPresent$3(ast.builtin)) {
	                switch (ast.builtin) {
	                    case BuiltinVar.Super:
	                    case BuiltinVar.This:
	                        return ctx.superInstance;
	                    case BuiltinVar.CatchError:
	                        varName = CATCH_ERROR_VAR$2;
	                        break;
	                    case BuiltinVar.CatchStack:
	                        varName = CATCH_STACK_VAR$2;
	                        break;
	                    default:
	                        throw new BaseException$3('Unknown builtin variable ' + ast.builtin);
	                }
	            }
	            var currCtx = ctx;
	            while (currCtx != null) {
	                if (currCtx.vars.has(varName)) {
	                    return currCtx.vars.get(varName);
	                }
	                currCtx = currCtx.parent;
	            }
	            throw new BaseException$3('Not declared variable ' + varName);
	        }
	    }, {
	        key: 'visitWriteKeyExpr',
	        value: function visitWriteKeyExpr(expr, ctx) {
	            var receiver = expr.receiver.visitExpression(this, ctx);
	            var index = expr.index.visitExpression(this, ctx);
	            var value = expr.value.visitExpression(this, ctx);
	            receiver[index] = value;
	            return value;
	        }
	    }, {
	        key: 'visitWritePropExpr',
	        value: function visitWritePropExpr(expr, ctx) {
	            var receiver = expr.receiver.visitExpression(this, ctx);
	            var value = expr.value.visitExpression(this, ctx);
	            if (isDynamicInstance(receiver)) {
	                var di = receiver;
	                if (di.props.has(expr.name)) {
	                    di.props.set(expr.name, value);
	                } else {
	                    reflector$2.setter(expr.name)(receiver, value);
	                }
	            } else {
	                reflector$2.setter(expr.name)(receiver, value);
	            }
	            return value;
	        }
	    }, {
	        key: 'visitInvokeMethodExpr',
	        value: function visitInvokeMethodExpr(expr, ctx) {
	            var receiver = expr.receiver.visitExpression(this, ctx);
	            var args = this.visitAllExpressions(expr.args, ctx);
	            var result;
	            if (isPresent$3(expr.builtin)) {
	                switch (expr.builtin) {
	                    case BuiltinMethod.ConcatArray:
	                        result = ListWrapper$3.concat(receiver, args[0]);
	                        break;
	                    case BuiltinMethod.SubscribeObservable:
	                        result = ObservableWrapper$3.subscribe(receiver, args[0]);
	                        break;
	                    case BuiltinMethod.bind:
	                        if (IS_DART$3) {
	                            result = receiver;
	                        } else {
	                            result = receiver.bind(args[0]);
	                        }
	                        break;
	                    default:
	                        throw new BaseException$3('Unknown builtin method ' + expr.builtin);
	                }
	            } else if (isDynamicInstance(receiver)) {
	                var di = receiver;
	                if (di.methods.has(expr.name)) {
	                    result = FunctionWrapper$3.apply(di.methods.get(expr.name), args);
	                } else {
	                    result = reflector$2.method(expr.name)(receiver, args);
	                }
	            } else {
	                result = reflector$2.method(expr.name)(receiver, args);
	            }
	            return result;
	        }
	    }, {
	        key: 'visitInvokeFunctionExpr',
	        value: function visitInvokeFunctionExpr(stmt, ctx) {
	            var args = this.visitAllExpressions(stmt.args, ctx);
	            var fnExpr = stmt.fn;
	            if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
	                ctx.superInstance = ctx.instanceFactory.createInstance(ctx.superClass, ctx.className, args, ctx.props, ctx.getters, ctx.methods);
	                ctx.parent.superInstance = ctx.superInstance;
	                return null;
	            } else {
	                var fn = stmt.fn.visitExpression(this, ctx);
	                return FunctionWrapper$3.apply(fn, args);
	            }
	        }
	    }, {
	        key: 'visitReturnStmt',
	        value: function visitReturnStmt(stmt, ctx) {
	            return new ReturnValue(stmt.value.visitExpression(this, ctx));
	        }
	    }, {
	        key: 'visitDeclareClassStmt',
	        value: function visitDeclareClassStmt(stmt, ctx) {
	            var clazz = new _DynamicClass(stmt, ctx, this);
	            ctx.vars.set(stmt.name, clazz);
	            return null;
	        }
	    }, {
	        key: 'visitExpressionStmt',
	        value: function visitExpressionStmt(stmt, ctx) {
	            return stmt.expr.visitExpression(this, ctx);
	        }
	    }, {
	        key: 'visitIfStmt',
	        value: function visitIfStmt(stmt, ctx) {
	            var condition = stmt.condition.visitExpression(this, ctx);
	            if (condition) {
	                return this.visitAllStatements(stmt.trueCase, ctx);
	            } else if (isPresent$3(stmt.falseCase)) {
	                return this.visitAllStatements(stmt.falseCase, ctx);
	            }
	            return null;
	        }
	    }, {
	        key: 'visitTryCatchStmt',
	        value: function visitTryCatchStmt(stmt, ctx) {
	            try {
	                return this.visitAllStatements(stmt.bodyStmts, ctx);
	            } catch (e) {
	                var childCtx = ctx.createChildWihtLocalVars();
	                childCtx.vars.set(CATCH_ERROR_VAR$2, e);
	                childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);
	                return this.visitAllStatements(stmt.catchStmts, childCtx);
	            }
	        }
	    }, {
	        key: 'visitThrowStmt',
	        value: function visitThrowStmt(stmt, ctx) {
	            throw stmt.error.visitExpression(this, ctx);
	        }
	    }, {
	        key: 'visitCommentStmt',
	        value: function visitCommentStmt(stmt, context) {
	            return null;
	        }
	    }, {
	        key: 'visitInstantiateExpr',
	        value: function visitInstantiateExpr(ast, ctx) {
	            var args = this.visitAllExpressions(ast.args, ctx);
	            var clazz = ast.classExpr.visitExpression(this, ctx);
	            if (clazz instanceof _DynamicClass) {
	                return clazz.instantiate(args);
	            } else {
	                return FunctionWrapper$3.apply(reflector$2.factory(clazz), args);
	            }
	        }
	    }, {
	        key: 'visitLiteralExpr',
	        value: function visitLiteralExpr(ast, ctx) {
	            return ast.value;
	        }
	    }, {
	        key: 'visitExternalExpr',
	        value: function visitExternalExpr(ast, ctx) {
	            return ast.value.runtime;
	        }
	    }, {
	        key: 'visitConditionalExpr',
	        value: function visitConditionalExpr(ast, ctx) {
	            if (ast.condition.visitExpression(this, ctx)) {
	                return ast.trueCase.visitExpression(this, ctx);
	            } else if (isPresent$3(ast.falseCase)) {
	                return ast.falseCase.visitExpression(this, ctx);
	            }
	            return null;
	        }
	    }, {
	        key: 'visitNotExpr',
	        value: function visitNotExpr(ast, ctx) {
	            return !ast.condition.visitExpression(this, ctx);
	        }
	    }, {
	        key: 'visitCastExpr',
	        value: function visitCastExpr(ast, ctx) {
	            return ast.value.visitExpression(this, ctx);
	        }
	    }, {
	        key: 'visitFunctionExpr',
	        value: function visitFunctionExpr(ast, ctx) {
	            var paramNames = ast.params.map(function (param) {
	                return param.name;
	            });
	            return _declareFn(paramNames, ast.statements, ctx, this);
	        }
	    }, {
	        key: 'visitDeclareFunctionStmt',
	        value: function visitDeclareFunctionStmt(stmt, ctx) {
	            var paramNames = stmt.params.map(function (param) {
	                return param.name;
	            });
	            ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
	            return null;
	        }
	    }, {
	        key: 'visitBinaryOperatorExpr',
	        value: function visitBinaryOperatorExpr(ast, ctx) {
	            var _this2 = this;

	            var lhs = function lhs() {
	                return ast.lhs.visitExpression(_this2, ctx);
	            };
	            var rhs = function rhs() {
	                return ast.rhs.visitExpression(_this2, ctx);
	            };
	            switch (ast.operator) {
	                case BinaryOperator.Equals:
	                    return lhs() == rhs();
	                case BinaryOperator.Identical:
	                    return lhs() === rhs();
	                case BinaryOperator.NotEquals:
	                    return lhs() != rhs();
	                case BinaryOperator.NotIdentical:
	                    return lhs() !== rhs();
	                case BinaryOperator.And:
	                    return lhs() && rhs();
	                case BinaryOperator.Or:
	                    return lhs() || rhs();
	                case BinaryOperator.Plus:
	                    return lhs() + rhs();
	                case BinaryOperator.Minus:
	                    return lhs() - rhs();
	                case BinaryOperator.Divide:
	                    return lhs() / rhs();
	                case BinaryOperator.Multiply:
	                    return lhs() * rhs();
	                case BinaryOperator.Modulo:
	                    return lhs() % rhs();
	                case BinaryOperator.Lower:
	                    return lhs() < rhs();
	                case BinaryOperator.LowerEquals:
	                    return lhs() <= rhs();
	                case BinaryOperator.Bigger:
	                    return lhs() > rhs();
	                case BinaryOperator.BiggerEquals:
	                    return lhs() >= rhs();
	                default:
	                    throw new BaseException$3('Unknown operator ' + ast.operator);
	            }
	        }
	    }, {
	        key: 'visitReadPropExpr',
	        value: function visitReadPropExpr(ast, ctx) {
	            var result;
	            var receiver = ast.receiver.visitExpression(this, ctx);
	            if (isDynamicInstance(receiver)) {
	                var di = receiver;
	                if (di.props.has(ast.name)) {
	                    result = di.props.get(ast.name);
	                } else if (di.getters.has(ast.name)) {
	                    result = di.getters.get(ast.name)();
	                } else if (di.methods.has(ast.name)) {
	                    result = di.methods.get(ast.name);
	                } else {
	                    result = reflector$2.getter(ast.name)(receiver);
	                }
	            } else {
	                result = reflector$2.getter(ast.name)(receiver);
	            }
	            return result;
	        }
	    }, {
	        key: 'visitReadKeyExpr',
	        value: function visitReadKeyExpr(ast, ctx) {
	            var receiver = ast.receiver.visitExpression(this, ctx);
	            var prop = ast.index.visitExpression(this, ctx);
	            return receiver[prop];
	        }
	    }, {
	        key: 'visitLiteralArrayExpr',
	        value: function visitLiteralArrayExpr(ast, ctx) {
	            return this.visitAllExpressions(ast.entries, ctx);
	        }
	    }, {
	        key: 'visitLiteralMapExpr',
	        value: function visitLiteralMapExpr(ast, ctx) {
	            var _this3 = this;

	            var result = {};
	            ast.entries.forEach(function (entry) {
	                return result[entry[0]] = entry[1].visitExpression(_this3, ctx);
	            });
	            return result;
	        }
	    }, {
	        key: 'visitAllExpressions',
	        value: function visitAllExpressions(expressions, ctx) {
	            var _this4 = this;

	            return expressions.map(function (expr) {
	                return expr.visitExpression(_this4, ctx);
	            });
	        }
	    }, {
	        key: 'visitAllStatements',
	        value: function visitAllStatements(statements, ctx) {
	            for (var i = 0; i < statements.length; i++) {
	                var stmt = statements[i];
	                var val = stmt.visitStatement(this, ctx);
	                if (val instanceof ReturnValue) {
	                    return val;
	                }
	            }
	            return null;
	        }
	    }]);
	    return StatementInterpreter;
	}();

	function _declareFn(varNames, statements, ctx, visitor) {
	    switch (varNames.length) {
	        case 0:
	            return function () {
	                return _executeFunctionStatements(varNames, [], statements, ctx, visitor);
	            };
	        case 1:
	            return function (d0 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0], statements, ctx, visitor);
	            };
	        case 2:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1], statements, ctx, visitor);
	            };
	        case 3:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2], statements, ctx, visitor);
	            };
	        case 4:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */, d3 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2, d3], statements, ctx, visitor);
	            };
	        case 5:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */, d3 /** TODO #9100 */, d4 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4], statements, ctx, visitor);
	            };
	        case 6:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */, d3 /** TODO #9100 */, d4 /** TODO #9100 */, d5 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5], statements, ctx, visitor);
	            };
	        case 7:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */, d3 /** TODO #9100 */, d4 /** TODO #9100 */, d5 /** TODO #9100 */, d6 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6], statements, ctx, visitor);
	            };
	        case 8:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */, d3 /** TODO #9100 */, d4 /** TODO #9100 */, d5 /** TODO #9100 */, d6 /** TODO #9100 */, d7 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7], statements, ctx, visitor);
	            };
	        case 9:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */, d3 /** TODO #9100 */, d4 /** TODO #9100 */, d5 /** TODO #9100 */, d6 /** TODO #9100 */, d7 /** TODO #9100 */, d8 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7, d8], statements, ctx, visitor);
	            };
	        case 10:
	            return function (d0 /** TODO #9100 */, d1 /** TODO #9100 */, d2 /** TODO #9100 */, d3 /** TODO #9100 */, d4 /** TODO #9100 */, d5 /** TODO #9100 */, d6 /** TODO #9100 */, d7 /** TODO #9100 */, d8 /** TODO #9100 */, d9 /** TODO #9100 */) {
	                return _executeFunctionStatements(varNames, [d0, d1, d2, d3, d4, d5, d6, d7, d8, d9], statements, ctx, visitor);
	            };
	        default:
	            throw new BaseException$3('Declaring functions with more than 10 arguments is not supported right now');
	    }
	}
	var CATCH_ERROR_VAR$2 = 'error';
	var CATCH_STACK_VAR$2 = 'stack';

	var InterpretiveAppViewInstanceFactory = function () {
	    function InterpretiveAppViewInstanceFactory() {
	        classCallCheck(this, InterpretiveAppViewInstanceFactory);
	    }

	    createClass(InterpretiveAppViewInstanceFactory, [{
	        key: 'createInstance',
	        value: function createInstance(superClass, clazz, args, props, getters, methods) {
	            if (superClass === AppView$1) {
	                // We are always using DebugAppView as parent.
	                // However, in prod mode we generate a constructor call that does
	                // not have the argument for the debugNodeInfos.
	                args = args.concat([null]);
	                return new _InterpretiveAppView(args, props, getters, methods);
	            } else if (superClass === DebugAppView$1) {
	                return new _InterpretiveAppView(args, props, getters, methods);
	            }
	            throw new BaseException$3('Can\'t instantiate class ' + superClass + ' in interpretative mode');
	        }
	    }]);
	    return InterpretiveAppViewInstanceFactory;
	}();

	var _InterpretiveAppView = function (_DebugAppView) {
	    inherits(_InterpretiveAppView, _DebugAppView);

	    function _InterpretiveAppView(args, props, getters, methods) {
	        classCallCheck(this, _InterpretiveAppView);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(_InterpretiveAppView).call(this, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]));

	        _this.props = props;
	        _this.getters = getters;
	        _this.methods = methods;
	        return _this;
	    }

	    createClass(_InterpretiveAppView, [{
	        key: 'createInternal',
	        value: function createInternal(rootSelector) {
	            var m = this.methods.get('createInternal');
	            if (isPresent$3(m)) {
	                return m(rootSelector);
	            } else {
	                return get(Object.getPrototypeOf(_InterpretiveAppView.prototype), 'createInternal', this).call(this, rootSelector);
	            }
	        }
	    }, {
	        key: 'injectorGetInternal',
	        value: function injectorGetInternal(token, nodeIndex, notFoundResult) {
	            var m = this.methods.get('injectorGetInternal');
	            if (isPresent$3(m)) {
	                return m(token, nodeIndex, notFoundResult);
	            } else {
	                return get(Object.getPrototypeOf(_InterpretiveAppView.prototype), 'injectorGet', this).call(this, token, nodeIndex, notFoundResult);
	            }
	        }
	    }, {
	        key: 'detachInternal',
	        value: function detachInternal() {
	            var m = this.methods.get('detachInternal');
	            if (isPresent$3(m)) {
	                return m();
	            } else {
	                return get(Object.getPrototypeOf(_InterpretiveAppView.prototype), 'detachInternal', this).call(this);
	            }
	        }
	    }, {
	        key: 'destroyInternal',
	        value: function destroyInternal() {
	            var m = this.methods.get('destroyInternal');
	            if (isPresent$3(m)) {
	                return m();
	            } else {
	                return get(Object.getPrototypeOf(_InterpretiveAppView.prototype), 'destroyInternal', this).call(this);
	            }
	        }
	    }, {
	        key: 'dirtyParentQueriesInternal',
	        value: function dirtyParentQueriesInternal() {
	            var m = this.methods.get('dirtyParentQueriesInternal');
	            if (isPresent$3(m)) {
	                return m();
	            } else {
	                return get(Object.getPrototypeOf(_InterpretiveAppView.prototype), 'dirtyParentQueriesInternal', this).call(this);
	            }
	        }
	    }, {
	        key: 'detectChangesInternal',
	        value: function detectChangesInternal(throwOnChange) {
	            var m = this.methods.get('detectChangesInternal');
	            if (isPresent$3(m)) {
	                return m(throwOnChange);
	            } else {
	                return get(Object.getPrototypeOf(_InterpretiveAppView.prototype), 'detectChangesInternal', this).call(this, throwOnChange);
	            }
	        }
	    }]);
	    return _InterpretiveAppView;
	}(DebugAppView$1);

	var RuntimeCompiler = function () {
	    function RuntimeCompiler(_metadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _viewCompiler, _genConfig) {
	        classCallCheck(this, RuntimeCompiler);

	        this._metadataResolver = _metadataResolver;
	        this._templateNormalizer = _templateNormalizer;
	        this._templateParser = _templateParser;
	        this._styleCompiler = _styleCompiler;
	        this._viewCompiler = _viewCompiler;
	        this._genConfig = _genConfig;
	        this._compiledTemplateCache = new Map();
	        this._compiledHostTemplateCache = new Map();
	    }

	    createClass(RuntimeCompiler, [{
	        key: 'resolveComponent',
	        value: function resolveComponent(component) {
	            if (isString$3(component)) {
	                return PromiseWrapper$3.reject(new BaseException$3('Cannot resolve component using \'' + component + '\'.'), null);
	            }
	            return this.compileComponentAsync(component);
	        }
	    }, {
	        key: 'compileComponentAsync',
	        value: function compileComponentAsync(compType) {
	            var _this = this;

	            var templates = this._getTransitiveCompiledTemplates(compType, true);
	            var loadingPromises = [];
	            templates.forEach(function (template) {
	                if (template.loading) {
	                    loadingPromises.push(template.loading);
	                }
	            });
	            return Promise.all(loadingPromises).then(function () {
	                templates.forEach(function (template) {
	                    _this._compileTemplate(template);
	                });
	                return _this._getCompiledHostTemplate(compType).proxyComponentFactory;
	            });
	        }
	    }, {
	        key: 'compileComponentSync',
	        value: function compileComponentSync(compType) {
	            var _this2 = this;

	            var templates = this._getTransitiveCompiledTemplates(compType, true);
	            templates.forEach(function (template) {
	                if (template.loading) {
	                    throw new BaseException$3('Can\'t compile synchronously as ' + template.compType.name + ' is still being loaded!');
	                }
	            });
	            templates.forEach(function (template) {
	                _this2._compileTemplate(template);
	            });
	            return this._getCompiledHostTemplate(compType).proxyComponentFactory;
	        }
	    }, {
	        key: 'clearCacheFor',
	        value: function clearCacheFor(compType) {
	            this._metadataResolver.clearCacheFor(compType);
	            this._compiledHostTemplateCache.delete(compType);
	            var compiledTemplate = this._compiledTemplateCache.get(compType);
	            if (compiledTemplate) {
	                this._templateNormalizer.clearCacheFor(compiledTemplate.normalizedCompMeta);
	                this._compiledTemplateCache.delete(compType);
	            }
	        }
	    }, {
	        key: 'clearCache',
	        value: function clearCache() {
	            this._metadataResolver.clearCache();
	            this._compiledTemplateCache.clear();
	            this._compiledHostTemplateCache.clear();
	            this._templateNormalizer.clearCache();
	        }
	    }, {
	        key: '_getCompiledHostTemplate',
	        value: function _getCompiledHostTemplate(type) {
	            var compiledTemplate = this._compiledHostTemplateCache.get(type);
	            if (isBlank$3(compiledTemplate)) {
	                var compMeta = this._metadataResolver.getDirectiveMetadata(type);
	                assertComponent(compMeta);
	                var hostMeta = createHostComponentMeta(compMeta.type, compMeta.selector);
	                compiledTemplate = new CompiledTemplate(true, compMeta.selector, compMeta.type, [], [type], [], [], this._templateNormalizer.normalizeDirective(hostMeta));
	                this._compiledHostTemplateCache.set(type, compiledTemplate);
	            }
	            return compiledTemplate;
	        }
	    }, {
	        key: '_getCompiledTemplate',
	        value: function _getCompiledTemplate(type) {
	            var compiledTemplate = this._compiledTemplateCache.get(type);
	            if (isBlank$3(compiledTemplate)) {
	                var compMeta = this._metadataResolver.getDirectiveMetadata(type);
	                assertComponent(compMeta);
	                var viewDirectives = [];
	                var viewComponentTypes = [];
	                this._metadataResolver.getViewDirectivesMetadata(type).forEach(function (dirOrComp) {
	                    if (dirOrComp.isComponent) {
	                        viewComponentTypes.push(dirOrComp.type.runtime);
	                    } else {
	                        viewDirectives.push(dirOrComp);
	                    }
	                });
	                var precompileComponentTypes = compMeta.precompile.map(function (typeMeta) {
	                    return typeMeta.runtime;
	                });
	                var pipes = this._metadataResolver.getViewPipesMetadata(type);
	                compiledTemplate = new CompiledTemplate(false, compMeta.selector, compMeta.type, viewDirectives, viewComponentTypes, precompileComponentTypes, pipes, this._templateNormalizer.normalizeDirective(compMeta));
	                this._compiledTemplateCache.set(type, compiledTemplate);
	            }
	            return compiledTemplate;
	        }
	    }, {
	        key: '_getTransitiveCompiledTemplates',
	        value: function _getTransitiveCompiledTemplates(compType, isHost) {
	            var _this3 = this;

	            var target = arguments.length <= 2 || arguments[2] === undefined ? new Set() : arguments[2];

	            var template = isHost ? this._getCompiledHostTemplate(compType) : this._getCompiledTemplate(compType);
	            if (!target.has(template)) {
	                target.add(template);
	                template.viewComponentTypes.forEach(function (compType) {
	                    _this3._getTransitiveCompiledTemplates(compType, false, target);
	                });
	                template.precompileHostComponentTypes.forEach(function (compType) {
	                    _this3._getTransitiveCompiledTemplates(compType, true, target);
	                });
	            }
	            return target;
	        }
	    }, {
	        key: '_compileTemplate',
	        value: function _compileTemplate(template) {
	            var _this4 = this;

	            if (template.isCompiled) {
	                return;
	            }
	            var compMeta = template.normalizedCompMeta;
	            var externalStylesheetsByModuleUrl = new Map();
	            var stylesCompileResult = this._styleCompiler.compileComponent(compMeta);
	            stylesCompileResult.externalStylesheets.forEach(function (r) {
	                externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r);
	            });
	            this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);
	            var viewCompMetas = template.viewComponentTypes.map(function (compType) {
	                return _this4._getCompiledTemplate(compType).normalizedCompMeta;
	            });
	            var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, template.viewDirectives.concat(viewCompMetas), template.viewPipes, compMeta.type.name);
	            var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), template.viewPipes);
	            var depTemplates = compileResult.dependencies.map(function (dep) {
	                var depTemplate = void 0;
	                if (dep instanceof ViewFactoryDependency) {
	                    var vfd = dep;
	                    depTemplate = _this4._getCompiledTemplate(vfd.comp.runtime);
	                    vfd.placeholder.runtime = depTemplate.proxyViewFactory;
	                    vfd.placeholder.name = 'viewFactory_' + vfd.comp.name;
	                } else if (dep instanceof ComponentFactoryDependency) {
	                    var cfd = dep;
	                    depTemplate = _this4._getCompiledHostTemplate(cfd.comp.runtime);
	                    cfd.placeholder.runtime = depTemplate.proxyComponentFactory;
	                    cfd.placeholder.name = 'compFactory_' + cfd.comp.name;
	                }
	                return depTemplate;
	            });
	            var statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);
	            var factory;
	            if (IS_DART$3 || !this._genConfig.useJit) {
	                factory = interpretStatements(statements, compileResult.viewFactoryVar, new InterpretiveAppViewInstanceFactory());
	            } else {
	                factory = jitStatements(template.compType.name + '.template.js', statements, compileResult.viewFactoryVar);
	            }
	            template.compiled(factory);
	        }
	    }, {
	        key: '_resolveStylesCompileResult',
	        value: function _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl) {
	            var _this5 = this;

	            result.dependencies.forEach(function (dep, i) {
	                var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);
	                var nestedStylesArr = _this5._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
	                dep.valuePlaceholder.runtime = nestedStylesArr;
	                dep.valuePlaceholder.name = 'importedStyles' + i;
	            });
	        }
	    }, {
	        key: '_resolveAndEvalStylesCompileResult',
	        value: function _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl) {
	            this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
	            if (IS_DART$3 || !this._genConfig.useJit) {
	                return interpretStatements(result.statements, result.stylesVar, new InterpretiveAppViewInstanceFactory());
	            } else {
	                return jitStatements(result.meta.moduleUrl + '.css.js', result.statements, result.stylesVar);
	            }
	        }
	    }]);
	    return RuntimeCompiler;
	}();
	/** @nocollapse */
	RuntimeCompiler.decorators = [{ type: Injectable }];
	/** @nocollapse */
	RuntimeCompiler.ctorParameters = [{ type: CompileMetadataResolver }, { type: DirectiveNormalizer }, { type: TemplateParser }, { type: StyleCompiler }, { type: ViewCompiler }, { type: CompilerConfig }];

	var CompiledTemplate = function () {
	    function CompiledTemplate(isHost, selector, compType, viewDirectives, viewComponentTypes, precompileHostComponentTypes, viewPipes, _normalizeResult) {
	        var _this6 = this;

	        classCallCheck(this, CompiledTemplate);

	        this.isHost = isHost;
	        this.compType = compType;
	        this.viewDirectives = viewDirectives;
	        this.viewComponentTypes = viewComponentTypes;
	        this.precompileHostComponentTypes = precompileHostComponentTypes;
	        this.viewPipes = viewPipes;
	        this._normalizeResult = _normalizeResult;
	        this._viewFactory = null;
	        this.loading = null;
	        this._normalizedCompMeta = null;
	        this.isCompiled = false;
	        this.isCompiledWithDeps = false;
	        this.proxyViewFactory = function () {
	            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                args[_key] = arguments[_key];
	            }

	            return _this6._viewFactory.apply(null, args);
	        };
	        this.proxyComponentFactory = isHost ? new ComponentFactory(selector, this.proxyViewFactory, compType.runtime) : null;
	        if (_normalizeResult.syncResult) {
	            this._normalizedCompMeta = _normalizeResult.syncResult;
	        } else {
	            this.loading = _normalizeResult.asyncResult.then(function (normalizedCompMeta) {
	                _this6._normalizedCompMeta = normalizedCompMeta;
	                _this6.loading = null;
	            });
	        }
	    }

	    createClass(CompiledTemplate, [{
	        key: 'compiled',
	        value: function compiled(viewFactory) {
	            this._viewFactory = viewFactory;
	            this.isCompiled = true;
	        }
	    }, {
	        key: 'depsCompiled',
	        value: function depsCompiled() {
	            this.isCompiledWithDeps = true;
	        }
	    }, {
	        key: 'normalizedCompMeta',
	        get: function get() {
	            if (this.loading) {
	                throw new BaseException$3('Template is still loading for ' + this.compType.name + '!');
	            }
	            return this._normalizedCompMeta;
	        }
	    }]);
	    return CompiledTemplate;
	}();

	function assertComponent(meta) {
	    if (!meta.isComponent) {
	        throw new BaseException$3('Could not compile \'' + meta.type.name + '\' because it is not a component.');
	    }
	}

	// =================================================================================================
	// =================================================================================================
	// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
	// =================================================================================================
	// =================================================================================================
	//
	//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
	//                               Reach out to mprobst for details.
	//
	// =================================================================================================
	/** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */
	var SECURITY_SCHEMA = {};
	function registerContext(ctx, specs) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	        for (var _iterator = specs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var spec = _step.value;

	            SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	}
	// Case is insignificant below, all element and attribute names are lower-cased for lookup.
	registerContext(SecurityContext$2.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);
	registerContext(SecurityContext$2.STYLE, ['*|style']);
	// NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
	registerContext(SecurityContext$2.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'source|srcset', 'video|poster', 'video|src']);
	registerContext(SecurityContext$2.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src', 'track|src']);

	var BOOLEAN = 'boolean';
	var NUMBER = 'number';
	var STRING = 'string';
	var OBJECT = 'object';
	/**
	 * This array represents the DOM schema. It encodes inheritance, properties, and events.
	 *
	 * ## Overview
	 *
	 * Each line represents one kind of element. The `element_inheritance` and properties are joined
	 * using `element_inheritance|preperties` syntax.
	 *
	 * ## Element Inheritance
	 *
	 * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
	 * Here the individual elements are separated by `,` (commas). Every element in the list
	 * has identical properties.
	 *
	 * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
	 * specified then `""` (blank) element is assumed.
	 *
	 * NOTE: The blank element inherits from root `*` element, the super element of all elements.
	 *
	 * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
	 *
	 * ## Properties
	 *
	 * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
	 * by a special character designating its type:
	 *
	 * - (no prefix): property is a string.
	 * - `*`: property represents an event.
	 * - `!`: property is a boolean.
	 * - `#`: property is a number.
	 * - `%`: property is an object.
	 *
	 * ## Query
	 *
	 * The class creates an internal squas representaino which allows to easily answer the query of
	 * if a given property exist on a given element.
	 *
	 * NOTE: We don't yet support querying for types or events.
	 * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
	 *       see dom_element_schema_registry_spec.ts
	 */
	// =================================================================================================
	// =================================================================================================
	// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
	// =================================================================================================
	// =================================================================================================
	//
	//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
	//
	// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
	// dom_security_schema.ts. Reach out to mprobst & rjamet for details.
	//
	// =================================================================================================
	var SCHEMA =
	/*@ts2dart_const*/['*|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop', '^*|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*autocomplete,*autocompleteerror,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,#volume', ':svg:^*|*abort,*autocomplete,*autocompleteerror,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerpolicy,rel,rev,search,shape,target,text,type,username', 'area|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerpolicy,search,shape,target,username', 'audio^media|', 'br|clear', 'base|href,target', 'body|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas|#height,#width', 'content|select', 'dl|!compact', 'datalist|', 'details|!open', 'dialog|!open,returnValue', 'dir|!compact', 'div|align', 'embed|align,height,name,src,type,width', 'fieldset|!disabled,name', 'font|color,face,size', 'form|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr|align,color,!noShade,size,width', 'head|', 'h1,h2,h3,h4,h5,h6|align', 'html|version', 'iframe|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerpolicy,%sandbox,scrolling,src,srcdoc,width', 'img|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerpolicy,sizes,src,srcset,useMap,#vspace,#width', 'input|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'keygen|!autofocus,challenge,!disabled,keytype,name', 'li|type,#value', 'label|htmlFor', 'legend|align', 'link|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type', 'map|name', 'marquee|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu|!compact', 'meta|content,httpEquiv,name,scheme', 'meter|#high,#low,#max,#min,#optimum,#value', 'ins,del|cite,dateTime', 'ol|!compact,!reversed,#start,type', 'object|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup|!disabled,label', 'option|!defaultSelected,!disabled,label,!selected,text,value', 'output|defaultValue,%htmlFor,name,value', 'p|align', 'param|name,type,value,valueType', 'picture|', 'pre|#width', 'progress|#max,#value', 'q,blockquote,cite|', 'script|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow|', 'source|media,sizes,src,srcset,type', 'span|', 'style|!disabled,media,type', 'caption|align', 'th,td|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup|align,ch,chOff,#span,vAlign,width', 'table|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody|align,ch,chOff,vAlign', 'template|', 'textarea|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title|text', 'track|!default,kind,label,src,srclang', 'ul|!compact,type', 'unknown|', 'video^media|#height,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:cursor^:svg:|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan'];
	var attrToPropMap = {
	    'class': 'className',
	    'formaction': 'formAction',
	    'innerHtml': 'innerHTML',
	    'readonly': 'readOnly',
	    'tabindex': 'tabIndex'
	};
	var DomElementSchemaRegistry = function (_ElementSchemaRegistr) {
	    inherits(DomElementSchemaRegistry, _ElementSchemaRegistr);

	    function DomElementSchemaRegistry() {
	        classCallCheck(this, DomElementSchemaRegistry);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(DomElementSchemaRegistry).call(this));

	        _this.schema = {};
	        SCHEMA.forEach(function (encodedType) {
	            var parts = encodedType.split('|');
	            var properties = parts[1].split(',');
	            var typeParts = (parts[0] + '^').split('^');
	            var typeName = typeParts[0];
	            var type = {};
	            typeName.split(',').forEach(function (tag) {
	                return _this.schema[tag] = type;
	            });
	            var superType = _this.schema[typeParts[1]];
	            if (isPresent$3(superType)) {
	                StringMapWrapper$3.forEach(superType, function (v /** TODO #9100 */, k /** TODO #9100 */) {
	                    return type[k] = v;
	                });
	            }
	            properties.forEach(function (property) {
	                if (property == '') {} else if (property.startsWith('*')) {} else if (property.startsWith('!')) {
	                    type[property.substring(1)] = BOOLEAN;
	                } else if (property.startsWith('#')) {
	                    type[property.substring(1)] = NUMBER;
	                } else if (property.startsWith('%')) {
	                    type[property.substring(1)] = OBJECT;
	                } else {
	                    type[property] = STRING;
	                }
	            });
	        });
	        return _this;
	    }

	    createClass(DomElementSchemaRegistry, [{
	        key: 'hasProperty',
	        value: function hasProperty(tagName, propName) {
	            if (tagName.indexOf('-') !== -1) {
	                if (tagName === 'ng-container' || tagName === 'ng-content') {
	                    return false;
	                }
	                // Can't tell now as we don't know which properties a custom element will get
	                // once it is instantiated
	                return true;
	            } else {
	                var elementProperties = this.schema[tagName.toLowerCase()];
	                if (!isPresent$3(elementProperties)) {
	                    elementProperties = this.schema['unknown'];
	                }
	                return isPresent$3(elementProperties[propName]);
	            }
	        }
	        /**
	         * securityContext returns the security context for the given property on the given DOM tag.
	         *
	         * Tag and property name are statically known and cannot change at runtime, i.e. it is not
	         * possible to bind a value into a changing attribute or tag name.
	         *
	         * The filtering is white list based. All attributes in the schema above are assumed to have the
	         * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
	         * attack vectors are assigned their appropriate context.
	         */

	    }, {
	        key: 'securityContext',
	        value: function securityContext(tagName, propName) {
	            // Make sure comparisons are case insensitive, so that case differences between attribute and
	            // property names do not have a security impact.
	            tagName = tagName.toLowerCase();
	            propName = propName.toLowerCase();
	            var ctx = SECURITY_SCHEMA[tagName + '|' + propName];
	            if (ctx !== undefined) return ctx;
	            ctx = SECURITY_SCHEMA['*|' + propName];
	            return ctx !== undefined ? ctx : SecurityContext$2.NONE;
	        }
	    }, {
	        key: 'getMappedPropName',
	        value: function getMappedPropName(propName) {
	            var mappedPropName = StringMapWrapper$3.get(attrToPropMap, propName);
	            return isPresent$3(mappedPropName) ? mappedPropName : propName;
	        }
	    }]);
	    return DomElementSchemaRegistry;
	}(ElementSchemaRegistry);
	/** @nocollapse */
	DomElementSchemaRegistry.decorators = [{ type: Injectable }];
	/** @nocollapse */
	DomElementSchemaRegistry.ctorParameters = [];

	/**
	 * A set of providers that provide `RuntimeCompiler` and its dependencies to use for
	 * template compilation.
	 */
	var COMPILER_PROVIDERS =
	/*@ts2dart_const*/[Lexer, Parser, HtmlParser, TemplateParser, DirectiveNormalizer, CompileMetadataResolver, DEFAULT_PACKAGE_URL_PROVIDER, StyleCompiler, ViewCompiler,
	/*@ts2dart_Provider*/{ provide: CompilerConfig, useValue: new CompilerConfig() }, RuntimeCompiler,
	/*@ts2dart_Provider*/{ provide: ComponentResolver, useExisting: RuntimeCompiler },
	/*@ts2dart_Provider*/{ provide: Compiler, useExisting: RuntimeCompiler }, DomElementSchemaRegistry,
	/*@ts2dart_Provider*/{ provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry }, UrlResolver, ViewResolver, DirectiveResolver, PipeResolver];

	/**
	 * A message extracted from a template.
	 *
	 * The identity of a message is comprised of `content` and `meaning`.
	 *
	 * `description` is additional information provided to the translator.
	 */
	var Message = function Message(content, meaning) {
	  var description = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	  classCallCheck(this, Message);

	  this.content = content;
	  this.meaning = meaning;
	  this.description = description;
	};
	/**
	 * Computes the id of a message
	 */
	function id(m) {
	  var meaning = isPresent$3(m.meaning) ? m.meaning : '';
	  var content = isPresent$3(m.content) ? m.content : '';
	  return escape$3('$ng|' + meaning + '|' + content);
	}

	var I18N_ATTR = 'i18n';
	var I18N_ATTR_PREFIX = 'i18n-';
	var CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*"([\s\S]*?)"[\s\S]*\)/g;
	/**
	 * An i18n error.
	 */
	var I18nError = function (_ParseError) {
	    inherits(I18nError, _ParseError);

	    function I18nError(span, msg) {
	        classCallCheck(this, I18nError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(I18nError).call(this, span, msg));
	    }

	    return I18nError;
	}(ParseError);
	function partition(nodes, errors, implicitTags) {
	    var parts = [];
	    for (var i = 0; i < nodes.length; ++i) {
	        var node = nodes[i];
	        var msgNodes = [];
	        // Nodes between `<!-- i18n -->` and `<!-- /i18n -->`
	        if (_isOpeningComment(node)) {
	            var i18n = node.value.replace(/^i18n:?/, '').trim();
	            while (++i < nodes.length && !_isClosingComment(nodes[i])) {
	                msgNodes.push(nodes[i]);
	            }
	            if (i === nodes.length) {
	                errors.push(new I18nError(node.sourceSpan, 'Missing closing \'i18n\' comment.'));
	                break;
	            }
	            parts.push(new Part(null, null, msgNodes, i18n, true));
	        } else if (node instanceof HtmlElementAst) {
	            // Node with an `i18n` attribute
	            var _i18n = _findI18nAttr(node);
	            var hasI18n = isPresent$3(_i18n) || implicitTags.indexOf(node.name) > -1;
	            parts.push(new Part(node, null, node.children, isPresent$3(_i18n) ? _i18n.value : null, hasI18n));
	        } else if (node instanceof HtmlTextAst) {
	            parts.push(new Part(null, node, null, null, false));
	        }
	    }
	    return parts;
	}
	var Part = function () {
	    function Part(rootElement, rootTextNode, children, i18n, hasI18n) {
	        classCallCheck(this, Part);

	        this.rootElement = rootElement;
	        this.rootTextNode = rootTextNode;
	        this.children = children;
	        this.i18n = i18n;
	        this.hasI18n = hasI18n;
	    }

	    createClass(Part, [{
	        key: 'createMessage',
	        value: function createMessage(parser, interpolationConfig) {
	            return new Message(stringifyNodes(this.children, parser, interpolationConfig), meaning(this.i18n), description(this.i18n));
	        }
	    }, {
	        key: 'sourceSpan',
	        get: function get() {
	            if (isPresent$3(this.rootElement)) {
	                return this.rootElement.sourceSpan;
	            }
	            if (isPresent$3(this.rootTextNode)) {
	                return this.rootTextNode.sourceSpan;
	            }
	            return this.children[0].sourceSpan;
	        }
	    }]);
	    return Part;
	}();
	function _isOpeningComment(n) {
	    return n instanceof HtmlCommentAst && isPresent$3(n.value) && n.value.startsWith('i18n');
	}
	function _isClosingComment(n) {
	    return n instanceof HtmlCommentAst && isPresent$3(n.value) && n.value === '/i18n';
	}
	function _findI18nAttr(p) {
	    var attrs = p.attrs;
	    for (var i = 0; i < attrs.length; i++) {
	        if (attrs[i].name === I18N_ATTR) {
	            return attrs[i];
	        }
	    }
	    return null;
	}
	function meaning(i18n) {
	    if (isBlank$3(i18n) || i18n == '') return null;
	    return i18n.split('|')[0];
	}
	function description(i18n) {
	    if (isBlank$3(i18n) || i18n == '') return null;
	    var parts = i18n.split('|', 2);
	    return parts.length > 1 ? parts[1] : null;
	}
	/**
	 * Extract a translation string given an `i18n-` prefixed attribute.
	 *
	 * @internal
	 */
	function messageFromI18nAttribute(parser, interpolationConfig, p, i18nAttr) {
	    var expectedName = i18nAttr.name.substring(5);
	    var attr = p.attrs.find(function (a) {
	        return a.name == expectedName;
	    });
	    if (attr) {
	        return messageFromAttribute(parser, interpolationConfig, attr, meaning(i18nAttr.value), description(i18nAttr.value));
	    }
	    throw new I18nError(p.sourceSpan, 'Missing attribute \'' + expectedName + '\'.');
	}
	function messageFromAttribute(parser, interpolationConfig, attr) {
	    var meaning = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	    var description = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];

	    var value = removeInterpolation(attr.value, attr.sourceSpan, parser, interpolationConfig);
	    return new Message(value, meaning, description);
	}
	function removeInterpolation(value, source, parser, interpolationConfig) {
	    try {
	        var parsed = parser.splitInterpolation(value, source.toString(), interpolationConfig);
	        var usedNames = new Map();
	        if (isPresent$3(parsed)) {
	            var res = '';
	            for (var i = 0; i < parsed.strings.length; ++i) {
	                res += parsed.strings[i];
	                if (i != parsed.strings.length - 1) {
	                    var customPhName = getPhNameFromBinding(parsed.expressions[i], i);
	                    customPhName = dedupePhName(usedNames, customPhName);
	                    res += '<ph name="' + customPhName + '"/>';
	                }
	            }
	            return res;
	        } else {
	            return value;
	        }
	    } catch (e) {
	        return value;
	    }
	}
	function getPhNameFromBinding(input, index) {
	    var customPhMatch = StringWrapper$3.split(input, CUSTOM_PH_EXP);
	    return customPhMatch.length > 1 ? customPhMatch[1] : '' + index;
	}
	function dedupePhName(usedNames, name) {
	    var duplicateNameCount = usedNames.get(name);
	    if (isPresent$3(duplicateNameCount)) {
	        usedNames.set(name, duplicateNameCount + 1);
	        return name + '_' + duplicateNameCount;
	    } else {
	        usedNames.set(name, 1);
	        return name;
	    }
	}
	function stringifyNodes(nodes, parser, interpolationConfig) {
	    var visitor = new _StringifyVisitor(parser, interpolationConfig);
	    return htmlVisitAll(visitor, nodes).join('');
	}

	var _StringifyVisitor = function () {
	    function _StringifyVisitor(_parser, _interpolationConfig) {
	        classCallCheck(this, _StringifyVisitor);

	        this._parser = _parser;
	        this._interpolationConfig = _interpolationConfig;
	        this._index = 0;
	    }

	    createClass(_StringifyVisitor, [{
	        key: 'visitElement',
	        value: function visitElement(ast, context) {
	            var name = this._index++;
	            var children = this._join(htmlVisitAll(this, ast.children), '');
	            return '<ph name="e' + name + '">' + children + '</ph>';
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, context) {
	            var index = this._index++;
	            var noInterpolation = removeInterpolation(ast.value, ast.sourceSpan, this._parser, this._interpolationConfig);
	            if (noInterpolation != ast.value) {
	                return '<ph name="t' + index + '">' + noInterpolation + '</ph>';
	            }
	            return ast.value;
	        }
	    }, {
	        key: 'visitComment',
	        value: function visitComment(ast, context) {
	            return '';
	        }
	    }, {
	        key: 'visitExpansion',
	        value: function visitExpansion(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitExpansionCase',
	        value: function visitExpansionCase(ast, context) {
	            return null;
	        }
	    }, {
	        key: '_join',
	        value: function _join(strs, str) {
	            return strs.filter(function (s) {
	                return s.length > 0;
	            }).join(str);
	        }
	    }]);
	    return _StringifyVisitor;
	}();

	// http://cldr.unicode.org/index/cldr-spec/plural-rules
	var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
	/**
	 * Expands special forms into elements.
	 *
	 * For example,
	 *
	 * ```
	 * { messages.length, plural,
	 *   =0 {zero}
	 *   =1 {one}
	 *   other {more than one}
	 * }
	 * ```
	 *
	 * will be expanded into
	 *
	 * ```
	 * <ng-container [ngPlural]="messages.length">
	 *   <template ngPluralCase="=0">zero</ng-container>
	 *   <template ngPluralCase="=1">one</ng-container>
	 *   <template ngPluralCase="other">more than one</ng-container>
	 * </ng-container>
	 * ```
	 */
	function expandNodes(nodes) {
	    var expander = new _Expander();
	    return new ExpansionResult(htmlVisitAll(expander, nodes), expander.isExpanded, expander.errors);
	}
	var ExpansionResult = function ExpansionResult(nodes, expanded, errors) {
	    classCallCheck(this, ExpansionResult);

	    this.nodes = nodes;
	    this.expanded = expanded;
	    this.errors = errors;
	};
	/**
	 * Expand expansion forms (plural, select) to directives
	 *
	 * @internal
	 */

	var _Expander = function () {
	    function _Expander() {
	        classCallCheck(this, _Expander);

	        this.isExpanded = false;
	        this.errors = [];
	    }

	    createClass(_Expander, [{
	        key: 'visitElement',
	        value: function visitElement(ast, context) {
	            return new HtmlElementAst(ast.name, ast.attrs, htmlVisitAll(this, ast.children), ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, context) {
	            return ast;
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, context) {
	            return ast;
	        }
	    }, {
	        key: 'visitComment',
	        value: function visitComment(ast, context) {
	            return ast;
	        }
	    }, {
	        key: 'visitExpansion',
	        value: function visitExpansion(ast, context) {
	            this.isExpanded = true;
	            return ast.type == 'plural' ? _expandPluralForm(ast, this.errors) : _expandDefaultForm(ast, this.errors);
	        }
	    }, {
	        key: 'visitExpansionCase',
	        value: function visitExpansionCase(ast, context) {
	            throw new BaseException$3('Should not be reached');
	        }
	    }]);
	    return _Expander;
	}();

	function _expandPluralForm(ast, errors) {
	    var children = ast.cases.map(function (c) {
	        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
	            errors.push(new I18nError(c.valueSourceSpan, 'Plural cases should be "=<number>" or one of ' + PLURAL_CASES.join(", ")));
	        }
	        var expansionResult = expandNodes(c.expression);
	        errors.push.apply(errors, toConsumableArray(expansionResult.errors));
	        return new HtmlElementAst('template', [new HtmlAttrAst('ngPluralCase', '' + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
	    });
	    var switchAttr = new HtmlAttrAst('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
	    return new HtmlElementAst('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
	}
	function _expandDefaultForm(ast, errors) {
	    var children = ast.cases.map(function (c) {
	        var expansionResult = expandNodes(c.expression);
	        errors.push.apply(errors, toConsumableArray(expansionResult.errors));
	        return new HtmlElementAst('template', [new HtmlAttrAst('ngSwitchCase', '' + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
	    });
	    var switchAttr = new HtmlAttrAst('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
	    return new HtmlElementAst('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
	}

	var _PLACEHOLDER_ELEMENT = 'ph';
	var _NAME_ATTR = 'name';
	var _PLACEHOLDER_EXPANDED_REGEXP = /<ph(\s)+name=("(\w)+")><\/ph>/gi;
	/**
	 * Creates an i18n-ed version of the parsed template.
	 *
	 * Algorithm:
	 *
	 * See `message_extractor.ts` for details on the partitioning algorithm.
	 *
	 * This is how the merging works:
	 *
	 * 1. Use the stringify function to get the message id. Look up the message in the map.
	 * 2. Get the translated message. At this point we have two trees: the original tree
	 * and the translated tree, where all the elements are replaced with placeholders.
	 * 3. Use the original tree to create a mapping Index:number -> HtmlAst.
	 * 4. Walk the translated tree.
	 * 5. If we encounter a placeholder element, get its name property.
	 * 6. Get the type and the index of the node using the name property.
	 * 7. If the type is 'e', which means element, then:
	 *     - translate the attributes of the original element
	 *     - recurse to merge the children
	 *     - create a new element using the original element name, original position,
	 *     and translated children and attributes
	 * 8. If the type if 't', which means text, then:
	 *     - get the list of expressions from the original node.
	 *     - get the string version of the interpolation subtree
	 *     - find all the placeholders in the translated message, and replace them with the
	 *     corresponding original expressions
	 */
	var I18nHtmlParser = function () {
	    function I18nHtmlParser(_htmlParser, _parser, _messagesContent, _messages, _implicitTags, _implicitAttrs) {
	        classCallCheck(this, I18nHtmlParser);

	        this._htmlParser = _htmlParser;
	        this._parser = _parser;
	        this._messagesContent = _messagesContent;
	        this._messages = _messages;
	        this._implicitTags = _implicitTags;
	        this._implicitAttrs = _implicitAttrs;
	    }

	    createClass(I18nHtmlParser, [{
	        key: 'parse',
	        value: function parse(sourceContent, sourceUrl) {
	            var parseExpansionForms = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	            var interpolationConfig = arguments.length <= 3 || arguments[3] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[3];

	            this.errors = [];
	            this._interpolationConfig = interpolationConfig;
	            var res = this._htmlParser.parse(sourceContent, sourceUrl, true);
	            if (res.errors.length > 0) {
	                return res;
	            } else {
	                var _errors;

	                var expanded = expandNodes(res.rootNodes);
	                var nodes = this._recurse(expanded.nodes);
	                (_errors = this.errors).push.apply(_errors, toConsumableArray(expanded.errors));
	                return this.errors.length > 0 ? new HtmlParseTreeResult([], this.errors) : new HtmlParseTreeResult(nodes, []);
	            }
	        }
	    }, {
	        key: '_processI18nPart',
	        value: function _processI18nPart(part) {
	            try {
	                return part.hasI18n ? this._mergeI18Part(part) : this._recurseIntoI18nPart(part);
	            } catch (e) {
	                if (e instanceof I18nError) {
	                    this.errors.push(e);
	                    return [];
	                } else {
	                    throw e;
	                }
	            }
	        }
	    }, {
	        key: '_mergeI18Part',
	        value: function _mergeI18Part(part) {
	            var message = part.createMessage(this._parser, this._interpolationConfig);
	            var messageId = id(message);
	            if (!StringMapWrapper$3.contains(this._messages, messageId)) {
	                throw new I18nError(part.sourceSpan, 'Cannot find message for id \'' + messageId + '\', content \'' + message.content + '\'.');
	            }
	            var parsedMessage = this._messages[messageId];
	            return this._mergeTrees(part, parsedMessage, part.children);
	        }
	    }, {
	        key: '_recurseIntoI18nPart',
	        value: function _recurseIntoI18nPart(p) {
	            // we found an element without an i18n attribute
	            // we need to recurse in cause its children may have i18n set
	            // we also need to translate its attributes
	            if (isPresent$3(p.rootElement)) {
	                var root = p.rootElement;
	                var children = this._recurse(p.children);
	                var attrs = this._i18nAttributes(root);
	                return [new HtmlElementAst(root.name, attrs, children, root.sourceSpan, root.startSourceSpan, root.endSourceSpan)];
	            } else if (isPresent$3(p.rootTextNode)) {
	                return [p.rootTextNode];
	            } else {
	                return this._recurse(p.children);
	            }
	        }
	    }, {
	        key: '_recurse',
	        value: function _recurse(nodes) {
	            var _this = this;

	            var parts = partition(nodes, this.errors, this._implicitTags);
	            return ListWrapper$3.flatten(parts.map(function (p) {
	                return _this._processI18nPart(p);
	            }));
	        }
	    }, {
	        key: '_mergeTrees',
	        value: function _mergeTrees(p, translated, original) {
	            var l = new _CreateNodeMapping();
	            htmlVisitAll(l, original);
	            // merge the translated tree with the original tree.
	            // we do it by preserving the source code position of the original tree
	            var merged = this._mergeTreesHelper(translated, l.mapping);
	            // if the root element is present, we need to create a new root element with its attributes
	            // translated
	            if (isPresent$3(p.rootElement)) {
	                var root = p.rootElement;
	                var attrs = this._i18nAttributes(root);
	                return [new HtmlElementAst(root.name, attrs, merged, root.sourceSpan, root.startSourceSpan, root.endSourceSpan)];
	            } else if (isPresent$3(p.rootTextNode)) {
	                throw new BaseException$3('should not be reached');
	            } else {
	                return merged;
	            }
	        }
	    }, {
	        key: '_mergeTreesHelper',
	        value: function _mergeTreesHelper(translated, mapping) {
	            var _this2 = this;

	            return translated.map(function (t) {
	                if (t instanceof HtmlElementAst) {
	                    return _this2._mergeElementOrInterpolation(t, translated, mapping);
	                } else if (t instanceof HtmlTextAst) {
	                    return t;
	                } else {
	                    throw new BaseException$3('should not be reached');
	                }
	            });
	        }
	    }, {
	        key: '_mergeElementOrInterpolation',
	        value: function _mergeElementOrInterpolation(t, translated, mapping) {
	            var name = this._getName(t);
	            var type = name[0];
	            var index = NumberWrapper$3.parseInt(name.substring(1), 10);
	            var originalNode = mapping[index];
	            if (type == 't') {
	                return this._mergeTextInterpolation(t, originalNode);
	            } else if (type == 'e') {
	                return this._mergeElement(t, originalNode, mapping);
	            } else {
	                throw new BaseException$3('should not be reached');
	            }
	        }
	    }, {
	        key: '_getName',
	        value: function _getName(t) {
	            if (t.name != _PLACEHOLDER_ELEMENT) {
	                throw new I18nError(t.sourceSpan, 'Unexpected tag "' + t.name + '". Only "' + _PLACEHOLDER_ELEMENT + '" tags are allowed.');
	            }
	            var names = t.attrs.filter(function (a) {
	                return a.name == _NAME_ATTR;
	            });
	            if (names.length == 0) {
	                throw new I18nError(t.sourceSpan, 'Missing "' + _NAME_ATTR + '" attribute.');
	            }
	            return names[0].value;
	        }
	    }, {
	        key: '_mergeTextInterpolation',
	        value: function _mergeTextInterpolation(t, originalNode) {
	            var split = this._parser.splitInterpolation(originalNode.value, originalNode.sourceSpan.toString(), this._interpolationConfig);
	            var exps = isPresent$3(split) ? split.expressions : [];
	            var messageSubstring = this._messagesContent.substring(t.startSourceSpan.end.offset, t.endSourceSpan.start.offset);
	            var translated = this._replacePlaceholdersWithExpressions(messageSubstring, exps, originalNode.sourceSpan);
	            return new HtmlTextAst(translated, originalNode.sourceSpan);
	        }
	    }, {
	        key: '_mergeElement',
	        value: function _mergeElement(t, originalNode, mapping) {
	            var children = this._mergeTreesHelper(t.children, mapping);
	            return new HtmlElementAst(originalNode.name, this._i18nAttributes(originalNode), children, originalNode.sourceSpan, originalNode.startSourceSpan, originalNode.endSourceSpan);
	        }
	    }, {
	        key: '_i18nAttributes',
	        value: function _i18nAttributes(el) {
	            var _this3 = this;

	            var res = [];
	            var implicitAttrs = isPresent$3(this._implicitAttrs[el.name]) ? this._implicitAttrs[el.name] : [];
	            el.attrs.forEach(function (attr) {
	                if (attr.name.startsWith(I18N_ATTR_PREFIX) || attr.name == I18N_ATTR) return;
	                var message = void 0;
	                var i18ns = el.attrs.filter(function (a) {
	                    return a.name == '' + I18N_ATTR_PREFIX + attr.name;
	                });
	                if (i18ns.length == 0) {
	                    if (implicitAttrs.indexOf(attr.name) == -1) {
	                        res.push(attr);
	                        return;
	                    }
	                    message = messageFromAttribute(_this3._parser, _this3._interpolationConfig, attr);
	                } else {
	                    message = messageFromI18nAttribute(_this3._parser, _this3._interpolationConfig, el, i18ns[0]);
	                }
	                var messageId = id(message);
	                if (StringMapWrapper$3.contains(_this3._messages, messageId)) {
	                    var updatedMessage = _this3._replaceInterpolationInAttr(attr, _this3._messages[messageId]);
	                    res.push(new HtmlAttrAst(attr.name, updatedMessage, attr.sourceSpan));
	                } else {
	                    throw new I18nError(attr.sourceSpan, 'Cannot find message for id \'' + messageId + '\', content \'' + message.content + '\'.');
	                }
	            });
	            return res;
	        }
	    }, {
	        key: '_replaceInterpolationInAttr',
	        value: function _replaceInterpolationInAttr(attr, msg) {
	            var split = this._parser.splitInterpolation(attr.value, attr.sourceSpan.toString(), this._interpolationConfig);
	            var exps = isPresent$3(split) ? split.expressions : [];
	            var first = msg[0];
	            var last = msg[msg.length - 1];
	            var start = first.sourceSpan.start.offset;
	            var end = last instanceof HtmlElementAst ? last.endSourceSpan.end.offset : last.sourceSpan.end.offset;
	            var messageSubstring = this._messagesContent.substring(start, end);
	            return this._replacePlaceholdersWithExpressions(messageSubstring, exps, attr.sourceSpan);
	        }
	    }, {
	        key: '_replacePlaceholdersWithExpressions',
	        value: function _replacePlaceholdersWithExpressions(message, exps, sourceSpan) {
	            var _this4 = this;

	            var expMap = this._buildExprMap(exps);
	            return RegExpWrapper$3.replaceAll(_PLACEHOLDER_EXPANDED_REGEXP, message, function (match) {
	                var nameWithQuotes = match[2];
	                var name = nameWithQuotes.substring(1, nameWithQuotes.length - 1);
	                return _this4._convertIntoExpression(name, expMap, sourceSpan);
	            });
	        }
	    }, {
	        key: '_buildExprMap',
	        value: function _buildExprMap(exps) {
	            var expMap = new Map();
	            var usedNames = new Map();
	            for (var i = 0; i < exps.length; i++) {
	                var phName = getPhNameFromBinding(exps[i], i);
	                expMap.set(dedupePhName(usedNames, phName), exps[i]);
	            }
	            return expMap;
	        }
	    }, {
	        key: '_convertIntoExpression',
	        value: function _convertIntoExpression(name, expMap, sourceSpan) {
	            if (expMap.has(name)) {
	                return '' + this._interpolationConfig.start + expMap.get(name) + this._interpolationConfig.end;
	            } else {
	                throw new I18nError(sourceSpan, 'Invalid interpolation name \'' + name + '\'');
	            }
	        }
	    }]);
	    return I18nHtmlParser;
	}();

	var _CreateNodeMapping = function () {
	    function _CreateNodeMapping() {
	        classCallCheck(this, _CreateNodeMapping);

	        this.mapping = [];
	    }

	    createClass(_CreateNodeMapping, [{
	        key: 'visitElement',
	        value: function visitElement(ast, context) {
	            this.mapping.push(ast);
	            htmlVisitAll(this, ast.children);
	            return null;
	        }
	    }, {
	        key: 'visitAttr',
	        value: function visitAttr(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitText',
	        value: function visitText(ast, context) {
	            this.mapping.push(ast);
	            return null;
	        }
	    }, {
	        key: 'visitExpansion',
	        value: function visitExpansion(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitExpansionCase',
	        value: function visitExpansionCase(ast, context) {
	            return null;
	        }
	    }, {
	        key: 'visitComment',
	        value: function visitComment(ast, context) {
	            return '';
	        }
	    }]);
	    return _CreateNodeMapping;
	}();

	/**
	 * All messages extracted from a template.
	 */
	var ExtractionResult = function ExtractionResult(messages, errors) {
	    classCallCheck(this, ExtractionResult);

	    this.messages = messages;
	    this.errors = errors;
	};
	/**
	 * Extracts all messages from a template.
	 *
	 * Algorithm:
	 *
	 * To understand the algorithm, you need to know how partitioning works.
	 * Partitioning is required as we can use two i18n comments to group node siblings together.
	 * That is why we cannot just use nodes.
	 *
	 * Partitioning transforms an array of HtmlAst into an array of Part.
	 * A part can optionally contain a root element or a root text node. And it can also contain
	 * children.
	 * A part can contain i18n property, in which case it needs to be extracted.
	 *
	 * Example:
	 *
	 * The following array of nodes will be split into four parts:
	 *
	 * ```
	 * <a>A</a>
	 * <b i18n>B</b>
	 * <!-- i18n -->
	 * <c>C</c>
	 * D
	 * <!-- /i18n -->
	 * E
	 * ```
	 *
	 * Part 1 containing the a tag. It should not be translated.
	 * Part 2 containing the b tag. It should be translated.
	 * Part 3 containing the c tag and the D text node. It should be translated.
	 * Part 4 containing the E text node. It should not be translated..
	 *
	 * It is also important to understand how we stringify nodes to create a message.
	 *
	 * We walk the tree and replace every element node with a placeholder. We also replace
	 * all expressions in interpolation with placeholders. We also insert a placeholder element
	 * to wrap a text node containing interpolation.
	 *
	 * Example:
	 *
	 * The following tree:
	 *
	 * ```
	 * <a>A{{I}}</a><b>B</b>
	 * ```
	 *
	 * will be stringified into:
	 * ```
	 * <ph name="e0"><ph name="t1">A<ph name="0"/></ph></ph><ph name="e2">B</ph>
	 * ```
	 *
	 * This is what the algorithm does:
	 *
	 * 1. Use the provided html parser to get the html AST of the template.
	 * 2. Partition the root nodes, and process each part separately.
	 * 3. If a part does not have the i18n attribute, recurse to process children and attributes.
	 * 4. If a part has the i18n attribute, stringify the nodes to create a Message.
	 */
	var MessageExtractor = function () {
	    function MessageExtractor(_htmlParser, _parser, _implicitTags, _implicitAttrs) {
	        classCallCheck(this, MessageExtractor);

	        this._htmlParser = _htmlParser;
	        this._parser = _parser;
	        this._implicitTags = _implicitTags;
	        this._implicitAttrs = _implicitAttrs;
	    }

	    createClass(MessageExtractor, [{
	        key: 'extract',
	        value: function extract(template, sourceUrl) {
	            var interpolationConfig = arguments.length <= 2 || arguments[2] === undefined ? DEFAULT_INTERPOLATION_CONFIG : arguments[2];

	            this._messages = [];
	            this._errors = [];
	            var res = this._htmlParser.parse(template, sourceUrl, true);
	            if (res.errors.length == 0) {
	                this._recurse(res.rootNodes, interpolationConfig);
	            }
	            return new ExtractionResult(this._messages, this._errors.concat(res.errors));
	        }
	    }, {
	        key: '_extractMessagesFromPart',
	        value: function _extractMessagesFromPart(part, interpolationConfig) {
	            if (part.hasI18n) {
	                this._messages.push(part.createMessage(this._parser, interpolationConfig));
	                this._recurseToExtractMessagesFromAttributes(part.children, interpolationConfig);
	            } else {
	                this._recurse(part.children, interpolationConfig);
	            }
	            if (isPresent$3(part.rootElement)) {
	                this._extractMessagesFromAttributes(part.rootElement, interpolationConfig);
	            }
	        }
	    }, {
	        key: '_recurse',
	        value: function _recurse(nodes, interpolationConfig) {
	            var _this = this;

	            if (isPresent$3(nodes)) {
	                var parts = partition(nodes, this._errors, this._implicitTags);
	                parts.forEach(function (part) {
	                    return _this._extractMessagesFromPart(part, interpolationConfig);
	                });
	            }
	        }
	    }, {
	        key: '_recurseToExtractMessagesFromAttributes',
	        value: function _recurseToExtractMessagesFromAttributes(nodes, interpolationConfig) {
	            var _this2 = this;

	            nodes.forEach(function (n) {
	                if (n instanceof HtmlElementAst) {
	                    _this2._extractMessagesFromAttributes(n, interpolationConfig);
	                    _this2._recurseToExtractMessagesFromAttributes(n.children, interpolationConfig);
	                }
	            });
	        }
	    }, {
	        key: '_extractMessagesFromAttributes',
	        value: function _extractMessagesFromAttributes(p, interpolationConfig) {
	            var _this3 = this;

	            var transAttrs = isPresent$3(this._implicitAttrs[p.name]) ? this._implicitAttrs[p.name] : [];
	            var explicitAttrs = [];
	            // `i18n-` prefixed attributes should be translated
	            p.attrs.filter(function (attr) {
	                return attr.name.startsWith(I18N_ATTR_PREFIX);
	            }).forEach(function (attr) {
	                try {
	                    explicitAttrs.push(attr.name.substring(I18N_ATTR_PREFIX.length));
	                    _this3._messages.push(messageFromI18nAttribute(_this3._parser, interpolationConfig, p, attr));
	                } catch (e) {
	                    if (e instanceof I18nError) {
	                        _this3._errors.push(e);
	                    } else {
	                        throw e;
	                    }
	                }
	            });
	            // implicit attributes should also be translated
	            p.attrs.filter(function (attr) {
	                return !attr.name.startsWith(I18N_ATTR_PREFIX);
	            }).filter(function (attr) {
	                return explicitAttrs.indexOf(attr.name) == -1;
	            }).filter(function (attr) {
	                return transAttrs.indexOf(attr.name) > -1;
	            }).forEach(function (attr) {
	                return _this3._messages.push(messageFromAttribute(_this3._parser, interpolationConfig, attr));
	            });
	        }
	    }]);
	    return MessageExtractor;
	}();

	var _PLACEHOLDER_REGEXP = RegExpWrapper$3.create('\\<ph(\\s)+name=("(\\w)+")\\/\\>');
	var XmbDeserializationError = function (_ParseError) {
	    inherits(XmbDeserializationError, _ParseError);

	    function XmbDeserializationError(span, msg) {
	        classCallCheck(this, XmbDeserializationError);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(XmbDeserializationError).call(this, span, msg));
	    }

	    return XmbDeserializationError;
	}(ParseError);

	// asset:<package-name>/<realm>/<path-to-module>
	var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/g;
	/**
	 * Interface that defines how import statements should be generated.
	 */
	var ImportGenerator = function () {
	    function ImportGenerator() {
	        classCallCheck(this, ImportGenerator);
	    }

	    createClass(ImportGenerator, null, [{
	        key: 'parseAssetUrl',
	        value: function parseAssetUrl(url) {
	            return AssetUrl.parse(url);
	        }
	    }]);
	    return ImportGenerator;
	}();
	var AssetUrl = function () {
	    function AssetUrl(packageName, firstLevelDir, modulePath) {
	        classCallCheck(this, AssetUrl);

	        this.packageName = packageName;
	        this.firstLevelDir = firstLevelDir;
	        this.modulePath = modulePath;
	    }

	    createClass(AssetUrl, null, [{
	        key: 'parse',
	        value: function parse(url) {
	            var allowNonMatching = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	            var match = RegExpWrapper$3.firstMatch(_ASSET_URL_RE, url);
	            if (isPresent$3(match)) {
	                return new AssetUrl(match[1], match[2], match[3]);
	            }
	            if (allowNonMatching) {
	                return null;
	            }
	            throw new BaseException$3('Url ' + url + ' is not a valid asset: url');
	        }
	    }]);
	    return AssetUrl;
	}();

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalScope$4;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope$4 = self;
	    } else {
	        globalScope$4 = global;
	    }
	} else {
	    globalScope$4 = window;
	}
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var global$5 = globalScope$4;
	var Date$5 = global$5.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	global$5.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent$4(obj) {
	    return obj !== undefined && obj !== null;
	}
	function isBlank$4(obj) {
	    return obj === undefined || obj === null;
	}
	function isArray$5(obj) {
	    return Array.isArray(obj);
	}
	function noop$4() {}
	var StringWrapper$4 = function () {
	    function StringWrapper() {
	        classCallCheck(this, StringWrapper);
	    }

	    createClass(StringWrapper, null, [{
	        key: 'fromCharCode',
	        value: function fromCharCode(code) {
	            return String.fromCharCode(code);
	        }
	    }, {
	        key: 'charCodeAt',
	        value: function charCodeAt(s, index) {
	            return s.charCodeAt(index);
	        }
	    }, {
	        key: 'split',
	        value: function split(s, regExp) {
	            return s.split(regExp);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(s, s2) {
	            return s === s2;
	        }
	    }, {
	        key: 'stripLeft',
	        value: function stripLeft(s, charVal) {
	            if (s && s.length) {
	                var pos = 0;
	                for (var i = 0; i < s.length; i++) {
	                    if (s[i] != charVal) break;
	                    pos++;
	                }
	                s = s.substring(pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'stripRight',
	        value: function stripRight(s, charVal) {
	            if (s && s.length) {
	                var pos = s.length;
	                for (var i = s.length - 1; i >= 0; i--) {
	                    if (s[i] != charVal) break;
	                    pos--;
	                }
	                s = s.substring(0, pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'replace',
	        value: function replace(s, from, _replace) {
	            return s.replace(from, _replace);
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(s, from, replace) {
	            return s.replace(from, replace);
	        }
	    }, {
	        key: 'slice',
	        value: function slice(s) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return s.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'replaceAllMapped',
	        value: function replaceAllMapped(s, from, cb) {
	            return s.replace(from, function () {
	                for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
	                    matches[_key] = arguments[_key];
	                }

	                // Remove offset & string from the result array
	                matches.splice(-2, 2);
	                // The callback receives match, p1, ..., pn
	                return cb(matches);
	            });
	        }
	    }, {
	        key: 'contains',
	        value: function contains(s, substr) {
	            return s.indexOf(substr) != -1;
	        }
	    }, {
	        key: 'compare',
	        value: function compare(a, b) {
	            if (a < b) {
	                return -1;
	            } else if (a > b) {
	                return 1;
	            } else {
	                return 0;
	            }
	        }
	    }]);
	    return StringWrapper;
	}();

	var StringJoiner$4 = function () {
	    function StringJoiner() {
	        var parts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, StringJoiner);

	        this.parts = parts;
	    }

	    createClass(StringJoiner, [{
	        key: 'add',
	        value: function add(part) {
	            this.parts.push(part);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.parts.join('');
	        }
	    }]);
	    return StringJoiner;
	}();
	var NumberParseError$4 = function (_Error) {
	    inherits(NumberParseError, _Error);

	    function NumberParseError(message) {
	        classCallCheck(this, NumberParseError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NumberParseError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(NumberParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return NumberParseError;
	}(Error);
	var NumberWrapper$4 = function () {
	    function NumberWrapper() {
	        classCallCheck(this, NumberWrapper);
	    }

	    createClass(NumberWrapper, null, [{
	        key: 'toFixed',
	        value: function toFixed(n, fractionDigits) {
	            return n.toFixed(fractionDigits);
	        }
	    }, {
	        key: 'equal',
	        value: function equal(a, b) {
	            return a === b;
	        }
	    }, {
	        key: 'parseIntAutoRadix',
	        value: function parseIntAutoRadix(text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new NumberParseError$4('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        }
	    }, {
	        key: 'parseInt',
	        value: function (_parseInt) {
	            function parseInt(_x4, _x5) {
	                return _parseInt.apply(this, arguments);
	            }

	            parseInt.toString = function () {
	                return _parseInt.toString();
	            };

	            return parseInt;
	        }(function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new NumberParseError$4('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        })
	        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.

	    }, {
	        key: 'parseFloat',
	        value: function (_parseFloat) {
	            function parseFloat(_x6) {
	                return _parseFloat.apply(this, arguments);
	            }

	            parseFloat.toString = function () {
	                return _parseFloat.toString();
	            };

	            return parseFloat;
	        }(function (text) {
	            return parseFloat(text);
	        })
	    }, {
	        key: 'isNumeric',
	        value: function isNumeric(value) {
	            return !isNaN(value - parseFloat(value));
	        }
	    }, {
	        key: 'isNaN',
	        value: function (_isNaN) {
	            function isNaN(_x7) {
	                return _isNaN.apply(this, arguments);
	            }

	            isNaN.toString = function () {
	                return _isNaN.toString();
	            };

	            return isNaN;
	        }(function (value) {
	            return isNaN(value);
	        })
	    }, {
	        key: 'isInteger',
	        value: function isInteger(value) {
	            return Number.isInteger(value);
	        }
	    }, {
	        key: 'NaN',
	        get: function get() {
	            return NaN;
	        }
	    }]);
	    return NumberWrapper;
	}();
	var RegExpWrapper$4 = function () {
	    function RegExpWrapper() {
	        classCallCheck(this, RegExpWrapper);
	    }

	    createClass(RegExpWrapper, null, [{
	        key: 'create',
	        value: function create(regExpStr) {
	            var flags = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            flags = flags.replace(/g/g, '');
	            return new global$5.RegExp(regExpStr, flags + 'g');
	        }
	    }, {
	        key: 'firstMatch',
	        value: function firstMatch(regExp, input) {
	            // Reset multimatch regex state
	            regExp.lastIndex = 0;
	            return regExp.exec(input);
	        }
	    }, {
	        key: 'test',
	        value: function test(regExp, input) {
	            regExp.lastIndex = 0;
	            return regExp.test(input);
	        }
	    }, {
	        key: 'matcher',
	        value: function matcher(regExp, input) {
	            // Reset regex state for the case
	            // someone did not loop over all matches
	            // last time.
	            regExp.lastIndex = 0;
	            return { re: regExp, input: input };
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(regExp, input, replace) {
	            var c = regExp.exec(input);
	            var res = '';
	            regExp.lastIndex = 0;
	            var prev = 0;
	            while (c) {
	                res += input.substring(prev, c.index);
	                res += replace(c);
	                prev = c.index + c[0].length;
	                regExp.lastIndex = prev;
	                c = regExp.exec(input);
	            }
	            res += input.substring(prev);
	            return res;
	        }
	    }]);
	    return RegExpWrapper;
	}();
	var RegExpMatcherWrapper$4 = function () {
	    function RegExpMatcherWrapper() {
	        classCallCheck(this, RegExpMatcherWrapper);
	    }

	    createClass(RegExpMatcherWrapper, null, [{
	        key: 'next',
	        value: function next(matcher) {
	            return matcher.re.exec(matcher.input);
	        }
	    }]);
	    return RegExpMatcherWrapper;
	}();
	var FunctionWrapper$4 = function () {
	    function FunctionWrapper() {
	        classCallCheck(this, FunctionWrapper);
	    }

	    createClass(FunctionWrapper, null, [{
	        key: 'apply',
	        value: function apply(fn, posArgs) {
	            return fn.apply(null, posArgs);
	        }
	    }, {
	        key: 'bind',
	        value: function bind(fn, scope) {
	            return fn.bind(scope);
	        }
	    }]);
	    return FunctionWrapper;
	}();
	function isJsObject$4(o) {
	    return o !== null && (typeof o === 'function' || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object');
	}
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json$4 = function () {
	    function Json() {
	        classCallCheck(this, Json);
	    }

	    createClass(Json, null, [{
	        key: 'parse',
	        value: function parse(s) {
	            return global$5.JSON.parse(s);
	        }
	    }, {
	        key: 'stringify',
	        value: function stringify(data) {
	            // Dart doesn't take 3 arguments
	            return global$5.JSON.stringify(data, null, 2);
	        }
	    }]);
	    return Json;
	}();
	var DateWrapper$4 = function () {
	    function DateWrapper() {
	        classCallCheck(this, DateWrapper);
	    }

	    createClass(DateWrapper, null, [{
	        key: 'create',
	        value: function create(year) {
	            var month = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var day = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	            var hour = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	            var minutes = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
	            var seconds = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
	            var milliseconds = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];

	            return new Date$5(year, month - 1, day, hour, minutes, seconds, milliseconds);
	        }
	    }, {
	        key: 'fromISOString',
	        value: function fromISOString(str) {
	            return new Date$5(str);
	        }
	    }, {
	        key: 'fromMillis',
	        value: function fromMillis(ms) {
	            return new Date$5(ms);
	        }
	    }, {
	        key: 'toMillis',
	        value: function toMillis(date) {
	            return date.getTime();
	        }
	    }, {
	        key: 'now',
	        value: function now() {
	            return new Date$5();
	        }
	    }, {
	        key: 'toJson',
	        value: function toJson(date) {
	            return date.toJSON();
	        }
	    }]);
	    return DateWrapper;
	}();
	var _symbolIterator$4 = null;
	function getSymbolIterator$4() {
	    if (isBlank$4(_symbolIterator$4)) {
	        if (isPresent$4(globalScope$4.Symbol) && isPresent$4(Symbol.iterator)) {
	            _symbolIterator$4 = Symbol.iterator;
	        } else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator$4 = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator$4;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PromiseCompleter$4 = function PromiseCompleter() {
	    var _this = this;

	    classCallCheck(this, PromiseCompleter);

	    this.promise = new Promise(function (res, rej) {
	        _this.resolve = res;
	        _this.reject = rej;
	    });
	};
	var PromiseWrapper$4 = function () {
	    function PromiseWrapper() {
	        classCallCheck(this, PromiseWrapper);
	    }

	    createClass(PromiseWrapper, null, [{
	        key: "resolve",
	        value: function resolve(obj) {
	            return Promise.resolve(obj);
	        }
	    }, {
	        key: "reject",
	        value: function reject(obj, _) {
	            return Promise.reject(obj);
	        }
	        // Note: We can't rename this method into `catch`, as this is not a valid
	        // method name in Dart.

	    }, {
	        key: "catchError",
	        value: function catchError(promise, onError) {
	            return promise.catch(onError);
	        }
	    }, {
	        key: "all",
	        value: function all(promises) {
	            if (promises.length == 0) return Promise.resolve([]);
	            return Promise.all(promises);
	        }
	    }, {
	        key: "then",
	        value: function then(promise, success, rejection) {
	            return promise.then(success, rejection);
	        }
	    }, {
	        key: "wrap",
	        value: function wrap(computation) {
	            return new Promise(function (res, rej) {
	                try {
	                    res(computation());
	                } catch (e) {
	                    rej(e);
	                }
	            });
	        }
	    }, {
	        key: "scheduleMicrotask",
	        value: function scheduleMicrotask(computation) {
	            PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) {});
	        }
	    }, {
	        key: "completer",
	        value: function completer() {
	            return new PromiseCompleter$4();
	        }
	    }]);
	    return PromiseWrapper;
	}();

	var TimerWrapper$4 = function () {
	    function TimerWrapper() {
	        classCallCheck(this, TimerWrapper);
	    }

	    createClass(TimerWrapper, null, [{
	        key: 'setTimeout',
	        value: function setTimeout(fn, millis) {
	            return global$5.setTimeout(fn, millis);
	        }
	    }, {
	        key: 'clearTimeout',
	        value: function clearTimeout(id) {
	            global$5.clearTimeout(id);
	        }
	    }, {
	        key: 'setInterval',
	        value: function setInterval(fn, millis) {
	            return global$5.setInterval(fn, millis);
	        }
	    }, {
	        key: 'clearInterval',
	        value: function clearInterval(id) {
	            global$5.clearInterval(id);
	        }
	    }]);
	    return TimerWrapper;
	}();
	var ObservableWrapper$4 = function () {
	    function ObservableWrapper() {
	        classCallCheck(this, ObservableWrapper);
	    }

	    createClass(ObservableWrapper, null, [{
	        key: 'subscribe',

	        // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	        value: function subscribe(emitter, onNext, onError) {
	            var onComplete = arguments.length <= 3 || arguments[3] === undefined ? function () {} : arguments[3];

	            onError = typeof onError === 'function' && onError || noop$4;
	            onComplete = typeof onComplete === 'function' && onComplete || noop$4;
	            return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
	        }
	    }, {
	        key: 'isObservable',
	        value: function isObservable(obs) {
	            return !!obs.subscribe;
	        }
	        /**
	         * Returns whether `obs` has any subscribers listening to events.
	         */

	    }, {
	        key: 'hasSubscribers',
	        value: function hasSubscribers(obs) {
	            return obs.observers.length > 0;
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {
	            subscription.unsubscribe();
	        }
	        /**
	         * @deprecated - use callEmit() instead
	         */

	    }, {
	        key: 'callNext',
	        value: function callNext(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callEmit',
	        value: function callEmit(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callError',
	        value: function callError(emitter, error) {
	            emitter.error(error);
	        }
	    }, {
	        key: 'callComplete',
	        value: function callComplete(emitter) {
	            emitter.complete();
	        }
	    }, {
	        key: 'fromPromise',
	        value: function fromPromise(promise) {
	            return PromiseObservable.create(promise);
	        }
	    }, {
	        key: 'toPromise',
	        value: function toPromise(obj) {
	            return _toPromise.call(obj);
	        }
	    }]);
	    return ObservableWrapper;
	}();
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter$4 = function (_Subject) {
	    inherits(EventEmitter, _Subject);

	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */

	    function EventEmitter() {
	        var isAsync = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	        classCallCheck(this, EventEmitter);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EventEmitter).call(this));

	        _this.__isAsync = isAsync;
	        return _this;
	    }

	    createClass(EventEmitter, [{
	        key: 'emit',
	        value: function emit(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	        /**
	         * @deprecated - use .emit(value) instead
	         */

	    }, {
	        key: 'next',
	        value: function next(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	    }, {
	        key: 'subscribe',
	        value: function subscribe(generatorOrNext, error, complete) {
	            var schedulerFn = void 0;
	            var errorFn = function errorFn(err) {
	                return null;
	            };
	            var completeFn = function completeFn() {
	                return null;
	            };
	            if (generatorOrNext && (typeof generatorOrNext === 'undefined' ? 'undefined' : _typeof(generatorOrNext)) === 'object') {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext.next(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext.next(value);
	                };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return generatorOrNext.error(err);
	                        });
	                    } : function (err) {
	                        generatorOrNext.error(err);
	                    };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return generatorOrNext.complete();
	                        });
	                    } : function () {
	                        generatorOrNext.complete();
	                    };
	                }
	            } else {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext(value);
	                };
	                if (error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return error(err);
	                        });
	                    } : function (err) {
	                        error(err);
	                    };
	                }
	                if (complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return complete();
	                        });
	                    } : function () {
	                        complete();
	                    };
	                }
	            }
	            return get(Object.getPrototypeOf(EventEmitter.prototype), 'subscribe', this).call(this, schedulerFn, errorFn, completeFn);
	        }
	    }]);
	    return EventEmitter;
	}(Subject);

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException$4 = function (_Error) {
	  inherits(BaseWrappedException, _Error);

	  function BaseWrappedException(message) {
	    classCallCheck(this, BaseWrappedException);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(BaseWrappedException).call(this, message));
	  }

	  createClass(BaseWrappedException, [{
	    key: 'wrapperMessage',
	    get: function get() {
	      return '';
	    }
	  }, {
	    key: 'wrapperStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalException',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'message',
	    get: function get() {
	      return '';
	    }
	  }]);
	  return BaseWrappedException;
	}(Error);

	var Map$5 = global$5.Map;
	var Set$5 = global$5.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs$4 = function () {
	    try {
	        if (new Map$5([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) {
	                return new Map$5(pairs);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new Map$5();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	}();
	var createMapFromMap$4 = function () {
	    try {
	        if (new Map$5(new Map$5())) {
	            return function createMapFromMap(m) {
	                return new Map$5(m);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromMap(m) {
	        var map = new Map$5();
	        m.forEach(function (v, k) {
	            map.set(k, v);
	        });
	        return map;
	    };
	}();
	var _clearValues$4 = function () {
	    if (new Map$5().keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!(k = keyIterator.next()).done) {
	                m.set(k.value, null);
	            }
	        };
	    } else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) {
	                m.set(k, null);
	            });
	        };
	    }
	}();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap$4 = function () {
	    try {
	        if (new Map$5().values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    } catch (e) {}
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper$4.createFixedSize(m.size),
	            i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	}();
	var MapWrapper$4 = function () {
	    function MapWrapper() {
	        classCallCheck(this, MapWrapper);
	    }

	    createClass(MapWrapper, null, [{
	        key: 'clone',
	        value: function clone(m) {
	            return createMapFromMap$4(m);
	        }
	    }, {
	        key: 'createFromStringMap',
	        value: function createFromStringMap(stringMap) {
	            var result = new Map$5();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        }
	    }, {
	        key: 'toStringMap',
	        value: function toStringMap(m) {
	            var r = {};
	            m.forEach(function (v, k) {
	                return r[k] = v;
	            });
	            return r;
	        }
	    }, {
	        key: 'createFromPairs',
	        value: function createFromPairs(pairs) {
	            return createMapFromPairs$4(pairs);
	        }
	    }, {
	        key: 'clearValues',
	        value: function clearValues(m) {
	            _clearValues$4(m);
	        }
	    }, {
	        key: 'iterable',
	        value: function iterable(m) {
	            return m;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(m) {
	            return _arrayFromMap$4(m, false);
	        }
	    }, {
	        key: 'values',
	        value: function values(m) {
	            return _arrayFromMap$4(m, true);
	        }
	    }]);
	    return MapWrapper;
	}();
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper$4 = function () {
	    function StringMapWrapper() {
	        classCallCheck(this, StringMapWrapper);
	    }

	    createClass(StringMapWrapper, null, [{
	        key: 'create',
	        value: function create() {
	            // Note: We are not using Object.create(null) here due to
	            // performance!
	            // http://jsperf.com/ng2-object-create-null
	            return {};
	        }
	    }, {
	        key: 'contains',
	        value: function contains(map, key) {
	            return map.hasOwnProperty(key);
	        }
	    }, {
	        key: 'get',
	        value: function get(map, key) {
	            return map.hasOwnProperty(key) ? map[key] : undefined;
	        }
	    }, {
	        key: 'set',
	        value: function set(map, key, value) {
	            map[key] = value;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(map) {
	            return Object.keys(map);
	        }
	    }, {
	        key: 'values',
	        value: function values(map) {
	            return Object.keys(map).reduce(function (r, a) {
	                r.push(map[a]);
	                return r;
	            }, []);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(map) {
	            for (var prop in map) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(map, key) {
	            delete map[key];
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(map, callback) {
	            for (var prop in map) {
	                if (map.hasOwnProperty(prop)) {
	                    callback(map[prop], prop);
	                }
	            }
	        }
	    }, {
	        key: 'merge',
	        value: function merge(m1, m2) {
	            var m = {};
	            for (var attr in m1) {
	                if (m1.hasOwnProperty(attr)) {
	                    m[attr] = m1[attr];
	                }
	            }
	            for (var attr in m2) {
	                if (m2.hasOwnProperty(attr)) {
	                    m[attr] = m2[attr];
	                }
	            }
	            return m;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            var key;
	            for (var i = 0; i < k1.length; i++) {
	                key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }]);
	    return StringMapWrapper;
	}();
	var ListWrapper$4 = function () {
	    function ListWrapper() {
	        classCallCheck(this, ListWrapper);
	    }

	    createClass(ListWrapper, null, [{
	        key: 'createFixedSize',

	        // JS has no way to express a statically fixed size list, but dart does so we
	        // keep both methods.
	        value: function createFixedSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'createGrowableSize',
	        value: function createGrowableSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'clone',
	        value: function clone(array) {
	            return array.slice(0);
	        }
	    }, {
	        key: 'forEachWithIndex',
	        value: function forEachWithIndex(array, fn) {
	            for (var i = 0; i < array.length; i++) {
	                fn(array[i], i);
	            }
	        }
	    }, {
	        key: 'first',
	        value: function first(array) {
	            if (!array) return null;
	            return array[0];
	        }
	    }, {
	        key: 'last',
	        value: function last(array) {
	            if (!array || array.length == 0) return null;
	            return array[array.length - 1];
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(array, value) {
	            var startIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	            return array.indexOf(value, startIndex);
	        }
	    }, {
	        key: 'contains',
	        value: function contains(list, el) {
	            return list.indexOf(el) !== -1;
	        }
	    }, {
	        key: 'reversed',
	        value: function reversed(array) {
	            var a = ListWrapper.clone(array);
	            return a.reverse();
	        }
	    }, {
	        key: 'concat',
	        value: function concat(a, b) {
	            return a.concat(b);
	        }
	    }, {
	        key: 'insert',
	        value: function insert(list, index, value) {
	            list.splice(index, 0, value);
	        }
	    }, {
	        key: 'removeAt',
	        value: function removeAt(list, index) {
	            var res = list[index];
	            list.splice(index, 1);
	            return res;
	        }
	    }, {
	        key: 'removeAll',
	        value: function removeAll(list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'clear',
	        value: function clear(list) {
	            list.length = 0;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(list) {
	            return list.length == 0;
	        }
	    }, {
	        key: 'fill',
	        value: function fill(list, value) {
	            var start = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	            var end = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            list.fill(value, start, end === null ? list.length : end);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(a, b) {
	            if (a.length != b.length) return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i]) return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'slice',
	        value: function slice(l) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return l.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'splice',
	        value: function splice(l, from, length) {
	            return l.splice(from, length);
	        }
	    }, {
	        key: 'sort',
	        value: function sort(l, compareFn) {
	            if (isPresent$4(compareFn)) {
	                l.sort(compareFn);
	            } else {
	                l.sort();
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString(l) {
	            return l.toString();
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON(l) {
	            return JSON.stringify(l);
	        }
	    }, {
	        key: 'maximum',
	        value: function maximum(list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (isBlank$4(candidate)) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        }
	    }, {
	        key: 'flatten',
	        value: function flatten(list) {
	            var target = [];
	            _flattenArray$4(list, target);
	            return target;
	        }
	    }, {
	        key: 'addAll',
	        value: function addAll(list, source) {
	            for (var i = 0; i < source.length; i++) {
	                list.push(source[i]);
	            }
	        }
	    }]);
	    return ListWrapper;
	}();
	function _flattenArray$4(source, target) {
	    if (isPresent$4(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (isArray$5(item)) {
	                _flattenArray$4(item, target);
	            } else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable$4(obj) {
	    if (!isJsObject$4(obj)) return false;
	    return isArray$5(obj) || !(obj instanceof Map$5) && getSymbolIterator$4() in obj; // JS Iterable have a Symbol.iterator prop
	}
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList$4 = function () {
	    var test = new Set$5([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) {
	            return new Set$5(lst);
	        };
	    } else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new Set$5(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	}();
	var SetWrapper$4 = function () {
	    function SetWrapper() {
	        classCallCheck(this, SetWrapper);
	    }

	    createClass(SetWrapper, null, [{
	        key: 'createFromList',
	        value: function createFromList(lst) {
	            return createSetFromList$4(lst);
	        }
	    }, {
	        key: 'has',
	        value: function has(s, key) {
	            return s.has(key);
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(m, k) {
	            m.delete(k);
	        }
	    }]);
	    return SetWrapper;
	}();

	var _ArrayLogger$4 = function () {
	    function _ArrayLogger() {
	        classCallCheck(this, _ArrayLogger);

	        this.res = [];
	    }

	    createClass(_ArrayLogger, [{
	        key: 'log',
	        value: function log(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logError',
	        value: function logError(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return _ArrayLogger;
	}();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */


	var ExceptionHandler$4 = function () {
	    function ExceptionHandler(_logger) {
	        var _rethrowException = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        classCallCheck(this, ExceptionHandler);

	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }

	    createClass(ExceptionHandler, [{
	        key: 'call',
	        value: function call(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var originalException = this._findOriginalException(exception);
	            var originalStack = this._findOriginalStack(exception);
	            var context = this._findContext(exception);
	            this._logger.logGroup('EXCEPTION: ' + this._extractMessage(exception));
	            if (isPresent$4(stackTrace) && isBlank$4(originalStack)) {
	                this._logger.logError('STACKTRACE:');
	                this._logger.logError(this._longStackTrace(stackTrace));
	            }
	            if (isPresent$4(reason)) {
	                this._logger.logError('REASON: ' + reason);
	            }
	            if (isPresent$4(originalException)) {
	                this._logger.logError('ORIGINAL EXCEPTION: ' + this._extractMessage(originalException));
	            }
	            if (isPresent$4(originalStack)) {
	                this._logger.logError('ORIGINAL STACKTRACE:');
	                this._logger.logError(this._longStackTrace(originalStack));
	            }
	            if (isPresent$4(context)) {
	                this._logger.logError('ERROR CONTEXT:');
	                this._logger.logError(context);
	            }
	            this._logger.logGroupEnd();
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	            if (this._rethrowException) throw exception;
	        }
	        /** @internal */

	    }, {
	        key: '_extractMessage',
	        value: function _extractMessage(exception) {
	            return exception instanceof BaseWrappedException$4 ? exception.wrapperMessage : exception.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_longStackTrace',
	        value: function _longStackTrace(stackTrace) {
	            return isListLikeIterable$4(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_findContext',
	        value: function _findContext(exception) {
	            try {
	                if (!(exception instanceof BaseWrappedException$4)) return null;
	                return isPresent$4(exception.context) ? exception.context : this._findContext(exception.originalException);
	            } catch (e) {
	                // exception.context can throw an exception. if it happens, we ignore the context.
	                return null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalException',
	        value: function _findOriginalException(exception) {
	            if (!(exception instanceof BaseWrappedException$4)) return null;
	            var e = exception.originalException;
	            while (e instanceof BaseWrappedException$4 && isPresent$4(e.originalException)) {
	                e = e.originalException;
	            }
	            return e;
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalStack',
	        value: function _findOriginalStack(exception) {
	            if (!(exception instanceof BaseWrappedException$4)) return null;
	            var e = exception;
	            var stack = exception.originalStack;
	            while (e instanceof BaseWrappedException$4 && isPresent$4(e.originalException)) {
	                e = e.originalException;
	                if (e instanceof BaseWrappedException$4 && isPresent$4(e.originalException)) {
	                    stack = e.originalStack;
	                }
	            }
	            return stack;
	        }
	    }], [{
	        key: 'exceptionToString',
	        value: function exceptionToString(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var l = new _ArrayLogger$4();
	            var e = new ExceptionHandler(l, false);
	            e.call(exception, stackTrace, reason);
	            return l.res.join('\n');
	        }
	    }]);
	    return ExceptionHandler;
	}();

	/**
	 * @stable
	 */
	var BaseException$4 = function (_Error) {
	    inherits(BaseException, _Error);

	    function BaseException() {
	        var message = arguments.length <= 0 || arguments[0] === undefined ? '--' : arguments[0];
	        classCallCheck(this, BaseException);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseException).call(this, message));

	        _this.message = message;
	        _this.stack = new Error(message).stack;
	        return _this;
	    }

	    createClass(BaseException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return BaseException;
	}(Error);
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException$4 = function (_BaseWrappedException) {
	    inherits(WrappedException, _BaseWrappedException);

	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        classCallCheck(this, WrappedException);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(WrappedException).call(this, _wrapperMessage));

	        _this2._wrapperMessage = _wrapperMessage;
	        _this2._originalException = _originalException;
	        _this2._originalStack = _originalStack;
	        _this2._context = _context;
	        _this2._wrapperStack = new Error(_wrapperMessage).stack;
	        return _this2;
	    }

	    createClass(WrappedException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            return this._wrapperMessage;
	        }
	    }, {
	        key: 'wrapperStack',
	        get: function get() {
	            return this._wrapperStack;
	        }
	    }, {
	        key: 'originalException',
	        get: function get() {
	            return this._originalException;
	        }
	    }, {
	        key: 'originalStack',
	        get: function get() {
	            return this._originalStack;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._context;
	        }
	    }, {
	        key: 'message',
	        get: function get() {
	            return ExceptionHandler$4.exceptionToString(this);
	        }
	    }]);
	    return WrappedException;
	}(BaseWrappedException$4);

	/**
	 * An implementation of XHR that uses a template cache to avoid doing an actual
	 * XHR.
	 *
	 * The template cache needs to be built and loaded into window.$templateCache
	 * via a separate mechanism.
	 */
	var CachedXHR = function (_XHR) {
	    inherits(CachedXHR, _XHR);

	    function CachedXHR() {
	        classCallCheck(this, CachedXHR);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(CachedXHR).call(this));

	        _this._cache = global$5.$templateCache;
	        if (_this._cache == null) {
	            throw new BaseException$4('CachedXHR: Template cache was not found in $templateCache.');
	        }
	        return _this;
	    }

	    createClass(CachedXHR, [{
	        key: 'get',
	        value: function get(url) {
	            if (this._cache.hasOwnProperty(url)) {
	                return PromiseWrapper$4.resolve(this._cache[url]);
	            } else {
	                return PromiseWrapper$4.reject('CachedXHR: Did not find cached template for ' + url, null);
	            }
	        }
	    }]);
	    return CachedXHR;
	}(XHR);

	var XHRImpl = function (_XHR) {
	    inherits(XHRImpl, _XHR);

	    function XHRImpl() {
	        classCallCheck(this, XHRImpl);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(XHRImpl).apply(this, arguments));
	    }

	    createClass(XHRImpl, [{
	        key: 'get',
	        value: function get(url) {
	            var completer = PromiseWrapper$4.completer();
	            var xhr = new XMLHttpRequest();
	            xhr.open('GET', url, true);
	            xhr.responseType = 'text';
	            xhr.onload = function () {
	                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	                // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
	                var response = isPresent$4(xhr.response) ? xhr.response : xhr.responseText;
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status = xhr.status === 1223 ? 204 : xhr.status;
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status === 0) {
	                    status = response ? 200 : 0;
	                }
	                if (200 <= status && status <= 300) {
	                    completer.resolve(response);
	                } else {
	                    completer.reject('Failed to load ' + url, null);
	                }
	            };
	            xhr.onerror = function () {
	                completer.reject('Failed to load ' + url, null);
	            };
	            xhr.send();
	            return completer.promise;
	        }
	    }]);
	    return XHRImpl;
	}(XHR);

	/**
	 * @experimental
	 */
	var WORKER_APP_COMPILER_PROVIDERS = [COMPILER_PROVIDERS, {
	    provide: CompilerConfig,
	    useFactory: function useFactory(platformDirectives, platformPipes) {
	        return new CompilerConfig({ platformDirectives: platformDirectives, platformPipes: platformPipes });
	    },
	    deps: [PLATFORM_DIRECTIVES, PLATFORM_PIPES]
	}, { provide: XHR, useClass: XHRImpl }, { provide: PLATFORM_DIRECTIVES, useValue: COMMON_DIRECTIVES, multi: true }, { provide: PLATFORM_PIPES, useValue: COMMON_PIPES, multi: true }];

	// use native raf rather than the zone wrapped one
	var originalRaf = (window[window['Zone']['__symbol__']('requestAnimationFrame')] || window[window['Zone']['__symbol__']('webkitRequestAnimationFrame')]);
	// if the originalRaf from the Zone symbol is not available, we need to provide the polyfilled version
	var nativeRaf = originalRaf !== undefined ? originalRaf['bind'](window) : window.requestAnimationFrame.bind(window);
	// zone wrapped raf
	var raf = window.requestAnimationFrame.bind(window);
	var cancelRaf = window.cancelAnimationFrame.bind(window);
	var nativeTimeout = window[window['Zone']['__symbol__']('setTimeout')]['bind'](window);
	var clearNativeTimeout = window[window['Zone']['__symbol__']('clearTimeout')]['bind'](window);
	function rafFrames(framesToWait, callback) {
	    framesToWait = Math.ceil(framesToWait);
	    if (framesToWait < 2) {
	        nativeRaf(callback);
	    }
	    else {
	        nativeTimeout(function () {
	            nativeRaf(callback);
	        }, (framesToWait - 1) * 16.6667);
	    }
	}
	var CSS = {};
	(function () {
	    // transform
	    var i;
	    var keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform',
	        '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
	    for (i = 0; i < keys.length; i++) {
	        if (document.documentElement.style[keys[i]] !== undefined) {
	            CSS.transform = keys[i];
	            break;
	        }
	    }
	    // transition
	    keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
	    for (i = 0; i < keys.length; i++) {
	        if (document.documentElement.style[keys[i]] !== undefined) {
	            CSS.transition = keys[i];
	            break;
	        }
	    }
	    // The only prefix we care about is webkit for transitions.
	    var isWebkit = CSS.transition.indexOf('webkit') > -1;
	    // transition duration
	    CSS.transitionDuration = (isWebkit ? '-webkit-' : '') + 'transition-duration';
	    // transition timing function
	    CSS.transitionTimingFn = (isWebkit ? '-webkit-' : '') + 'transition-timing-function';
	    // transition delay
	    CSS.transitionDelay = (isWebkit ? '-webkit-' : '') + 'transition-delay';
	    // To be sure transitionend works everywhere, include *both* the webkit and non-webkit events
	    CSS.transitionEnd = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
	    // transform origin
	    CSS.transformOrigin = (isWebkit ? '-webkit-' : '') + 'transform-origin';
	})();
	function transitionEnd(el, callback) {
	    if (el) {
	        CSS.transitionEnd.split(' ').forEach(function (eventName) {
	            el.addEventListener(eventName, onEvent);
	        });
	        return unregister;
	    }
	    function unregister() {
	        CSS.transitionEnd.split(' ').forEach(function (eventName) {
	            el.removeEventListener(eventName, onEvent);
	        });
	    }
	    function onEvent(ev) {
	        if (el === ev.target) {
	            unregister();
	            callback(ev);
	        }
	    }
	}
	function ready(callback) {
	    var promise = null;
	    if (!callback) {
	        // a callback wasn't provided, so let's return a promise instead
	        promise = new Promise(function (resolve) { callback = resolve; });
	    }
	    if (document.readyState === 'complete' || document.readyState === 'interactive') {
	        callback();
	    }
	    else {
	        document.addEventListener('DOMContentLoaded', completed, false);
	        window.addEventListener('load', completed, false);
	    }
	    return promise;
	    function completed() {
	        document.removeEventListener('DOMContentLoaded', completed, false);
	        window.removeEventListener('load', completed, false);
	        callback();
	    }
	}
	function windowLoad(callback) {
	    var promise = null;
	    if (!callback) {
	        // a callback wasn't provided, so let's return a promise instead
	        promise = new Promise(function (resolve) { callback = resolve; });
	    }
	    if (document.readyState === 'complete') {
	        callback();
	    }
	    else {
	        window.addEventListener('load', completed, false);
	    }
	    return promise;
	    function completed() {
	        window.removeEventListener('load', completed, false);
	        callback();
	    }
	}
	function pointerCoord(ev) {
	    // get coordinates for either a mouse click
	    // or a touch depending on the given event
	    var c = { x: 0, y: 0 };
	    if (ev) {
	        var touches = ev.touches && ev.touches.length ? ev.touches : [ev];
	        var e = (ev.changedTouches && ev.changedTouches[0]) || touches[0];
	        if (e) {
	            c.x = e.clientX || e.pageX || 0;
	            c.y = e.clientY || e.pageY || 0;
	        }
	    }
	    return c;
	}
	function hasPointerMoved(threshold, startCoord, endCoord) {
	    return startCoord && endCoord &&
	        (Math.abs(startCoord.x - endCoord.x) > threshold || Math.abs(startCoord.y - endCoord.y) > threshold);
	}
	function isActive(ele) {
	    return !!(ele && (document.activeElement === ele));
	}
	function hasFocus(ele) {
	    return isActive(ele) && (ele.parentElement.querySelector(':focus') === ele);
	}
	function isTextInput(ele) {
	    return !!ele &&
	        (ele.tagName === 'TEXTAREA' ||
	            ele.contentEditable === 'true' ||
	            (ele.tagName === 'INPUT' && !(/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i).test(ele.type)));
	}
	function hasFocusedTextInput() {
	    var ele = document.activeElement;
	    if (isTextInput(ele)) {
	        return (ele.parentElement.querySelector(':focus') === ele);
	    }
	    return false;
	}
	var skipInputAttrsReg = /^(value|checked|disabled|type|class|style|id|autofocus|autocomplete|autocorrect)$/i;
	function copyInputAttributes(srcElement, destElement) {
	    // copy attributes from one element to another
	    // however, skip over a few of them as they're already
	    // handled in the angular world
	    var attrs = srcElement.attributes;
	    for (var i = 0; i < attrs.length; i++) {
	        var attr = attrs[i];
	        if (!skipInputAttrsReg.test(attr.name)) {
	            destElement.setAttribute(attr.name, attr.value);
	        }
	    }
	}
	var matchesFn;
	var matchesMethods = ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector'];
	matchesMethods.some(function (fn) {
	    if (typeof document.documentElement[fn] === 'function') {
	        matchesFn = fn;
	        return true;
	    }
	});
	function closest(ele, selector, checkSelf) {
	    if (ele && matchesFn) {
	        // traverse parents
	        ele = (checkSelf ? ele : ele.parentElement);
	        while (ele !== null) {
	            if (ele[matchesFn](selector)) {
	                return ele;
	            }
	            ele = ele.parentElement;
	        }
	    }
	    return null;
	}
	/**
	 * Get the element offsetWidth and offsetHeight. Values are cached
	 * to reduce DOM reads. Cache is cleared on a window resize.
	 */
	function getDimensions(ele, id) {
	    var dimensions = dimensionCache[id];
	    if (!dimensions) {
	        // make sure we got good values before caching
	        if (ele.offsetWidth && ele.offsetHeight) {
	            dimensions = dimensionCache[id] = {
	                width: ele.offsetWidth,
	                height: ele.offsetHeight,
	                left: ele.offsetLeft,
	                top: ele.offsetTop
	            };
	        }
	        else {
	            // do not cache bad values
	            return { width: 0, height: 0, left: 0, top: 0 };
	        }
	    }
	    return dimensions;
	}
	function clearDimensions(id) {
	    delete dimensionCache[id];
	}
	function windowDimensions() {
	    if (!dimensionCache.win) {
	        // make sure we got good values before caching
	        if (window.innerWidth && window.innerHeight) {
	            dimensionCache.win = {
	                width: window.innerWidth,
	                height: window.innerHeight
	            };
	        }
	        else {
	            // do not cache bad values
	            return { width: 0, height: 0 };
	        }
	    }
	    return dimensionCache.win;
	}
	function flushDimensionCache() {
	    dimensionCache = {};
	}
	var dimensionCache = {};


	var domUtil = Object.freeze({
	    nativeRaf: nativeRaf,
	    raf: raf,
	    cancelRaf: cancelRaf,
	    nativeTimeout: nativeTimeout,
	    clearNativeTimeout: clearNativeTimeout,
	    rafFrames: rafFrames,
	    CSS: CSS,
	    transitionEnd: transitionEnd,
	    ready: ready,
	    windowLoad: windowLoad,
	    pointerCoord: pointerCoord,
	    hasPointerMoved: hasPointerMoved,
	    isActive: isActive,
	    hasFocus: hasFocus,
	    isTextInput: isTextInput,
	    hasFocusedTextInput: hasFocusedTextInput,
	    copyInputAttributes: copyInputAttributes,
	    closest: closest,
	    getDimensions: getDimensions,
	    clearDimensions: clearDimensions,
	    windowDimensions: windowDimensions,
	    flushDimensionCache: flushDimensionCache
	});

	/**
	 * Given a min and max, restrict the given number
	 * to the range.
	 * @param min the minimum
	 * @param n the value
	 * @param max the maximum
	 */
	function clamp(min, n, max) {
	    return Math.max(min, Math.min(n, max));
	}
	/**
	 * The assign() method is used to copy the values of all enumerable own
	 * properties from one or more source objects to a target object. It will
	 * return the target object. When available, this method will use
	 * `Object.assign()` under-the-hood.
	 * @param target  The target object
	 * @param source(s)  The source object
	 */
	function assign() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i - 0] = arguments[_i];
	    }
	    if (typeof Object.assign !== 'function') {
	        // use the old-school shallow extend method
	        return _baseExtend(args[0], [].slice.call(args, 1), false);
	    }
	    // use the built in ES6 Object.assign method
	    return Object.assign.apply(null, args);
	}
	/**
	 * Do a deep extend (merge).
	 * @param dst the destination
	 * @param ... the param objects
	 */
	function merge$1(dst) {
	    var args = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        args[_i - 1] = arguments[_i];
	    }
	    return _baseExtend(dst, [].slice.call(arguments, 1), true);
	}
	function _baseExtend(dst, objs, deep) {
	    for (var i = 0, ii = objs.length; i < ii; ++i) {
	        var obj = objs[i];
	        if (!obj || !isObject$1(obj) && !isFunction$6(obj))
	            continue;
	        var keys = Object.keys(obj);
	        for (var j = 0, jj = keys.length; j < jj; j++) {
	            var key = keys[j];
	            var src = obj[key];
	            if (deep && isObject$1(src)) {
	                if (!isObject$1(dst[key]))
	                    dst[key] = isArray$6(src) ? [] : {};
	                _baseExtend(dst[key], [src], true);
	            }
	            else {
	                dst[key] = src;
	            }
	        }
	    }
	    return dst;
	}
	function debounce(fn, wait, immediate) {
	    if (immediate === void 0) { immediate = false; }
	    var timeout, args, context, timestamp, result;
	    return function () {
	        context = this;
	        args = arguments;
	        timestamp = Date.now();
	        var later = function () {
	            var last = Date.now() - timestamp;
	            if (last < wait) {
	                timeout = setTimeout(later, wait - last);
	            }
	            else {
	                timeout = null;
	                if (!immediate)
	                    result = fn.apply(context, args);
	            }
	        };
	        var callNow = immediate && !timeout;
	        if (!timeout) {
	            timeout = setTimeout(later, wait);
	        }
	        if (callNow)
	            result = fn.apply(context, args);
	        return result;
	    };
	}
	/**
	 * Apply default arguments if they don't exist in
	 * the first object.
	 * @param the destination to apply defaults to.
	 */
	function defaults$1(dest) {
	    var args = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        args[_i - 1] = arguments[_i];
	    }
	    for (var i = arguments.length - 1; i >= 1; i--) {
	        var source = arguments[i] || {};
	        for (var key in source) {
	            if (source.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {
	                dest[key] = source[key];
	            }
	        }
	    }
	    return dest;
	}
	var isString$5 = function (val) { return typeof val === 'string'; };
	var isNumber$5 = function (val) { return typeof val === 'number'; };
	var isFunction$6 = function (val) { return typeof val === 'function'; };
	var isDefined = function (val) { return typeof val !== 'undefined'; };
	var isUndefined = function (val) { return typeof val === 'undefined'; };
	var isPresent$5 = function (val) { return val !== undefined && val !== null; };
	var isBlank$5 = function (val) { return val === undefined || val === null; };
	var isObject$1 = function (val) { return typeof val === 'object'; };
	var isArray$6 = Array.isArray;
	var isTrueProperty = function (val) {
	    if (typeof val === 'string') {
	        val = val.toLowerCase().trim();
	        return (val === 'true' || val === 'on' || val === '');
	    }
	    return !!val;
	};
	var isCheckedProperty = function (a, b) {
	    if (a === undefined || a === null || a === '') {
	        return (b === undefined || b === null || b === '');
	    }
	    else if (a === true || a === 'true') {
	        return (b === true || b === 'true');
	    }
	    else if (a === false || a === 'false') {
	        return (b === false || b === 'false');
	    }
	    else if (a === 0 || a === '0') {
	        return (b === 0 || b === '0');
	    }
	    // not using strict comparison on purpose
	    /* tslint:disable */
	    return (a == b);
	    /* tslint:enable */
	};
	/**
	 * Convert a string in the format thisIsAString to a slug format this-is-a-string
	 */
	function pascalCaseToDashCase(val) {
	    if (val === void 0) { val = ''; }
	    return val.charAt(0).toLowerCase() + val.substring(1).replace(/[A-Z]/g, function (match) {
	        return '-' + match.toLowerCase();
	    });
	}
	/**
	 * Grab all query strings keys and values.
	 * @param url
	 */
	function getQuerystring(url) {
	    var queryParams = {};
	    if (url) {
	        var startIndex = url.indexOf('?');
	        if (startIndex !== -1) {
	            var queries = url.slice(startIndex + 1).split('&');
	            for (var i = 0; i < queries.length; i++) {
	                if (queries[i].indexOf('=') > 0) {
	                    var split = queries[i].split('=');
	                    if (split.length > 1) {
	                        queryParams[split[0].toLowerCase()] = split[1].split('#')[0];
	                    }
	                }
	            }
	        }
	    }
	    return queryParams;
	}

	/**
	 * @name Platform
	 * @description
	 * The Platform service can be used to get information about your current device.
	 * You can get all of the platforms associated with the device using the [platforms](#platforms)
	 * method, including whether the app is being viewed from a tablet, if it's
	 * on a mobile device or browser, and the exact platform (iOS, Android, etc).
	 * You can also get the orientation of the device, if it uses right-to-left
	 * language direction, and much much more. With this information you can completely
	 * customize your app to fit any device.
	 *
	 * @usage
	 * ```ts
	 * import {Platform} from 'ionic-angular';
	 *
	 * @Component({...})
	 * export MyPage {
	 *   constructor(platform: Platform) {
	 *     this.platform = platform;
	 *   }
	 * }
	 * ```
	 * @demo /docs/v2/demos/platform/
	 */
	var Platform = (function () {
	    function Platform(platforms) {
	        var _this = this;
	        if (platforms === void 0) { platforms = []; }
	        this._versions = {};
	        this._onResizes = [];
	        this._bbActions = [];
	        // Events meant to be triggered by the engine
	        // **********************************************
	        /**
	         * @private
	         */
	        this.backButton = new EventEmitter();
	        /**
	         * The pause event emits when the native platform puts the application
	         * into the background, typically when the user switches to a different
	         * application. This event would emit when a Cordova app is put into
	         * the background, however, it would not fire on a standard web browser.
	         */
	        this.pause = new EventEmitter();
	        /**
	         * The resume event emits when the native platform pulls the application
	         * out from the background. This event would emit when a Cordova app comes
	         * out from the background, however, it would not fire on a standard web browser.
	         */
	        this.resume = new EventEmitter();
	        this._platforms = platforms;
	        this._readyPromise = new Promise(function (res) { _this._readyResolve = res; });
	        this.backButton.subscribe(function () {
	            // the hardware back button event has been fired
	            console.debug('hardware back button');
	            // decide which backbutton action should run
	            _this.runBackButtonAction();
	        });
	    }
	    /**
	     * @private
	     */
	    Platform.prototype.setZone = function (zone) {
	        this.zone = zone;
	    };
	    // Methods
	    // **********************************************
	    /**
	     * @returns {boolean} returns true/false based on platform.
	     * @description
	     * Depending on the platform the user is on, `is(platformName)` will
	     * return `true` or `false`. Note that the same app can return `true`
	     * for more than one platform name. For example, an app running from
	     * an iPad would return `true` for the platform names: `mobile`,
	     * `ios`, `ipad`, and `tablet`. Additionally, if the app was running
	     * from Cordova then `cordova` would be true, and if it was running
	     * from a web browser on the iPad then `mobileweb` would be `true`.
	     *
	     * ```
	     * import {Platform} from 'ionic-angular';
	     *
	     * @Component({...})
	     * export MyPage {
	     *   constructor(platform: Platform) {
	     *     this.platform = platform;
	     *
	     *     if (this.platform.is('ios')) {
	     *       // This will only print when on iOS
	     *       console.log("I'm an iOS device!");
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * | Platform Name   | Description                        |
	     * |-----------------|------------------------------------|
	     * | android         | on a device running Android.       |
	     * | cordova         | on a device running Cordova.       |
	     * | core            | on a desktop device.               |
	     * | ios             | on a device running iOS.           |
	     * | ipad            | on an iPad device.                 |
	     * | iphone          | on an iPhone device.               |
	     * | mobile          | on a mobile device.                |
	     * | mobileweb       | in a browser on a mobile device.   |
	     * | phablet         | on a phablet device.               |
	     * | tablet          | on a tablet device.                |
	     * | windows         | on a device running Windows.       |
	     *
	     * @param {string} platformName
	     */
	    Platform.prototype.is = function (platformName) {
	        return (this._platforms.indexOf(platformName) > -1);
	    };
	    /**
	     * @returns {array} the array of platforms
	     * @description
	     * Depending on what device you are on, `platforms` can return multiple values.
	     * Each possible value is a hierarchy of platforms. For example, on an iPhone,
	     * it would return `mobile`, `ios`, and `iphone`.
	     *
	     * ```
	     * import {Platform} from 'ionic-angular';
	     *
	     * @Component({...})
	     * export MyPage {
	     *   constructor(platform: Platform) {
	     *     this.platform = platform;
	     *
	     *     // This will print an array of the current platforms
	     *     console.log(this.platform.platforms());
	     *   }
	     * }
	     * ```
	     */
	    Platform.prototype.platforms = function () {
	        // get the array of active platforms, which also knows the hierarchy,
	        // with the last one the most important
	        return this._platforms;
	    };
	    /**
	     * Returns an object containing version information about all of the platforms.
	     *
	     * ```
	     * import {Platform} from 'ionic-angular';
	     *
	     * @Component({...})
	     * export MyPage {
	     *   constructor(platform: Platform) {
	     *     this.platform = platform;
	     *
	     *     // This will print an object containing
	     *     // all of the platforms and their versions
	     *     console.log(platform.versions());
	     *   }
	     * }
	     * ```
	     *
	     * @returns {object} An object containing all of the platforms and their versions.
	     */
	    Platform.prototype.versions = function () {
	        // get all the platforms that have a valid parsed version
	        return this._versions;
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.version = function () {
	        for (var platformName in this._versions) {
	            if (this._versions[platformName]) {
	                return this._versions[platformName];
	            }
	        }
	        return {};
	    };
	    /**
	     * Returns a promise when the platform is ready and native functionality
	     * can be called. If the app is running from within a web browser, then
	     * the promise will resolve when the DOM is ready. When the app is running
	     * from an application engine such as Cordova, then the promise will
	     * resolve when Cordova triggers the `deviceready` event.
	     *
	     * The resolved value is the `readySource`, which states which platform
	     * ready was used. For example, when Cordova is ready, the resolved ready
	     * source is `cordova`. The default ready source value will be `dom`. The
	     * `readySource` is useful if different logic should run depending on the
	     * platform the app is running from. For example, only Cordova can execute
	     * the status bar plugin, so the web should not run status bar plugin logic.
	     *
	     * ```
	     * import {Component} from '@angular/core';
	     * import {Platform} from 'ionic-angular';
	     *
	     * @Component({...})
	     * export MyApp {
	     *   constructor(platform: Platform) {
	     *     platform.ready().then((readySource) => {
	     *       console.log('Platform ready from', readySource);
	     *       // Platform now ready, execute any required native code
	     *     });
	     *   }
	     * }
	     * ```
	     * @returns {promise}
	     */
	    Platform.prototype.ready = function () {
	        return this._readyPromise;
	    };
	    /**
	     * @private
	     * This should be triggered by the engine when the platform is
	     * ready. If there was no custom prepareReady method from the engine,
	     * such as Cordova or Electron, then it uses the default DOM ready.
	     */
	    Platform.prototype.triggerReady = function (readySource) {
	        var _this = this;
	        this.zone.run(function () {
	            _this._readyResolve(readySource);
	        });
	    };
	    /**
	     * @private
	     * This is the default prepareReady if it's not replaced by an engine,
	     * such as Cordova or Electron. If there was no custom prepareReady
	     * method from an engine then it uses the method below, which triggers
	     * the platform ready on the DOM ready event, and the default resolved
	     * value is `dom`.
	     */
	    Platform.prototype.prepareReady = function () {
	        var _this = this;
	        ready(function () {
	            _this.triggerReady('dom');
	        });
	    };
	    /**
	     * Set the app's language direction, which will update the `dir` attribute
	     * on the app's root `<html>` element. We recommend the app's `index.html`
	     * file already has the correct `dir` attribute value set, such as
	     * `<html dir="ltr">` or `<html dir="rtl">`. This method is useful if the
	     * direction needs to be dynamically changed per user/session.
	     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
	     * @param {string} dir  Examples: `rtl`, `ltr`
	     */
	    Platform.prototype.setDir = function (dir, updateDocument) {
	        this._dir = (dir || '').toLowerCase();
	        if (updateDocument !== false) {
	            document.documentElement.setAttribute('dir', dir);
	        }
	    };
	    /**
	     * Returns app's language direction.
	     * We recommend the app's `index.html` file already has the correct `dir`
	     * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
	     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
	     * @returns {string}
	     */
	    Platform.prototype.dir = function () {
	        return this._dir;
	    };
	    /**
	     * Returns if this app is using right-to-left language direction or not.
	     * We recommend the app's `index.html` file already has the correct `dir`
	     * attribute value set, such as `<html dir="ltr">` or `<html dir="rtl">`.
	     * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)
	     * @returns {boolean}
	     */
	    Platform.prototype.isRTL = function () {
	        return (this._dir === 'rtl');
	    };
	    /**
	     * Set the app's language and optionally the country code, which will update
	     * the `lang` attribute on the app's root `<html>` element.
	     * We recommend the app's `index.html` file already has the correct `lang`
	     * attribute value set, such as `<html lang="en">`. This method is useful if
	     * the language needs to be dynamically changed per user/session.
	     * [W3C: Declaring language in HTML](http://www.w3.org/International/questions/qa-html-language-declarations)
	     * @param {string} language  Examples: `en-US`, `en-GB`, `ar`, `de`, `zh`, `es-MX`
	     */
	    Platform.prototype.setLang = function (language, updateDocument) {
	        this._lang = language;
	        if (updateDocument !== false) {
	            document.documentElement.setAttribute('lang', language);
	        }
	    };
	    /**
	     * Returns app's language and optional country code.
	     * We recommend the app's `index.html` file already has the correct `lang`
	     * attribute value set, such as `<html lang="en">`.
	     * [W3C: Declaring language in HTML](http://www.w3.org/International/questions/qa-html-language-declarations)
	     * @returns {string}
	     */
	    Platform.prototype.lang = function () {
	        return this._lang;
	    };
	    // Methods meant to be overridden by the engine
	    // **********************************************
	    // Provided NOOP methods so they do not error when
	    // called by engines (the browser)that do not provide them
	    /**
	     * @private
	     */
	    Platform.prototype.exitApp = function () { };
	    /**
	     * The back button event is triggered when the user presses the native
	     * platform's back button, also referred to as the "hardware" back button.
	     * This event is only used within Cordova apps running on Android and
	     * Windows platforms. This event is not fired on iOS since iOS doesn't come
	     * with a hardware back button in the same sense an Android or Windows device
	     * does.
	     *
	     * Registering a hardware back button action and setting a priority allows
	     * apps to control which action should be called when the hardware back
	     * button is pressed. This method decides which of the registered back button
	     * actions has the highest priority and should be called.
	     *
	     * @param {Function} callback Called when the back button is pressed,
	     * if this registered action has the highest priority.
	     * @param {number} priority Set the priority for this action. Only the highest priority will execute. Defaults to `0`.
	     * @returns {Function} A function that, when called, will unregister
	     * the its back button action.
	     */
	    Platform.prototype.registerBackButtonAction = function (fn, priority) {
	        var _this = this;
	        if (priority === void 0) { priority = 0; }
	        var action = { fn: fn, priority: priority };
	        this._bbActions.push(action);
	        // return a function to unregister this back button action
	        return function () {
	            var index = _this._bbActions.indexOf(action);
	            if (index > -1) {
	                _this._bbActions.splice(index, 1);
	            }
	        };
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.runBackButtonAction = function () {
	        // decide which one back button action should run
	        var winner = null;
	        this._bbActions.forEach(function (action) {
	            if (!winner || action.priority >= winner.priority) {
	                winner = action;
	            }
	        });
	        // run the winning action if there is one
	        winner && winner.fn && winner.fn();
	    };
	    // Getter/Setter Methods
	    // **********************************************
	    /**
	     * @private
	     */
	    Platform.prototype.setUrl = function (url) {
	        this._url = url;
	        this._qs = getQuerystring(url);
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.url = function () {
	        return this._url;
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.query = function (key) {
	        return (this._qs || {})[key];
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.setUserAgent = function (userAgent) {
	        this._ua = userAgent;
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.userAgent = function () {
	        return this._ua || '';
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.setNavigatorPlatform = function (navigatorPlatform) {
	        this._bPlt = navigatorPlatform;
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.navigatorPlatform = function () {
	        return this._bPlt || '';
	    };
	    /**
	     * Gets the width of the platform's viewport using `window.innerWidth`.
	     * Using this method is preferred since the dimension is a cached value,
	     * which reduces the chance of multiple and expensive DOM reads.
	     */
	    Platform.prototype.width = function () {
	        return windowDimensions().width;
	    };
	    /**
	     * Gets the height of the platform's viewport using `window.innerHeight`.
	     * Using this method is preferred since the dimension is a cached value,
	     * which reduces the chance of multiple and expensive DOM reads.
	     */
	    Platform.prototype.height = function () {
	        return windowDimensions().height;
	    };
	    /**
	     * Returns `true` if the app is in portait mode.
	     */
	    Platform.prototype.isPortrait = function () {
	        return this.width() < this.height();
	    };
	    /**
	     * Returns `true` if the app is in landscape mode.
	     */
	    Platform.prototype.isLandscape = function () {
	        return !this.isPortrait();
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.windowResize = function () {
	        var self = this;
	        clearTimeout(self._resizeTm);
	        self._resizeTm = setTimeout(function () {
	            flushDimensionCache();
	            for (var i = 0; i < self._onResizes.length; i++) {
	                try {
	                    self._onResizes[i]();
	                }
	                catch (e) {
	                    console.error(e);
	                }
	            }
	        }, 200);
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.onResize = function (cb) {
	        var self = this;
	        self._onResizes.push(cb);
	        return function () {
	            var index = self._onResizes.indexOf(cb);
	            if (index > -1) {
	                self._onResizes.splice(index, 1);
	            }
	        };
	    };
	    // Platform Registry
	    // **********************************************
	    /**
	     * @private
	     */
	    Platform.register = function (platformConfig) {
	        platformRegistry[platformConfig.name] = platformConfig;
	    };
	    /**
	     * @private
	     */
	    Platform.registry = function () {
	        return platformRegistry;
	    };
	    /**
	     * @private
	     */
	    Platform.get = function (platformName) {
	        return platformRegistry[platformName] || {};
	    };
	    /**
	     * @private
	     */
	    Platform.setDefault = function (platformName) {
	        platformDefault = platformName;
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.testQuery = function (queryValue, queryTestValue) {
	        var valueSplit = queryValue.toLowerCase().split(';');
	        return valueSplit.indexOf(queryTestValue) > -1;
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.testNavigatorPlatform = function (navigatorPlatformExpression) {
	        var rgx = new RegExp(navigatorPlatformExpression, 'i');
	        return rgx.test(this._bPlt);
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.matchUserAgentVersion = function (userAgentExpression) {
	        if (this._ua && userAgentExpression) {
	            var val = this._ua.match(userAgentExpression);
	            if (val) {
	                return {
	                    major: val[1],
	                    minor: val[2]
	                };
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.isPlatformMatch = function (queryStringName, userAgentAtLeastHas, userAgentMustNotHave) {
	        if (userAgentMustNotHave === void 0) { userAgentMustNotHave = []; }
	        var queryValue = this.query('ionicplatform');
	        if (queryValue) {
	            return this.testQuery(queryValue, queryStringName);
	        }
	        userAgentAtLeastHas = userAgentAtLeastHas || [queryStringName];
	        var userAgent = this._ua.toLowerCase();
	        for (var i = 0; i < userAgentAtLeastHas.length; i++) {
	            if (userAgent.indexOf(userAgentAtLeastHas[i]) > -1) {
	                for (var j = 0; j < userAgentMustNotHave.length; j++) {
	                    if (userAgent.indexOf(userAgentMustNotHave[j]) > -1) {
	                        return false;
	                    }
	                }
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.load = function () {
	        var rootPlatformNode;
	        var enginePlatformNode;
	        var self = this;
	        // figure out the most specific platform and active engine
	        var tmpPlatform;
	        for (var platformName in platformRegistry) {
	            tmpPlatform = this.matchPlatform(platformName);
	            if (tmpPlatform) {
	                // we found a platform match!
	                // check if its more specific than the one we already have
	                if (tmpPlatform.isEngine) {
	                    // because it matched then this should be the active engine
	                    // you cannot have more than one active engine
	                    enginePlatformNode = tmpPlatform;
	                }
	                else if (!rootPlatformNode || tmpPlatform.depth > rootPlatformNode.depth) {
	                    // only find the root node for platforms that are not engines
	                    // set this node as the root since we either don't already
	                    // have one, or this one is more specific that the current one
	                    rootPlatformNode = tmpPlatform;
	                }
	            }
	        }
	        if (!rootPlatformNode) {
	            rootPlatformNode = new PlatformNode(platformDefault);
	        }
	        // build a Platform instance filled with the
	        // hierarchy of active platforms and settings
	        if (rootPlatformNode) {
	            // check if we found an engine node (cordova/node-webkit/etc)
	            if (enginePlatformNode) {
	                // add the engine to the first in the platform hierarchy
	                // the original rootPlatformNode now becomes a child
	                // of the engineNode, which is not the new root
	                enginePlatformNode.child = rootPlatformNode;
	                rootPlatformNode.parent = enginePlatformNode;
	                rootPlatformNode = enginePlatformNode;
	            }
	            var platformNode = rootPlatformNode;
	            while (platformNode) {
	                insertSuperset(platformNode);
	                platformNode = platformNode.child;
	            }
	            // make sure the root noot is actually the root
	            // incase a node was inserted before the root
	            platformNode = rootPlatformNode.parent;
	            while (platformNode) {
	                rootPlatformNode = platformNode;
	                platformNode = platformNode.parent;
	            }
	            platformNode = rootPlatformNode;
	            while (platformNode) {
	                platformNode.initialize(this);
	                // set the array of active platforms with
	                // the last one in the array the most important
	                this._platforms.push(platformNode.name);
	                // get the platforms version if a version parser was provided
	                this._versions[platformNode.name] = platformNode.version(this);
	                // go to the next platform child
	                platformNode = platformNode.child;
	            }
	        }
	        if (this._platforms.indexOf('mobile') > -1 && this._platforms.indexOf('cordova') === -1) {
	            this._platforms.push('mobileweb');
	        }
	    };
	    /**
	     * @private
	     */
	    Platform.prototype.matchPlatform = function (platformName) {
	        // build a PlatformNode and assign config data to it
	        // use it's getRoot method to build up its hierarchy
	        // depending on which platforms match
	        var platformNode = new PlatformNode(platformName);
	        var rootNode = platformNode.getRoot(this);
	        if (rootNode) {
	            rootNode.depth = 0;
	            var childPlatform = rootNode.child;
	            while (childPlatform) {
	                rootNode.depth++;
	                childPlatform = childPlatform.child;
	            }
	        }
	        return rootNode;
	    };
	    return Platform;
	}());
	function insertSuperset(platformNode) {
	    var supersetPlaformName = platformNode.superset();
	    if (supersetPlaformName) {
	        // add a platform in between two exist platforms
	        // so we can build the correct hierarchy of active platforms
	        var supersetPlatform = new PlatformNode(supersetPlaformName);
	        supersetPlatform.parent = platformNode.parent;
	        supersetPlatform.child = platformNode;
	        if (supersetPlatform.parent) {
	            supersetPlatform.parent.child = supersetPlatform;
	        }
	        platformNode.parent = supersetPlatform;
	    }
	}
	/**
	 * @private
	 */
	var PlatformNode = (function () {
	    function PlatformNode(platformName) {
	        this.c = Platform.get(platformName);
	        this.name = platformName;
	        this.isEngine = this.c.isEngine;
	    }
	    PlatformNode.prototype.settings = function () {
	        return this.c.settings || {};
	    };
	    PlatformNode.prototype.superset = function () {
	        return this.c.superset;
	    };
	    PlatformNode.prototype.isMatch = function (p) {
	        return this.c.isMatch && this.c.isMatch(p) || false;
	    };
	    PlatformNode.prototype.initialize = function (platform) {
	        this.c.initialize && this.c.initialize(platform);
	    };
	    PlatformNode.prototype.version = function (p) {
	        if (this.c.versionParser) {
	            var v = this.c.versionParser(p);
	            if (v) {
	                var str = v.major + '.' + v.minor;
	                return {
	                    str: str,
	                    num: parseFloat(str),
	                    major: parseInt(v.major, 10),
	                    minor: parseInt(v.minor, 10)
	                };
	            }
	        }
	    };
	    PlatformNode.prototype.getRoot = function (p) {
	        if (this.isMatch(p)) {
	            var parents = this.getSubsetParents(this.name);
	            if (!parents.length) {
	                return this;
	            }
	            var platform = null;
	            var rootPlatform = null;
	            for (var i = 0; i < parents.length; i++) {
	                platform = new PlatformNode(parents[i]);
	                platform.child = this;
	                rootPlatform = platform.getRoot(p);
	                if (rootPlatform) {
	                    this.parent = platform;
	                    return rootPlatform;
	                }
	            }
	        }
	        return null;
	    };
	    PlatformNode.prototype.getSubsetParents = function (subsetPlatformName) {
	        var platformRegistry = Platform.registry();
	        var parentPlatformNames = [];
	        var platform = null;
	        for (var platformName in platformRegistry) {
	            platform = platformRegistry[platformName];
	            if (platform.subsets && platform.subsets.indexOf(subsetPlatformName) > -1) {
	                parentPlatformNames.push(platformName);
	            }
	        }
	        return parentPlatformNames;
	    };
	    return PlatformNode;
	}());
	var platformRegistry = {};
	var platformDefault = null;

	/**
	 * @name Config
	 * @demo /docs/v2/demos/config/
	 * @description
	 * The Config lets you configure your entire app or specific platforms.
	 * You can set the tab placement, icon mode, animations, and more here.
	 *
	 * ```ts
	 * import {ionicBootstrap} from 'ionic-angular';
	 *
	 * ionicBootstrap(AppRoot, customProviders, {
	 *   backButtonText: 'Go Back',
	 *   iconMode: 'ios',
	 *   modalEnter: 'modal-slide-in',
	 *   modalLeave: 'modal-slide-out',
	 *   tabbarPlacement: 'bottom',
	 *   pageTransition: 'ios',
	 * });
	 * ```
	 *
	 *
	 * Config can be overwritten at multiple levels allowing for more granular configuration.
	 * Below is an example where an app can override any setting we want based on a platform.
	 *
	 * ```ts
	 * import {ionicBootstrap} from 'ionic-angular';
	 *
	 * ionicBootstrap(AppRoot, customProviders, {
	 *   tabbarPlacement: 'bottom',
	 *   platforms: {
	 *   ios: {
	 *     tabbarPlacement: 'top',
	 *   }
	 * });
	 * ```
	 *
	 * We could also configure these values at a component level. Take `tabbarPlacement`,
	 * we can configure this as a property on our `ion-tabs`.
	 *
	 * ```html
	 * <ion-tabs tabbarPlacement="top">
	 *   <ion-tab tabTitle="Dash" tabIcon="pulse" [root]="tabRoot"></ion-tab>
	 * </ion-tabs>
	 * ```
	 *
	 * The last way we could configure is through URL query strings. This is useful for testing
	 * while in the browser. Simply add `?ionic<PROPERTYNAME>=<value>` to the url.
	 *
	 * ```bash
	 * http://localhost:8100/?ionicTabbarPlacement=bottom
	 * ```
	 *
	 * Any value can be added to config, and looked up at a later in any component.
	 *
	 * ```js
	 * config.set('ios', 'favoriteColor', 'green');
	 *
	 * // from any page in your app:
	 * config.get('favoriteColor'); // 'green' when iOS
	 * ```
	 *
	 *
	 * A config value can come from anywhere and be anything, but there are default
	 * values for each mode. The [theming](../../../theming/platform-specific-styles/)
	 * documentation has a chart of the default mode configuration. The following
	 * chart displays each property with a description of what it controls.
	 *
	 *
	 * | Config Property          | Type                | Details                                                                                                                                          |
	 * |--------------------------|---------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
	 * | `activator`              | `string`            | Used for buttons, changes the effect of pressing on a button. Available options: `"ripple"`, `"highlight"`.                                      |
	 * | `actionSheetEnter`       | `string`            | The name of the transition to use while an action sheet is presented.                                                                            |
	 * | `actionSheetLeave`       | `string`            | The name of the transition to use while an action sheet is dismissed.                                                                            |
	 * | `alertEnter`             | `string`            | The name of the transition to use while an alert is presented.                                                                                   |
	 * | `alertLeave`             | `string`            | The name of the transition to use while an alert is dismissed.                                                                                   |
	 * | `backButtonText`         | `string`            | The text to display by the back button icon in the navbar.                                                                                       |
	 * | `backButtonIcon`         | `string`            | The icon to use as the back button icon.                                                                                                         |
	 * | `iconMode`               | `string`            | The mode to use for all icons throughout the application. Available options: `"ios"`, `"md"`                                                     |
	 * | `loadingEnter`           | `string`            | The name of the transition to use while a loading indicator is presented.                                                                        |
	 * | `loadingLeave`           | `string`            | The name of the transition to use while a loading indicator is dismissed.                                                                        |
	 * | `menuType`               | `string`            | Type of menu to display. Available options: `"overlay"`, `"reveal"`, `"push"`.                                                                   |
	 * | `modalEnter`             | `string`            | The name of the transition to use while a modal is presented.                                                                                    |
	 * | `modalLeave`             | `string`            | The name of the transition to use while a modal is dismiss.                                                                                      |
	 * | `pageTransition`         | `string`            | The name of the transition to use while changing pages.                                                                                          |
	 * | `pageTransitionDelay`    | `number`            | The delay in milliseconds before the transition starts while changing pages.                                                                     |
	 * | `pickerEnter`            | `string`            | The name of the transition to use while a picker is presented.                                                                                   |
	 * | `pickerLeave`            | `string`            | The name of the transition to use while a picker is dismissed.                                                                                   |
	 * | `popoverEnter`           | `string`            | The name of the transition to use while a popover is presented.                                                                                  |
	 * | `popoverLeave`           | `string`            | The name of the transition to use while a popover is dismissed.                                                                                  |
	 * | `prodMode`               | `boolean`           | Disable development mode, which turns off assertions and other checks within the framework. One important assertion this disables verifies that a change detection pass does not result in additional changes to any bindings (also known as unidirectional data flow).
	 * | `spinner`                | `string`            | The default spinner to use when a name is not defined.                                                                                           |
	 * | `tabbarHighlight`        | `boolean`           | Whether to show a highlight line under the tab when it is selected.                                                                              |
	 * | `tabbarLayout`           | `string`            | The layout to use for all tabs. Available options: `"icon-top"`, `"icon-left"`, `"icon-right"`, `"icon-bottom"`, `"icon-hide"`, `"title-hide"`.  |
	 * | `tabbarPlacement`        | `string`            | The position of the tabs. Available options: `"top"`, `"bottom"`                                                                                 |
	 * | `tabSubPages`            | `boolean`           | Whether to hide the tabs on child pages or not. If `true` it will not show the tabs on child pages.                                              |
	 * | `toastEnter`             | `string`            | The name of the transition to use while a toast is presented.                                                                                    |
	 * | `toastLeave`             | `string`            | The name of the transition to use while a toast is dismissed.                                                                                    |
	 *
	**/
	var Config = (function () {
	    function Config(config) {
	        this._c = {};
	        this._s = {};
	        this._s = config && isObject$1(config) && !isArray$6(config) ? config : {};
	    }
	    /**
	     * @name get
	     * @description
	     * Returns a single config value, given a key.
	     *
	     * @param {string} [key] - the key for the config value
	     * @param {any} [fallbackValue] - a fallback value to use when the config
	     * value was not found, or is config value is `null`. Fallback value
	     *  defaults to `null`.
	     */
	    Config.prototype.get = function (key, fallbackValue) {
	        if (fallbackValue === void 0) { fallbackValue = null; }
	        if (!isDefined(this._c[key])) {
	            if (!isDefined(key)) {
	                throw 'config key is not defined';
	            }
	            // if the value was already set this will all be skipped
	            // if there was no user config then it'll check each of
	            // the user config's platforms, which already contains
	            // settings from default platform configs
	            var userPlatformValue = undefined;
	            var userDefaultValue = this._s[key];
	            var userPlatformModeValue = undefined;
	            var userDefaultModeValue = undefined;
	            var platformValue = undefined;
	            var platformModeValue = undefined;
	            var configObj = null;
	            if (this.platform) {
	                var queryStringValue = this.platform.query('ionic' + key.toLowerCase());
	                if (isDefined(queryStringValue)) {
	                    return this._c[key] = (queryStringValue === 'true' ? true : queryStringValue === 'false' ? false : queryStringValue);
	                }
	                // check the platform settings object for this value
	                // loop though each of the active platforms
	                // array of active platforms, which also knows the hierarchy,
	                // with the last one the most important
	                var activePlatformKeys = this.platform.platforms();
	                // loop through all of the active platforms we're on
	                for (var i = 0, l = activePlatformKeys.length; i < l; i++) {
	                    // get user defined platform values
	                    if (this._s.platforms) {
	                        configObj = this._s.platforms[activePlatformKeys[i]];
	                        if (configObj) {
	                            if (isDefined(configObj[key])) {
	                                userPlatformValue = configObj[key];
	                            }
	                            configObj = Config.getModeConfig(configObj.mode);
	                            if (configObj && isDefined(configObj[key])) {
	                                userPlatformModeValue = configObj[key];
	                            }
	                        }
	                    }
	                    // get default platform's setting
	                    configObj = Platform.get(activePlatformKeys[i]);
	                    if (configObj && configObj.settings) {
	                        if (isDefined(configObj.settings[key])) {
	                            // found a setting for this platform
	                            platformValue = configObj.settings[key];
	                        }
	                        configObj = Config.getModeConfig(configObj.settings.mode);
	                        if (configObj && isDefined(configObj[key])) {
	                            // found setting for this platform's mode
	                            platformModeValue = configObj[key];
	                        }
	                    }
	                }
	            }
	            configObj = Config.getModeConfig(this._s.mode);
	            if (configObj && isDefined(configObj[key])) {
	                userDefaultModeValue = configObj[key];
	            }
	            // cache the value
	            this._c[key] = isDefined(userPlatformValue) ? userPlatformValue :
	                isDefined(userDefaultValue) ? userDefaultValue :
	                    isDefined(userPlatformModeValue) ? userPlatformModeValue :
	                        isDefined(userDefaultModeValue) ? userDefaultModeValue :
	                            isDefined(platformValue) ? platformValue :
	                                isDefined(platformModeValue) ? platformModeValue :
	                                    null;
	        }
	        // return key's value
	        // either it came directly from the user config
	        // or it was from the users platform configs
	        // or it was from the default platform configs
	        // in that order
	        var rtnVal;
	        if (isFunction$6(this._c[key])) {
	            rtnVal = this._c[key](this.platform);
	        }
	        else {
	            rtnVal = this._c[key];
	        }
	        return (rtnVal !== null ? rtnVal : fallbackValue);
	    };
	    /**
	     * @name getBoolean
	     * @description
	     * Same as `get()`, however always returns a boolean value. If the
	     * value from `get()` is `null`, then it'll return the `fallbackValue`
	     * which defaults to `false`. Otherwise, `getBoolean()` will return
	     * if the config value is truthy or not. It also returns `true` if
	     * the config value was the string value `"true"`.
	     * @param {string} [key] - the key for the config value
	     * @param {boolean} [fallbackValue] - a fallback value to use when the config
	     * value was `null`. Fallback value defaults to `false`.
	     */
	    Config.prototype.getBoolean = function (key, fallbackValue) {
	        if (fallbackValue === void 0) { fallbackValue = false; }
	        var val = this.get(key);
	        if (val === null) {
	            return fallbackValue;
	        }
	        if (typeof val === 'string') {
	            return val === 'true';
	        }
	        return !!val;
	    };
	    /**
	     * @name getNumber
	     * @description
	     * Same as `get()`, however always returns a number value. Uses `parseFloat()`
	     * on the value received from `get()`. If the result from the parse is `NaN`,
	     * then it will return the value passed to `fallbackValue`. If no fallback
	     * value was provided then it'll default to returning `NaN` when the result
	     * is not a valid number.
	     * @param {string} [key] - the key for the config value
	     * @param {number} [fallbackValue] - a fallback value to use when the config
	     * value turned out to be `NaN`. Fallback value defaults to `NaN`.
	     */
	    Config.prototype.getNumber = function (key, fallbackValue) {
	        if (fallbackValue === void 0) { fallbackValue = NaN; }
	        var val = parseFloat(this.get(key));
	        return isNaN(val) ? fallbackValue : val;
	    };
	    /**
	     * @name set
	     * @description
	     * Sets a single config value.
	     *
	     * @param {string} [platform] - The platform (either 'ios' or 'android') that the config value should apply to. Leaving this blank will apply the config value to all platforms.
	     * @param {string} [key] - The key used to look up the value at a later point in time.
	     * @param {string} [value] - The config value being stored.
	     */
	    Config.prototype.set = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var arg0 = args[0];
	        var arg1 = args[1];
	        switch (args.length) {
	            case 2:
	                // set('key', 'value') = set key/value pair
	                // arg1 = value
	                this._s[arg0] = arg1;
	                delete this._c[arg0]; // clear cache
	                break;
	            case 3:
	                // setting('ios', 'key', 'value') = set key/value pair for platform
	                // arg0 = platform
	                // arg1 = key
	                // arg2 = value
	                this._s.platforms = this._s.platforms || {};
	                this._s.platforms[arg0] = this._s.platforms[arg0] || {};
	                this._s.platforms[arg0][arg1] = args[2];
	                delete this._c[arg1]; // clear cache
	                break;
	        }
	        return this;
	    };
	    /**
	     * @private
	     * @name settings()
	     * @description
	     */
	    Config.prototype.settings = function (arg0, arg1) {
	        switch (arguments.length) {
	            case 0:
	                return this._s;
	            case 1:
	                // settings({...})
	                this._s = arg0;
	                this._c = {}; // clear cache
	                break;
	            case 2:
	                // settings('ios', {...})
	                this._s.platforms = this._s.platforms || {};
	                this._s.platforms[arg0] = arg1;
	                this._c = {}; // clear cache
	                break;
	        }
	        return this;
	    };
	    /**
	     * @private
	     */
	    Config.prototype.setPlatform = function (platform) {
	        this.platform = platform;
	    };
	    /**
	     * @private
	     */
	    Config.setModeConfig = function (mode, config) {
	        modeConfigs[mode] = config;
	    };
	    /**
	     * @private
	     */
	    Config.getModeConfig = function (mode) {
	        return modeConfigs[mode] || null;
	    };
	    return Config;
	}());
	var modeConfigs = {};

	var DEFAULT_EXPIRE = 330;
	var ClickBlock = (function () {
	    function ClickBlock(app, config, elementRef, renderer) {
	        this.elementRef = elementRef;
	        this.renderer = renderer;
	        this._showing = false;
	        app.clickBlock = this;
	        this.isEnabled = config.getBoolean('clickBlock', true);
	    }
	    ClickBlock.prototype.activate = function (shouldShow, expire) {
	        if (this.isEnabled) {
	            clearNativeTimeout(this._tmrId);
	            if (shouldShow) {
	                this._tmrId = nativeTimeout(this.activate.bind(this, false), expire || DEFAULT_EXPIRE);
	            }
	            if (this._showing !== shouldShow) {
	                this.renderer.setElementClass(this.elementRef.nativeElement, 'click-block-active', shouldShow);
	                this._showing = shouldShow;
	            }
	        }
	    };
	    /** @nocollapse */
	    ClickBlock.decorators = [
	        { type: Directive, args: [{
	                    selector: 'click-block'
	                },] },
	    ];
	    /** @nocollapse */
	    ClickBlock.ctorParameters = [
	        { type: App, decorators: [{ type: Inject, args: [forwardRef(function () { return App; }),] },] },
	        { type: Config, },
	        { type: ElementRef, },
	        { type: Renderer, },
	    ];
	    return ClickBlock;
	}());

	var Form = (function () {
	    function Form() {
	        this._focused = null;
	        this._ids = -1;
	        this._inputs = [];
	    }
	    Form.prototype.register = function (input) {
	        this._inputs.push(input);
	    };
	    Form.prototype.deregister = function (input) {
	        var index = this._inputs.indexOf(input);
	        if (index > -1) {
	            this._inputs.splice(index, 1);
	        }
	        if (input === this._focused) {
	            this._focused = null;
	        }
	    };
	    Form.prototype.focusOut = function () {
	        var activeElement = document.activeElement;
	        activeElement && activeElement.blur && activeElement.blur();
	    };
	    Form.prototype.setAsFocused = function (input) {
	        this._focused = input;
	    };
	    /**
	     * Focuses the next input element, if it exists.
	     */
	    Form.prototype.tabFocus = function (currentInput) {
	        var index = this._inputs.indexOf(currentInput);
	        if (index > -1 && (index + 1) < this._inputs.length) {
	            var nextInput = this._inputs[index + 1];
	            if (nextInput !== this._focused) {
	                console.debug('tabFocus, next');
	                return nextInput.initFocus();
	            }
	        }
	        index = this._inputs.indexOf(this._focused);
	        if (index > 0) {
	            var previousInput = this._inputs[index - 1];
	            if (previousInput) {
	                console.debug('tabFocus, previous');
	                previousInput.initFocus();
	            }
	        }
	    };
	    Form.prototype.nextId = function () {
	        return ++this._ids;
	    };
	    /** @nocollapse */
	    Form.decorators = [
	        { type: Injectable },
	    ];
	    return Form;
	}());

	var Key;
	(function (Key) {
	    Key[Key["ENTER"] = 13] = "ENTER";
	    Key[Key["ESCAPE"] = 27] = "ESCAPE";
	    Key[Key["TAB"] = 9] = "TAB";
	})(Key || (Key = {}));
	;

	var Keyboard = (function () {
	    function Keyboard(config, _form, _zone) {
	        var _this = this;
	        this._form = _form;
	        this._zone = _zone;
	        _zone.runOutsideAngular(function () {
	            _this.focusOutline(config.get('focusOutline'), document);
	        });
	    }
	    /**
	     * Check to see if the keyboard is open or not.
	     *
	     * ```ts
	     * export class MyClass{
	     *  constructor(keyboard: Keyboard){
	     *    this.keyboard = keyboard;
	     *  }
	     *  keyboardCheck(){
	     *    setTimeout(()  => console.log('is the keyboard open ', this.keyboard.isOpen()));
	     *  }
	     * }
	     *
	     * ```
	     *
	     * @return {boolean} returns a true or flase value if the keyboard is open or not
	     */
	    Keyboard.prototype.isOpen = function () {
	        return hasFocusedTextInput();
	    };
	    /**
	     * When the keyboard is closed, call any methods you want
	     *
	     * ```ts
	     * export class MyClass{
	     *  constructor(keyboard: Keyboard){
	     *    this.keyboard = keyboard;
	     *    this.keyboard.onClose(this.closeCallback);
	     *  }
	     *  closeCallback(){
	     *     // call what ever functionality you want on keyboard close
	     *     console.log('Closing time');
	     *  }
	     * }
	     *
	     * ```
	     * @param {function} callback method you want to call when the keyboard has been closed
	     * @return {function} returns a callback that gets fired when the keyboard is closed
	     */
	    Keyboard.prototype.onClose = function (callback, pollingInternval, pollingChecksMax) {
	        if (pollingInternval === void 0) { pollingInternval = KEYBOARD_CLOSE_POLLING; }
	        if (pollingChecksMax === void 0) { pollingChecksMax = KEYBOARD_POLLING_CHECKS_MAX; }
	        console.debug('keyboard onClose');
	        var self = this;
	        var checks = 0;
	        var promise = null;
	        if (!callback) {
	            // a callback wasn't provided, so let's return a promise instead
	            promise = new Promise(function (resolve) { callback = resolve; });
	        }
	        function checkKeyboard() {
	            console.debug('keyboard isOpen', self.isOpen());
	            if (!self.isOpen() || checks > pollingChecksMax) {
	                rafFrames(30, function () {
	                    self._zone.run(function () {
	                        console.debug('keyboard closed');
	                        callback();
	                    });
	                });
	            }
	            else {
	                nativeTimeout(checkKeyboard, pollingInternval);
	            }
	            checks++;
	        }
	        nativeTimeout(checkKeyboard, pollingInternval);
	        return promise;
	    };
	    /**
	     * Programmatically close the keyboard
	     *
	     */
	    Keyboard.prototype.close = function () {
	        var _this = this;
	        console.debug('keyboard close()');
	        nativeRaf(function () {
	            if (hasFocusedTextInput()) {
	                // only focus out when a text input has focus
	                _this._form.focusOut();
	            }
	        });
	    };
	    /**
	     * @private
	     */
	    Keyboard.prototype.focusOutline = function (setting, document) {
	        /* Focus Outline
	         * --------------------------------------------------
	         * By default, when a keydown event happens from a tab key, then
	         * the 'focus-outline' css class is added to the body element
	         * so focusable elements have an outline. On a mousedown or
	         * touchstart event, then the 'focus-outline' css class is removed.
	         *
	         * Config default overrides:
	         * focusOutline: true     - Always add the focus-outline
	         * focusOutline: false    - Do not add the focus-outline
	         */
	        var self = this;
	        var isKeyInputEnabled = false;
	        function cssClass() {
	            nativeRaf(function () {
	                document.body.classList[isKeyInputEnabled ? 'add' : 'remove']('focus-outline');
	            });
	        }
	        if (setting === true) {
	            isKeyInputEnabled = true;
	            return cssClass();
	        }
	        else if (setting === false) {
	            return;
	        }
	        // default is to add the focus-outline when the tab key is used
	        function keyDown(ev) {
	            if (!isKeyInputEnabled && ev.keyCode === Key.TAB) {
	                isKeyInputEnabled = true;
	                enableKeyInput();
	            }
	        }
	        function pointerDown() {
	            isKeyInputEnabled = false;
	            enableKeyInput();
	        }
	        function enableKeyInput() {
	            cssClass();
	            self._zone.runOutsideAngular(function () {
	                document.removeEventListener('mousedown', pointerDown);
	                document.removeEventListener('touchstart', pointerDown);
	                if (isKeyInputEnabled) {
	                    document.addEventListener('mousedown', pointerDown);
	                    document.addEventListener('touchstart', pointerDown);
	                }
	            });
	        }
	        document.addEventListener('keydown', keyDown);
	    };
	    /** @nocollapse */
	    Keyboard.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    Keyboard.ctorParameters = [
	        { type: Config, },
	        { type: Form, },
	        { type: NgZone, },
	    ];
	    return Keyboard;
	}());
	var KEYBOARD_CLOSE_POLLING = 150;
	var KEYBOARD_POLLING_CHECKS_MAX = 100;

	/**
	 * @name MenuController
	 * @description
	 * The MenuController is a provider which makes it easy to control a [Menu](../Menu).
	 * Its methods can be used to display the menu, enable the menu, toggle the menu, and more.
	 * The controller will grab a reference to the menu by the `side`, `id`, or, if neither
	 * of these are passed to it, it will grab the first menu it finds.
	 *
	 *
	 * @usage
	 *
	 * Add a basic menu component to start with. See the [Menu](../Menu) API docs
	 * for more information on adding menu components.
	 *
	 * ```html
	 * <ion-menu [content]="mycontent">
	 *   <ion-content>
	 *     <ion-list>
	 *     ...
	 *     </ion-list>
	 *   </ion-content>
	 * </ion-menu>
	 *
	 * <ion-nav #mycontent [root]="rootPage"></ion-nav>
	 * ```
	 *
	 * To call the controller methods, inject the `MenuController` provider
	 * into the page. Then, create some methods for opening, closing, and
	 * toggling the menu.
	 *
	 * ```ts
	 * import {Component} from '@angular/core';
	 * import {MenuController} from 'ionic-angular';
	 *
	 * @Component({...})
	 * export class MyPage {
	 *
	 *  constructor(private menu: MenuController) {
	 *
	 *  }
	 *
	 *  openMenu() {
	 *    this.menu.open();
	 *  }
	 *
	 *  closeMenu() {
	 *    this.menu.close();
	 *  }
	 *
	 *  toggleMenu() {
	 *    this.menu.toggle();
	 *  }
	 *
	 * }
	 * ```
	 *
	 * Since only one menu exists, the `MenuController` will grab the
	 * correct menu and call the correct method for each.
	 *
	 *
	 * ### Multiple Menus on Different Sides
	 *
	 * For applications with both a left and right menu, the desired menu can be
	 * grabbed by passing the `side` of the menu. If nothing is passed, it will
	 * default to the `"left"` menu.
	 *
	 * ```html
	 * <ion-menu side="left" [content]="mycontent">...</ion-menu>
	 * <ion-menu side="right" [content]="mycontent">...</ion-menu>
	 * <ion-nav #mycontent [root]="rootPage"></ion-nav>
	 * ```
	 *
	 * ```ts
	 *  toggleLeftMenu() {
	 *    this.menu.toggle();
	 *  }
	 *
	 *  toggleRightMenu() {
	 *    this.menu.toggle('right');
	 *  }
	 * ```
	 *
	 *
	 * ### Multiple Menus on the Same Side
	 *
	 * An application can have multiple menus on the same side. In order to determine
	 * the menu to control, an `id` should be passed. In the example below, the menu
	 * with the `authenticated` id will be enabled, and the menu with the `unauthenticated`
	 * id will be disabled.
	 *
	 * ```html
	 * <ion-menu id="authenticated" side="left" [content]="mycontent">...</ion-menu>
	 * <ion-menu id="unauthenticated" side="left" [content]="mycontent">...</ion-menu>
	 * <ion-nav #mycontent [root]="rootPage"></ion-nav>
	 * ```
	 *
	 * ```ts
	 *  enableAuthenticatedMenu() {
	 *    this.menu.enable(true, 'authenticated');
	 *    this.menu.enable(false, 'unauthenticated');
	 *  }
	 * ```
	 *
	 * Note: if an app only has one menu, there is no reason to pass an `id`.
	 *
	 *
	 * @demo /docs/v2/demos/menu/
	 *
	 * @see {@link /docs/v2/components#menus Menu Component Docs}
	 * @see {@link ../Menu Menu API Docs}
	 *
	 */
	var MenuController = (function () {
	    function MenuController() {
	        this._menus = [];
	    }
	    /**
	     * Progamatically open the Menu.
	     * @return {Promise} returns a promise when the menu is fully opened
	     */
	    MenuController.prototype.open = function (menuId) {
	        var menu = this.get(menuId);
	        if (menu) {
	            return menu.open();
	        }
	        return Promise.resolve(false);
	    };
	    /**
	     * Progamatically close the Menu. If no `menuId` is given as the first
	     * argument then it'll close any menu which is open. If a `menuId`
	     * is given then it'll close that exact menu.
	     * @param {string} [menuId]  Optionally get the menu by its id, or side.
	     * @return {Promise} returns a promise when the menu is fully closed
	     */
	    MenuController.prototype.close = function (menuId) {
	        var menu;
	        if (menuId) {
	            // find the menu by its id
	            menu = this.get(menuId);
	        }
	        else {
	            // find the menu that is open
	            menu = this._menus.find(function (m) { return m.isOpen; });
	        }
	        if (menu) {
	            // close the menu
	            return menu.close();
	        }
	        return Promise.resolve(false);
	    };
	    MenuController.prototype.tempDisable = function (temporarilyDisable) {
	        this._menus.forEach(function (menu) {
	            menu.tempDisable(temporarilyDisable);
	        });
	    };
	    /**
	     * Toggle the menu. If it's closed, it will open, and if opened, it
	     * will close.
	     * @param {string} [menuId]  Optionally get the menu by its id, or side.
	     * @return {Promise} returns a promise when the menu has been toggled
	     */
	    MenuController.prototype.toggle = function (menuId) {
	        var menu = this.get(menuId);
	        if (menu) {
	            return menu.toggle();
	        }
	        return Promise.resolve(false);
	    };
	    /**
	     * Used to enable or disable a menu. For example, there could be multiple
	     * left menus, but only one of them should be able to be opened at the same
	     * time. If there are multiple menus on the same side, then enabling one menu
	     * will also automatically disable all the others that are on the same side.
	     * @param {string} [menuId]  Optionally get the menu by its id, or side.
	     * @return {Menu}  Returns the instance of the menu, which is useful for chaining.
	     */
	    MenuController.prototype.enable = function (shouldEnable, menuId) {
	        var menu = this.get(menuId);
	        if (menu) {
	            return menu.enable(shouldEnable);
	        }
	    };
	    /**
	     * Used to enable or disable the ability to swipe open the menu.
	     * @param {boolean} shouldEnable  True if it should be swipe-able, false if not.
	     * @param {string} [menuId]  Optionally get the menu by its id, or side.
	     * @return {Menu}  Returns the instance of the menu, which is useful for chaining.
	     */
	    MenuController.prototype.swipeEnable = function (shouldEnable, menuId) {
	        var menu = this.get(menuId);
	        if (menu) {
	            return menu.swipeEnable(shouldEnable);
	        }
	    };
	    /**
	     * @return {boolean} Returns true if the menu is currently open, otherwise false.
	     */
	    MenuController.prototype.isOpen = function (menuId) {
	        var menu = this.get(menuId);
	        return menu && menu.isOpen || false;
	    };
	    /**
	     * @return {boolean} Returns true if the menu is currently enabled, otherwise false.
	     */
	    MenuController.prototype.isEnabled = function (menuId) {
	        var menu = this.get(menuId);
	        return menu && menu.enabled || false;
	    };
	    /**
	     * Used to get a menu instance. If a `menuId` is not provided then it'll
	     * return the first menu found. If a `menuId` is `left` or `right`, then
	     * it'll return the enabled menu on that side. Otherwise, if a `menuId` is
	     * provided, then it'll try to find the menu using the menu's `id`
	     * property. If a menu is not found then it'll return `null`.
	     * @param {string} [menuId]  Optionally get the menu by its id, or side.
	     * @return {Menu}  Returns the instance of the menu if found, otherwise `null`.
	     */
	    MenuController.prototype.get = function (menuId) {
	        var menu;
	        if (menuId === 'left' || menuId === 'right') {
	            // there could be more than one menu on the same side
	            // so first try to get the enabled one
	            menu = this._menus.find(function (m) { return m.side === menuId && m.enabled; });
	            if (menu)
	                return menu;
	            // didn't find a menu side that is enabled
	            // so try to get the first menu side found
	            return this._menus.find(function (m) { return m.side === menuId; }) || null;
	        }
	        else if (menuId) {
	            // the menuId was not left or right
	            // so try to get the menu by its "id"
	            return this._menus.find(function (m) { return m.id === menuId; }) || null;
	        }
	        // return the first enabled menu
	        menu = this._menus.find(function (m) { return m.enabled; });
	        if (menu)
	            return menu;
	        // get the first menu in the array, if one exists
	        return (this._menus.length ? this._menus[0] : null);
	    };
	    /**
	     * @return {Array<Menu>}  Returns an array of all menu instances.
	     */
	    MenuController.prototype.getMenus = function () {
	        return this._menus;
	    };
	    /**
	     * @private
	     */
	    MenuController.prototype.register = function (menu) {
	        this._menus.push(menu);
	    };
	    /**
	     * @private
	     */
	    MenuController.prototype.unregister = function (menu) {
	        var index = this._menus.indexOf(menu);
	        if (index > -1) {
	            this._menus.splice(index, 1);
	        }
	    };
	    /**
	     * @private
	     */
	    MenuController.registerType = function (name, cls) {
	        menuTypes[name] = cls;
	    };
	    /**
	     * @private
	     */
	    MenuController.create = function (type, menuCmp, platform) {
	        return new menuTypes[type](menuCmp, platform);
	    };
	    return MenuController;
	}());
	var menuTypes = {};

	var ids = 0;
	/**
	 * Base class for all Ionic components. Exposes some common functionality
	 * that all Ionic components need, such as accessing underlying native elements and
	 * sending/receiving app-level events.
	 */
	var Ion = (function () {
	    function Ion(elementRef) {
	        this.elementRef = elementRef;
	        this._id = 'i' + ids++;
	    }
	    Ion.prototype.getElementRef = function () {
	        return this.elementRef;
	    };
	    Ion.prototype.getNativeElement = function () {
	        return this.elementRef.nativeElement;
	    };
	    Ion.prototype.getDimensions = function () {
	        return getDimensions(this.elementRef.nativeElement, this._id);
	    };
	    Ion.prototype.width = function () {
	        return getDimensions(this.elementRef.nativeElement, this._id).width;
	    };
	    Ion.prototype.height = function () {
	        return getDimensions(this.elementRef.nativeElement, this._id).height;
	    };
	    Ion.prototype.ngOnDestroy = function () {
	        clearDimensions(this._id);
	    };
	    return Ion;
	}());

	/**
	 * @name NavParams
	 * @description
	 * NavParams are an object that exists on a page and can contain data for that particular view.
	 * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible
	 * option with a simple `get` method.
	 *
	 * @usage
	 * ```ts
	 * export class MyClass{
	 *  constructor(private params: NavParams){
	 *    // userParams is an object we have in our nav-parameters
	 *    this.params.get('userParams');
	 *  }
	 * }
	 * ```
	 * @demo /docs/v2/demos/nav-params/
	 * @see {@link /docs/v2/components#navigation Navigation Component Docs}
	 * @see {@link ../NavController/ NavController API Docs}
	 * @see {@link ../Nav/ Nav API Docs}
	 * @see {@link ../NavPush/ NavPush API Docs}
	 */
	var NavParams = (function () {
	    /**
	     * @private
	     * @param {TODO} data  TODO
	     */
	    function NavParams(data) {
	        if (data === void 0) { data = {}; }
	        this.data = data;
	    }
	    /**
	     * Get the value of a nav-parameter for the current view
	     *
	     * ```ts
	     * export class MyClass{
	     *  constructor(private params: NavParams){
	     *    // userParams is an object we have in our nav-parameters
	     *    this.params.get('userParams');
	     *  }
	     * }
	     * ```
	     *
	     *
	     * @param {string} parameter Which param you want to look up
	     */
	    NavParams.prototype.get = function (param) {
	        return this.data[param];
	    };
	    return NavParams;
	}());

	function renderDateTime(template, value, locale) {
	    if (isBlank$5(value)) {
	        return '';
	    }
	    var tokens = [];
	    var hasText = false;
	    FORMAT_KEYS.forEach(function (format, index) {
	        if (template.indexOf(format.f) > -1) {
	            var token = '{' + index + '}';
	            var text = renderTextFormat(format.f, value[format.k], value, locale);
	            if (!hasText && text && isPresent$5(value[format.k])) {
	                hasText = true;
	            }
	            tokens.push(token, text);
	            template = template.replace(format.f, token);
	        }
	    });
	    if (!hasText) {
	        return '';
	    }
	    for (var i = 0; i < tokens.length; i += 2) {
	        template = template.replace(tokens[i], tokens[i + 1]);
	    }
	    return template;
	}
	function renderTextFormat(format, value, date, locale) {
	    if (format === FORMAT_DDDD || format === FORMAT_DDD) {
	        try {
	            value = (new Date(date.year, date.month - 1, date.day)).getDay();
	            if (format === FORMAT_DDDD) {
	                return (isPresent$5(locale.dayNames) ? locale.dayNames : DAY_NAMES)[value];
	            }
	            return (isPresent$5(locale.dayShortNames) ? locale.dayShortNames : DAY_SHORT_NAMES)[value];
	        }
	        catch (e) { }
	        return '';
	    }
	    if (format === FORMAT_A) {
	        return date ? date.hour < 12 ? 'AM' : 'PM' : isPresent$5(value) ? value.toUpperCase() : '';
	    }
	    if (format === FORMAT_a) {
	        return date ? date.hour < 12 ? 'am' : 'pm' : isPresent$5(value) ? value : '';
	    }
	    if (isBlank$5(value)) {
	        return '';
	    }
	    if (format === FORMAT_YY || format === FORMAT_MM ||
	        format === FORMAT_DD || format === FORMAT_HH ||
	        format === FORMAT_mm || format === FORMAT_ss) {
	        return twoDigit(value);
	    }
	    if (format === FORMAT_YYYY) {
	        return fourDigit(value);
	    }
	    if (format === FORMAT_MMMM) {
	        return (isPresent$5(locale.monthNames) ? locale.monthNames : MONTH_NAMES)[value - 1];
	    }
	    if (format === FORMAT_MMM) {
	        return (isPresent$5(locale.monthShortNames) ? locale.monthShortNames : MONTH_SHORT_NAMES)[value - 1];
	    }
	    if (format === FORMAT_hh || format === FORMAT_h) {
	        if (value === 0) {
	            return '12';
	        }
	        if (value > 12) {
	            value -= 12;
	        }
	        if (format === FORMAT_hh && value < 10) {
	            return ('0' + value);
	        }
	    }
	    return value.toString();
	}
	function dateValueRange(format, min, max) {
	    var opts = [];
	    var i;
	    if (format === FORMAT_YYYY || format === FORMAT_YY) {
	        // year
	        i = max.year;
	        while (i >= min.year) {
	            opts.push(i--);
	        }
	    }
	    else if (format === FORMAT_MMMM || format === FORMAT_MMM ||
	        format === FORMAT_MM || format === FORMAT_M ||
	        format === FORMAT_hh || format === FORMAT_h) {
	        // month or 12-hour
	        for (i = 1; i < 13; i++) {
	            opts.push(i);
	        }
	    }
	    else if (format === FORMAT_DDDD || format === FORMAT_DDD ||
	        format === FORMAT_DD || format === FORMAT_D) {
	        // day
	        for (i = 1; i < 32; i++) {
	            opts.push(i);
	        }
	    }
	    else if (format === FORMAT_HH || format === FORMAT_H) {
	        // 24-hour
	        for (i = 0; i < 24; i++) {
	            opts.push(i);
	        }
	    }
	    else if (format === FORMAT_mm || format === FORMAT_m) {
	        // minutes
	        for (i = 0; i < 60; i++) {
	            opts.push(i);
	        }
	    }
	    else if (format === FORMAT_ss || format === FORMAT_s) {
	        // seconds
	        for (i = 0; i < 60; i++) {
	            opts.push(i);
	        }
	    }
	    else if (format === FORMAT_A || format === FORMAT_a) {
	        // AM/PM
	        opts.push('am', 'pm');
	    }
	    return opts;
	}
	function dateSortValue(year, month, day) {
	    return parseInt("1" + fourDigit(year) + twoDigit(month) + twoDigit(day), 10);
	}
	function dateDataSortValue(data) {
	    if (data) {
	        return dateSortValue(data.year, data.month, data.day);
	    }
	    return -1;
	}
	function daysInMonth(month, year) {
	    return (month === 4 || month === 6 || month === 9 || month === 11) ? 30 : (month === 2) ? isLeapYear(year) ? 29 : 28 : 31;
	}
	function isLeapYear(year) {
	    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
	}
	var ISO_8601_REGEXP = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
	var TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
	function parseDate(val) {
	    // manually parse IS0 cuz Date.parse cannot be trusted
	    // ISO 8601 format: 1994-12-15T13:47:20Z
	    var parse;
	    if (isPresent$5(val) && val !== '') {
	        // try parsing for just time first, HH:MM
	        parse = TIME_REGEXP.exec(val);
	        if (isPresent$5(parse)) {
	            // adjust the array so it fits nicely with the datetime parse
	            parse.unshift(undefined, undefined);
	            parse[2] = parse[3] = undefined;
	        }
	        else {
	            // try parsing for full ISO datetime
	            parse = ISO_8601_REGEXP.exec(val);
	        }
	    }
	    if (isBlank$5(parse)) {
	        // wasn't able to parse the ISO datetime
	        return null;
	    }
	    // ensure all the parse values exist with at least 0
	    for (var i = 1; i < 8; i++) {
	        parse[i] = (parse[i] !== undefined ? parseInt(parse[i], 10) : null);
	    }
	    var tzOffset = 0;
	    if (isPresent$5(parse[9]) && isPresent$5(parse[10])) {
	        // hours
	        tzOffset = parseInt(parse[10], 10) * 60;
	        if (isPresent$5(parse[11])) {
	            // minutes
	            tzOffset += parseInt(parse[11], 10);
	        }
	        if (parse[9] === '-') {
	            // + or -
	            tzOffset *= -1;
	        }
	    }
	    return {
	        year: parse[1],
	        month: parse[2],
	        day: parse[3],
	        hour: parse[4],
	        minute: parse[5],
	        second: parse[6],
	        millisecond: parse[7],
	        tzOffset: tzOffset,
	    };
	}
	function updateDate(existingData, newData) {
	    if (isPresent$5(newData) && newData !== '') {
	        if (isString$5(newData)) {
	            // new date is a string, and hopefully in the ISO format
	            // convert it to our DateTimeData if a valid ISO
	            newData = parseDate(newData);
	            if (newData) {
	                // successfully parsed the ISO string to our DateTimeData
	                assign(existingData, newData);
	                return;
	            }
	        }
	        else if ((isPresent$5(newData.year) || isPresent$5(newData.hour))) {
	            // newData is from of a datetime picker's selected values
	            // update the existing DateTimeData data with the new values
	            // do some magic for 12-hour values
	            if (isPresent$5(newData.ampm) && isPresent$5(newData.hour)) {
	                if (newData.ampm.value === 'pm') {
	                    newData.hour.value = (newData.hour.value === 12 ? 12 : newData.hour.value + 12);
	                }
	                else {
	                    newData.hour.value = (newData.hour.value === 12 ? 0 : newData.hour.value);
	                }
	            }
	            // merge new values from the picker's selection
	            // to the existing DateTimeData values
	            for (var k in newData) {
	                existingData[k] = newData[k].value;
	            }
	            return;
	        }
	        // eww, invalid data
	        console.warn("Error parsing date: \"" + newData + "\". Please provide a valid ISO 8601 datetime format: https://www.w3.org/TR/NOTE-datetime");
	    }
	    else {
	        // blank data, clear everything out
	        for (var k in existingData) {
	            delete existingData[k];
	        }
	    }
	}
	function parseTemplate(template) {
	    var formats = [];
	    template = template.replace(/[^\w\s]/gi, ' ');
	    FORMAT_KEYS.forEach(function (format) {
	        if (format.f.length > 1 && template.indexOf(format.f) > -1 && template.indexOf(format.f + format.f.charAt(0)) < 0) {
	            template = template.replace(format.f, ' ' + format.f + ' ');
	        }
	    });
	    var words = template.split(' ').filter(function (w) { return w.length > 0; });
	    words.forEach(function (word, i) {
	        FORMAT_KEYS.forEach(function (format) {
	            if (word === format.f) {
	                if (word === FORMAT_A || word === FORMAT_a) {
	                    // this format is an am/pm format, so it's an "a" or "A"
	                    if ((formats.indexOf(FORMAT_h) < 0 && formats.indexOf(FORMAT_hh) < 0) ||
	                        (words[i - 1] !== FORMAT_m && words[i - 1] !== FORMAT_mm)) {
	                        // template does not already have a 12-hour format
	                        // or this am/pm format doesn't have a minute format immediately before it
	                        // so do not treat this word "a" or "A" as an am/pm format
	                        return;
	                    }
	                }
	                formats.push(word);
	            }
	        });
	    });
	    return formats;
	}
	function getValueFromFormat(date, format) {
	    if (format === FORMAT_A || format === FORMAT_a) {
	        return (date.hour < 12 ? 'am' : 'pm');
	    }
	    if (format === FORMAT_hh || format === FORMAT_h) {
	        return (date.hour > 12 ? date.hour - 12 : date.hour);
	    }
	    return date[convertFormatToKey(format)];
	}
	function convertFormatToKey(format) {
	    for (var k in FORMAT_KEYS) {
	        if (FORMAT_KEYS[k].f === format) {
	            return FORMAT_KEYS[k].k;
	        }
	    }
	    return null;
	}
	function convertDataToISO(data) {
	    // https://www.w3.org/TR/NOTE-datetime
	    var rtn = '';
	    if (isPresent$5(data)) {
	        if (isPresent$5(data.year)) {
	            // YYYY
	            rtn = fourDigit(data.year);
	            if (isPresent$5(data.month)) {
	                // YYYY-MM
	                rtn += '-' + twoDigit(data.month);
	                if (isPresent$5(data.day)) {
	                    // YYYY-MM-DD
	                    rtn += '-' + twoDigit(data.day);
	                    if (isPresent$5(data.hour)) {
	                        // YYYY-MM-DDTHH:mm:SS
	                        rtn += "T" + twoDigit(data.hour) + ":" + twoDigit(data.minute) + ":" + twoDigit(data.second);
	                        if (data.millisecond > 0) {
	                            // YYYY-MM-DDTHH:mm:SS.SSS
	                            rtn += '.' + threeDigit(data.millisecond);
	                        }
	                        if (isBlank$5(data.tzOffset) || data.tzOffset === 0) {
	                            // YYYY-MM-DDTHH:mm:SSZ
	                            rtn += 'Z';
	                        }
	                        else {
	                            // YYYY-MM-DDTHH:mm:SS+/-HH:mm
	                            rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(data.tzOffset / 60)) + ':' + twoDigit(data.tzOffset % 60);
	                        }
	                    }
	                }
	            }
	        }
	        else if (isPresent$5(data.hour)) {
	            // HH:mm
	            rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
	            if (isPresent$5(data.second)) {
	                // HH:mm:SS
	                rtn += ':' + twoDigit(data.second);
	                if (isPresent$5(data.millisecond)) {
	                    // HH:mm:SS.SSS
	                    rtn += '.' + threeDigit(data.millisecond);
	                }
	            }
	        }
	    }
	    return rtn;
	}
	function twoDigit(val) {
	    return ('0' + (isPresent$5(val) ? val : '0')).slice(-2);
	}
	function threeDigit(val) {
	    return ('00' + (isPresent$5(val) ? val : '0')).slice(-3);
	}
	function fourDigit(val) {
	    return ('000' + (isPresent$5(val) ? val : '0')).slice(-4);
	}
	var FORMAT_YYYY = 'YYYY';
	var FORMAT_YY = 'YY';
	var FORMAT_MMMM = 'MMMM';
	var FORMAT_MMM = 'MMM';
	var FORMAT_MM = 'MM';
	var FORMAT_M = 'M';
	var FORMAT_DDDD = 'DDDD';
	var FORMAT_DDD = 'DDD';
	var FORMAT_DD = 'DD';
	var FORMAT_D = 'D';
	var FORMAT_HH = 'HH';
	var FORMAT_H = 'H';
	var FORMAT_hh = 'hh';
	var FORMAT_h = 'h';
	var FORMAT_mm = 'mm';
	var FORMAT_m = 'm';
	var FORMAT_ss = 'ss';
	var FORMAT_s = 's';
	var FORMAT_A = 'A';
	var FORMAT_a = 'a';
	var FORMAT_KEYS = [
	    { f: FORMAT_YYYY, k: 'year' },
	    { f: FORMAT_MMMM, k: 'month' },
	    { f: FORMAT_DDDD, k: 'day' },
	    { f: FORMAT_MMM, k: 'month' },
	    { f: FORMAT_DDD, k: 'day' },
	    { f: FORMAT_YY, k: 'year' },
	    { f: FORMAT_MM, k: 'month' },
	    { f: FORMAT_DD, k: 'day' },
	    { f: FORMAT_HH, k: 'hour' },
	    { f: FORMAT_hh, k: 'hour' },
	    { f: FORMAT_mm, k: 'minute' },
	    { f: FORMAT_ss, k: 'second' },
	    { f: FORMAT_M, k: 'month' },
	    { f: FORMAT_D, k: 'day' },
	    { f: FORMAT_H, k: 'hour' },
	    { f: FORMAT_h, k: 'hour' },
	    { f: FORMAT_m, k: 'minute' },
	    { f: FORMAT_s, k: 'second' },
	    { f: FORMAT_A, k: 'ampm' },
	    { f: FORMAT_a, k: 'ampm' },
	];
	var DAY_NAMES = [
	    'Sunday',
	    'Monday',
	    'Tuesday',
	    'Wednesday',
	    'Thursday',
	    'Friday',
	    'Saturday',
	];
	var DAY_SHORT_NAMES = [
	    'Sun',
	    'Mon',
	    'Tue',
	    'Wed',
	    'Thu',
	    'Fri',
	    'Sat',
	];
	var MONTH_NAMES = [
	    'January',
	    'February',
	    'March',
	    'April',
	    'May',
	    'June',
	    'July',
	    'August',
	    'September',
	    'October',
	    'November',
	    'December',
	];
	var MONTH_SHORT_NAMES = [
	    'Jan',
	    'Feb',
	    'Mar',
	    'Apr',
	    'May',
	    'Jun',
	    'Jul',
	    'Aug',
	    'Sep',
	    'Oct',
	    'Nov',
	    'Dec',
	];

	var dom = domUtil;

	var win$1 = window;
	var doc = document;
	/*! Hammer.JS - v2.0.6 - 2015-12-23
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2015 Jorik Tangelder;
	 * Licensed under the  license */
	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = doc.createElement('div');
	var TYPE_FUNCTION = 'function';
	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;
	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}
	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}
	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;
	    if (!obj) {
	        return;
	    }
	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    }
	    else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    }
	    else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}
	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype, childP;
	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;
	    if (properties) {
	        assign(childP, properties);
	    }
	}
	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}
	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}
	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}
	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function (type) {
	        target.addEventListener(type, handler, false);
	    });
	}
	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function (type) {
	        target.removeEventListener(type, handler, false);
	    });
	}
	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}
	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}
	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}
	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    }
	    else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}
	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray$1(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}
	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;
	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }
	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        }
	        else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key] ? 1 : 0;
	            });
	        }
	    }
	    return results;
	}
	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);
	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;
	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}
	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}
	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}
	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';
	var COMPUTE_INTERVAL = 25;
	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;
	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;
	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];
	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input$1(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;
	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function (ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };
	    this.init();
	}
	Input$1.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function () { },
	    /**
	     * bind the events
	     */
	    init: function () {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },
	    /**
	     * unbind the events
	     */
	    destroy: function () {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};
	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;
	    if (inputClass) {
	        Type = inputClass;
	    }
	    else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    }
	    else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    }
	    else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    }
	    else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}
	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));
	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;
	    if (isFirst) {
	        manager.session = {};
	    }
	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;
	    // compute scale, rotation etc
	    computeInputData(manager, input);
	    // emit secret event
	    manager.emit('hammer.input', input);
	    manager.recognize(input);
	    manager.session.prevInput = input;
	}
	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;
	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }
	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    }
	    else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }
	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;
	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);
	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);
	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;
	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);
	    computeIntervalInputData(session, input);
	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}
	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};
	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };
	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }
	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}
	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;
	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);
	        session.lastInterval = input;
	    }
	    else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }
	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}
	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }
	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}
	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;
	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }
	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }
	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}
	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}
	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }
	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}
	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
	    return Math.sqrt((x * x) + (y * y));
	}
	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}
	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}
	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}
	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};
	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput(manager, handler) {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;
	    this.allow = true; // used by Input.TouchMouse to disable mouse events
	    this.pressed = false; // mousedown state
	    Input$1.apply(this, arguments);
	}
	inherit(MouseInput, Input$1, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];
	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }
	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }
	        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
	        if (!this.pressed || !this.allow) {
	            return;
	        }
	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }
	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});
	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};
	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};
	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
	// IE10 has prefixed support, and case-sensitive
	if (win$1.MSPointerEvent && !win$1.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}
	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;
	    Input$1.apply(this, arguments);
	    this.store = (this.manager.session.pointerEvents = []);
	}
	inherit(PointerEventInput, Input$1, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;
	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);
	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');
	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        }
	        else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }
	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }
	        // update the event in the store
	        store[storeIndex] = ev;
	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });
	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});
	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};
	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;
	    Input$1.apply(this, arguments);
	}
	inherit(SingleTouchInput, Input$1, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }
	        if (!this.started) {
	            return;
	        }
	        var touches = normalizeSingleTouches.call(this, ev, type);
	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }
	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});
	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray$1(ev.touches);
	    var changed = toArray$1(ev.changedTouches);
	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }
	    return [all, changed];
	}
	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};
	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput(manager, handler) {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};
	    Input$1.apply(this, arguments);
	}
	inherit(TouchInput, Input$1, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }
	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});
	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray$1(ev.touches);
	    var targetIds = this.targetIds;
	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }
	    var i, targetTouches, changedTouches = toArray$1(ev.changedTouches), changedTargetTouches = [], target = this.target;
	    // get target touches from touches
	    targetTouches = allTouches.filter(function (touch) {
	        return hasParent(touch.target, target);
	    });
	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }
	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }
	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }
	    if (!changedTargetTouches.length) {
	        return;
	    }
	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}
	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */
	function TouchMouseInput() {
	    Input$1.apply(this, arguments);
	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);
	}
	inherit(TouchMouseInput, Input$1, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH), isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);
	        // when we're in a touch event, so  block all upcoming mouse events
	        // most mobile browser also emit mouseevents, right after touchstart
	        if (isTouch) {
	            this.mouse.allow = false;
	        }
	        else if (isMouse && !this.mouse.allow) {
	            return;
	        }
	        // reset the allowMouse when we're done
	        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
	            this.mouse.allow = true;
	        }
	        this.callback(manager, inputEvent, inputData);
	    },
	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});
	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}
	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function (value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }
	        if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },
	    /**
	     * just re-set the touchAction value
	     */
	    update: function () {
	        this.set(this.manager.options.touchAction);
	    },
	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function () {
	        var actions = [];
	        each(this.manager.recognizers, function (recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },
	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function (input) {
	        // not needed with native support for the touchAction property
	        if (NATIVE_TOUCH_ACTION) {
	            return;
	        }
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;
	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }
	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture
	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;
	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }
	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }
	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },
	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function (srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};
	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }
	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }
	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }
	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }
	    return TOUCH_ACTION_AUTO;
	}
	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;
	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});
	    this.id = uniqueId();
	    this.manager = null;
	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);
	    this.state = STATE_POSSIBLE;
	    this.simultaneous = {};
	    this.requireFail = [];
	}
	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},
	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function (options) {
	        assign(this.options, options);
	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },
	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function (otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }
	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },
	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function (otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },
	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function (otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }
	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },
	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function (otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },
	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function () {
	        return this.requireFail.length > 0;
	    },
	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function (otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },
	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function (input) {
	        var self = this;
	        var state = this.state;
	        function emit(event) {
	            self.manager.emit(event, input);
	        }
	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	        emit(self.options.event); // simple 'eventName' events
	        if (input.additionalEvent) {
	            emit(input.additionalEvent);
	        }
	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },
	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function (input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },
	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function () {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },
	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function (inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);
	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }
	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }
	        this.state = this.process(inputDataClone);
	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },
	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function (inputData) { },
	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function () { },
	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function () { }
	};
	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    }
	    else if (state & STATE_ENDED) {
	        return 'end';
	    }
	    else if (state & STATE_CHANGED) {
	        return 'move';
	    }
	    else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}
	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    }
	    else if (direction == DIRECTION_UP) {
	        return 'up';
	    }
	    else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    }
	    else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}
	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}
	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}
	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },
	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function (input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },
	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function (input) {
	        var state = this.state;
	        var eventType = input.eventType;
	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);
	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        }
	        else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            }
	            else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});
	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	    this.pX = null;
	    this.pY = null;
	}
	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },
	    getTouchAction: function () {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },
	    directionTest: function (input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;
	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            }
	            else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },
	    attrTest: function (input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },
	    emit: function (input) {
	        this.pX = input.deltaX;
	        this.pY = input.deltaY;
	        var direction = directionStr(input.direction);
	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});
	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}
	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },
	    getTouchAction: function () {
	        return [TOUCH_ACTION_NONE];
	    },
	    attrTest: function (input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },
	    emit: function (input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});
	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);
	    this._timer = null;
	    this._input = null;
	}
	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251,
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },
	    getTouchAction: function () {
	        return [TOUCH_ACTION_AUTO];
	    },
	    process: function (input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;
	        this._input = input;
	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        }
	        else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function () {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        }
	        else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },
	    reset: function () {
	        clearTimeout(this._timer);
	    },
	    emit: function (input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }
	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        }
	        else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});
	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}
	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },
	    getTouchAction: function () {
	        return [TOUCH_ACTION_NONE];
	    },
	    attrTest: function (input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});
	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}
	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },
	    getTouchAction: function () {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },
	    attrTest: function (input) {
	        var direction = this.options.direction;
	        var velocity;
	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        }
	        else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        }
	        else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }
	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },
	    emit: function (input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }
	        this.manager.emit(this.options.event, input);
	    }
	});
	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);
	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;
	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}
	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300,
	        time: 250,
	        threshold: 9,
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },
	    getTouchAction: function () {
	        return [TOUCH_ACTION_MANIPULATION];
	    },
	    process: function (input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;
	        this.reset();
	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }
	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }
	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;
	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            }
	            else {
	                this.count += 1;
	            }
	            this._input = input;
	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                }
	                else {
	                    this._timer = setTimeoutContext(function () {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },
	    failTimeout: function () {
	        this._timer = setTimeoutContext(function () {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },
	    reset: function () {
	        clearTimeout(this._timer);
	    },
	    emit: function () {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});
	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer$1(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, _defaults.preset);
	    return new Manager(element, options);
	}
	/**
	 * default settings
	 * @namespace
	 */
	var _defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,
	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,
	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,
	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,
	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,
	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, { enable: false }],
	        [PinchRecognizer, { enable: false }, ['rotate']],
	        [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
	        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],
	        [PressRecognizer]
	    ],
	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',
	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',
	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',
	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',
	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',
	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};
	var STOP = 1;
	var FORCED_STOP = 2;
	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, _defaults, options || {});
	    this.options.inputTarget = this.options.inputTarget || element;
	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);
	    toggleCssProps(this, true);
	    each(this.options.recognizers, function (item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}
	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function (options) {
	        assign(this.options, options);
	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },
	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function (force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },
	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function (inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }
	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);
	        var recognizer;
	        var recognizers = this.recognizers;
	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;
	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }
	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];
	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer ||
	                recognizer.canRecognizeWith(curRecognizer))) {
	                recognizer.recognize(inputData);
	            }
	            else {
	                recognizer.reset();
	            }
	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },
	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function (recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }
	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },
	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function (recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }
	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }
	        this.recognizers.push(recognizer);
	        recognizer.manager = this;
	        this.touchAction.update();
	        return recognizer;
	    },
	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function (recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }
	        recognizer = this.get(recognizer);
	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);
	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }
	        return this;
	    },
	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function (events, handler) {
	        var handlers = this.handlers;
	        each(splitStr(events), function (event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },
	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function (events, handler) {
	        var handlers = this.handlers;
	        each(splitStr(events), function (event) {
	            if (!handler) {
	                delete handlers[event];
	            }
	            else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },
	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function (event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }
	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }
	        data.type = event;
	        data.preventDefault = function () {
	            data.srcEvent.preventDefault();
	        };
	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },
	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function () {
	        this.element && toggleCssProps(this, false);
	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};
	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    each(manager.options.cssProps, function (value, name) {
	        element.style[prefixed(element.style, name)] = add ? value : '';
	    });
	}
	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = doc.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}
	assign(Hammer$1, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,
	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,
	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,
	    Manager: Manager,
	    Input: Input$1,
	    TouchAction: TouchAction,
	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,
	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,
	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});
	win$1.Hammer = Hammer$1;

	/**
	 * @private
	 * A gesture recognizer class.
	 *
	 * TODO(mlynch): Re-enable the DOM event simulation that was causing issues (or verify hammer does this already, it might);
	 */
	var Gesture = (function () {
	    function Gesture(element, opts) {
	        if (opts === void 0) { opts = {}; }
	        this._callbacks = {};
	        this.isListening = false;
	        defaults$1(opts, {
	            domEvents: true
	        });
	        this.element = element;
	        // Map 'x' or 'y' string to hammerjs opts
	        this.direction = opts.direction || 'x';
	        opts.direction = this.direction === 'x' ?
	            DIRECTION_HORIZONTAL :
	            DIRECTION_VERTICAL;
	        this._options = opts;
	    }
	    Gesture.prototype.options = function (opts) {
	        assign(this._options, opts);
	    };
	    Gesture.prototype.on = function (type, cb) {
	        if (type === 'pinch' || type === 'rotate') {
	            this._hammer.get('pinch').set({ enable: true });
	        }
	        this._hammer.on(type, cb);
	        (this._callbacks[type] || (this._callbacks[type] = [])).push(cb);
	    };
	    Gesture.prototype.off = function (type, cb) {
	        this._hammer.off(type, this._callbacks[type] ? cb : null);
	    };
	    Gesture.prototype.listen = function () {
	        if (!this.isListening) {
	            this._hammer = Hammer$1(this.element, this._options);
	        }
	        this.isListening = true;
	    };
	    Gesture.prototype.unlisten = function () {
	        var eventType;
	        var i;
	        if (this._hammer && this.isListening) {
	            for (eventType in this._callbacks) {
	                for (i = 0; i < this._callbacks[eventType].length; i++) {
	                    this._hammer.off(eventType, this._callbacks[eventType]);
	                }
	            }
	            this._hammer.destroy();
	        }
	        this._callbacks = {};
	        this._hammer = null;
	        this.isListening = false;
	    };
	    Gesture.prototype.destroy = function () {
	        this.unlisten();
	        this.element = this._options = null;
	    };
	    return Gesture;
	}());

	var __extends$5 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var DragGesture = (function (_super) {
	    __extends$5(DragGesture, _super);
	    function DragGesture(element, opts) {
	        if (opts === void 0) { opts = {}; }
	        defaults$1(opts, {});
	        _super.call(this, element, opts);
	    }
	    DragGesture.prototype.listen = function () {
	        var _this = this;
	        _super.prototype.listen.call(this);
	        this.on('panstart', function (ev) {
	            if (_this.onDragStart(ev) !== false) {
	                _this.dragging = true;
	            }
	        });
	        this.on('panmove', function (ev) {
	            if (!_this.dragging)
	                return;
	            if (_this.onDrag(ev) === false) {
	                _this.dragging = false;
	            }
	        });
	        this.on('panend', function (ev) {
	            if (!_this.dragging)
	                return;
	            _this.onDragEnd(ev);
	            _this.dragging = false;
	        });
	    };
	    DragGesture.prototype.onDrag = function (ev) { return true; };
	    DragGesture.prototype.onDragStart = function (ev) { return true; };
	    DragGesture.prototype.onDragEnd = function (ev) { };
	    return DragGesture;
	}(Gesture));

	var __extends$4 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var SlideGesture = (function (_super) {
	    __extends$4(SlideGesture, _super);
	    function SlideGesture(element, opts) {
	        if (opts === void 0) { opts = {}; }
	        _super.call(this, element, opts);
	        this.slide = null;
	        this.element = element;
	    }
	    /*
	     * Get the min and max for the slide. pageX/pageY.
	     * Only called on dragstart.
	     */
	    SlideGesture.prototype.getSlideBoundaries = function (slide, ev) {
	        return {
	            min: 0,
	            max: this.element.offsetWidth
	        };
	    };
	    /*
	     * Get the element's pos when the drag starts.
	     * For example, an open side menu starts at 100% and a closed
	     * sidemenu starts at 0%.
	     */
	    SlideGesture.prototype.getElementStartPos = function (slide, ev) {
	        return 0;
	    };
	    SlideGesture.prototype.canStart = function (ev) {
	        return true;
	    };
	    SlideGesture.prototype.onDragStart = function (ev) {
	        if (!this.canStart(ev)) {
	            return false;
	        }
	        this.slide = {};
	        this.onSlideBeforeStart(this.slide, ev);
	        var _a = this.getSlideBoundaries(this.slide, ev), min = _a.min, max = _a.max;
	        this.slide.min = min;
	        this.slide.max = max;
	        this.slide.elementStartPos = this.getElementStartPos(this.slide, ev);
	        this.slide.pointerStartPos = ev.center[this.direction];
	        this.slide.started = true;
	        this.onSlideStart(this.slide, ev);
	        return true;
	    };
	    SlideGesture.prototype.onDrag = function (ev) {
	        if (!this.slide || !this.slide.started) {
	            return false;
	        }
	        this.slide.pos = ev.center[this.direction];
	        this.slide.distance = clamp(this.slide.min, this.slide.pos - this.slide.pointerStartPos + this.slide.elementStartPos, this.slide.max);
	        this.slide.delta = this.slide.pos - this.slide.pointerStartPos;
	        this.onSlide(this.slide, ev);
	        return true;
	    };
	    SlideGesture.prototype.onDragEnd = function (ev) {
	        if (!this.slide || !this.slide.started)
	            return;
	        this.onSlideEnd(this.slide, ev);
	        this.slide = null;
	    };
	    SlideGesture.prototype.onSlideBeforeStart = function (slide, ev) { };
	    SlideGesture.prototype.onSlideStart = function (slide, ev) { };
	    SlideGesture.prototype.onSlide = function (slide, ev) { };
	    SlideGesture.prototype.onSlideEnd = function (slide, ev) { };
	    return SlideGesture;
	}(DragGesture));

	var __extends$3 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var SlideEdgeGesture = (function (_super) {
	    __extends$3(SlideEdgeGesture, _super);
	    function SlideEdgeGesture(element, opts) {
	        if (opts === void 0) { opts = {}; }
	        defaults$1(opts, {
	            edge: 'left',
	            maxEdgeStart: 50
	        });
	        _super.call(this, element, opts);
	        // Can check corners through use of eg 'left top'
	        this.edges = opts.edge.split(' ');
	        this.maxEdgeStart = opts.maxEdgeStart;
	    }
	    SlideEdgeGesture.prototype.canStart = function (ev) {
	        var _this = this;
	        this._d = this.getContainerDimensions();
	        return this.edges.every(function (edge) { return _this._checkEdge(edge, ev.center); });
	    };
	    SlideEdgeGesture.prototype.getContainerDimensions = function () {
	        return {
	            left: 0,
	            top: 0,
	            width: windowDimensions().width,
	            height: windowDimensions().height
	        };
	    };
	    SlideEdgeGesture.prototype._checkEdge = function (edge, pos) {
	        switch (edge) {
	            case 'left': return pos.x <= this._d.left + this.maxEdgeStart;
	            case 'right': return pos.x >= this._d.width - this.maxEdgeStart;
	            case 'top': return pos.y <= this._d.top + this.maxEdgeStart;
	            case 'bottom': return pos.y >= this._d.height - this.maxEdgeStart;
	        }
	    };
	    return SlideEdgeGesture;
	}(SlideGesture));

	var __extends$2 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SwipeBackGesture = (function (_super) {
	    __extends$2(SwipeBackGesture, _super);
	    function SwipeBackGesture(element, options, _nav, _menuCtrl) {
	        _super.call(this, element, assign({
	            direction: 'x',
	            maxEdgeStart: 75
	        }, options));
	        this._nav = _nav;
	        this._menuCtrl = _menuCtrl;
	    }
	    SwipeBackGesture.prototype.canStart = function (ev) {
	        // the gesture swipe angle must be mainly horizontal and the
	        // gesture distance would be relatively short for a swipe back
	        // and swipe back must be possible on this nav controller
	        if (ev.angle > -40 &&
	            ev.angle < 40 &&
	            ev.distance < 50 &&
	            this._nav.canSwipeBack()) {
	            // passed the tests, now see if the super says it's cool or not
	            return _super.prototype.canStart.call(this, ev);
	        }
	        // nerp, not today
	        return false;
	    };
	    SwipeBackGesture.prototype.onSlideBeforeStart = function (slideData, ev) {
	        console.debug('swipeBack, onSlideBeforeStart', ev.srcEvent.type);
	        this._nav.swipeBackStart();
	        this._menuCtrl.tempDisable(true);
	    };
	    SwipeBackGesture.prototype.onSlide = function (slide) {
	        var stepValue = (slide.distance / slide.max);
	        console.debug('swipeBack, onSlide, distance', slide.distance, 'max', slide.max, 'stepValue', stepValue);
	        this._nav.swipeBackProgress(stepValue);
	    };
	    SwipeBackGesture.prototype.onSlideEnd = function (slide, ev) {
	        var shouldComplete = (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5);
	        var currentStepValue = (slide.distance / slide.max);
	        console.debug('swipeBack, onSlideEnd, shouldComplete', shouldComplete, 'currentStepValue', currentStepValue);
	        this._nav.swipeBackEnd(shouldComplete, currentStepValue);
	        this._menuCtrl.tempDisable(false);
	    };
	    return SwipeBackGesture;
	}(SlideEdgeGesture));

	/**
	 * @private
	 *
	 * - play
	 * - Add before classes - DOM WRITE
	 * - Remove before classes - DOM WRITE
	 * - Add before inline styles - DOM WRITE
	 * - set inline FROM styles - DOM WRITE
	 * - RAF
	 * - run before functions that have dom reads - DOM READ
	 * - run before functions that have dom writes - DOM WRITE
	 * - set css transition duration/easing - DOM WRITE
	 * - RAF
	 * - set inline TO styles - DOM WRITE
	 */
	var Animation = (function () {
	    function Animation(ele, opts) {
	        if (opts === void 0) { opts = {}; }
	        this._c = [];
	        this._el = [];
	        this._fx = {};
	        this._dur = null;
	        this._easing = null;
	        this._bfSty = {};
	        this._bfAdd = [];
	        this._bfRmv = [];
	        this._afSty = {};
	        this._afAdd = [];
	        this._afRmv = [];
	        this._bfReadFns = [];
	        this._bfWriteFns = [];
	        this._fFns = [];
	        this._fOnceFns = [];
	        this._rv = false;
	        this._lastUpd = 0;
	        this.isPlaying = false;
	        this.hasTween = false;
	        this.hasCompleted = false;
	        this.element(ele);
	        this._opts = assign({
	            renderDelay: 24
	        }, opts);
	    }
	    /**
	     * NO DOM
	     */
	    Animation.prototype._reset = function () {
	        this._fx = {};
	        this._bfSty = {};
	        this._afSty = {};
	        this._el.length = this._c.length = this._bfAdd.length = this._bfRmv.length = this._afAdd.length = this._afRmv.length = this._fFns.length = this._bfReadFns.length = this._bfWriteFns.length = this._fOnceFns.length = 0;
	        this._easing = this._dur = null;
	    };
	    Animation.prototype.element = function (ele) {
	        var i;
	        if (ele) {
	            if (ele.length) {
	                for (i = 0; i < ele.length; i++) {
	                    this._addEle(ele[i]);
	                }
	            }
	            else if (typeof ele === 'string') {
	                ele = document.querySelectorAll(ele);
	                for (i = 0; i < ele.length; i++) {
	                    this._addEle(ele[i]);
	                }
	            }
	            else {
	                this._addEle(ele);
	            }
	        }
	        return this;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype._addEle = function (ele) {
	        if (ele.nativeElement) {
	            ele = ele.nativeElement;
	        }
	        if (ele.nodeType === 1) {
	            this._el.push(ele);
	        }
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.parent = function (parentAnimation) {
	        this._parent = parentAnimation;
	        return this;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.add = function (childAnimation) {
	        childAnimation.parent(this);
	        this._c.push(childAnimation);
	        return this;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.getDuration = function () {
	        return this._dur !== null ? this._dur : (this._parent && this._parent.getDuration()) || 0;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.duration = function (milliseconds) {
	        this._dur = milliseconds;
	        return this;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.getEasing = function () {
	        return this._easing !== null ? this._easing : (this._parent && this._parent.getEasing()) || null;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.easing = function (name) {
	        this._easing = name;
	        return this;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.from = function (prop, val) {
	        this._addProp('from', prop, val);
	        return this;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.to = function (prop, val, clearProperyAfterTransition) {
	        var fx = this._addProp('to', prop, val);
	        if (clearProperyAfterTransition) {
	            // if this effect is a transform then clear the transform effect
	            // otherwise just clear the actual property
	            this.after.clearStyles([fx.trans ? CSS.transform : prop]);
	        }
	        return this;
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.fromTo = function (prop, fromVal, toVal, clearProperyAfterTransition) {
	        return this.from(prop, fromVal).to(prop, toVal, clearProperyAfterTransition);
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype._addProp = function (state, prop, val) {
	        var fxProp = this._fx[prop];
	        if (!fxProp) {
	            // first time we've see this EffectProperty
	            fxProp = this._fx[prop] = {
	                trans: (typeof TRANSFORMS[prop] !== 'undefined'),
	                wc: ''
	            };
	            // add the will-change property for transforms or opacity
	            if (fxProp.trans) {
	                fxProp.wc = CSS.transform;
	            }
	            else if (prop === 'opacity') {
	                fxProp.wc = prop;
	            }
	        }
	        // add from/to EffectState to the EffectProperty
	        var fxState = fxProp[state] = {
	            val: val,
	            num: null,
	            unit: '',
	        };
	        if (typeof val === 'string' && val.indexOf(' ') < 0) {
	            var r = val.match(CSS_VALUE_REGEX);
	            var num = parseFloat(r[1]);
	            if (!isNaN(num)) {
	                fxState.num = num;
	            }
	            fxState.unit = (r[0] !== r[2] ? r[2] : '');
	        }
	        else if (typeof val === 'number') {
	            fxState.num = val;
	        }
	        return fxProp;
	    };
	    Object.defineProperty(Animation.prototype, "before", {
	        /**
	         * NO DOM
	         */
	        get: function () {
	            var _this = this;
	            return {
	                addClass: function (className) {
	                    _this._bfAdd.push(className);
	                    return _this;
	                },
	                removeClass: function (className) {
	                    _this._bfRmv.push(className);
	                    return _this;
	                },
	                setStyles: function (styles) {
	                    _this._bfSty = styles;
	                    return _this;
	                },
	                clearStyles: function (propertyNames) {
	                    for (var i = 0; i < propertyNames.length; i++) {
	                        _this._bfSty[propertyNames[i]] = '';
	                    }
	                    return _this;
	                },
	                addDomReadFn: function (domReadFn) {
	                    _this._bfReadFns.push(domReadFn);
	                    return _this;
	                },
	                addDomWriteFn: function (domWriteFn) {
	                    _this._bfWriteFns.push(domWriteFn);
	                    return _this;
	                }
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Animation.prototype, "after", {
	        /**
	         * NO DOM
	         */
	        get: function () {
	            var _this = this;
	            return {
	                addClass: function (className) {
	                    _this._afAdd.push(className);
	                    return _this;
	                },
	                removeClass: function (className) {
	                    _this._afRmv.push(className);
	                    return _this;
	                },
	                setStyles: function (styles) {
	                    _this._afSty = styles;
	                    return _this;
	                },
	                clearStyles: function (propertyNames) {
	                    for (var i = 0; i < propertyNames.length; i++) {
	                        _this._afSty[propertyNames[i]] = '';
	                    }
	                    return _this;
	                }
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype.play = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        var self = this;
	        var i;
	        if (isDefined(opts.duration)) {
	            self._dur = opts.duration;
	        }
	        console.debug('Animation, play, duration', self._dur, 'easing', self._easing);
	        // always default that an animation does not tween
	        // a tween requires that an Animation class has an element
	        // and that it has at least one FROM/TO effect
	        // and that the FROM/TO effect can tween numeric values
	        self.hasTween = false;
	        self.hasCompleted = false;
	        self.isPlaying = true;
	        // this is the top level animation and is in full control
	        // of when the async play() should actually kick off
	        // if there is no duration then it'll set the TO property immediately
	        // if there is a duration, then it'll stage all animations at the
	        // FROM property and transition duration, wait a few frames, then
	        // kick off the animation by setting the TO property for each animation
	        // ensure all past transition end events have been cleared
	        self._clearAsync();
	        if (self._dur > 30) {
	            // this animation has a duration, so it should animate
	            // place all the elements with their FROM properties
	            // set the FROM properties
	            // ******** DOM WRITE ****************
	            self._progress(0);
	            // add the will-change or translateZ properties when applicable
	            // ******** DOM WRITE ****************
	            self._willChg(true);
	            // set the async TRANSITION END event
	            // and run onFinishes when the transition ends
	            // ******** DOM WRITE ****************
	            self._asyncEnd(self._dur, true);
	            // begin each animation when everything is rendered in their place
	            // and the transition duration/easing is ready to go
	            rafFrames(self._opts.renderDelay / 16, function () {
	                // there's been a moment and the elements are in place
	                // fire off all the "before" function that have DOM READS in them
	                // elements will be in the DOM, however visibily hidden
	                // so we can read their dimensions if need be
	                // ******** DOM READ ****************
	                self._beforeReadFn();
	                // ******** DOM READS ABOVE / DOM WRITES BELOW ****************
	                // fire off all the "before" function that have DOM WRITES in them
	                // ******** DOM WRITE ****************
	                self._beforeWriteFn();
	                // stage all of the before css classes and inline styles
	                // will recursively stage all child elements
	                // ******** DOM WRITE ****************
	                self._before();
	                // now set the TRANSITION duration/easing
	                // ******** DOM WRITE ****************
	                self._setTrans(self._dur, false);
	                // wait a few moments again to wait for the transition
	                // info to take hold in the DOM
	                rafFrames(2, function () {
	                    // browser had some time to render everything in place
	                    // and the transition duration/easing is set
	                    // now set the TO properties
	                    // which will trigger the transition to begin
	                    // ******** DOM WRITE ****************
	                    self._progress(1);
	                });
	            });
	        }
	        else {
	            // this animation does not have a duration
	            // but we still need to apply the styles and wait
	            // a frame so we can accurately read the dimensions
	            rafFrames(self._opts.renderDelay / 16, function () {
	                // fire off all the "before" function that have DOM READS in them
	                // elements will be in the DOM, however visibily hidden
	                // so we can read their dimensions if need be
	                // ******** DOM READ ****************
	                self._beforeReadFn();
	                // ******** DOM READS ABOVE / DOM WRITES BELOW ****************
	                // fire off all the "before" function that have DOM WRITES in them
	                // ******** DOM WRITE ****************
	                self._beforeWriteFn();
	                // ensure before css has ran
	                // ******** DOM WRITE ****************
	                self._before();
	                // this animation does not have a duration, so it should not animate
	                // just go straight to the TO properties and call it done
	                // ******** DOM WRITE ****************
	                self._progress(1);
	                // since there was no animation, immediately run the after
	                // ******** DOM WRITE ****************
	                self._after();
	                // since there was no animation, it's done
	                // fire off all the onFinishes
	                // and now you know
	                self._didFinish(true);
	            });
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype.stop = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        var self = this;
	        var duration = isDefined(opts.duration) ? opts.duration : 0;
	        var stepValue = isDefined(opts.stepValue) ? opts.stepValue : 1;
	        // ensure all past transition end events have been cleared
	        this._clearAsync();
	        // set the TO properties
	        // ******** DOM WRITE ****************
	        self._progress(stepValue);
	        if (duration > 30) {
	            // this animation has a duration, so it should animate
	            // place all the elements with their TO properties
	            // now set the TRANSITION duration
	            // ******** DOM WRITE ****************
	            self._setTrans(duration, true);
	            // set the async TRANSITION END event
	            // and run onFinishes when the transition ends
	            // ******** DOM WRITE ****************
	            self._asyncEnd(duration, false);
	        }
	        else {
	            // this animation does not have a duration, so it should not animate
	            // just go straight to the TO properties and call it done
	            // ******** DOM WRITE ****************
	            self._after();
	            // since there was no animation, it's done
	            // fire off all the onFinishes
	            self._didFinish(false);
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype._asyncEnd = function (duration, shouldComplete) {
	        var self = this;
	        function onTransitionEnd(ev) {
	            console.debug('Animation onTransitionEnd', ev.target.nodeName, ev.propertyName);
	            // ensure transition end events and timeouts have been cleared
	            self._clearAsync();
	            // set the after styles
	            // ******** DOM WRITE ****************
	            self._after();
	            // remove will change properties
	            // ******** DOM WRITE ****************
	            self._willChg(false);
	            // transition finished
	            self._didFinish(shouldComplete);
	        }
	        function onTransitionFallback() {
	            console.debug('Animation onTransitionFallback');
	            // oh noz! the transition end event didn't fire in time!
	            // instead the fallback timer when first
	            // clear the other async end events from firing
	            self._tmr = 0;
	            self._clearAsync();
	            // too late to have a smooth animation, just finish it
	            // ******** DOM WRITE ****************
	            self._setTrans(0, true);
	            // ensure the ending progress step gets rendered
	            // ******** DOM WRITE ****************
	            self._progress(1);
	            // set the after styles
	            // ******** DOM WRITE ****************
	            self._after();
	            // remove will change properties
	            // ******** DOM WRITE ****************
	            self._willChg(false);
	            // transition finished
	            self._didFinish(shouldComplete);
	        }
	        // set the TRANSITION END event on one of the transition elements
	        self._unregTrans = transitionEnd(self._transEl(), onTransitionEnd);
	        // set a fallback timeout if the transition end event never fires, or is too slow
	        // transition end fallback: (animation duration + XXms)
	        self._tmr = nativeTimeout(onTransitionFallback, duration + 400);
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype._clearAsync = function () {
	        this._unregTrans && this._unregTrans();
	        if (this._tmr) {
	            clearTimeout(this._tmr);
	            this._tmr = 0;
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype._progress = function (stepValue) {
	        // bread 'n butter
	        var i;
	        var prop;
	        var fx;
	        var val;
	        var transforms;
	        var tweenEffect;
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i]._progress(stepValue);
	        }
	        if (this._el.length) {
	            // flip the number if we're going in reverse
	            if (this._rv) {
	                stepValue = ((stepValue * -1) + 1);
	            }
	            transforms = [];
	            for (prop in this._fx) {
	                fx = this._fx[prop];
	                if (fx.from && fx.to) {
	                    tweenEffect = (fx.from.num !== fx.to.num);
	                    if (tweenEffect) {
	                        this.hasTween = true;
	                    }
	                    if (stepValue === 0) {
	                        // FROM
	                        val = fx.from.val;
	                    }
	                    else if (stepValue === 1) {
	                        // TO
	                        val = fx.to.val;
	                    }
	                    else if (tweenEffect) {
	                        // EVERYTHING IN BETWEEN
	                        val = (((fx.to.num - fx.from.num) * stepValue) + fx.from.num) + fx.to.unit;
	                    }
	                    else {
	                        val = null;
	                    }
	                    if (val !== null) {
	                        if (fx.trans) {
	                            transforms.push(prop + '(' + val + ')');
	                        }
	                        else {
	                            for (i = 0; i < this._el.length; i++) {
	                                // ******** DOM WRITE ****************
	                                this._el[i].style[prop] = val;
	                            }
	                        }
	                    }
	                }
	            }
	            // place all transforms on the same property
	            if (transforms.length) {
	                if (!SUPPORTS_WILL_CHANGE) {
	                    // if the element doesn't support will-change
	                    // then auto add translateZ for transform properties
	                    transforms.push('translateZ(0px)');
	                }
	                for (i = 0; i < this._el.length; i++) {
	                    // ******** DOM WRITE ****************
	                    this._el[i].style[CSS.transform] = transforms.join(' ');
	                }
	            }
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype._setTrans = function (duration, forcedLinearEasing) {
	        var i;
	        var easing;
	        // set the TRANSITION properties inline on the element
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i]._setTrans(duration, forcedLinearEasing);
	        }
	        if (Object.keys(this._fx).length) {
	            easing = (forcedLinearEasing ? 'linear' : this.getEasing());
	            for (i = 0; i < this._el.length; i++) {
	                if (duration > 0) {
	                    // all parent/child animations should have the same duration
	                    // ******** DOM WRITE ****************
	                    this._el[i].style[CSS.transition] = '';
	                    this._el[i].style[CSS.transitionDuration] = duration + 'ms';
	                    // each animation can have a different easing
	                    if (easing) {
	                        // ******** DOM WRITE ****************
	                        this._el[i].style[CSS.transitionTimingFn] = easing;
	                    }
	                }
	                else {
	                    this._el[i].style[CSS.transition] = 'none';
	                }
	            }
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype._willChg = function (addWillChange) {
	        var i;
	        var wc;
	        var prop;
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i]._willChg(addWillChange);
	        }
	        if (SUPPORTS_WILL_CHANGE) {
	            wc = [];
	            if (addWillChange) {
	                for (prop in this._fx) {
	                    if (this._fx[prop].wc !== '') {
	                        if (this._fx[prop].wc === 'webkitTransform') {
	                            wc.push('transform', '-webkit-transform');
	                        }
	                        else {
	                            wc.push(this._fx[prop].wc);
	                        }
	                    }
	                }
	            }
	            for (i = 0; i < this._el.length; i++) {
	                // ******** DOM WRITE ****************
	                this._el[i].style['willChange'] = wc.join(',');
	            }
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype._before = function () {
	        // before the RENDER_DELAY
	        // before the animations have started
	        var i;
	        var j;
	        var prop;
	        var ele;
	        // stage all of the child animations
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i]._before();
	        }
	        if (!this._rv) {
	            for (i = 0; i < this._el.length; i++) {
	                ele = this._el[i];
	                // css classes to add before the animation
	                for (j = 0; j < this._bfAdd.length; j++) {
	                    // ******** DOM WRITE ****************
	                    ele.classList.add(this._bfAdd[j]);
	                }
	                // css classes to remove before the animation
	                for (j = 0; j < this._bfRmv.length; j++) {
	                    // ******** DOM WRITE ****************
	                    ele.classList.remove(this._bfRmv[j]);
	                }
	                // inline styles to add before the animation
	                for (prop in this._bfSty) {
	                    // ******** DOM WRITE ****************
	                    ele.style[prop] = this._bfSty[prop];
	                }
	            }
	        }
	    };
	    /**
	     * DOM READ
	     */
	    Animation.prototype._beforeReadFn = function () {
	        var i;
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM READ ****************
	            this._c[i]._beforeReadFn();
	        }
	        for (i = 0; i < this._bfReadFns.length; i++) {
	            // ******** DOM READ ****************
	            this._bfReadFns[i]();
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype._beforeWriteFn = function () {
	        var i;
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i]._beforeWriteFn();
	        }
	        for (i = 0; i < this._bfReadFns.length; i++) {
	            // ******** DOM WRITE ****************
	            this._bfWriteFns[i]();
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype._after = function () {
	        // after the animations have finished
	        var i;
	        var j;
	        var prop;
	        var ele;
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i]._after();
	        }
	        for (i = 0; i < this._el.length; i++) {
	            ele = this._el[i];
	            // remove the transition duration/easing
	            // ******** DOM WRITE ****************
	            ele.style[CSS.transitionDuration] = '';
	            // ******** DOM WRITE ****************
	            ele.style[CSS.transitionTimingFn] = '';
	            if (this._rv) {
	                // finished in reverse direction
	                // css classes that were added before the animation should be removed
	                for (j = 0; j < this._bfAdd.length; j++) {
	                    // ******** DOM WRITE ****************
	                    ele.classList.remove(this._bfAdd[j]);
	                }
	                // css classes that were removed before the animation should be added
	                for (j = 0; j < this._bfRmv.length; j++) {
	                    // ******** DOM WRITE ****************
	                    ele.classList.add(this._bfRmv[j]);
	                }
	                // inline styles that were added before the animation should be removed
	                for (prop in this._bfSty) {
	                    // ******** DOM WRITE ****************
	                    ele.style[prop] = '';
	                }
	            }
	            else {
	                // finished in forward direction
	                // css classes to add after the animation
	                for (j = 0; j < this._afAdd.length; j++) {
	                    // ******** DOM WRITE ****************
	                    ele.classList.add(this._afAdd[j]);
	                }
	                // css classes to remove after the animation
	                for (j = 0; j < this._afRmv.length; j++) {
	                    // ******** DOM WRITE ****************
	                    ele.classList.remove(this._afRmv[j]);
	                }
	                // inline styles to add after the animation
	                for (prop in this._afSty) {
	                    // ******** DOM WRITE ****************
	                    ele.style[prop] = this._afSty[prop];
	                }
	            }
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype.progressStart = function () {
	        for (var i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i].progressStart();
	        }
	        // ******** DOM WRITE ****************
	        this._willChg(true);
	        // ******** DOM WRITE ****************
	        this._before();
	        // force no duration, linear easing
	        // ******** DOM WRITE ****************
	        this._setTrans(0, true);
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype.progressStep = function (stepValue) {
	        var now = Date.now();
	        // only update if the last update was more than 16ms ago
	        if (now - 16 > this._lastUpd) {
	            this._lastUpd = now;
	            stepValue = Math.min(1, Math.max(0, stepValue));
	            for (var i = 0; i < this._c.length; i++) {
	                // ******** DOM WRITE ****************
	                this._c[i].progressStep(stepValue);
	            }
	            if (this._rv) {
	                // if the animation is going in reverse then
	                // flip the step value: 0 becomes 1, 1 becomes 0
	                stepValue = ((stepValue * -1) + 1);
	            }
	            // ******** DOM WRITE ****************
	            this._progress(stepValue);
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype.progressEnd = function (shouldComplete, currentStepValue) {
	        console.debug('Animation, progressEnd, shouldComplete', shouldComplete, 'currentStepValue', currentStepValue);
	        for (var i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i].progressEnd(shouldComplete, currentStepValue);
	        }
	        // set all the animations to their final position
	        // ******** DOM WRITE ****************
	        this._progress(shouldComplete ? 1 : 0);
	        // if it's already at the final position, or close, then it's done
	        // otherwise we need to add a transition end event listener
	        if (currentStepValue < 0.05 || currentStepValue > 0.95) {
	            // the progress was already left off at the point that is finished
	            // for example, the left menu was dragged all the way open already
	            // ******** DOM WRITE ****************
	            this._after();
	            // ******** DOM WRITE ****************
	            this._willChg(false);
	            this._didFinish(shouldComplete);
	        }
	        else {
	            // the stepValue was left off at a point when it needs to finish transition still
	            // for example, the left menu was opened 75% and needs to finish opening
	            // ******** DOM WRITE ****************
	            this._asyncEnd(64, shouldComplete);
	            // force quick duration, linear easing
	            // ******** DOM WRITE ****************
	            this._setTrans(64, true);
	        }
	    };
	    /**
	     * POSSIBLE DOM READ/WRITE
	     */
	    Animation.prototype.onFinish = function (callback, onceTimeCallback, clearOnFinishCallacks) {
	        if (onceTimeCallback === void 0) { onceTimeCallback = false; }
	        if (clearOnFinishCallacks === void 0) { clearOnFinishCallacks = false; }
	        if (clearOnFinishCallacks) {
	            this._fFns = [];
	            this._fOnceFns = [];
	        }
	        if (onceTimeCallback) {
	            this._fOnceFns.push(callback);
	        }
	        else {
	            this._fFns.push(callback);
	        }
	        return this;
	    };
	    /**
	     * POSSIBLE DOM READ/WRITE
	     */
	    Animation.prototype._didFinish = function (hasCompleted) {
	        this.isPlaying = false;
	        this.hasCompleted = hasCompleted;
	        var i;
	        for (i = 0; i < this._fFns.length; i++) {
	            this._fFns[i](this);
	        }
	        for (i = 0; i < this._fOnceFns.length; i++) {
	            this._fOnceFns[i](this);
	        }
	        this._fOnceFns = [];
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype.reverse = function (shouldReverse) {
	        if (shouldReverse === void 0) { shouldReverse = true; }
	        for (var i = 0; i < this._c.length; i++) {
	            this._c[i].reverse(shouldReverse);
	        }
	        this._rv = shouldReverse;
	        return this;
	    };
	    /**
	     * DOM WRITE
	     */
	    Animation.prototype.destroy = function (removeElement) {
	        var i;
	        var ele;
	        for (i = 0; i < this._c.length; i++) {
	            // ******** DOM WRITE ****************
	            this._c[i].destroy(removeElement);
	        }
	        if (removeElement) {
	            for (i = 0; i < this._el.length; i++) {
	                ele = this._el[i];
	                // ******** DOM WRITE ****************
	                ele.parentNode && ele.parentNode.removeChild(ele);
	            }
	        }
	        this._clearAsync();
	        this._reset();
	    };
	    /**
	     * NO DOM
	     */
	    Animation.prototype._transEl = function () {
	        // get the lowest level element that has an Animation
	        var i;
	        var targetEl;
	        for (i = 0; i < this._c.length; i++) {
	            targetEl = this._c[i]._transEl();
	            if (targetEl) {
	                return targetEl;
	            }
	        }
	        return (this.hasTween && this._el.length ? this._el[0] : null);
	    };
	    // ***** STATIC CLASSES *********
	    Animation.create = function (name, opts) {
	        if (opts === void 0) { opts = {}; }
	        var AnimationClass = AnimationRegistry[name];
	        if (!AnimationClass) {
	            // couldn't find an animation by the given name
	            // fallback to just the base Animation class
	            AnimationClass = Animation;
	        }
	        return new AnimationClass(null, opts);
	    };
	    Animation.register = function (name, AnimationClass) {
	        AnimationRegistry[name] = AnimationClass;
	    };
	    return Animation;
	}());
	var TRANSFORMS = {
	    'translateX': 1, 'translateY': 1, 'translateZ': 1,
	    'scale': 1, 'scaleX': 1, 'scaleY': 1, 'scaleZ': 1,
	    'rotate': 1, 'rotateX': 1, 'rotateY': 1, 'rotateZ': 1,
	    'skewX': 1, 'skewY': 1, 'perspective': 1
	};
	var CSS_VALUE_REGEX = /(^-?\d*\.?\d*)(.*)/;
	var SUPPORTS_WILL_CHANGE = (typeof document.documentElement.style['willChange'] !== 'undefined');
	var AnimationRegistry = {};

	var __extends$6 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 *
	 * - play
	 * - Add before classes - DOM WRITE
	 * - Remove before classes - DOM WRITE
	 * - Add before inline styles - DOM WRITE
	 * - set inline FROM styles - DOM WRITE
	 * - RAF
	 * - read toolbar dimensions - DOM READ
	 * - write content top/bottom padding - DOM WRITE
	 * - set css transition duration/easing - DOM WRITE
	 * - RAF
	 * - set inline TO styles - DOM WRITE
	 */
	var Transition = (function (_super) {
	    __extends$6(Transition, _super);
	    function Transition(enteringView, leavingView, opts) {
	        _super.call(this, null, {
	            renderDelay: opts.renderDelay
	        });
	        this.enteringView = enteringView;
	    }
	    Transition.createTransition = function (enteringView, leavingView, opts) {
	        var TransitionClass = TransitionRegistry[opts.animation];
	        if (!TransitionClass) {
	            // didn't find a transition animation, default to ios-transition
	            TransitionClass = TransitionRegistry['ios-transition'];
	        }
	        return new TransitionClass(enteringView, leavingView, opts);
	    };
	    Transition.register = function (name, TransitionClass) {
	        TransitionRegistry[name] = TransitionClass;
	    };
	    return Transition;
	}(Animation));
	var TransitionRegistry = {};

	/**
	 * @name ViewController
	 * @description
	 * Access various features and information about the current view.
	 * @usage
	 *  ```ts
	 * import { Component } from '@angular/core';
	 * import { ViewController } from 'ionic-angular';
	 *
	 * @Component({...})
	 * export class MyPage{
	 *
	 *   constructor(public viewCtrl: ViewController) {}
	 *
	 * }
	 * ```
	 */
	var ViewController = (function () {
	    function ViewController(componentType, data) {
	        this.componentType = componentType;
	        this._tbRefs = [];
	        this._hdAttr = null;
	        this._leavingOpts = null;
	        this._loaded = false;
	        this._onDidDismiss = null;
	        this._onWillDismiss = null;
	        /**
	         * @private
	         */
	        this.instance = {};
	        /**
	         * @private
	         */
	        this.state = 0;
	        /**
	         * @private
	         * If this is currently the active view, then set to false
	         * if it does not want the other views to fire their own lifecycles.
	         */
	        this.fireOtherLifecycles = true;
	        /**
	         * @private
	         */
	        this.isOverlay = false;
	        this._emitter = new EventEmitter();
	        // passed in data could be NavParams, but all we care about is its data object
	        this.data = (data instanceof NavParams ? data.data : (isPresent$5(data) ? data : {}));
	        this.willEnter = new EventEmitter();
	        this.didEnter = new EventEmitter();
	        this.willLeave = new EventEmitter();
	        this.didLeave = new EventEmitter();
	        this.willUnload = new EventEmitter();
	        this.didUnload = new EventEmitter();
	    }
	    /**
	     * @private
	     */
	    ViewController.prototype.subscribe = function (generatorOrNext) {
	        return this._emitter.subscribe(generatorOrNext);
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.emit = function (data) {
	        this._emitter.emit(data);
	    };
	    /**
	     * @private
	     * onDismiss(..) has been deprecated. Please use onDidDismiss(..) instead
	     */
	    ViewController.prototype.onDismiss = function (callback) {
	        // deprecated warning: added beta.11 2016-06-30
	        console.warn('onDismiss(..) has been deprecated. Please use onDidDismiss(..) instead');
	        this.onDidDismiss(callback);
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.onDidDismiss = function (callback) {
	        this._onDidDismiss = callback;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.onWillDismiss = function (callback) {
	        this._onWillDismiss = callback;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.dismiss = function (data, role, navOptions) {
	        var _this = this;
	        if (navOptions === void 0) { navOptions = {}; }
	        var options = merge$1({}, this._leavingOpts, navOptions);
	        this._onWillDismiss && this._onWillDismiss(data, role);
	        return this._nav.remove(this._nav.indexOf(this), 1, options).then(function () {
	            _this._onDidDismiss && _this._onDidDismiss(data, role);
	            return data;
	        });
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setNav = function (navCtrl) {
	        this._nav = navCtrl;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.getNav = function () {
	        return this._nav;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.getTransitionName = function (direction) {
	        return this._nav && this._nav.config.get('pageTransition');
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.getNavParams = function () {
	        return new NavParams(this.data);
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setLeavingOpts = function (opts) {
	        this._leavingOpts = opts;
	    };
	    /**
	     * Check to see if you can go back in the navigation stack.
	     * @param {boolean} Check whether or not you can go back from this page
	     * @returns {boolean} Returns if it's possible to go back from this Page.
	     */
	    ViewController.prototype.enableBack = function () {
	        // update if it's possible to go back from this nav item
	        if (this._nav) {
	            var previousItem = this._nav.getPrevious(this);
	            // the previous view may exist, but if it's about to be destroyed
	            // it shouldn't be able to go back to
	            return !!(previousItem);
	        }
	        return false;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setChangeDetector = function (cd) {
	        this._cd = cd;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setInstance = function (instance) {
	        this.instance = instance;
	    };
	    Object.defineProperty(ViewController.prototype, "name", {
	        /**
	         * @private
	         */
	        get: function () {
	            return this.componentType ? this.componentType['name'] : '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewController.prototype, "index", {
	        /**
	         * Get the index of the current component in the current navigation stack.
	         * @returns {number} Returns the index of this page within its `NavController`.
	         */
	        get: function () {
	            return (this._nav ? this._nav.indexOf(this) : -1);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @returns {boolean} Returns if this Page is the first in the stack of pages within its NavController.
	     */
	    ViewController.prototype.isFirst = function () {
	        return (this._nav ? this._nav.first() === this : false);
	    };
	    /**
	     * @returns {boolean} Returns if this Page is the last in the stack of pages within its NavController.
	     */
	    ViewController.prototype.isLast = function () {
	        return (this._nav ? this._nav.last() === this : false);
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.domShow = function (shouldShow, renderer) {
	        // using hidden element attribute to display:none and not render views
	        // renderAttr of '' means the hidden attribute will be added
	        // renderAttr of null means the hidden attribute will be removed
	        // doing checks to make sure we only make an update to the element when needed
	        if (this._pgRef &&
	            (shouldShow && this._hdAttr === '' ||
	                !shouldShow && this._hdAttr !== '')) {
	            this._hdAttr = (shouldShow ? null : '');
	            renderer.setElementAttribute(this._pgRef.nativeElement, 'hidden', this._hdAttr);
	        }
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setZIndex = function (zIndex, renderer) {
	        if (this._pgRef && zIndex !== this.zIndex) {
	            this.zIndex = zIndex;
	            renderer.setElementStyle(this._pgRef.nativeElement, 'z-index', zIndex.toString());
	        }
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setPageRef = function (elementRef) {
	        this._pgRef = elementRef;
	    };
	    /**
	     * @private
	     * @returns {elementRef} Returns the Page's ElementRef
	     */
	    ViewController.prototype.pageRef = function () {
	        return this._pgRef;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setContentRef = function (elementRef) {
	        this._cntRef = elementRef;
	    };
	    /**
	     * @private
	     * @returns {elementRef} Returns the Page's Content ElementRef
	     */
	    ViewController.prototype.contentRef = function () {
	        return this._cntRef;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setContent = function (directive) {
	        this._cntDir = directive;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setToolbarRef = function (elementRef) {
	        this._tbRefs.push(elementRef);
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.toolbarRefs = function () {
	        return this._tbRefs;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setHeader = function (directive) {
	        this._hdrDir = directive;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.getHeader = function () {
	        return this._hdrDir;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setFooter = function (directive) {
	        this._ftrDir = directive;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.getFooter = function () {
	        return this._ftrDir;
	    };
	    /**
	     * @private
	     * @returns {component} Returns the Page's Content component reference.
	     */
	    ViewController.prototype.getContent = function () {
	        return this._cntDir;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.setNavbar = function (directive) {
	        this._nbDir = directive;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.getNavbar = function () {
	        return this._nbDir;
	    };
	    /**
	     *
	     * Find out if the current component has a NavBar or not. Be sure
	     * to wrap this in an `ionViewWillEnter` method in order to make sure
	     * the view has rendered fully.
	     * @returns {boolean} Returns a boolean if this Page has a navbar or not.
	     */
	    ViewController.prototype.hasNavbar = function () {
	        return !!this.getNavbar();
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.navbarRef = function () {
	        var navbar = this.getNavbar();
	        return navbar && navbar.getElementRef();
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.titleRef = function () {
	        var navbar = this.getNavbar();
	        return navbar && navbar.getTitleRef();
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.navbarItemRefs = function () {
	        var navbar = this.getNavbar();
	        return navbar && navbar.getItemRefs();
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.backBtnRef = function () {
	        var navbar = this.getNavbar();
	        return navbar && navbar.getBackButtonRef();
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.backBtnTextRef = function () {
	        var navbar = this.getNavbar();
	        return navbar && navbar.getBackButtonTextRef();
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.navbarBgRef = function () {
	        var navbar = this.getNavbar();
	        return navbar && navbar.getBackgroundRef();
	    };
	    /**
	     * Change the title of the back-button. Be sure to call this
	     * after `ionViewWillEnter` to make sure the  DOM has been rendered.
	     * @param {string} backButtonText Set the back button text.
	     */
	    ViewController.prototype.setBackButtonText = function (val) {
	        var navbar = this.getNavbar();
	        if (navbar) {
	            navbar.setBackButtonText(val);
	        }
	    };
	    /**
	     * Set if the back button for the current view is visible or not. Be sure to call this
	     * after `ionViewWillEnter` to make sure the  DOM has been rendered.
	     * @param {boolean} Set if this Page's back button should show or not.
	     */
	    ViewController.prototype.showBackButton = function (shouldShow) {
	        var navbar = this.getNavbar();
	        if (navbar) {
	            navbar.hideBackButton = !shouldShow;
	        }
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.isLoaded = function () {
	        return this._loaded;
	    };
	    /**
	     * The loaded method is used to load any dynamic content/components
	     * into the dom before proceeding with the transition.  If a component
	     * needs dynamic component loading, extending ViewController and
	     * overriding this method is a good option
	     * @param {function} done is a callback that must be called when async
	     * loading/actions are completed
	     */
	    ViewController.prototype.loaded = function (done) {
	        done();
	    };
	    /**
	     * @private
	     * The view has loaded. This event only happens once per view being
	     * created. If a view leaves but is cached, then this will not
	     * fire again on a subsequent viewing. This method is a good place
	     * to put your setup code for the view; however, it is not the
	     * recommended method to use when a view becomes active.
	     */
	    ViewController.prototype.fireLoaded = function () {
	        this._loaded = true;
	        ctrlFn(this, 'Loaded');
	    };
	    /**
	     * @private
	     * The view is about to enter and become the active view.
	     */
	    ViewController.prototype.fireWillEnter = function () {
	        if (this._cd) {
	            // ensure this has been re-attached to the change detector
	            this._cd.reattach();
	            // detect changes before we run any user code
	            this._cd.detectChanges();
	        }
	        this.willEnter.emit(null);
	        ctrlFn(this, 'WillEnter');
	    };
	    /**
	     * @private
	     * The view has fully entered and is now the active view. This
	     * will fire, whether it was the first load or loaded from the cache.
	     */
	    ViewController.prototype.fireDidEnter = function () {
	        var navbar = this.getNavbar();
	        navbar && navbar.didEnter();
	        this.didEnter.emit(null);
	        ctrlFn(this, 'DidEnter');
	    };
	    /**
	     * @private
	     * The view has is about to leave and no longer be the active view.
	     */
	    ViewController.prototype.fireWillLeave = function () {
	        this.willLeave.emit(null);
	        ctrlFn(this, 'WillLeave');
	    };
	    /**
	     * @private
	     * The view has finished leaving and is no longer the active view. This
	     * will fire, whether it is cached or unloaded.
	     */
	    ViewController.prototype.fireDidLeave = function () {
	        this.didLeave.emit(null);
	        ctrlFn(this, 'DidLeave');
	        // when this is not the active page
	        // we no longer need to detect changes
	        this._cd && this._cd.detach();
	    };
	    /**
	     * @private
	     * The view is about to be destroyed and have its elements removed.
	     */
	    ViewController.prototype.fireWillUnload = function () {
	        this.willUnload.emit(null);
	        ctrlFn(this, 'WillUnload');
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.onDestroy = function (destroyFn) {
	        this._destroyFn = destroyFn;
	    };
	    /**
	     * @private
	     */
	    ViewController.prototype.destroy = function () {
	        this.didUnload.emit(null);
	        ctrlFn(this, 'DidUnload');
	        this._destroyFn && this._destroyFn();
	        this._destroyFn = null;
	    };
	    /** @nocollapse */
	    ViewController.propDecorators = {
	        '_emitter': [{ type: Output },],
	    };
	    return ViewController;
	}());
	function ctrlFn(viewCtrl, fnName) {
	    if (viewCtrl.instance) {
	        // deprecated warning: added 2016-06-01, beta.8
	        if (viewCtrl.instance['onPage' + fnName]) {
	            try {
	                console.warn('onPage' + fnName + '() has been deprecated. Please rename to ionView' + fnName + '()');
	                viewCtrl.instance['onPage' + fnName]();
	            }
	            catch (e) {
	                console.error(viewCtrl.name + ' onPage' + fnName + ': ' + e.message);
	            }
	        }
	        // fire off ionView lifecycle instance method
	        if (viewCtrl.instance['ionView' + fnName]) {
	            try {
	                viewCtrl.instance['ionView' + fnName]();
	            }
	            catch (e) {
	                console.error(viewCtrl.name + ' ionView' + fnName + ': ' + e.message);
	            }
	        }
	    }
	}

	var __extends$1 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @name NavController
	 * @description
	 * _For examples on the basic usage of NavController, check out the
	 * [Navigation section](../../../../components/#navigation) of the Component
	 * docs._
	 *
	 * NavController is the base class for navigation controller components like
	 * [`Nav`](../Nav/) and [`Tab`](../../Tabs/Tab/). You use navigation controllers
	 * to navigate to [pages](#creating_pages) in your app. At a basic level, a
	 * navigation controller is an array of pages representing a particular history
	 * (of a Tab for example). This array can be manipulated to navigate throughout
	 * an app by pushing and popping pages or inserting and removing them at
	 * arbitrary locations in history.
	 *
	 * The current page is the last one in the array, or the top of the stack if we
	 * think of it that way.  [Pushing](#push) a new page onto the top of the
	 * navigation stack causes the new page to be animated in, while [popping](#pop)
	 * the current page will navigate to the previous page in the stack.
	 *
	 * Unless you are using a directive like [NavPush](../NavPush/), or need a
	 * specific NavController, most times you will inject and use a reference to the
	 * nearest NavController to manipulate the navigation stack.
	 *
	 * ### Injecting NavController
	 * Injecting NavController will always get you an instance of the nearest
	 * NavController, regardless of whether it is a Tab or a Nav.
	 *
	 * Behind the scenes, when Ionic instantiates a new NavController, it creates an
	 * injector with NavController bound to that instance (usually either a Nav or
	 * Tab) and adds the injector to its own providers.  For more information on
	 * providers and dependency injection, see [Providers and DI]().
	 *
	 * Instead, you can inject NavController and know that it is the correct
	 * navigation controller for most situations (for more advanced situations, see
	 * [Menu](../../Menu/Menu/) and [Tab](../../Tab/Tab/)).
	 *
	 * ```ts
	 *  class MyComponent {
	 *    constructor(private nav: NavController) {
	 *
	 *    }
	 *  }
	 * ```
	 *
	 *
	 * ## Page creation
	 * Pages are created when they are added to the navigation stack.  For methods
	 * like [push()](#push), the NavController takes any component class that is
	 * decorated with `@Component` as its first argument.  The NavController then
	 * compiles that component, adds it to the app and animates it into view.
	 *
	 * By default, pages are cached and left in the DOM if they are navigated away
	 * from but still in the navigation stack (the exiting page on a `push()` for
	 * example).  They are destroyed when removed from the navigation stack (on
	 * [pop()](#pop) or [setRoot()](#setRoot)).
	 *
	 *
	 * ## Lifecycle events
	 * Lifecycle events are fired during various stages of navigation.  They can be
	 * defined in any component type which is pushed/popped from a `NavController`.
	 *
	 * ```ts
	 * import {Component } from '@angular/core';
	 *
	 * @Component({
	 *   template: 'Hello World'
	 * })
	 * class HelloWorld {
	 *   ionViewLoaded() {
	 *     console.log("I'm alive!");
	 *   }
	 *   ionViewWillLeave() {
	 *     console.log("Looks like I'm about to leave :(");
	 *   }
	 * }
	 * ```
	 *
	 *  | Page Event          | Description                                                                                                                                                                                                                                                                        |
	 *  |---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
	 *  | `ionViewLoaded`     | Runs when the page has loaded. This event only happens once per page being created and added to the DOM. If a page leaves but is cached, then this event will not fire again on a subsequent viewing. The `ionViewLoaded` event is good place to put your setup code for the page. |
	 *  | `ionViewWillEnter`  | Runs when the page is about to enter and become the active page.                                                                                                                                                                                                                   |
	 *  | `ionViewDidEnter`   | Runs when the page has fully entered and is now the active page. This event will fire, whether it was the first load or a cached page.                                                                                                                                             |
	 *  | `ionViewWillLeave`  | Runs when the page is about to leave and no longer be the active page.                                                                                                                                                                                                             |
	 *  | `ionViewDidLeave`   | Runs when the page has finished leaving and is no longer the active page.                                                                                                                                                                                                          |
	 *  | `ionViewWillUnload` | Runs when the page is about to be destroyed and have its elements removed.                                                                                                                                                                                                         |
	 *  | `ionViewDidUnload`  | Runs after the page has been destroyed and its elements have been removed.
	 *
	 *
	 * ## Nav Transition Promises
	 *
	 * Navigation transitions are asynchronous, meaning they take a few moments to finish, and
	 * the duration of a transition could be any number. In most cases the async nature of a
	 * transition doesn't cause any problems and the nav controller is pretty good about handling
	 * which transition was the most recent when multiple transitions have been kicked off.
	 * However, when an app begins firing off many transitions, on the same stack at
	 * *roughly* the same time, the nav controller can start to get lost as to which transition
	 * should be finishing, and which transitions should not be animated.
	 *
	 * In cases where an app's navigation can be altered by other async tasks, which may or
	 * may not take a long time, it's best to rely on each nav transition's returned
	 * promise. So instead of firing and forgetting multiple `push` or `pop` nav transitions,
	 * it's better to fire the next nav transition when the previous one has finished.
	 *
	 * In the example below, after the async operation has completed, we then want to transition
	 * to another page. Where the potential problem comes in, is that if the async operation
	 * completed 100ms after the first transition started, then kicking off another transition
	 * halfway through the first transition ends up with a janky animation. Instead, it's best
	 * to always ensure the first transition has already finished before starting the next.
	 *
	 * ```ts
	 * // begin the first transition
	 * let navTransition = this.nav.push(SomePage);
	 *
	 * // start an async call, we're not sure how long it'll take
	 * someAsyncOperation().then(() => {
	 *   // incase the async operation completed faster than the time
	 *   // it took to finish the first transition, this logic should
	 *   // always ensure that the previous transition has resolved
	 *   // first before kicking off the next transition
	 *   navTransition.then(() => {
	 *     this.nav.push(AnotherPage);
	 *   });
	 * });
	 * ```
	 *
	 * ## NavOptions
	 *
	 * Some methods on `NavController` allow for customizing the current transition.
	 * To do this, we can pass an object with the modified properites.
	 *
	 * | Property  | Value     | Description                                                                                                |
	 * |-----------|-----------|------------------------------------------------------------------------------------------------------------|
	 * | animate   | `boolean` | Whether or not the transition should animate.                                                              |
	 * | animation | `string`  | What kind of animation should be used.                                                                     |
	 * | direction | `string`  | The conceptual direction the user is navigating. For example, is the user navigating `forward`, or `back`? |
	 * | duration  | `number`  | The length in milliseconds the animation should take.                                                      |
	 * | easing    | `string`  | The easing for the animation.                                                                              |
	 *
	 * The property 'animation' understands the following values: `md-transition`, `ios-transition` and `wp-transition`.
	 *
	 * @see {@link /docs/v2/components#navigation Navigation Component Docs}
	 */
	var NavController = (function (_super) {
	    __extends$1(NavController, _super);
	    function NavController(parent, _app, config, _keyboard, elementRef, _zone, _renderer, _compiler, _menuCtrl) {
	        _super.call(this, elementRef);
	        this._app = _app;
	        this._keyboard = _keyboard;
	        this._zone = _zone;
	        this._renderer = _renderer;
	        this._compiler = _compiler;
	        this._menuCtrl = _menuCtrl;
	        this._transIds = 0;
	        this._init = false;
	        this._children = [];
	        this._ids = -1;
	        this._views = [];
	        /**
	         * @private
	         */
	        this.routers = [];
	        /**
	         * @private
	         */
	        this.isPortal = false;
	        /**
	         * @private
	         */
	        this._trnsTime = 0;
	        this.parent = parent;
	        this.config = config;
	        this._trnsDelay = config.get('pageTransitionDelay');
	        this._sbEnabled = config.getBoolean('swipeBackEnabled');
	        this._sbThreshold = config.getNumber('swipeBackThreshold', 40);
	        this.id = (++ctrlIds).toString();
	        this.viewDidLoad = new EventEmitter();
	        this.viewWillEnter = new EventEmitter();
	        this.viewDidEnter = new EventEmitter();
	        this.viewWillLeave = new EventEmitter();
	        this.viewDidLeave = new EventEmitter();
	        this.viewWillUnload = new EventEmitter();
	        this.viewDidUnload = new EventEmitter();
	    }
	    /**
	     * @private
	     */
	    NavController.prototype.setViewport = function (val) {
	        this._viewport = val;
	    };
	    /**
	     * Set the root for the current navigation stack.
	     * @param {Page} page  The name of the component you want to push on the navigation stack.
	     * @param {object} [params={}] Any nav-params you want to pass along to the next view.
	     * @param {object} [opts={}] Any options you want to use pass to transtion.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.setRoot = function (page, params, opts) {
	        return this.setPages([{ page: page, params: params }], opts);
	    };
	    /**
	     * Set the views of the current navigation stack and navigate to the
	     * last view. By default animations are disabled, but they can be enabled
	     * by passing options to the navigation controller.You can also pass any
	     * navigation params to the individual pages in the array.
	     *
	     * @param {array<Page>} pages  An arry of page components and their params to load in the stack.
	     * @param {object} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.setPages = function (pages, opts) {
	        if (!pages || !pages.length) {
	            return Promise.resolve(false);
	        }
	        if (isBlank$5(opts)) {
	            opts = {};
	        }
	        // remove existing views
	        var leavingView = this._remove(0, this._views.length);
	        // create view controllers out of the pages and insert the new views
	        var views = pages.map(function (p) { return new ViewController(p.page, p.params); });
	        var enteringView = this._insert(0, views);
	        // if animation wasn't set to true then default it to NOT animate
	        if (opts.animate !== true) {
	            opts.animate = false;
	        }
	        // set the nav direction to "back" if it wasn't set
	        opts.direction = opts.direction || 'back';
	        var resolve;
	        var promise = new Promise(function (res) { resolve = res; });
	        // start the transition, fire resolve when done...
	        this._transition(enteringView, leavingView, opts, function (hasCompleted) {
	            // transition has completed!!
	            resolve(hasCompleted);
	        });
	        return promise;
	    };
	    /**
	     * Push a new component onto the current navication stack. Pass any aditional information
	     * along as an object. This additional information is acessible through NavParams
	     *
	     * @param {Page} page  The page component class you want to push on to the navigation stack
	     * @param {object} [params={}] Any nav-params you want to pass along to the next view
	     * @param {object} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.push = function (page, params, opts) {
	        return this.insertPages(-1, [{ page: page, params: params }], opts);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please use inject the overlays controller and use the present method on the instance instead.
	     */
	    NavController.prototype.present = function (enteringView, opts) {
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('nav.present() has been deprecated.\n' +
	            'Please inject the overlay\'s controller and use the present method on the instance instead.');
	        return Promise.resolve();
	    };
	    /**
	     * Inserts a component into the nav stack at the specified index. This is useful if
	     * you need to add a component at any point in your navigation stack.
	     *
	     *
	     * @param {number} insertIndex  The index where to insert the page.
	     * @param {Page} page  The component you want to insert into the nav stack.
	     * @param {object} [params={}] Any nav-params you want to pass along to the next page.
	     * @param {object} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.insert = function (insertIndex, page, params, opts) {
	        return this.insertPages(insertIndex, [{ page: page, params: params }], opts);
	    };
	    /**
	     * Inserts an array of components into the nav stack at the specified index.
	     * The last component in the array will animate in and become the active component
	     *
	     * @param {number} insertIndex  The index where you want to insert the page.
	     * @param {array<{page: Page, params=: any}>} insertPages  An array of objects, each with a `page` and optionally `params` property.
	     * @param {object} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.insertPages = function (insertIndex, insertPages, opts) {
	        var views = insertPages.map(function (p) { return new ViewController(p.page, p.params); });
	        return this.insertViews(insertIndex, views, opts);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.insertViews = function (insertIndex, insertViews, opts) {
	        if (!insertViews || !insertViews.length) {
	            return Promise.reject('invalid pages');
	        }
	        if (isBlank$5(opts)) {
	            opts = {};
	        }
	        // insert the new page into the stack
	        // returns the newly created entering view
	        var enteringView = this._insert(insertIndex, insertViews);
	        // set the nav direction to "forward" if it wasn't set
	        opts.direction = opts.direction || 'forward';
	        // set which animation it should use if it wasn't set yet
	        if (!opts.animation) {
	            opts.animation = enteringView.getTransitionName(opts.direction);
	        }
	        var resolve;
	        var promise = new Promise(function (res) { resolve = res; });
	        // it's possible that the newly added view doesn't need to
	        // transition in, but was simply inserted somewhere in the stack
	        // go backwards through the stack and find the first active view
	        // which could be active or one ready to enter
	        for (var i = this._views.length - 1; i >= 0; i--) {
	            if (this._views[i].state === STATE_ACTIVE || this._views[i].state === STATE_INIT_ENTER) {
	                // found the view at the end of the stack that's either
	                // already active or it is about to enter
	                if (this._views[i] === enteringView) {
	                    // cool, so the last valid view is also our entering view!!
	                    // this means we should animate that bad boy in so it's the active view
	                    // return a promise and resolve when the transition has completed
	                    // get the leaving view which the _insert() already set
	                    var leavingView = this.getByState(STATE_INIT_LEAVE);
	                    // start the transition, fire resolve when done...
	                    this._transition(enteringView, leavingView, opts, function (hasCompleted) {
	                        // transition has completed!!
	                        resolve(hasCompleted);
	                    });
	                    return promise;
	                }
	                break;
	            }
	        }
	        // the page was not pushed onto the end of the stack
	        // but rather inserted somewhere in the middle or beginning
	        // Since there are views after this new one, don't transition in
	        // auto resolve cuz there was is no need for an animation
	        return Promise.resolve(enteringView);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._insert = function (insertIndex, insertViews) {
	        // when this is done, there should only be at most
	        // 1 STATE_INIT_ENTER and 1 STATE_INIT_LEAVE
	        // there should not be any that are STATE_ACTIVE after this is done
	        var _this = this;
	        // allow -1 to be passed in to auto push it on the end
	        // and clean up the index if it's larger then the size of the stack
	        if (insertIndex < 0 || insertIndex > this._views.length) {
	            insertIndex = this._views.length;
	        }
	        // first see if there's an active view
	        var view = this.getActive();
	        if (view) {
	            // there's an active view, set that it's initialized to leave
	            view.state = STATE_INIT_LEAVE;
	        }
	        else if (view = this.getByState(STATE_INIT_ENTER)) {
	            // oh no, there's already a transition initalized ready to enter!
	            // but it actually hasn't entered yet at all so lets
	            // just keep it in the array, but not render or animate it in
	            view.state = STATE_INACTIVE;
	        }
	        // insert each of the views in the pages array
	        var insertView = null;
	        insertViews.forEach(function (view, i) {
	            insertView = view;
	            // create the new entering view
	            view.setNav(_this);
	            view.state = STATE_INACTIVE;
	            // give this inserted view an ID
	            _this._incId(view);
	            // insert the entering view into the correct index in the stack
	            _this._views.splice(insertIndex + i, 0, view);
	        });
	        if (insertView) {
	            insertView.state = STATE_INIT_ENTER;
	        }
	        return insertView;
	    };
	    /**
	     * Call to navigate back from a current component. Similar to `push()`, you
	     * can also pass navigation options.
	     *
	     * @param {object} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.pop = function (opts) {
	        // get the index of the active view
	        // which will become the view to be leaving
	        var activeView = this.getByState(STATE_TRANS_ENTER) ||
	            this.getByState(STATE_INIT_ENTER) ||
	            this.getActive();
	        if (isBlank$5(opts)) {
	            opts = {};
	        }
	        // if not set, by default climb up the nav controllers if
	        // there isn't a previous view in this nav controller
	        if (isBlank$5(opts.climbNav)) {
	            opts.climbNav = true;
	        }
	        return this.remove(this.indexOf(activeView), 1, opts);
	    };
	    /**
	     * Navigate back to the root of the stack, no matter how far back that is.
	     *
	     * @param {object} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.popToRoot = function (opts) {
	        return this.popTo(this.first(), opts);
	    };
	    /**
	     * Pop to a specific view in the history stack.
	     *
	     * @param {ViewController} view  to pop to
	     * @param {object} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.popTo = function (view, opts) {
	        var startIndex = this.indexOf(view);
	        if (startIndex < 0) {
	            return Promise.reject('View not found to pop to');
	        }
	        var activeView = this.getByState(STATE_TRANS_ENTER) ||
	            this.getByState(STATE_INIT_ENTER) ||
	            this.getActive();
	        var removeCount = this.indexOf(activeView) - startIndex;
	        return this.remove(startIndex + 1, removeCount, opts);
	    };
	    /**
	     * Removes a page from the nav stack at the specified index.
	     *
	     * @param {number} [startIndex]  The starting index to remove pages from the stack. Default is the index of the last page.
	     * @param {number} [removeCount]  The number of pages to remove, defaults to remove `1`.
	     * @param {object} [opts={}] Any options you want to use pass to transtion.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    NavController.prototype.remove = function (startIndex, removeCount, opts) {
	        var _this = this;
	        if (startIndex === void 0) { startIndex = -1; }
	        if (removeCount === void 0) { removeCount = 1; }
	        if (startIndex === -1) {
	            startIndex = this._views.length - 1;
	        }
	        else if (startIndex < 0 || startIndex >= this._views.length) {
	            return Promise.reject('remove index out of range');
	        }
	        if (isBlank$5(opts)) {
	            opts = {};
	        }
	        // default the direction to "back"
	        opts.direction = opts.direction || 'back';
	        // figure out the states of each view in the stack
	        var leavingView = this._remove(startIndex, removeCount);
	        if (!leavingView) {
	            var forcedActive = this.getByState(STATE_FORCE_ACTIVE);
	            if (forcedActive) {
	                // this scenario happens when a remove is going on
	                // during a transition
	                if (this._trans) {
	                    this._trans.stop();
	                    this._trans.destroy();
	                    this._trans = null;
	                    this._cleanup();
	                }
	                return Promise.resolve(false);
	            }
	        }
	        if (leavingView) {
	            // there is a view ready to leave, meaning that a transition needs
	            // to happen and the previously active view is going to animate out
	            // get the view thats ready to enter
	            var enteringView = this.getByState(STATE_INIT_ENTER);
	            if (!enteringView && !this.isPortal) {
	                // oh nos! no entering view to go to!
	                // if there is no previous view that would enter in this nav stack
	                // and the option is set to climb up the nav parent looking
	                // for the next nav we could transition to instead
	                if (opts.climbNav) {
	                    var parentNav = this.parent;
	                    while (parentNav) {
	                        if (!parentNav['_tabs']) {
	                            // Tabs can be a parent, but it is not a collection of views
	                            // only we're looking for an actual NavController w/ stack of views
	                            leavingView.fireWillLeave();
	                            this.viewWillLeave.emit(leavingView);
	                            this._app.viewWillLeave.emit(leavingView);
	                            return parentNav.pop(opts).then(function (rtnVal) {
	                                leavingView.fireDidLeave();
	                                _this.viewDidLeave.emit(leavingView);
	                                _this._app.viewDidLeave.emit(leavingView);
	                                return rtnVal;
	                            });
	                        }
	                        parentNav = parentNav.parent;
	                    }
	                }
	                // there's no previous view and there's no valid parent nav
	                // to climb to so this shouldn't actually remove the leaving
	                // view because there's nothing that would enter, eww
	                leavingView.state = STATE_ACTIVE;
	                return Promise.resolve(false);
	            }
	            var resolve_1;
	            var promise = new Promise(function (res) { resolve_1 = res; });
	            if (!opts.animation) {
	                opts.animation = leavingView.getTransitionName(opts.direction);
	            }
	            // start the transition, fire resolve when done...
	            this._transition(enteringView, leavingView, opts, function (hasCompleted) {
	                // transition has completed!!
	                resolve_1(hasCompleted);
	            });
	            return promise;
	        }
	        // no need to transition when the active view isn't being removed
	        // there's still an active view after _remove() figured out states
	        // so this means views that were only removed before the active
	        // view, so auto-resolve since no transition needs to happen
	        return Promise.resolve(false);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._remove = function (startIndex, removeCount) {
	        var _this = this;
	        // when this is done, there should only be at most
	        // 1 STATE_INIT_ENTER and 1 STATE_INIT_LEAVE
	        // there should not be any that are STATE_ACTIVE after this is done
	        var view = null;
	        // loop through each view that is set to be removed
	        for (var i = startIndex, ii = removeCount + startIndex; i < ii; i++) {
	            view = this.getByIndex(i);
	            if (!view)
	                break;
	            if (view.state === STATE_TRANS_ENTER || view.state === STATE_TRANS_LEAVE) {
	                // oh no!!! this view should be removed, but it's
	                // actively transitioning in at the moment!!
	                // since it's viewable right now, let's just set that
	                // it should be removed after the transition
	                view.state = STATE_REMOVE_AFTER_TRANS;
	            }
	            else if (view.state === STATE_INIT_ENTER) {
	                // asked to be removed before it even entered!
	                view.state = STATE_CANCEL_ENTER;
	            }
	            else {
	                // if this view is already leaving then no need to immediately
	                // remove it, otherwise set the remove state
	                // this is useful if the view being removed isn't going to
	                // animate out, but just removed from the stack, no transition
	                view.state = STATE_REMOVE;
	            }
	        }
	        if (view = this.getByState(STATE_INIT_LEAVE)) {
	            // looks like there's already an active leaving view
	            // reassign previous entering view to just be inactive
	            var enteringView = this.getByState(STATE_INIT_ENTER);
	            if (enteringView) {
	                enteringView.state = STATE_INACTIVE;
	            }
	            // from the index of the leaving view, go backwards and
	            // find the first view that is inactive
	            for (var i = this.indexOf(view) - 1; i >= 0; i--) {
	                if (this._views[i].state === STATE_INACTIVE) {
	                    this._views[i].state = STATE_INIT_ENTER;
	                    break;
	                }
	            }
	        }
	        else if (view = this.getByState(STATE_TRANS_LEAVE)) {
	            // an active transition is happening, but a new transition
	            // still needs to happen force this view to be the active one
	            view.state = STATE_FORCE_ACTIVE;
	        }
	        else if (view = this.getByState(STATE_REMOVE)) {
	            // there is no active transition about to happen
	            // find the first view that is supposed to be removed and
	            // set that it is the init leaving view
	            // the first view to be removed, it should init leave
	            view.state = STATE_INIT_LEAVE;
	            view.fireWillUnload();
	            this.viewWillUnload.emit(view);
	            this._app.viewWillUnload.emit(view);
	            // from the index of the leaving view, go backwards and
	            // find the first view that is inactive so it can be the entering
	            for (var i = this.indexOf(view) - 1; i >= 0; i--) {
	                if (this._views[i].state === STATE_INACTIVE) {
	                    this._views[i].state = STATE_INIT_ENTER;
	                    break;
	                }
	            }
	        }
	        // if there is still an active view, then it wasn't one that was
	        // set to be removed, so there actually won't be a transition at all
	        view = this.getActive();
	        if (view) {
	            // the active view remains untouched, so all the removes
	            // must have happened before it, so really no need for transition
	            view = this.getByState(STATE_INIT_ENTER);
	            if (view) {
	                // if it was going to enter, then just make inactive
	                view.state = STATE_INACTIVE;
	            }
	            view = this.getByState(STATE_INIT_LEAVE);
	            if (view) {
	                // this was going to leave, so just remove it completely
	                view.state = STATE_REMOVE;
	            }
	        }
	        // remove views that have been set to be removed, but not
	        // apart of any transitions that will eventually happen
	        this._views.filter(function (v) { return v.state === STATE_REMOVE; }).forEach(function (view) {
	            view.fireWillLeave();
	            view.fireDidLeave();
	            _this._views.splice(_this.indexOf(view), 1);
	            view.destroy();
	        });
	        return this.getByState(STATE_INIT_LEAVE);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._transition = function (enteringView, leavingView, opts, done) {
	        var _this = this;
	        var transId = ++this._transIds;
	        if (enteringView === leavingView) {
	            // if the entering view and leaving view are the same thing don't continue
	            this._transFinish(transId, enteringView, leavingView, null, false);
	            return done(false);
	        }
	        if (isBlank$5(opts)) {
	            opts = {};
	        }
	        this._setAnimate(opts);
	        if (!leavingView) {
	            // if no leaving view then create a bogus one
	            leavingView = new ViewController();
	        }
	        if (!enteringView) {
	            // if no entering view then create a bogus one
	            enteringView = new ViewController();
	            enteringView.fireLoaded();
	        }
	        /* Async steps to complete a transition
	          1. _render: compile the view and render it in the DOM. Load page if it hasn't loaded already. When done call postRender
	          2. _postRender: Run willEnter/willLeave, then wait a frame (change detection happens), then call beginTransition
	          3. _beforeTrans: Create the transition's animation, play the animation, wait for it to end
	          4. _afterTrans: Run didEnter/didLeave, call _transComplete()
	          5. _transComplete: Cleanup, remove cache views, then call the final callback
	        */
	        // begin the multiple async process of transitioning to the entering view
	        this._render(transId, enteringView, leavingView, opts, function (hasCompleted) {
	            _this._transFinish(transId, enteringView, leavingView, opts.direction, hasCompleted);
	            done(hasCompleted);
	        });
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._setAnimate = function (opts) {
	        if ((this._views.length === 1 && !this._init && !this.isPortal) || this.config.get('animate') === false) {
	            opts.animate = false;
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._render = function (transId, enteringView, leavingView, opts, done) {
	        // compile/load the view into the DOM
	        var _this = this;
	        if (enteringView.state === STATE_INACTIVE) {
	            // this entering view is already set to inactive, so this
	            // transition must be canceled, so don't continue
	            return done();
	        }
	        enteringView.state = STATE_INIT_ENTER;
	        leavingView.state = STATE_INIT_LEAVE;
	        // remember if this nav is already transitioning or not
	        var isAlreadyTransitioning = this.isTransitioning();
	        if (enteringView.isLoaded()) {
	            // already compiled this view, do not load again and continue
	            this._postRender(transId, enteringView, leavingView, isAlreadyTransitioning, opts, done);
	        }
	        else {
	            // view has not been compiled/loaded yet
	            // continue once the view has finished compiling
	            // DOM WRITE
	            this.setTransitioning(true, 500);
	            this.loadPage(enteringView, this._viewport, opts, function () {
	                enteringView.fireLoaded();
	                _this.viewDidLoad.emit(enteringView);
	                _this._app.viewDidLoad.emit(enteringView);
	                _this._postRender(transId, enteringView, leavingView, isAlreadyTransitioning, opts, done);
	            });
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._postRender = function (transId, enteringView, leavingView, isAlreadyTransitioning, opts, done) {
	        // called after _render has completed and the view is compiled/loaded
	        if (enteringView.state === STATE_INACTIVE) {
	            // this entering view is already set to inactive, so this
	            // transition must be canceled, so don't continue
	            return done();
	        }
	        if (!opts.preload) {
	            // the enteringView will become the active view, and is not being preloaded
	            // set the correct zIndex for the entering and leaving views
	            // if there's already another trans_enter happening then
	            // the zIndex for the entering view should go off of that one
	            // DOM WRITE
	            var lastestLeavingView = this.getByState(STATE_TRANS_ENTER) || leavingView;
	            this._setZIndex(enteringView, lastestLeavingView, opts.direction);
	            // make sure the entering and leaving views are showing
	            // DOM WRITE
	            if (isAlreadyTransitioning) {
	                // the previous transition was still going when this one started
	                // so to be safe, only update showing the entering/leaving
	                // don't hide the others when they could still be transitioning
	                enteringView.domShow(true, this._renderer);
	                leavingView.domShow(true, this._renderer);
	            }
	            else {
	                // there are no other transitions happening but this one
	                // only entering/leaving should show, all others hidden
	                // also if a view is an overlay or the previous view is an
	                // overlay then always show the overlay and the view before it
	                var view;
	                var shouldShow;
	                for (var i = 0, ii = this._views.length; i < ii; i++) {
	                    view = this._views[i];
	                    shouldShow = (view === enteringView) ||
	                        (view === leavingView) ||
	                        view.isOverlay ||
	                        (i < ii - 1 ? this._views[i + 1].isOverlay : false);
	                    view.domShow(shouldShow, this._renderer);
	                }
	            }
	            // call each view's lifecycle events
	            if (leavingView.fireOtherLifecycles) {
	                // only fire entering lifecycle if the leaving
	                // view hasn't explicitly set not to
	                enteringView.fireWillEnter();
	                this.viewWillEnter.emit(enteringView);
	                this._app.viewWillEnter.emit(enteringView);
	            }
	            if (enteringView.fireOtherLifecycles) {
	                // only fire leaving lifecycle if the entering
	                // view hasn't explicitly set not to
	                leavingView.fireWillLeave();
	                this.viewWillLeave.emit(leavingView);
	                this._app.viewWillLeave.emit(leavingView);
	            }
	        }
	        else {
	            // this view is being preloaded, don't call lifecycle events
	            // transition does not need to animate
	            opts.animate = false;
	        }
	        this._beforeTrans(enteringView, leavingView, opts, done);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._beforeTrans = function (enteringView, leavingView, opts, done) {
	        // called after one raf from postRender()
	        // create the transitions animation, play the animation
	        // when the transition ends call wait for it to end
	        var _this = this;
	        if (enteringView.state === STATE_INACTIVE || enteringView.state === STATE_CANCEL_ENTER) {
	            // this entering view is already set to inactive or has been canceled
	            // so this transition must not begin, so don't continue
	            return done();
	        }
	        enteringView.state = STATE_TRANS_ENTER;
	        leavingView.state = STATE_TRANS_LEAVE;
	        // everything during the transition should runOutsideAngular
	        this._zone.runOutsideAngular(function () {
	            // init the transition animation
	            var transitionOpts = {
	                animation: opts.animation,
	                direction: opts.direction,
	                duration: opts.duration,
	                easing: opts.easing,
	                renderDelay: opts.transitionDelay || _this._trnsDelay,
	                isRTL: _this.config.platform.isRTL(),
	                ev: opts.ev,
	            };
	            var transAnimation = _this._createTrans(enteringView, leavingView, transitionOpts);
	            _this._trans && _this._trans.destroy();
	            _this._trans = transAnimation;
	            if (opts.animate === false) {
	                // force it to not animate the elements, just apply the "to" styles
	                transAnimation.duration(0);
	            }
	            // check if a parent is transitioning and get the time that it ends
	            var parentTransitionEndTime = _this._getLongestTrans(Date.now());
	            if (parentTransitionEndTime > 0) {
	                // the parent is already transitioning and has disabled the app
	                // so just update the local transitioning information
	                var duration = parentTransitionEndTime - Date.now();
	                _this.setTransitioning(true, duration);
	            }
	            else {
	                // this is the only active transition (for now), so disable the app
	                var keyboardDurationPadding = 0;
	                if (_this._keyboard.isOpen()) {
	                    // add XXms to the duration the app is disabled when the keyboard is open
	                    keyboardDurationPadding = 600;
	                }
	                var duration = transAnimation.getDuration() + keyboardDurationPadding;
	                var enableApp = (duration < 64);
	                _this._app.setEnabled(enableApp, duration);
	                _this.setTransitioning(!enableApp, duration);
	            }
	            // create a callback for when the animation is done
	            transAnimation.onFinish(function (trans) {
	                // transition animation has ended
	                // destroy the animation and it's element references
	                trans.destroy();
	                _this._afterTrans(enteringView, leavingView, opts, trans.hasCompleted, done);
	            });
	            // cool, let's do this, start the transition
	            if (opts.progressAnimation) {
	                // this is a swipe to go back, just get the transition progress ready
	                // kick off the swipe animation start
	                transAnimation.progressStart();
	            }
	            else {
	                // this is a normal animation
	                // kick it off and let it play through
	                transAnimation.play();
	            }
	        });
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._afterTrans = function (enteringView, leavingView, opts, hasCompleted, done) {
	        // transition has completed, update each view's state
	        // place back into the zone, run didEnter/didLeave
	        // call the final callback when done
	        var _this = this;
	        // run inside of the zone again
	        this._zone.run(function () {
	            if (!opts.preload && hasCompleted) {
	                if (leavingView.fireOtherLifecycles) {
	                    // only fire entering lifecycle if the leaving
	                    // view hasn't explicitly set not to
	                    enteringView.fireDidEnter();
	                    _this.viewDidEnter.emit(enteringView);
	                    _this._app.viewDidEnter.emit(enteringView);
	                }
	                if (enteringView.fireOtherLifecycles && _this._init) {
	                    // only fire leaving lifecycle if the entering
	                    // view hasn't explicitly set not to
	                    // and after the nav has initialized
	                    leavingView.fireDidLeave();
	                    _this.viewDidLeave.emit(leavingView);
	                    _this._app.viewDidLeave.emit(leavingView);
	                }
	            }
	            if (enteringView.state === STATE_INACTIVE) {
	                // this entering view is already set to inactive, so this
	                // transition must be canceled, so don't continue
	                return done(hasCompleted);
	            }
	            if (opts.keyboardClose !== false && _this._keyboard.isOpen()) {
	                // the keyboard is still open!
	                // no problem, let's just close for them
	                _this._keyboard.close();
	                _this._keyboard.onClose(function () {
	                    // keyboard has finished closing, transition complete
	                    done(hasCompleted);
	                }, 32);
	            }
	            else {
	                // all good, transition complete
	                done(hasCompleted);
	            }
	        });
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._transFinish = function (transId, enteringView, leavingView, direction, hasCompleted) {
	        // a transition has completed, but not sure if it's the last one or not
	        // check if this transition is the most recent one or not
	        var _this = this;
	        if (enteringView.state === STATE_CANCEL_ENTER) {
	            // this view was told to leave before it finished entering
	            this.remove(enteringView.index, 1);
	        }
	        if (transId === this._transIds) {
	            // ok, good news, there were no other transitions that kicked
	            // off during the time this transition started and ended
	            if (hasCompleted) {
	                // this transition has completed as normal
	                // so the entering one is now the active view
	                // and the leaving view is now just inactive
	                if (enteringView.state !== STATE_REMOVE_AFTER_TRANS) {
	                    enteringView.state = STATE_ACTIVE;
	                }
	                if (leavingView.state !== STATE_REMOVE_AFTER_TRANS) {
	                    leavingView.state = STATE_INACTIVE;
	                }
	                // only need to do all this clean up if the transition
	                // completed, otherwise nothing actually changed
	                // destroy all of the views that come after the active view
	                this._cleanup();
	                // make sure only this entering view and PREVIOUS view are the
	                // only two views that are not display:none
	                // do not make any changes to the stack's current visibility
	                // if there is an overlay somewhere in the stack
	                leavingView = this.getPrevious(enteringView);
	                if (this.hasOverlay()) {
	                    // ensure the entering view is showing
	                    enteringView.domShow(true, this._renderer);
	                }
	                else {
	                    // only possibly hide a view if there are no overlays in the stack
	                    this._views.forEach(function (view) {
	                        var shouldShow = (view === enteringView) || (view === leavingView);
	                        view.domShow(shouldShow, _this._renderer);
	                    });
	                }
	                // this check only needs to happen once, which will add the css
	                // class to the nav when it's finished its first transition
	                this._init = true;
	            }
	            else {
	                // this transition has not completed, meaning the
	                // entering view did not end up as the active view
	                // this would happen when swipe to go back started
	                // but the user did not complete the swipe and the
	                // what was the active view stayed as the active view
	                leavingView.state = STATE_ACTIVE;
	                enteringView.state = STATE_INACTIVE;
	            }
	            // check if there is a parent actively transitioning
	            var transitionEndTime = this._getLongestTrans(Date.now());
	            // if transitionEndTime is greater than 0, there is a parent transition occurring
	            // so delegate enabling the app to the parent.  If it <= 0, go ahead and enable the app
	            if (transitionEndTime <= 0) {
	                this._app && this._app.setEnabled(true);
	            }
	            this.setTransitioning(false);
	            if (direction !== null && hasCompleted && !this.isPortal) {
	                // notify router of the state change if a direction was provided
	                // multiple routers can exist and each should be notified
	                this.routers.forEach(function (router) {
	                    router.stateChange(direction, enteringView);
	                });
	            }
	            // see if we should add the swipe back gesture listeners or not
	            this._sbCheck();
	        }
	        else {
	            // darn, so this wasn't the most recent transition
	            // so while this one did end, there's another more recent one
	            // still going on. Because a new transition is happening,
	            // then this entering view isn't actually going to be the active
	            // one, so only update the state to active/inactive if the state
	            // wasn't already updated somewhere else during its transition
	            if (enteringView.state === STATE_TRANS_ENTER) {
	                enteringView.state = STATE_INACTIVE;
	            }
	            if (leavingView.state === STATE_TRANS_LEAVE) {
	                leavingView.state = STATE_INACTIVE;
	            }
	        }
	    };
	    /**
	     *@private
	     * This method is just a wrapper to the Transition function of same name
	     * to make it easy/possible to mock the method call by overriding the function.
	     * In testing we don't want to actually do the animation, we want to return a stub instead
	     */
	    NavController.prototype._createTrans = function (enteringView, leavingView, transitionOpts) {
	        return Transition.createTransition(enteringView, leavingView, transitionOpts);
	    };
	    NavController.prototype._cleanup = function () {
	        var _this = this;
	        // ok, cleanup time!! Destroy all of the views that are
	        // INACTIVE and come after the active view
	        var activeViewIndex = this.indexOf(this.getActive());
	        var destroys = this._views.filter(function (v) { return v.state === STATE_REMOVE_AFTER_TRANS; });
	        for (var i = activeViewIndex + 1; i < this._views.length; i++) {
	            if (this._views[i].state === STATE_INACTIVE) {
	                destroys.push(this._views[i]);
	            }
	        }
	        // all pages being destroyed should be removed from the list of
	        // pages and completely removed from the dom
	        destroys.forEach(function (view) {
	            _this._views.splice(_this.indexOf(view), 1);
	            view.destroy();
	            _this.viewDidUnload.emit(view);
	            _this._app.viewDidUnload.emit(view);
	        });
	        // if any z-index goes under 0, then reset them all
	        var shouldResetZIndex = this._views.some(function (v) { return v.zIndex < 0; });
	        if (shouldResetZIndex) {
	            this._views.forEach(function (view) {
	                view.setZIndex(view.zIndex + INIT_ZINDEX + 1, _this._renderer);
	            });
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.getActiveChildNav = function () {
	        return this._children[this._children.length - 1];
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.registerChildNav = function (nav) {
	        this._children.push(nav);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.unregisterChildNav = function (nav) {
	        var index = this._children.indexOf(nav);
	        if (index > -1) {
	            this._children.splice(index, 1);
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.ngOnDestroy = function () {
	        for (var i = this._views.length - 1; i >= 0; i--) {
	            this._views[i].destroy();
	        }
	        this._views.length = 0;
	        if (this.parent && this.parent.unregisterChildNav) {
	            this.parent.unregisterChildNav(this);
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.loadPage = function (view, viewport, opts, done) {
	        var _this = this;
	        if (!viewport || !view.componentType) {
	            return;
	        }
	        // TEMPORARY: automatically set selector w/ dah reflector
	        // TODO: use componentFactory.create once fixed
	        addSelector(view.componentType, 'ion-page');
	        this._compiler.resolveComponent(view.componentType).then(function (componentFactory) {
	            if (view.state === STATE_CANCEL_ENTER) {
	                // view may have already been removed from the stack
	                // if so, don't even bother adding it
	                view.destroy();
	                _this._views.splice(view.index, 1);
	                return;
	            }
	            // add more providers to just this page
	            var componentProviders = ReflectiveInjector.resolve([
	                provide(NavController, { useValue: _this }),
	                provide(ViewController, { useValue: view }),
	                provide(NavParams, { useValue: view.getNavParams() })
	            ]);
	            var childInjector = ReflectiveInjector.fromResolvedProviders(componentProviders, _this._viewport.parentInjector);
	            var componentRef = componentFactory.create(childInjector, null, null);
	            viewport.insert(componentRef.hostView, viewport.length);
	            // a new ComponentRef has been created
	            // set the ComponentRef's instance to its ViewController
	            view.setInstance(componentRef.instance);
	            // the component has been loaded, so call the view controller's loaded method to load any dependencies into the dom
	            view.loaded(function () {
	                // the ElementRef of the actual ion-page created
	                var pageElementRef = componentRef.location;
	                // remember the ChangeDetectorRef for this ViewController
	                view.setChangeDetector(componentRef.changeDetectorRef);
	                // remember the ElementRef to the ion-page elementRef that was just created
	                view.setPageRef(pageElementRef);
	                // auto-add page css className created from component JS class name
	                var cssClassName = pascalCaseToDashCase(view.componentType.name);
	                _this._renderer.setElementClass(pageElementRef.nativeElement, cssClassName, true);
	                view.onDestroy(function () {
	                    // ensure the element is cleaned up for when the view pool reuses this element
	                    _this._renderer.setElementAttribute(pageElementRef.nativeElement, 'class', null);
	                    _this._renderer.setElementAttribute(pageElementRef.nativeElement, 'style', null);
	                    componentRef.destroy();
	                });
	                // our job is done here
	                done(view);
	            });
	        });
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.swipeBackStart = function () {
	        // default the direction to "back"
	        var opts = {
	            direction: 'back',
	            progressAnimation: true
	        };
	        // figure out the states of each view in the stack
	        var leavingView = this._remove(this._views.length - 1, 1);
	        if (leavingView) {
	            opts.animation = leavingView.getTransitionName(opts.direction);
	            // get the view thats ready to enter
	            var enteringView = this.getByState(STATE_INIT_ENTER);
	            // start the transition, fire callback when done...
	            this._transition(enteringView, leavingView, opts, function (hasCompleted) {
	                // swipe back has finished!!
	                console.debug('swipeBack, hasCompleted', hasCompleted);
	            });
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.swipeBackProgress = function (stepValue) {
	        if (this._trans && this._sbGesture) {
	            // continue to disable the app while actively dragging
	            this._app.setEnabled(false, 4000);
	            this.setTransitioning(true, 4000);
	            // set the transition animation's progress
	            this._trans.progressStep(stepValue);
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.swipeBackEnd = function (shouldComplete, currentStepValue) {
	        if (this._trans && this._sbGesture) {
	            // the swipe back gesture has ended
	            this._trans.progressEnd(shouldComplete, currentStepValue);
	        }
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._sbCheck = function () {
	        var _this = this;
	        if (this._sbEnabled) {
	            // this nav controller can have swipe to go back
	            if (!this._sbGesture) {
	                // create the swipe back gesture if we haven't already
	                var opts = {
	                    edge: 'left',
	                    threshold: this._sbThreshold
	                };
	                this._sbGesture = new SwipeBackGesture(this.getNativeElement(), opts, this, this._menuCtrl);
	            }
	            if (this.canSwipeBack()) {
	                // it is be possible to swipe back
	                if (!this._sbGesture.isListening) {
	                    this._zone.runOutsideAngular(function () {
	                        // start listening if it's not already
	                        console.debug('swipeBack gesture, listen');
	                        _this._sbGesture.listen();
	                    });
	                }
	            }
	            else if (this._sbGesture.isListening) {
	                // it should not be possible to swipe back
	                // but the gesture is still listening
	                console.debug('swipeBack gesture, unlisten');
	                this._sbGesture.unlisten();
	            }
	        }
	    };
	    /**
	     * If it's possible to use swipe back or not. If it's not possible
	     * to go back, or swipe back is not enabled, then this will return `false`.
	     * If it is possible to go back, and swipe back is enabled, then this
	     * will return `true`.
	     * @returns {boolean}
	     */
	    NavController.prototype.canSwipeBack = function () {
	        return (this._sbEnabled && !this.isTransitioning() && this._app.isEnabled() && this.canGoBack());
	    };
	    /**
	     * Returns `true` if there's a valid previous page that we can pop
	     * back to. Otherwise returns `false`.
	     * @returns {boolean}
	     */
	    NavController.prototype.canGoBack = function () {
	        var activeView = this.getActive();
	        if (activeView) {
	            return activeView.enableBack();
	        }
	        return false;
	    };
	    /**
	     * Returns if the nav controller is actively transitioning or not.
	     * @return {boolean}
	     */
	    NavController.prototype.isTransitioning = function () {
	        return (this._trnsTime > Date.now());
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.setTransitioning = function (isTransitioning, fallback) {
	        if (fallback === void 0) { fallback = 700; }
	        this._trnsTime = (isTransitioning ? Date.now() + fallback : 0);
	    };
	    /**
	     * @private
	     * This method traverses the tree of parents upwards
	     * and looks at the time the transition ends (if it's transitioning)
	     * and returns the value that is the furthest into the future
	     * thus giving us the longest transition duration
	     */
	    NavController.prototype._getLongestTrans = function (now) {
	        var parentNav = this.parent;
	        var transitionEndTime = -1;
	        while (parentNav) {
	            if (parentNav._trnsTime > transitionEndTime) {
	                transitionEndTime = parentNav._trnsTime;
	            }
	            parentNav = parentNav.parent;
	        }
	        // only check if the transitionTime is greater than the current time once
	        return transitionEndTime > 0 && transitionEndTime > now ? transitionEndTime : 0;
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.hasOverlay = function () {
	        for (var i = this._views.length - 1; i >= 0; i--) {
	            if (this._views[i].isOverlay) {
	                return true;
	            }
	        }
	        return false;
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.getByState = function (state) {
	        for (var i = this._views.length - 1; i >= 0; i--) {
	            if (this._views[i].state === state) {
	                return this._views[i];
	            }
	        }
	        return null;
	    };
	    /**
	     * @param {number} index  The index of the page to get.
	     * @returns {ViewController} Returns the view controller that matches the given index.
	     */
	    NavController.prototype.getByIndex = function (index) {
	        return (index < this._views.length && index > -1 ? this._views[index] : null);
	    };
	    /**
	     * @returns {ViewController} Returns the active page's view controller.
	     */
	    NavController.prototype.getActive = function () {
	        return this.getByState(STATE_ACTIVE);
	    };
	    /**
	     * @param {ViewController} view
	     * @returns {boolean}
	     */
	    NavController.prototype.isActive = function (view) {
	        return !!(view && view.state === STATE_ACTIVE);
	    };
	    /**
	     * Returns the view controller which is before the given view controller.
	     * @param {ViewController} view
	     * @returns {viewController}
	     */
	    NavController.prototype.getPrevious = function (view) {
	        return this.getByIndex(this.indexOf(view) - 1);
	    };
	    /**
	     * Returns the first view controller in this nav controller's stack.
	     * @returns {ViewController}
	     */
	    NavController.prototype.first = function () {
	        return (this._views.length ? this._views[0] : null);
	    };
	    /**
	     * Returns the last page in this nav controller's stack.
	     * @returns {ViewController}
	     */
	    NavController.prototype.last = function () {
	        return (this._views.length ? this._views[this._views.length - 1] : null);
	    };
	    /**
	     * Returns the index number of the given view controller.
	     * @param {ViewController} view
	     * @returns {number}
	     */
	    NavController.prototype.indexOf = function (view) {
	        return this._views.indexOf(view);
	    };
	    /**
	     * Returns the number of views in this nav controller.
	     * @returns {number} The number of views in this stack, including the current view.
	     */
	    NavController.prototype.length = function () {
	        return this._views.length;
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.isSwipeBackEnabled = function () {
	        return this._sbEnabled;
	    };
	    Object.defineProperty(NavController.prototype, "rootNav", {
	        /**
	         * Returns the root `NavController`.
	         * @returns {NavController}
	         */
	        get: function () {
	            var nav = this;
	            while (nav.parent) {
	                nav = nav.parent;
	            }
	            return nav;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * Dismiss all pages which have set the `dismissOnPageChange` property.
	     */
	    NavController.prototype.dismissPageChangeViews = function () {
	        this._views.forEach(function (view) {
	            if (view.data && view.data.dismissOnPageChange) {
	                view.dismiss();
	            }
	        });
	    };
	    /**
	     * @private
	     */
	    NavController.prototype.registerRouter = function (router) {
	        this.routers.push(router);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._incId = function (view) {
	        view.id = this.id + '-' + (++this._ids);
	    };
	    /**
	     * @private
	     */
	    NavController.prototype._setZIndex = function (enteringView, leavingView, direction) {
	        if (enteringView) {
	            // get the leaving view, which could be in various states
	            if (!leavingView || !leavingView.isLoaded()) {
	                // the leavingView is a mocked view, either we're
	                // actively transitioning or it's the initial load
	                var previousView = this.getPrevious(enteringView);
	                if (previousView && previousView.isLoaded()) {
	                    // we found a better previous view to reference
	                    // use this one instead
	                    enteringView.setZIndex(previousView.zIndex + 1, this._renderer);
	                }
	                else {
	                    // this is the initial view
	                    enteringView.setZIndex(this.isPortal ? PORTAL_ZINDEX : INIT_ZINDEX, this._renderer);
	                }
	            }
	            else if (direction === 'back') {
	                // moving back
	                enteringView.setZIndex(leavingView.zIndex - 1, this._renderer);
	            }
	            else {
	                // moving forward
	                enteringView.setZIndex(leavingView.zIndex + 1, this._renderer);
	            }
	        }
	    };
	    return NavController;
	}(Ion));
	var STATE_ACTIVE = 1;
	var STATE_INACTIVE = 2;
	var STATE_INIT_ENTER = 3;
	var STATE_INIT_LEAVE = 4;
	var STATE_TRANS_ENTER = 5;
	var STATE_TRANS_LEAVE = 6;
	var STATE_REMOVE = 7;
	var STATE_REMOVE_AFTER_TRANS = 8;
	var STATE_CANCEL_ENTER = 9;
	var STATE_FORCE_ACTIVE = 10;
	var INIT_ZINDEX = 100;
	var PORTAL_ZINDEX = 9999;
	var ctrlIds = -1;

	var __extends = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var NavPortal = (function (_super) {
	    __extends(NavPortal, _super);
	    function NavPortal(app, config, keyboard, elementRef, zone, renderer, compiler, menuCtrl, viewPort) {
	        _super.call(this, null, app, config, keyboard, elementRef, zone, renderer, compiler, menuCtrl);
	        this.isPortal = true;
	        this.setViewport(viewPort);
	        app.setPortal(this);
	        // on every page change make sure the portal has
	        // dismissed any views that should be auto dismissed on page change
	        app.viewDidLeave.subscribe(this.dismissPageChangeViews.bind(this));
	    }
	    /** @nocollapse */
	    NavPortal.decorators = [
	        { type: Directive, args: [{
	                    selector: '[nav-portal]'
	                },] },
	    ];
	    /** @nocollapse */
	    NavPortal.ctorParameters = [
	        { type: App, decorators: [{ type: Inject, args: [forwardRef(function () { return App; }),] },] },
	        { type: Config, },
	        { type: Keyboard, },
	        { type: ElementRef, },
	        { type: NgZone, },
	        { type: Renderer, },
	        { type: ComponentResolver, },
	        { type: MenuController, },
	        { type: ViewContainerRef, },
	    ];
	    return NavPortal;
	}(NavController));

	var App = (function () {
	    function App(_config, _platform) {
	        this._config = _config;
	        this._platform = _platform;
	        this._disTime = 0;
	        this._scrollTime = 0;
	        this._title = '';
	        this._titleSrv = new Title();
	        this._rootNav = null;
	        this.viewDidLoad = new EventEmitter();
	        this.viewWillEnter = new EventEmitter();
	        this.viewDidEnter = new EventEmitter();
	        this.viewWillLeave = new EventEmitter();
	        this.viewDidLeave = new EventEmitter();
	        this.viewWillUnload = new EventEmitter();
	        this.viewDidUnload = new EventEmitter();
	        // listen for hardware back button events
	        // register this back button action with a default priority
	        _platform.registerBackButtonAction(this.navPop.bind(this));
	    }
	    /**
	     * Sets the document title.
	     * @param {string} val  Value to set the document title to.
	     */
	    App.prototype.setTitle = function (val) {
	        if (val !== this._title) {
	            this._title = val;
	            this._titleSrv.setTitle(val);
	        }
	    };
	    /**
	     * @private
	     * Sets if the app is currently enabled or not, meaning if it's
	     * available to accept new user commands. For example, this is set to `false`
	     * while views transition, a modal slides up, an action-sheet
	     * slides up, etc. After the transition completes it is set back to `true`.
	     * @param {boolean} isEnabled
	     * @param {number} duration  When `isEnabled` is set to `false`, this argument
	     * is used to set the maximum number of milliseconds that app will wait until
	     * it will automatically enable the app again. It's basically a fallback incase
	     * something goes wrong during a transition and the app wasn't re-enabled correctly.
	     */
	    App.prototype.setEnabled = function (isEnabled, duration) {
	        if (duration === void 0) { duration = 700; }
	        this._disTime = (isEnabled ? 0 : Date.now() + duration);
	        if (this.clickBlock) {
	            if (isEnabled || duration <= 32) {
	                // disable the click block if it's enabled, or the duration is tiny
	                this.clickBlock.activate(false, 0);
	            }
	            else {
	                // show the click block for duration + some number
	                this.clickBlock.activate(true, duration + CLICK_BLOCK_BUFFER_IN_MILLIS);
	            }
	        }
	    };
	    /**
	     * @private
	     * Boolean if the app is actively enabled or not.
	     * @return {boolean}
	     */
	    App.prototype.isEnabled = function () {
	        return (this._disTime < Date.now());
	    };
	    /**
	     * @private
	     */
	    App.prototype.setScrolling = function () {
	        this._scrollTime = Date.now();
	    };
	    /**
	     * Boolean if the app is actively scrolling or not.
	     * @return {boolean}
	     */
	    App.prototype.isScrolling = function () {
	        return (this._scrollTime + 48 > Date.now());
	    };
	    /**
	     * @private
	     */
	    App.prototype.getActiveNav = function () {
	        var nav = this._rootNav || null;
	        var activeChildNav;
	        while (nav) {
	            activeChildNav = nav.getActiveChildNav();
	            if (!activeChildNav) {
	                break;
	            }
	            nav = activeChildNav;
	        }
	        return nav;
	    };
	    /**
	     * @private
	     */
	    App.prototype.getRootNav = function () {
	        return this._rootNav;
	    };
	    /**
	     * @private
	     */
	    App.prototype.setRootNav = function (nav) {
	        this._rootNav = nav;
	    };
	    /**
	     * @private
	     */
	    App.prototype.setPortal = function (portal) {
	        this._portal = portal;
	    };
	    /**
	     * @private
	     */
	    App.prototype.present = function (enteringView, opts) {
	        if (opts === void 0) { opts = {}; }
	        enteringView.setNav(this._portal);
	        opts.keyboardClose = false;
	        opts.direction = 'forward';
	        if (!opts.animation) {
	            opts.animation = enteringView.getTransitionName('forward');
	        }
	        enteringView.setLeavingOpts({
	            keyboardClose: false,
	            direction: 'back',
	            animation: enteringView.getTransitionName('back'),
	            ev: opts.ev
	        });
	        return this._portal.insertViews(-1, [enteringView], opts);
	    };
	    /**
	     * @private
	     */
	    App.prototype.navPop = function () {
	        // function used to climb up all parent nav controllers
	        function navPop(nav) {
	            if (nav) {
	                if (nav.length && nav.length() > 1) {
	                    // this nav controller has more than one view
	                    // pop the current view on this nav and we're done here
	                    console.debug('app, goBack pop nav');
	                    return nav.pop();
	                }
	                else if (nav.previousTab) {
	                    // FYI, using "nav instanceof Tabs" throws a Promise runtime error for whatever reason, idk
	                    // this is a Tabs container
	                    // see if there is a valid previous tab to go to
	                    var prevTab = nav.previousTab(true);
	                    if (prevTab) {
	                        console.debug('app, goBack previous tab');
	                        nav.select(prevTab);
	                        return Promise.resolve();
	                    }
	                }
	                // try again using the parent nav (if there is one)
	                return navPop(nav.parent);
	            }
	            // nerp, never found nav that could pop off a view
	            return null;
	        }
	        // app must be enabled and there must be a
	        // root nav controller for go back to work
	        if (this._rootNav && this.isEnabled()) {
	            // first check if the root navigation has any overlays
	            // opened in it's portal, like alert/actionsheet/popup
	            if (this._portal && this._portal.length() > 0) {
	                // there is an overlay view in the portal
	                // let's pop this one off to go back
	                console.debug('app, goBack pop overlay');
	                return this._portal.pop();
	            }
	            // next get the active nav, check itself and climb up all
	            // of its parent navs until it finds a nav that can pop
	            var navPromise = navPop(this.getActiveNav());
	            if (navPromise === null) {
	                // no views to go back to
	                // let's exit the app
	                if (this._config.getBoolean('navExitApp', true)) {
	                    console.debug('app, goBack exitApp');
	                    this._platform.exitApp();
	                }
	            }
	            else {
	                return navPromise;
	            }
	        }
	        return Promise.resolve();
	    };
	    /**
	     * @private
	     */
	    App.prototype.getRegisteredComponent = function (cls) {
	        // deprecated warning: added 2016-04-28, beta7
	        console.warn('Using app.getRegisteredComponent() to query components has been deprecated. ' +
	            'Please use Angular\'s ViewChild annotation instead:\n\nhttp://learnangular2.com/viewChild/');
	    };
	    /**
	     * @private
	     */
	    App.prototype.getComponent = function (id) {
	        // deprecated warning: added 2016-04-28, beta7
	        console.warn('Using app.getComponent() to query components has been deprecated. ' +
	            'Please use Angular\'s ViewChild annotation instead:\n\nhttp://learnangular2.com/viewChild/');
	    };
	    /**
	     * Get an instance of the global app injector that contains references to all of the instantiated providers
	     * @returns {Injector}
	     */
	    App.prototype.getAppInjector = function () {
	        // deprecated warning: added 2016-06-27, beta10
	        console.warn('Recent Angular2 versions should no longer require App.getAppInjector()');
	    };
	    /** @nocollapse */
	    App.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    App.ctorParameters = [
	        { type: Config, },
	        { type: Platform, },
	    ];
	    return App;
	}());
	var CLICK_BLOCK_BUFFER_IN_MILLIS = 64;

	/**
	 * Used to provide a {@link ControlValueAccessor} for form controls.
	 *
	 * See {@link DefaultValueAccessor} for how to implement one.
	 * @experimental
	 */
	var NG_VALUE_ACCESSOR$1 =
	/*@ts2dart_const*/new OpaqueToken('NgValueAccessor');

	var CHECKBOX_VALUE_ACCESSOR$1 = {
	    provide: NG_VALUE_ACCESSOR$1,
	    useExisting: forwardRef(function () {
	        return CheckboxControlValueAccessor$1;
	    }),
	    multi: true
	};
	var CheckboxControlValueAccessor$1 = function () {
	    function CheckboxControlValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, CheckboxControlValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(CheckboxControlValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this.onChange = fn;
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }]);
	    return CheckboxControlValueAccessor;
	}();
	/** @nocollapse */
	CheckboxControlValueAccessor$1.decorators = [{ type: Directive, args: [{
	        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
	        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
	        providers: [CHECKBOX_VALUE_ACCESSOR$1]
	    }] }];
	/** @nocollapse */
	CheckboxControlValueAccessor$1.ctorParameters = [{ type: Renderer }, { type: ElementRef }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalScope$5;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope$5 = self;
	    } else {
	        globalScope$5 = global;
	    }
	} else {
	    globalScope$5 = window;
	}
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var global$6 = globalScope$5;
	var Date$6 = global$6.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	global$6.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent$6(obj) {
	    return obj !== undefined && obj !== null;
	}
	function isBlank$6(obj) {
	    return obj === undefined || obj === null;
	}
	function isString$6(obj) {
	    return typeof obj === 'string';
	}
	function isPromise$5(obj) {
	    return obj instanceof global$6.Promise;
	}
	function isArray$7(obj) {
	    return Array.isArray(obj);
	}
	function noop$5() {}
	var StringWrapper$5 = function () {
	    function StringWrapper() {
	        classCallCheck(this, StringWrapper);
	    }

	    createClass(StringWrapper, null, [{
	        key: 'fromCharCode',
	        value: function fromCharCode(code) {
	            return String.fromCharCode(code);
	        }
	    }, {
	        key: 'charCodeAt',
	        value: function charCodeAt(s, index) {
	            return s.charCodeAt(index);
	        }
	    }, {
	        key: 'split',
	        value: function split(s, regExp) {
	            return s.split(regExp);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(s, s2) {
	            return s === s2;
	        }
	    }, {
	        key: 'stripLeft',
	        value: function stripLeft(s, charVal) {
	            if (s && s.length) {
	                var pos = 0;
	                for (var i = 0; i < s.length; i++) {
	                    if (s[i] != charVal) break;
	                    pos++;
	                }
	                s = s.substring(pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'stripRight',
	        value: function stripRight(s, charVal) {
	            if (s && s.length) {
	                var pos = s.length;
	                for (var i = s.length - 1; i >= 0; i--) {
	                    if (s[i] != charVal) break;
	                    pos--;
	                }
	                s = s.substring(0, pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'replace',
	        value: function replace(s, from, _replace) {
	            return s.replace(from, _replace);
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(s, from, replace) {
	            return s.replace(from, replace);
	        }
	    }, {
	        key: 'slice',
	        value: function slice(s) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return s.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'replaceAllMapped',
	        value: function replaceAllMapped(s, from, cb) {
	            return s.replace(from, function () {
	                for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
	                    matches[_key] = arguments[_key];
	                }

	                // Remove offset & string from the result array
	                matches.splice(-2, 2);
	                // The callback receives match, p1, ..., pn
	                return cb(matches);
	            });
	        }
	    }, {
	        key: 'contains',
	        value: function contains(s, substr) {
	            return s.indexOf(substr) != -1;
	        }
	    }, {
	        key: 'compare',
	        value: function compare(a, b) {
	            if (a < b) {
	                return -1;
	            } else if (a > b) {
	                return 1;
	            } else {
	                return 0;
	            }
	        }
	    }]);
	    return StringWrapper;
	}();

	var StringJoiner$5 = function () {
	    function StringJoiner() {
	        var parts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, StringJoiner);

	        this.parts = parts;
	    }

	    createClass(StringJoiner, [{
	        key: 'add',
	        value: function add(part) {
	            this.parts.push(part);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.parts.join('');
	        }
	    }]);
	    return StringJoiner;
	}();
	var NumberParseError$5 = function (_Error) {
	    inherits(NumberParseError, _Error);

	    function NumberParseError(message) {
	        classCallCheck(this, NumberParseError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NumberParseError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(NumberParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return NumberParseError;
	}(Error);
	var NumberWrapper$5 = function () {
	    function NumberWrapper() {
	        classCallCheck(this, NumberWrapper);
	    }

	    createClass(NumberWrapper, null, [{
	        key: 'toFixed',
	        value: function toFixed(n, fractionDigits) {
	            return n.toFixed(fractionDigits);
	        }
	    }, {
	        key: 'equal',
	        value: function equal(a, b) {
	            return a === b;
	        }
	    }, {
	        key: 'parseIntAutoRadix',
	        value: function parseIntAutoRadix(text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new NumberParseError$5('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        }
	    }, {
	        key: 'parseInt',
	        value: function (_parseInt) {
	            function parseInt(_x4, _x5) {
	                return _parseInt.apply(this, arguments);
	            }

	            parseInt.toString = function () {
	                return _parseInt.toString();
	            };

	            return parseInt;
	        }(function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new NumberParseError$5('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        })
	        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.

	    }, {
	        key: 'parseFloat',
	        value: function (_parseFloat) {
	            function parseFloat(_x6) {
	                return _parseFloat.apply(this, arguments);
	            }

	            parseFloat.toString = function () {
	                return _parseFloat.toString();
	            };

	            return parseFloat;
	        }(function (text) {
	            return parseFloat(text);
	        })
	    }, {
	        key: 'isNumeric',
	        value: function isNumeric(value) {
	            return !isNaN(value - parseFloat(value));
	        }
	    }, {
	        key: 'isNaN',
	        value: function (_isNaN) {
	            function isNaN(_x7) {
	                return _isNaN.apply(this, arguments);
	            }

	            isNaN.toString = function () {
	                return _isNaN.toString();
	            };

	            return isNaN;
	        }(function (value) {
	            return isNaN(value);
	        })
	    }, {
	        key: 'isInteger',
	        value: function isInteger(value) {
	            return Number.isInteger(value);
	        }
	    }, {
	        key: 'NaN',
	        get: function get() {
	            return NaN;
	        }
	    }]);
	    return NumberWrapper;
	}();
	var RegExpWrapper$5 = function () {
	    function RegExpWrapper() {
	        classCallCheck(this, RegExpWrapper);
	    }

	    createClass(RegExpWrapper, null, [{
	        key: 'create',
	        value: function create(regExpStr) {
	            var flags = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            flags = flags.replace(/g/g, '');
	            return new global$6.RegExp(regExpStr, flags + 'g');
	        }
	    }, {
	        key: 'firstMatch',
	        value: function firstMatch(regExp, input) {
	            // Reset multimatch regex state
	            regExp.lastIndex = 0;
	            return regExp.exec(input);
	        }
	    }, {
	        key: 'test',
	        value: function test(regExp, input) {
	            regExp.lastIndex = 0;
	            return regExp.test(input);
	        }
	    }, {
	        key: 'matcher',
	        value: function matcher(regExp, input) {
	            // Reset regex state for the case
	            // someone did not loop over all matches
	            // last time.
	            regExp.lastIndex = 0;
	            return { re: regExp, input: input };
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(regExp, input, replace) {
	            var c = regExp.exec(input);
	            var res = '';
	            regExp.lastIndex = 0;
	            var prev = 0;
	            while (c) {
	                res += input.substring(prev, c.index);
	                res += replace(c);
	                prev = c.index + c[0].length;
	                regExp.lastIndex = prev;
	                c = regExp.exec(input);
	            }
	            res += input.substring(prev);
	            return res;
	        }
	    }]);
	    return RegExpWrapper;
	}();
	var RegExpMatcherWrapper$5 = function () {
	    function RegExpMatcherWrapper() {
	        classCallCheck(this, RegExpMatcherWrapper);
	    }

	    createClass(RegExpMatcherWrapper, null, [{
	        key: 'next',
	        value: function next(matcher) {
	            return matcher.re.exec(matcher.input);
	        }
	    }]);
	    return RegExpMatcherWrapper;
	}();
	var FunctionWrapper$5 = function () {
	    function FunctionWrapper() {
	        classCallCheck(this, FunctionWrapper);
	    }

	    createClass(FunctionWrapper, null, [{
	        key: 'apply',
	        value: function apply(fn, posArgs) {
	            return fn.apply(null, posArgs);
	        }
	    }, {
	        key: 'bind',
	        value: function bind(fn, scope) {
	            return fn.bind(scope);
	        }
	    }]);
	    return FunctionWrapper;
	}();
	// JS has NaN !== NaN
	function looseIdentical$5(a, b) {
	    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	}
	function normalizeBool$5(obj) {
	    return isBlank$6(obj) ? false : obj;
	}
	function isJsObject$5(o) {
	    return o !== null && (typeof o === 'function' || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object');
	}
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json$5 = function () {
	    function Json() {
	        classCallCheck(this, Json);
	    }

	    createClass(Json, null, [{
	        key: 'parse',
	        value: function parse(s) {
	            return global$6.JSON.parse(s);
	        }
	    }, {
	        key: 'stringify',
	        value: function stringify(data) {
	            // Dart doesn't take 3 arguments
	            return global$6.JSON.stringify(data, null, 2);
	        }
	    }]);
	    return Json;
	}();
	var DateWrapper$5 = function () {
	    function DateWrapper() {
	        classCallCheck(this, DateWrapper);
	    }

	    createClass(DateWrapper, null, [{
	        key: 'create',
	        value: function create(year) {
	            var month = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var day = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	            var hour = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	            var minutes = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
	            var seconds = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
	            var milliseconds = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];

	            return new Date$6(year, month - 1, day, hour, minutes, seconds, milliseconds);
	        }
	    }, {
	        key: 'fromISOString',
	        value: function fromISOString(str) {
	            return new Date$6(str);
	        }
	    }, {
	        key: 'fromMillis',
	        value: function fromMillis(ms) {
	            return new Date$6(ms);
	        }
	    }, {
	        key: 'toMillis',
	        value: function toMillis(date) {
	            return date.getTime();
	        }
	    }, {
	        key: 'now',
	        value: function now() {
	            return new Date$6();
	        }
	    }, {
	        key: 'toJson',
	        value: function toJson(date) {
	            return date.toJSON();
	        }
	    }]);
	    return DateWrapper;
	}();
	var _symbolIterator$5 = null;
	function getSymbolIterator$5() {
	    if (isBlank$6(_symbolIterator$5)) {
	        if (isPresent$6(globalScope$5.Symbol) && isPresent$6(Symbol.iterator)) {
	            _symbolIterator$5 = Symbol.iterator;
	        } else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator$5 = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator$5;
	}
	function isPrimitive$5(obj) {
	    return !isJsObject$5(obj);
	}
	function hasConstructor$5(value, type) {
	    return value.constructor === type;
	}

	var DEFAULT_VALUE_ACCESSOR$1 =
	/* @ts2dart_Provider */{
	    provide: NG_VALUE_ACCESSOR$1,
	    useExisting: forwardRef(function () {
	        return DefaultValueAccessor$1;
	    }),
	    multi: true
	};
	var DefaultValueAccessor$1 = function () {
	    function DefaultValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, DefaultValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(DefaultValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            var normalizedValue = isBlank$6(value) ? '' : value;
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this.onChange = fn;
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }]);
	    return DefaultValueAccessor;
	}();
	/** @nocollapse */
	DefaultValueAccessor$1.decorators = [{ type: Directive, args: [{
	        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
	        // TODO: vsavkin replace the above selector with the one below it once
	        // https://github.com/angular/angular/issues/3011 is implemented
	        // selector: '[ngControl],[ngModel],[ngFormControl]',
	        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	        providers: [DEFAULT_VALUE_ACCESSOR$1]
	    }] }];
	/** @nocollapse */
	DefaultValueAccessor$1.ctorParameters = [{ type: Renderer }, { type: ElementRef }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException$5 = function (_Error) {
	  inherits(BaseWrappedException, _Error);

	  function BaseWrappedException(message) {
	    classCallCheck(this, BaseWrappedException);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(BaseWrappedException).call(this, message));
	  }

	  createClass(BaseWrappedException, [{
	    key: 'wrapperMessage',
	    get: function get() {
	      return '';
	    }
	  }, {
	    key: 'wrapperStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalException',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'message',
	    get: function get() {
	      return '';
	    }
	  }]);
	  return BaseWrappedException;
	}(Error);

	var Map$6 = global$6.Map;
	var Set$6 = global$6.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs$5 = function () {
	    try {
	        if (new Map$6([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) {
	                return new Map$6(pairs);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new Map$6();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	}();
	var createMapFromMap$5 = function () {
	    try {
	        if (new Map$6(new Map$6())) {
	            return function createMapFromMap(m) {
	                return new Map$6(m);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromMap(m) {
	        var map = new Map$6();
	        m.forEach(function (v, k) {
	            map.set(k, v);
	        });
	        return map;
	    };
	}();
	var _clearValues$5 = function () {
	    if (new Map$6().keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!(k = keyIterator.next()).done) {
	                m.set(k.value, null);
	            }
	        };
	    } else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) {
	                m.set(k, null);
	            });
	        };
	    }
	}();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap$5 = function () {
	    try {
	        if (new Map$6().values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    } catch (e) {}
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper$5.createFixedSize(m.size),
	            i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	}();
	var MapWrapper$5 = function () {
	    function MapWrapper() {
	        classCallCheck(this, MapWrapper);
	    }

	    createClass(MapWrapper, null, [{
	        key: 'clone',
	        value: function clone(m) {
	            return createMapFromMap$5(m);
	        }
	    }, {
	        key: 'createFromStringMap',
	        value: function createFromStringMap(stringMap) {
	            var result = new Map$6();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        }
	    }, {
	        key: 'toStringMap',
	        value: function toStringMap(m) {
	            var r = {};
	            m.forEach(function (v, k) {
	                return r[k] = v;
	            });
	            return r;
	        }
	    }, {
	        key: 'createFromPairs',
	        value: function createFromPairs(pairs) {
	            return createMapFromPairs$5(pairs);
	        }
	    }, {
	        key: 'clearValues',
	        value: function clearValues(m) {
	            _clearValues$5(m);
	        }
	    }, {
	        key: 'iterable',
	        value: function iterable(m) {
	            return m;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(m) {
	            return _arrayFromMap$5(m, false);
	        }
	    }, {
	        key: 'values',
	        value: function values(m) {
	            return _arrayFromMap$5(m, true);
	        }
	    }]);
	    return MapWrapper;
	}();
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper$5 = function () {
	    function StringMapWrapper() {
	        classCallCheck(this, StringMapWrapper);
	    }

	    createClass(StringMapWrapper, null, [{
	        key: 'create',
	        value: function create() {
	            // Note: We are not using Object.create(null) here due to
	            // performance!
	            // http://jsperf.com/ng2-object-create-null
	            return {};
	        }
	    }, {
	        key: 'contains',
	        value: function contains(map, key) {
	            return map.hasOwnProperty(key);
	        }
	    }, {
	        key: 'get',
	        value: function get(map, key) {
	            return map.hasOwnProperty(key) ? map[key] : undefined;
	        }
	    }, {
	        key: 'set',
	        value: function set(map, key, value) {
	            map[key] = value;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(map) {
	            return Object.keys(map);
	        }
	    }, {
	        key: 'values',
	        value: function values(map) {
	            return Object.keys(map).reduce(function (r, a) {
	                r.push(map[a]);
	                return r;
	            }, []);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(map) {
	            for (var prop in map) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(map, key) {
	            delete map[key];
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(map, callback) {
	            for (var prop in map) {
	                if (map.hasOwnProperty(prop)) {
	                    callback(map[prop], prop);
	                }
	            }
	        }
	    }, {
	        key: 'merge',
	        value: function merge(m1, m2) {
	            var m = {};
	            for (var attr in m1) {
	                if (m1.hasOwnProperty(attr)) {
	                    m[attr] = m1[attr];
	                }
	            }
	            for (var attr in m2) {
	                if (m2.hasOwnProperty(attr)) {
	                    m[attr] = m2[attr];
	                }
	            }
	            return m;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            var key;
	            for (var i = 0; i < k1.length; i++) {
	                key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }]);
	    return StringMapWrapper;
	}();
	var ListWrapper$5 = function () {
	    function ListWrapper() {
	        classCallCheck(this, ListWrapper);
	    }

	    createClass(ListWrapper, null, [{
	        key: 'createFixedSize',

	        // JS has no way to express a statically fixed size list, but dart does so we
	        // keep both methods.
	        value: function createFixedSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'createGrowableSize',
	        value: function createGrowableSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'clone',
	        value: function clone(array) {
	            return array.slice(0);
	        }
	    }, {
	        key: 'forEachWithIndex',
	        value: function forEachWithIndex(array, fn) {
	            for (var i = 0; i < array.length; i++) {
	                fn(array[i], i);
	            }
	        }
	    }, {
	        key: 'first',
	        value: function first(array) {
	            if (!array) return null;
	            return array[0];
	        }
	    }, {
	        key: 'last',
	        value: function last(array) {
	            if (!array || array.length == 0) return null;
	            return array[array.length - 1];
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(array, value) {
	            var startIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	            return array.indexOf(value, startIndex);
	        }
	    }, {
	        key: 'contains',
	        value: function contains(list, el) {
	            return list.indexOf(el) !== -1;
	        }
	    }, {
	        key: 'reversed',
	        value: function reversed(array) {
	            var a = ListWrapper.clone(array);
	            return a.reverse();
	        }
	    }, {
	        key: 'concat',
	        value: function concat(a, b) {
	            return a.concat(b);
	        }
	    }, {
	        key: 'insert',
	        value: function insert(list, index, value) {
	            list.splice(index, 0, value);
	        }
	    }, {
	        key: 'removeAt',
	        value: function removeAt(list, index) {
	            var res = list[index];
	            list.splice(index, 1);
	            return res;
	        }
	    }, {
	        key: 'removeAll',
	        value: function removeAll(list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'clear',
	        value: function clear(list) {
	            list.length = 0;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(list) {
	            return list.length == 0;
	        }
	    }, {
	        key: 'fill',
	        value: function fill(list, value) {
	            var start = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	            var end = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            list.fill(value, start, end === null ? list.length : end);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(a, b) {
	            if (a.length != b.length) return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i]) return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'slice',
	        value: function slice(l) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return l.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'splice',
	        value: function splice(l, from, length) {
	            return l.splice(from, length);
	        }
	    }, {
	        key: 'sort',
	        value: function sort(l, compareFn) {
	            if (isPresent$6(compareFn)) {
	                l.sort(compareFn);
	            } else {
	                l.sort();
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString(l) {
	            return l.toString();
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON(l) {
	            return JSON.stringify(l);
	        }
	    }, {
	        key: 'maximum',
	        value: function maximum(list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (isBlank$6(candidate)) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        }
	    }, {
	        key: 'flatten',
	        value: function flatten(list) {
	            var target = [];
	            _flattenArray$5(list, target);
	            return target;
	        }
	    }, {
	        key: 'addAll',
	        value: function addAll(list, source) {
	            for (var i = 0; i < source.length; i++) {
	                list.push(source[i]);
	            }
	        }
	    }]);
	    return ListWrapper;
	}();
	function _flattenArray$5(source, target) {
	    if (isPresent$6(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (isArray$7(item)) {
	                _flattenArray$5(item, target);
	            } else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable$5(obj) {
	    if (!isJsObject$5(obj)) return false;
	    return isArray$7(obj) || !(obj instanceof Map$6) && getSymbolIterator$5() in obj; // JS Iterable have a Symbol.iterator prop
	}
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList$5 = function () {
	    var test = new Set$6([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) {
	            return new Set$6(lst);
	        };
	    } else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new Set$6(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	}();
	var SetWrapper$5 = function () {
	    function SetWrapper() {
	        classCallCheck(this, SetWrapper);
	    }

	    createClass(SetWrapper, null, [{
	        key: 'createFromList',
	        value: function createFromList(lst) {
	            return createSetFromList$5(lst);
	        }
	    }, {
	        key: 'has',
	        value: function has(s, key) {
	            return s.has(key);
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(m, k) {
	            m.delete(k);
	        }
	    }]);
	    return SetWrapper;
	}();

	var _ArrayLogger$5 = function () {
	    function _ArrayLogger() {
	        classCallCheck(this, _ArrayLogger);

	        this.res = [];
	    }

	    createClass(_ArrayLogger, [{
	        key: 'log',
	        value: function log(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logError',
	        value: function logError(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return _ArrayLogger;
	}();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */


	var ExceptionHandler$5 = function () {
	    function ExceptionHandler(_logger) {
	        var _rethrowException = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        classCallCheck(this, ExceptionHandler);

	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }

	    createClass(ExceptionHandler, [{
	        key: 'call',
	        value: function call(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var originalException = this._findOriginalException(exception);
	            var originalStack = this._findOriginalStack(exception);
	            var context = this._findContext(exception);
	            this._logger.logGroup('EXCEPTION: ' + this._extractMessage(exception));
	            if (isPresent$6(stackTrace) && isBlank$6(originalStack)) {
	                this._logger.logError('STACKTRACE:');
	                this._logger.logError(this._longStackTrace(stackTrace));
	            }
	            if (isPresent$6(reason)) {
	                this._logger.logError('REASON: ' + reason);
	            }
	            if (isPresent$6(originalException)) {
	                this._logger.logError('ORIGINAL EXCEPTION: ' + this._extractMessage(originalException));
	            }
	            if (isPresent$6(originalStack)) {
	                this._logger.logError('ORIGINAL STACKTRACE:');
	                this._logger.logError(this._longStackTrace(originalStack));
	            }
	            if (isPresent$6(context)) {
	                this._logger.logError('ERROR CONTEXT:');
	                this._logger.logError(context);
	            }
	            this._logger.logGroupEnd();
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	            if (this._rethrowException) throw exception;
	        }
	        /** @internal */

	    }, {
	        key: '_extractMessage',
	        value: function _extractMessage(exception) {
	            return exception instanceof BaseWrappedException$5 ? exception.wrapperMessage : exception.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_longStackTrace',
	        value: function _longStackTrace(stackTrace) {
	            return isListLikeIterable$5(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_findContext',
	        value: function _findContext(exception) {
	            try {
	                if (!(exception instanceof BaseWrappedException$5)) return null;
	                return isPresent$6(exception.context) ? exception.context : this._findContext(exception.originalException);
	            } catch (e) {
	                // exception.context can throw an exception. if it happens, we ignore the context.
	                return null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalException',
	        value: function _findOriginalException(exception) {
	            if (!(exception instanceof BaseWrappedException$5)) return null;
	            var e = exception.originalException;
	            while (e instanceof BaseWrappedException$5 && isPresent$6(e.originalException)) {
	                e = e.originalException;
	            }
	            return e;
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalStack',
	        value: function _findOriginalStack(exception) {
	            if (!(exception instanceof BaseWrappedException$5)) return null;
	            var e = exception;
	            var stack = exception.originalStack;
	            while (e instanceof BaseWrappedException$5 && isPresent$6(e.originalException)) {
	                e = e.originalException;
	                if (e instanceof BaseWrappedException$5 && isPresent$6(e.originalException)) {
	                    stack = e.originalStack;
	                }
	            }
	            return stack;
	        }
	    }], [{
	        key: 'exceptionToString',
	        value: function exceptionToString(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var l = new _ArrayLogger$5();
	            var e = new ExceptionHandler(l, false);
	            e.call(exception, stackTrace, reason);
	            return l.res.join('\n');
	        }
	    }]);
	    return ExceptionHandler;
	}();

	/**
	 * @stable
	 */
	var BaseException$5 = function (_Error) {
	    inherits(BaseException, _Error);

	    function BaseException() {
	        var message = arguments.length <= 0 || arguments[0] === undefined ? '--' : arguments[0];
	        classCallCheck(this, BaseException);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseException).call(this, message));

	        _this.message = message;
	        _this.stack = new Error(message).stack;
	        return _this;
	    }

	    createClass(BaseException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return BaseException;
	}(Error);
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException$5 = function (_BaseWrappedException) {
	    inherits(WrappedException, _BaseWrappedException);

	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        classCallCheck(this, WrappedException);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(WrappedException).call(this, _wrapperMessage));

	        _this2._wrapperMessage = _wrapperMessage;
	        _this2._originalException = _originalException;
	        _this2._originalStack = _originalStack;
	        _this2._context = _context;
	        _this2._wrapperStack = new Error(_wrapperMessage).stack;
	        return _this2;
	    }

	    createClass(WrappedException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            return this._wrapperMessage;
	        }
	    }, {
	        key: 'wrapperStack',
	        get: function get() {
	            return this._wrapperStack;
	        }
	    }, {
	        key: 'originalException',
	        get: function get() {
	            return this._originalException;
	        }
	    }, {
	        key: 'originalStack',
	        get: function get() {
	            return this._originalStack;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._context;
	        }
	    }, {
	        key: 'message',
	        get: function get() {
	            return ExceptionHandler$5.exceptionToString(this);
	        }
	    }]);
	    return WrappedException;
	}(BaseWrappedException$5);
	function unimplemented$5() {
	    throw new BaseException$5('unimplemented');
	}

	/**
	 * Base class for control directives.
	 *
	 * Only used internally in the forms module.
	 *
	 * @experimental
	 */
	var AbstractControlDirective$1 = function () {
	    function AbstractControlDirective() {
	        classCallCheck(this, AbstractControlDirective);
	    }

	    createClass(AbstractControlDirective, [{
	        key: 'control',
	        get: function get() {
	            return unimplemented$5();
	        }
	    }, {
	        key: 'value',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.value : null;
	        }
	    }, {
	        key: 'valid',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.valid : null;
	        }
	    }, {
	        key: 'errors',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.errors : null;
	        }
	    }, {
	        key: 'pristine',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.pristine : null;
	        }
	    }, {
	        key: 'dirty',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.dirty : null;
	        }
	    }, {
	        key: 'touched',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.touched : null;
	        }
	    }, {
	        key: 'untouched',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.untouched : null;
	        }
	    }, {
	        key: 'statusChanges',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.statusChanges : null;
	        }
	    }, {
	        key: 'valueChanges',
	        get: function get() {
	            return isPresent$6(this.control) ? this.control.valueChanges : null;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return null;
	        }
	    }]);
	    return AbstractControlDirective;
	}();

	/**
	 * A base class that all control directive extend.
	 * It binds a {@link Control} object to a DOM element.
	 *
	 * Used internally by Angular forms.
	 *
	 * @experimental
	 */
	var NgControl$1 = function (_AbstractControlDirec) {
	  inherits(NgControl, _AbstractControlDirec);

	  function NgControl() {
	    var _Object$getPrototypeO;

	    classCallCheck(this, NgControl);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    var _this = possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(NgControl)).call.apply(_Object$getPrototypeO, [this].concat(args)));

	    _this.name = null;
	    _this.valueAccessor = null;
	    return _this;
	  }

	  createClass(NgControl, [{
	    key: 'validator',
	    get: function get() {
	      return unimplemented$5();
	    }
	  }, {
	    key: 'asyncValidator',
	    get: function get() {
	      return unimplemented$5();
	    }
	  }]);
	  return NgControl;
	}(AbstractControlDirective$1);

	var NgControlStatus$1 = function () {
	    function NgControlStatus(cd) {
	        classCallCheck(this, NgControlStatus);

	        this._cd = cd;
	    }

	    createClass(NgControlStatus, [{
	        key: 'ngClassUntouched',
	        get: function get() {
	            return isPresent$6(this._cd.control) ? this._cd.control.untouched : false;
	        }
	    }, {
	        key: 'ngClassTouched',
	        get: function get() {
	            return isPresent$6(this._cd.control) ? this._cd.control.touched : false;
	        }
	    }, {
	        key: 'ngClassPristine',
	        get: function get() {
	            return isPresent$6(this._cd.control) ? this._cd.control.pristine : false;
	        }
	    }, {
	        key: 'ngClassDirty',
	        get: function get() {
	            return isPresent$6(this._cd.control) ? this._cd.control.dirty : false;
	        }
	    }, {
	        key: 'ngClassValid',
	        get: function get() {
	            return isPresent$6(this._cd.control) ? this._cd.control.valid : false;
	        }
	    }, {
	        key: 'ngClassInvalid',
	        get: function get() {
	            return isPresent$6(this._cd.control) ? !this._cd.control.valid : false;
	        }
	    }]);
	    return NgControlStatus;
	}();
	/** @nocollapse */
	NgControlStatus$1.decorators = [{ type: Directive, args: [{
	        selector: '[formControlName],[ngModel],[formControl]',
	        host: {
	            '[class.ng-untouched]': 'ngClassUntouched',
	            '[class.ng-touched]': 'ngClassTouched',
	            '[class.ng-pristine]': 'ngClassPristine',
	            '[class.ng-dirty]': 'ngClassDirty',
	            '[class.ng-valid]': 'ngClassValid',
	            '[class.ng-invalid]': 'ngClassInvalid'
	        }
	    }] }];
	/** @nocollapse */
	NgControlStatus$1.ctorParameters = [{ type: NgControl$1, decorators: [{ type: Self }] }];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var PromiseCompleter$5 = function PromiseCompleter() {
	    var _this = this;

	    classCallCheck(this, PromiseCompleter);

	    this.promise = new Promise(function (res, rej) {
	        _this.resolve = res;
	        _this.reject = rej;
	    });
	};
	var PromiseWrapper$5 = function () {
	    function PromiseWrapper() {
	        classCallCheck(this, PromiseWrapper);
	    }

	    createClass(PromiseWrapper, null, [{
	        key: "resolve",
	        value: function resolve(obj) {
	            return Promise.resolve(obj);
	        }
	    }, {
	        key: "reject",
	        value: function reject(obj, _) {
	            return Promise.reject(obj);
	        }
	        // Note: We can't rename this method into `catch`, as this is not a valid
	        // method name in Dart.

	    }, {
	        key: "catchError",
	        value: function catchError(promise, onError) {
	            return promise.catch(onError);
	        }
	    }, {
	        key: "all",
	        value: function all(promises) {
	            if (promises.length == 0) return Promise.resolve([]);
	            return Promise.all(promises);
	        }
	    }, {
	        key: "then",
	        value: function then(promise, success, rejection) {
	            return promise.then(success, rejection);
	        }
	    }, {
	        key: "wrap",
	        value: function wrap(computation) {
	            return new Promise(function (res, rej) {
	                try {
	                    res(computation());
	                } catch (e) {
	                    rej(e);
	                }
	            });
	        }
	    }, {
	        key: "scheduleMicrotask",
	        value: function scheduleMicrotask(computation) {
	            PromiseWrapper.then(PromiseWrapper.resolve(null), computation, function (_) {});
	        }
	    }, {
	        key: "completer",
	        value: function completer() {
	            return new PromiseCompleter$5();
	        }
	    }]);
	    return PromiseWrapper;
	}();

	var TimerWrapper$5 = function () {
	    function TimerWrapper() {
	        classCallCheck(this, TimerWrapper);
	    }

	    createClass(TimerWrapper, null, [{
	        key: 'setTimeout',
	        value: function setTimeout(fn, millis) {
	            return global$6.setTimeout(fn, millis);
	        }
	    }, {
	        key: 'clearTimeout',
	        value: function clearTimeout(id) {
	            global$6.clearTimeout(id);
	        }
	    }, {
	        key: 'setInterval',
	        value: function setInterval(fn, millis) {
	            return global$6.setInterval(fn, millis);
	        }
	    }, {
	        key: 'clearInterval',
	        value: function clearInterval(id) {
	            global$6.clearInterval(id);
	        }
	    }]);
	    return TimerWrapper;
	}();
	var ObservableWrapper$5 = function () {
	    function ObservableWrapper() {
	        classCallCheck(this, ObservableWrapper);
	    }

	    createClass(ObservableWrapper, null, [{
	        key: 'subscribe',

	        // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	        value: function subscribe(emitter, onNext, onError) {
	            var onComplete = arguments.length <= 3 || arguments[3] === undefined ? function () {} : arguments[3];

	            onError = typeof onError === 'function' && onError || noop$5;
	            onComplete = typeof onComplete === 'function' && onComplete || noop$5;
	            return emitter.subscribe({ next: onNext, error: onError, complete: onComplete });
	        }
	    }, {
	        key: 'isObservable',
	        value: function isObservable(obs) {
	            return !!obs.subscribe;
	        }
	        /**
	         * Returns whether `obs` has any subscribers listening to events.
	         */

	    }, {
	        key: 'hasSubscribers',
	        value: function hasSubscribers(obs) {
	            return obs.observers.length > 0;
	        }
	    }, {
	        key: 'dispose',
	        value: function dispose(subscription) {
	            subscription.unsubscribe();
	        }
	        /**
	         * @deprecated - use callEmit() instead
	         */

	    }, {
	        key: 'callNext',
	        value: function callNext(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callEmit',
	        value: function callEmit(emitter, value) {
	            emitter.emit(value);
	        }
	    }, {
	        key: 'callError',
	        value: function callError(emitter, error) {
	            emitter.error(error);
	        }
	    }, {
	        key: 'callComplete',
	        value: function callComplete(emitter) {
	            emitter.complete();
	        }
	    }, {
	        key: 'fromPromise',
	        value: function fromPromise(promise) {
	            return PromiseObservable.create(promise);
	        }
	    }, {
	        key: 'toPromise',
	        value: function toPromise(obj) {
	            return _toPromise.call(obj);
	        }
	    }]);
	    return ObservableWrapper;
	}();
	/**
	 * Use by directives and components to emit custom Events.
	 *
	 * ### Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({
	 *   selector: 'zippy',
	 *   template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Output() open: EventEmitter<any> = new EventEmitter();
	 *   @Output() close: EventEmitter<any> = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.emit(null);
	 *     } else {
	 *       this.close.emit(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * The events payload can be accessed by the parameter `$event` on the components output event
	 * handler:
	 *
	 * ```
	 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	 * ```
	 *
	 * Uses Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 * @stable
	 */
	var EventEmitter$5 = function (_Subject) {
	    inherits(EventEmitter, _Subject);

	    /**
	     * Creates an instance of [EventEmitter], which depending on [isAsync],
	     * delivers events synchronously or asynchronously.
	     */

	    function EventEmitter() {
	        var isAsync = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	        classCallCheck(this, EventEmitter);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(EventEmitter).call(this));

	        _this.__isAsync = isAsync;
	        return _this;
	    }

	    createClass(EventEmitter, [{
	        key: 'emit',
	        value: function emit(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	        /**
	         * @deprecated - use .emit(value) instead
	         */

	    }, {
	        key: 'next',
	        value: function next(value) {
	            get(Object.getPrototypeOf(EventEmitter.prototype), 'next', this).call(this, value);
	        }
	    }, {
	        key: 'subscribe',
	        value: function subscribe(generatorOrNext, error, complete) {
	            var schedulerFn = void 0;
	            var errorFn = function errorFn(err) {
	                return null;
	            };
	            var completeFn = function completeFn() {
	                return null;
	            };
	            if (generatorOrNext && (typeof generatorOrNext === 'undefined' ? 'undefined' : _typeof(generatorOrNext)) === 'object') {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext.next(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext.next(value);
	                };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return generatorOrNext.error(err);
	                        });
	                    } : function (err) {
	                        generatorOrNext.error(err);
	                    };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return generatorOrNext.complete();
	                        });
	                    } : function () {
	                        generatorOrNext.complete();
	                    };
	                }
	            } else {
	                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
	                    setTimeout(function () {
	                        return generatorOrNext(value);
	                    });
	                } : function (value /** TODO #9100 */) {
	                    generatorOrNext(value);
	                };
	                if (error) {
	                    errorFn = this.__isAsync ? function (err) {
	                        setTimeout(function () {
	                            return error(err);
	                        });
	                    } : function (err) {
	                        error(err);
	                    };
	                }
	                if (complete) {
	                    completeFn = this.__isAsync ? function () {
	                        setTimeout(function () {
	                            return complete();
	                        });
	                    } : function () {
	                        complete();
	                    };
	                }
	            }
	            return get(Object.getPrototypeOf(EventEmitter.prototype), 'subscribe', this).call(this, schedulerFn, errorFn, completeFn);
	        }
	    }]);
	    return EventEmitter;
	}(Subject);

	/**
	 * Providers for validators to be used for {@link FormControl}s in a form.
	 *
	 * Provide this using `multi: true` to add validators.
	 *
	 * ### Example
	 *
	 * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}
	 * @experimental
	 */
	var NG_VALIDATORS$1 = new OpaqueToken('NgValidators');
	/**
	 * Providers for asynchronous validators to be used for {@link FormControl}s
	 * in a form.
	 *
	 * Provide this using `multi: true` to add validators.
	 *
	 * See {@link NG_VALIDATORS} for more details.
	 *
	 * @experimental
	 */
	var NG_ASYNC_VALIDATORS$1 =
	/*@ts2dart_const*/new OpaqueToken('NgAsyncValidators');
	/**
	 * Provides a set of validators used by form controls.
	 *
	 * A validator is a function that processes a {@link FormControl} or collection of
	 * controls and returns a map of errors. A null map means that validation has passed.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * var loginControl = new FormControl("", Validators.required)
	 * ```
	 *
	 * @experimental
	 */

	var Validators$1 = function () {
	    function Validators() {
	        classCallCheck(this, Validators);
	    }

	    createClass(Validators, null, [{
	        key: 'required',

	        /**
	         * Validator that requires controls to have a non-empty value.
	         */
	        value: function required(control) {
	            return isBlank$6(control.value) || isString$6(control.value) && control.value == '' ? { 'required': true } : null;
	        }
	        /**
	         * Validator that requires controls to have a value of a minimum length.
	         */

	    }, {
	        key: 'minLength',
	        value: function minLength(_minLength) {
	            return function (control) {
	                if (isPresent$6(Validators.required(control))) return null;
	                var v = control.value;
	                return v.length < _minLength ? { 'minlength': { 'requiredLength': _minLength, 'actualLength': v.length } } : null;
	            };
	        }
	        /**
	         * Validator that requires controls to have a value of a maximum length.
	         */

	    }, {
	        key: 'maxLength',
	        value: function maxLength(_maxLength) {
	            return function (control) {
	                if (isPresent$6(Validators.required(control))) return null;
	                var v = control.value;
	                return v.length > _maxLength ? { 'maxlength': { 'requiredLength': _maxLength, 'actualLength': v.length } } : null;
	            };
	        }
	        /**
	         * Validator that requires a control to match a regex to its value.
	         */

	    }, {
	        key: 'pattern',
	        value: function pattern(_pattern) {
	            return function (control) {
	                if (isPresent$6(Validators.required(control))) return null;
	                var regex = new RegExp('^' + _pattern + '$');
	                var v = control.value;
	                return regex.test(v) ? null : { 'pattern': { 'requiredPattern': '^' + _pattern + '$', 'actualValue': v } };
	            };
	        }
	        /**
	         * No-op validator.
	         */

	    }, {
	        key: 'nullValidator',
	        value: function nullValidator(c) {
	            return null;
	        }
	        /**
	         * Compose multiple validators into a single function that returns the union
	         * of the individual error maps.
	         */

	    }, {
	        key: 'compose',
	        value: function compose(validators) {
	            if (isBlank$6(validators)) return null;
	            var presentValidators = validators.filter(isPresent$6);
	            if (presentValidators.length == 0) return null;
	            return function (control) {
	                return _mergeErrors$1(_executeValidators$1(control, presentValidators));
	            };
	        }
	    }, {
	        key: 'composeAsync',
	        value: function composeAsync(validators) {
	            if (isBlank$6(validators)) return null;
	            var presentValidators = validators.filter(isPresent$6);
	            if (presentValidators.length == 0) return null;
	            return function (control) {
	                var promises = _executeAsyncValidators$1(control, presentValidators).map(_convertToPromise$1);
	                return PromiseWrapper$5.all(promises).then(_mergeErrors$1);
	            };
	        }
	    }]);
	    return Validators;
	}();

	function _convertToPromise$1(obj) {
	    return isPromise$5(obj) ? obj : ObservableWrapper$5.toPromise(obj);
	}
	function _executeValidators$1(control, validators) {
	    return validators.map(function (v) {
	        return v(control);
	    });
	}
	function _executeAsyncValidators$1(control, validators) {
	    return validators.map(function (v) {
	        return v(control);
	    });
	}
	function _mergeErrors$1(arrayOfErrors) {
	    var res = arrayOfErrors.reduce(function (res, errors) {
	        return isPresent$6(errors) ? StringMapWrapper$5.merge(res, errors) : res;
	    }, {});
	    return StringMapWrapper$5.isEmpty(res) ? null : res;
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	function normalizeValidator$1(validator) {
	    if (validator.validate !== undefined) {
	        return function (c) {
	            return validator.validate(c);
	        };
	    } else {
	        return validator;
	    }
	}
	function normalizeAsyncValidator$1(validator) {
	    if (validator.validate !== undefined) {
	        return function (c) {
	            return validator.validate(c);
	        };
	    } else {
	        return validator;
	    }
	}

	var NUMBER_VALUE_ACCESSOR$1 = {
	    provide: NG_VALUE_ACCESSOR$1,
	    useExisting: forwardRef(function () {
	        return NumberValueAccessor$1;
	    }),
	    multi: true
	};
	var NumberValueAccessor$1 = function () {
	    function NumberValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, NumberValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(NumberValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', value);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this.onChange = function (value) {
	                fn(value == '' ? null : NumberWrapper$5.parseFloat(value));
	            };
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }]);
	    return NumberValueAccessor;
	}();
	/** @nocollapse */
	NumberValueAccessor$1.decorators = [{ type: Directive, args: [{
	        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
	        host: {
	            '(change)': 'onChange($event.target.value)',
	            '(input)': 'onChange($event.target.value)',
	            '(blur)': 'onTouched()'
	        },
	        providers: [NUMBER_VALUE_ACCESSOR$1]
	    }] }];
	/** @nocollapse */
	NumberValueAccessor$1.ctorParameters = [{ type: Renderer }, { type: ElementRef }];

	var RADIO_VALUE_ACCESSOR$1 = {
	    provide: NG_VALUE_ACCESSOR$1,
	    useExisting: forwardRef(function () {
	        return RadioControlValueAccessor$1;
	    }),
	    multi: true
	};
	var NewRadioControlRegistry = function () {
	    function RadioControlRegistry() {
	        classCallCheck(this, RadioControlRegistry);

	        this._accessors = [];
	    }

	    createClass(RadioControlRegistry, [{
	        key: 'add',
	        value: function add(control, accessor) {
	            this._accessors.push([control, accessor]);
	        }
	    }, {
	        key: 'remove',
	        value: function remove(accessor) {
	            var indexToRemove = -1;
	            for (var i = 0; i < this._accessors.length; ++i) {
	                if (this._accessors[i][1] === accessor) {
	                    indexToRemove = i;
	                }
	            }
	            ListWrapper$5.removeAt(this._accessors, indexToRemove);
	        }
	    }, {
	        key: 'select',
	        value: function select(accessor) {
	            var _this = this;

	            this._accessors.forEach(function (c) {
	                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {
	                    c[1].fireUncheck(accessor.value);
	                }
	            });
	        }
	    }, {
	        key: '_isSameGroup',
	        value: function _isSameGroup(controlPair, accessor) {
	            if (!controlPair[0].control) return false;
	            return controlPair[0].control.root === accessor._control.control.root && controlPair[1].name === accessor.name;
	        }
	    }]);
	    return RadioControlRegistry;
	}();
	/** @nocollapse */
	NewRadioControlRegistry.decorators = [{ type: Injectable }];
	var RadioControlValueAccessor$1 = function () {
	    function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {
	        classCallCheck(this, RadioControlValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._registry = _registry;
	        this._injector = _injector;
	        this.onChange = function () {};
	        this.onTouched = function () {};
	    }

	    createClass(RadioControlValueAccessor, [{
	        key: 'ngOnInit',
	        value: function ngOnInit() {
	            this._control = this._injector.get(NgControl$1);
	            this._checkName();
	            this._registry.add(this._control, this);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this._registry.remove(this);
	        }
	    }, {
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this._state = value === this.value;
	            if (isPresent$6(value)) {
	                this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);
	            }
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            var _this2 = this;

	            this._fn = fn;
	            this.onChange = function () {
	                fn(_this2.value);
	                _this2._registry.select(_this2);
	            };
	        }
	    }, {
	        key: 'fireUncheck',
	        value: function fireUncheck(value) {
	            this.writeValue(value);
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	    }, {
	        key: '_checkName',
	        value: function _checkName() {
	            if (this.name && this.formControlName && this.name !== this.formControlName) {
	                this._throwNameError();
	            }
	            if (!this.name && this.formControlName) this.name = this.formControlName;
	        }
	    }, {
	        key: '_throwNameError',
	        value: function _throwNameError() {
	            throw new BaseException$5('\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type="radio" formControlName="food" name="food">\n    ');
	        }
	    }]);
	    return RadioControlValueAccessor;
	}();
	/** @nocollapse */
	RadioControlValueAccessor$1.decorators = [{ type: Directive, args: [{
	        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
	        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
	        providers: [RADIO_VALUE_ACCESSOR$1]
	    }] }];
	/** @nocollapse */
	RadioControlValueAccessor$1.ctorParameters = [{ type: Renderer }, { type: ElementRef }, { type: NewRadioControlRegistry }, { type: Injector }];
	/** @nocollapse */
	RadioControlValueAccessor$1.propDecorators = {
	    'name': [{ type: Input }],
	    'formControlName': [{ type: Input }],
	    'value': [{ type: Input }]
	};

	var SELECT_VALUE_ACCESSOR$1 = {
	    provide: NG_VALUE_ACCESSOR$1,
	    useExisting: forwardRef(function () {
	        return SelectControlValueAccessor$1;
	    }),
	    multi: true
	};
	function _buildValueString$2(id, value) {
	    if (isBlank$6(id)) return '' + value;
	    if (!isPrimitive$5(value)) value = 'Object';
	    return StringWrapper$5.slice(id + ': ' + value, 0, 50);
	}
	function _extractId$2(valueString) {
	    return valueString.split(':')[0];
	}
	var SelectControlValueAccessor$1 = function () {
	    function SelectControlValueAccessor(_renderer, _elementRef) {
	        classCallCheck(this, SelectControlValueAccessor);

	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        /** @internal */
	        this._optionMap = new Map();
	        /** @internal */
	        this._idCounter = 0;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(SelectControlValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            this.value = value;
	            var valueString = _buildValueString$2(this._getOptionId(value), value);
	            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            var _this = this;

	            this.onChange = function (valueString) {
	                _this.value = valueString;
	                fn(_this._getOptionValue(valueString));
	            };
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	        /** @internal */

	    }, {
	        key: '_registerOption',
	        value: function _registerOption() {
	            return (this._idCounter++).toString();
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionId',
	        value: function _getOptionId(value) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = MapWrapper$5.keys(this._optionMap)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var id = _step.value;

	                    if (looseIdentical$5(this._optionMap.get(id), value)) return id;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }

	            return null;
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionValue',
	        value: function _getOptionValue(valueString) {
	            var value = this._optionMap.get(_extractId$2(valueString));
	            return isPresent$6(value) ? value : valueString;
	        }
	    }]);
	    return SelectControlValueAccessor;
	}();
	/** @nocollapse */
	SelectControlValueAccessor$1.decorators = [{ type: Directive, args: [{
	        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
	        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
	        providers: [SELECT_VALUE_ACCESSOR$1]
	    }] }];
	/** @nocollapse */
	SelectControlValueAccessor$1.ctorParameters = [{ type: Renderer }, { type: ElementRef }];
	var NgSelectOption$1 = function () {
	    function NgSelectOption(_element, _renderer, _select) {
	        classCallCheck(this, NgSelectOption);

	        this._element = _element;
	        this._renderer = _renderer;
	        this._select = _select;
	        if (isPresent$6(this._select)) this.id = this._select._registerOption();
	    }

	    createClass(NgSelectOption, [{
	        key: '_setElementValue',

	        /** @internal */
	        value: function _setElementValue(value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            if (isPresent$6(this._select)) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        }
	    }, {
	        key: 'ngValue',
	        set: function set(value) {
	            if (this._select == null) return;
	            this._select._optionMap.set(this.id, value);
	            this._setElementValue(_buildValueString$2(this.id, value));
	            this._select.writeValue(this._select.value);
	        }
	    }, {
	        key: 'value',
	        set: function set(value) {
	            this._setElementValue(value);
	            if (isPresent$6(this._select)) this._select.writeValue(this._select.value);
	        }
	    }]);
	    return NgSelectOption;
	}();
	/** @nocollapse */
	NgSelectOption$1.decorators = [{ type: Directive, args: [{ selector: 'option' }] }];
	/** @nocollapse */
	NgSelectOption$1.ctorParameters = [{ type: ElementRef }, { type: Renderer }, { type: SelectControlValueAccessor$1, decorators: [{ type: Optional }, { type: Host }] }];
	/** @nocollapse */
	NgSelectOption$1.propDecorators = {
	    'ngValue': [{ type: Input, args: ['ngValue'] }],
	    'value': [{ type: Input, args: ['value'] }]
	};

	var SELECT_MULTIPLE_VALUE_ACCESSOR$1 = {
	    provide: NG_VALUE_ACCESSOR$1,
	    useExisting: forwardRef(function () {
	        return SelectMultipleControlValueAccessor$1;
	    }),
	    multi: true
	};
	function _buildValueString$3(id, value) {
	    if (isBlank$6(id)) return '' + value;
	    if (isString$6(value)) value = '\'' + value + '\'';
	    if (!isPrimitive$5(value)) value = 'Object';
	    return StringWrapper$5.slice(id + ': ' + value, 0, 50);
	}
	function _extractId$3(valueString) {
	    return valueString.split(':')[0];
	}
	var SelectMultipleControlValueAccessor$1 = function () {
	    function SelectMultipleControlValueAccessor() {
	        classCallCheck(this, SelectMultipleControlValueAccessor);

	        /** @internal */
	        this._optionMap = new Map();
	        /** @internal */
	        this._idCounter = 0;
	        this.onChange = function (_) {};
	        this.onTouched = function () {};
	    }

	    createClass(SelectMultipleControlValueAccessor, [{
	        key: 'writeValue',
	        value: function writeValue(value) {
	            var _this = this;

	            this.value = value;
	            if (value == null) return;
	            var values = value;
	            // convert values to ids
	            var ids = values.map(function (v) {
	                return _this._getOptionId(v);
	            });
	            this._optionMap.forEach(function (opt, o) {
	                opt._setSelected(ids.indexOf(o.toString()) > -1);
	            });
	        }
	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            var _this2 = this;

	            this.onChange = function (_) {
	                var selected = [];
	                if (_.hasOwnProperty('selectedOptions')) {
	                    var options = _.selectedOptions;
	                    for (var i = 0; i < options.length; i++) {
	                        var opt = options.item(i);
	                        var val = _this2._getOptionValue(opt.value);
	                        selected.push(val);
	                    }
	                } else {
	                    var _options = _.options;
	                    for (var i = 0; i < _options.length; i++) {
	                        var _opt = _options.item(i);
	                        if (_opt.selected) {
	                            var _val = _this2._getOptionValue(_opt.value);
	                            selected.push(_val);
	                        }
	                    }
	                }
	                fn(selected);
	            };
	        }
	    }, {
	        key: 'registerOnTouched',
	        value: function registerOnTouched(fn) {
	            this.onTouched = fn;
	        }
	        /** @internal */

	    }, {
	        key: '_registerOption',
	        value: function _registerOption(value) {
	            var id = (this._idCounter++).toString();
	            this._optionMap.set(id, value);
	            return id;
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionId',
	        value: function _getOptionId(value) {
	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = MapWrapper$5.keys(this._optionMap)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var id = _step.value;

	                    if (looseIdentical$5(this._optionMap.get(id)._value, value)) return id;
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }

	            return null;
	        }
	        /** @internal */

	    }, {
	        key: '_getOptionValue',
	        value: function _getOptionValue(valueString) {
	            var opt = this._optionMap.get(_extractId$3(valueString));
	            return isPresent$6(opt) ? opt._value : valueString;
	        }
	    }]);
	    return SelectMultipleControlValueAccessor;
	}();
	/** @nocollapse */
	SelectMultipleControlValueAccessor$1.decorators = [{ type: Directive, args: [{
	        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
	        host: { '(input)': 'onChange($event.target)', '(blur)': 'onTouched()' },
	        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR$1]
	    }] }];
	/** @nocollapse */
	SelectMultipleControlValueAccessor$1.ctorParameters = [];
	var NgSelectMultipleOption$1 = function () {
	    function NgSelectMultipleOption(_element, _renderer, _select) {
	        classCallCheck(this, NgSelectMultipleOption);

	        this._element = _element;
	        this._renderer = _renderer;
	        this._select = _select;
	        if (isPresent$6(this._select)) {
	            this.id = this._select._registerOption(this);
	        }
	    }

	    createClass(NgSelectMultipleOption, [{
	        key: '_setElementValue',

	        /** @internal */
	        value: function _setElementValue(value) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);
	        }
	        /** @internal */

	    }, {
	        key: '_setSelected',
	        value: function _setSelected(selected) {
	            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            if (isPresent$6(this._select)) {
	                this._select._optionMap.delete(this.id);
	                this._select.writeValue(this._select.value);
	            }
	        }
	    }, {
	        key: 'ngValue',
	        set: function set(value) {
	            if (this._select == null) return;
	            this._value = value;
	            this._setElementValue(_buildValueString$3(this.id, value));
	            this._select.writeValue(this._select.value);
	        }
	    }, {
	        key: 'value',
	        set: function set(value) {
	            if (isPresent$6(this._select)) {
	                this._value = value;
	                this._setElementValue(_buildValueString$3(this.id, value));
	                this._select.writeValue(this._select.value);
	            } else {
	                this._setElementValue(value);
	            }
	        }
	    }]);
	    return NgSelectMultipleOption;
	}();
	/** @nocollapse */
	NgSelectMultipleOption$1.decorators = [{ type: Directive, args: [{ selector: 'option' }] }];
	/** @nocollapse */
	NgSelectMultipleOption$1.ctorParameters = [{ type: ElementRef }, { type: Renderer }, { type: SelectMultipleControlValueAccessor$1, decorators: [{ type: Optional }, { type: Host }] }];
	/** @nocollapse */
	NgSelectMultipleOption$1.propDecorators = {
	    'ngValue': [{ type: Input, args: ['ngValue'] }],
	    'value': [{ type: Input, args: ['value'] }]
	};

	function controlPath$1(name, parent) {
	    var p = ListWrapper$5.clone(parent.path);
	    p.push(name);
	    return p;
	}
	function setUpControl$1(control, dir) {
	    if (isBlank$6(control)) _throwError$1(dir, 'Cannot find control');
	    if (isBlank$6(dir.valueAccessor)) _throwError$1(dir, 'No value accessor for');
	    control.validator = Validators$1.compose([control.validator, dir.validator]);
	    control.asyncValidator = Validators$1.composeAsync([control.asyncValidator, dir.asyncValidator]);
	    dir.valueAccessor.writeValue(control.value);
	    // view -> model
	    dir.valueAccessor.registerOnChange(function (newValue) {
	        dir.viewToModelUpdate(newValue);
	        control.updateValue(newValue, { emitModelToViewChange: false });
	        control.markAsDirty();
	    });
	    // model -> view
	    control.registerOnChange(function (newValue) {
	        return dir.valueAccessor.writeValue(newValue);
	    });
	    // touched
	    dir.valueAccessor.registerOnTouched(function () {
	        return control.markAsTouched();
	    });
	}
	function setUpFormContainer(control, dir) {
	    if (isBlank$6(control)) _throwError$1(dir, 'Cannot find control');
	    control.validator = Validators$1.compose([control.validator, dir.validator]);
	    control.asyncValidator = Validators$1.composeAsync([control.asyncValidator, dir.asyncValidator]);
	}
	function _throwError$1(dir, message) {
	    var path = dir.path.join(' -> ');
	    throw new BaseException$5(message + ' \'' + path + '\'');
	}
	function composeValidators$1(validators) {
	    return isPresent$6(validators) ? Validators$1.compose(validators.map(normalizeValidator$1)) : null;
	}
	function composeAsyncValidators$1(validators) {
	    return isPresent$6(validators) ? Validators$1.composeAsync(validators.map(normalizeAsyncValidator$1)) : null;
	}
	function isPropertyUpdated$1(changes, viewModel) {
	    if (!StringMapWrapper$5.contains(changes, 'model')) return false;
	    var change = changes['model'];
	    if (change.isFirstChange()) return true;
	    return !looseIdentical$5(viewModel, change.currentValue);
	}
	// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
	function selectValueAccessor$1(dir, valueAccessors) {
	    if (isBlank$6(valueAccessors)) return null;
	    var defaultAccessor;
	    var builtinAccessor;
	    var customAccessor;
	    valueAccessors.forEach(function (v) {
	        if (hasConstructor$5(v, DefaultValueAccessor$1)) {
	            defaultAccessor = v;
	        } else if (hasConstructor$5(v, CheckboxControlValueAccessor$1) || hasConstructor$5(v, NumberValueAccessor$1) || hasConstructor$5(v, SelectControlValueAccessor$1) || hasConstructor$5(v, SelectMultipleControlValueAccessor$1) || hasConstructor$5(v, RadioControlValueAccessor$1)) {
	            if (isPresent$6(builtinAccessor)) _throwError$1(dir, 'More than one built-in value accessor matches');
	            builtinAccessor = v;
	        } else {
	            if (isPresent$6(customAccessor)) _throwError$1(dir, 'More than one custom value accessor matches');
	            customAccessor = v;
	        }
	    });
	    if (isPresent$6(customAccessor)) return customAccessor;
	    if (isPresent$6(builtinAccessor)) return builtinAccessor;
	    if (isPresent$6(defaultAccessor)) return defaultAccessor;
	    _throwError$1(dir, 'No valid value accessor for');
	    return null;
	}

	/**
	 * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.
	 */
	var VALID$1 = 'VALID';
	/**
	 * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.
	 */
	var INVALID$1 = 'INVALID';
	/**
	 * Indicates that a FormControl is pending, i.e. that async validation is occurring and
	 * errors are not yet available for the input value.
	 */
	var PENDING$1 = 'PENDING';
	function _find$1(control, path) {
	    if (isBlank$6(path)) return null;
	    if (!(path instanceof Array)) {
	        path = path.split('/');
	    }
	    if (path instanceof Array && ListWrapper$5.isEmpty(path)) return null;
	    return path.reduce(function (v, name) {
	        if (v instanceof FormGroup) {
	            return isPresent$6(v.controls[name]) ? v.controls[name] : null;
	        } else if (v instanceof FormArray) {
	            var index = name;
	            return isPresent$6(v.at(index)) ? v.at(index) : null;
	        } else {
	            return null;
	        }
	    }, control);
	}
	function toObservable$1(r) {
	    return isPromise$5(r) ? ObservableWrapper$5.fromPromise(r) : r;
	}
	function coerceToValidator(validator) {
	    return Array.isArray(validator) ? composeValidators$1(validator) : validator;
	}
	function coerceToAsyncValidator(asyncValidator) {
	    return Array.isArray(asyncValidator) ? composeAsyncValidators$1(asyncValidator) : asyncValidator;
	}
	/**
	 * @experimental
	 */
	var AbstractControl$1 = function () {
	    function AbstractControl(validator, asyncValidator) {
	        classCallCheck(this, AbstractControl);

	        this.validator = validator;
	        this.asyncValidator = asyncValidator;
	        this._pristine = true;
	        this._touched = false;
	    }

	    createClass(AbstractControl, [{
	        key: 'setAsyncValidators',
	        value: function setAsyncValidators(newValidator) {
	            this.asyncValidator = coerceToAsyncValidator(newValidator);
	        }
	    }, {
	        key: 'clearAsyncValidators',
	        value: function clearAsyncValidators() {
	            this.asyncValidator = null;
	        }
	    }, {
	        key: 'setValidators',
	        value: function setValidators(newValidator) {
	            this.validator = coerceToValidator(newValidator);
	        }
	    }, {
	        key: 'clearValidators',
	        value: function clearValidators() {
	            this.validator = null;
	        }
	    }, {
	        key: 'markAsTouched',
	        value: function markAsTouched() {
	            this._touched = true;
	        }
	    }, {
	        key: 'markAsDirty',
	        value: function markAsDirty() {
	            var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var onlySelf = _ref.onlySelf;

	            onlySelf = normalizeBool$5(onlySelf);
	            this._pristine = false;
	            if (isPresent$6(this._parent) && !onlySelf) {
	                this._parent.markAsDirty({ onlySelf: onlySelf });
	            }
	        }
	    }, {
	        key: 'markAsPending',
	        value: function markAsPending() {
	            var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var onlySelf = _ref2.onlySelf;

	            onlySelf = normalizeBool$5(onlySelf);
	            this._status = PENDING$1;
	            if (isPresent$6(this._parent) && !onlySelf) {
	                this._parent.markAsPending({ onlySelf: onlySelf });
	            }
	        }
	    }, {
	        key: 'setParent',
	        value: function setParent(parent) {
	            this._parent = parent;
	        }
	    }, {
	        key: 'updateValueAndValidity',
	        value: function updateValueAndValidity() {
	            var _ref3 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	            var onlySelf = _ref3.onlySelf;
	            var emitEvent = _ref3.emitEvent;

	            onlySelf = normalizeBool$5(onlySelf);
	            emitEvent = isPresent$6(emitEvent) ? emitEvent : true;
	            this._updateValue();
	            this._errors = this._runValidator();
	            this._status = this._calculateStatus();
	            if (this._status == VALID$1 || this._status == PENDING$1) {
	                this._runAsyncValidator(emitEvent);
	            }
	            if (emitEvent) {
	                ObservableWrapper$5.callEmit(this._valueChanges, this._value);
	                ObservableWrapper$5.callEmit(this._statusChanges, this._status);
	            }
	            if (isPresent$6(this._parent) && !onlySelf) {
	                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	            }
	        }
	    }, {
	        key: '_runValidator',
	        value: function _runValidator() {
	            return isPresent$6(this.validator) ? this.validator(this) : null;
	        }
	    }, {
	        key: '_runAsyncValidator',
	        value: function _runAsyncValidator(emitEvent) {
	            var _this = this;

	            if (isPresent$6(this.asyncValidator)) {
	                this._status = PENDING$1;
	                this._cancelExistingSubscription();
	                var obs = toObservable$1(this.asyncValidator(this));
	                this._asyncValidationSubscription = ObservableWrapper$5.subscribe(obs, function (res) {
	                    return _this.setErrors(res, { emitEvent: emitEvent });
	                });
	            }
	        }
	    }, {
	        key: '_cancelExistingSubscription',
	        value: function _cancelExistingSubscription() {
	            if (isPresent$6(this._asyncValidationSubscription)) {
	                ObservableWrapper$5.dispose(this._asyncValidationSubscription);
	            }
	        }
	        /**
	         * Sets errors on a form control.
	         *
	         * This is used when validations are run not automatically, but manually by the user.
	         *
	         * Calling `setErrors` will also update the validity of the parent control.
	         *
	         * ## Usage
	         *
	         * ```
	         * var login = new FormControl("someLogin");
	         * login.setErrors({
	         *   "notUnique": true
	         * });
	         *
	         * expect(login.valid).toEqual(false);
	         * expect(login.errors).toEqual({"notUnique": true});
	         *
	         * login.updateValue("someOtherLogin");
	         *
	         * expect(login.valid).toEqual(true);
	         * ```
	         */

	    }, {
	        key: 'setErrors',
	        value: function setErrors(errors) {
	            var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	            var emitEvent = _ref4.emitEvent;

	            emitEvent = isPresent$6(emitEvent) ? emitEvent : true;
	            this._errors = errors;
	            this._updateControlsErrors(emitEvent);
	        }
	    }, {
	        key: 'find',
	        value: function find(path) {
	            return _find$1(this, path);
	        }
	    }, {
	        key: 'getError',
	        value: function getError(errorCode) {
	            var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var control = isPresent$6(path) && !ListWrapper$5.isEmpty(path) ? this.find(path) : this;
	            if (isPresent$6(control) && isPresent$6(control._errors)) {
	                return StringMapWrapper$5.get(control._errors, errorCode);
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'hasError',
	        value: function hasError(errorCode) {
	            var path = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            return isPresent$6(this.getError(errorCode, path));
	        }
	    }, {
	        key: '_updateControlsErrors',

	        /** @internal */
	        value: function _updateControlsErrors(emitEvent) {
	            this._status = this._calculateStatus();
	            if (emitEvent) {
	                ObservableWrapper$5.callEmit(this._statusChanges, this._status);
	            }
	            if (isPresent$6(this._parent)) {
	                this._parent._updateControlsErrors(emitEvent);
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_initObservables',
	        value: function _initObservables() {
	            this._valueChanges = new EventEmitter$5();
	            this._statusChanges = new EventEmitter$5();
	        }
	    }, {
	        key: '_calculateStatus',
	        value: function _calculateStatus() {
	            if (isPresent$6(this._errors)) return INVALID$1;
	            if (this._anyControlsHaveStatus(PENDING$1)) return PENDING$1;
	            if (this._anyControlsHaveStatus(INVALID$1)) return INVALID$1;
	            return VALID$1;
	        }
	    }, {
	        key: 'value',
	        get: function get() {
	            return this._value;
	        }
	    }, {
	        key: 'status',
	        get: function get() {
	            return this._status;
	        }
	    }, {
	        key: 'valid',
	        get: function get() {
	            return this._status === VALID$1;
	        }
	        /**
	         * Returns the errors of this control.
	         */

	    }, {
	        key: 'errors',
	        get: function get() {
	            return this._errors;
	        }
	    }, {
	        key: 'pristine',
	        get: function get() {
	            return this._pristine;
	        }
	    }, {
	        key: 'dirty',
	        get: function get() {
	            return !this.pristine;
	        }
	    }, {
	        key: 'touched',
	        get: function get() {
	            return this._touched;
	        }
	    }, {
	        key: 'untouched',
	        get: function get() {
	            return !this._touched;
	        }
	    }, {
	        key: 'valueChanges',
	        get: function get() {
	            return this._valueChanges;
	        }
	    }, {
	        key: 'statusChanges',
	        get: function get() {
	            return this._statusChanges;
	        }
	    }, {
	        key: 'pending',
	        get: function get() {
	            return this._status == PENDING$1;
	        }
	    }, {
	        key: 'root',
	        get: function get() {
	            var x = this;
	            while (isPresent$6(x._parent)) {
	                x = x._parent;
	            }
	            return x;
	        }
	    }]);
	    return AbstractControl;
	}();
	/**
	 * Defines a part of a form that cannot be divided into other controls. `FormControl`s have values
	 * and
	 * validation state, which is determined by an optional validation function.
	 *
	 * `FormControl` is one of the three fundamental building blocks used to define forms in Angular,
	 * along
	 * with {@link FormGroup} and {@link FormArray}.
	 *
	 * ## Usage
	 *
	 * By default, a `FormControl` is created for every `<input>` or other form component.
	 * With {@link FormControlDirective} or {@link FormGroupDirective} an existing {@link FormControl}
	 * can be bound to a DOM element instead. This `FormControl` can be configured with a custom
	 * validation function.
	 *
	 * @experimental
	 */
	var FormControl = function (_AbstractControl) {
	    inherits(FormControl, _AbstractControl);

	    function FormControl() {
	        var value = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];
	        var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, FormControl);

	        /** @internal */

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(FormControl).call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator)));

	        _this2._onChange = [];
	        _this2._value = value;
	        _this2.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        _this2._initObservables();
	        return _this2;
	    }
	    /**
	     * Set the value of the form control to `value`.
	     *
	     * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`
	     * and not its parent component. If `emitEvent` is `true`, this change will cause a
	     * `valueChanges` event on the `FormControl` to be emitted. Both of these options default to
	     * `false`.
	     *
	     * If `emitModelToViewChange` is `true`, the view will be notified about the new value
	     * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not
	     * specified.
	     */


	    createClass(FormControl, [{
	        key: 'updateValue',
	        value: function updateValue(value) {
	            var _this3 = this;

	            var _ref5 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	            var onlySelf = _ref5.onlySelf;
	            var emitEvent = _ref5.emitEvent;
	            var emitModelToViewChange = _ref5.emitModelToViewChange;

	            emitModelToViewChange = isPresent$6(emitModelToViewChange) ? emitModelToViewChange : true;
	            this._value = value;
	            if (this._onChange.length && emitModelToViewChange) {
	                this._onChange.forEach(function (changeFn) {
	                    return changeFn(_this3._value);
	                });
	            }
	            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        }
	        /**
	         * @internal
	         */

	    }, {
	        key: '_updateValue',
	        value: function _updateValue() {}
	        /**
	         * @internal
	         */

	    }, {
	        key: '_anyControlsHaveStatus',
	        value: function _anyControlsHaveStatus(status) {
	            return false;
	        }
	        /**
	         * Register a listener for change events.
	         */

	    }, {
	        key: 'registerOnChange',
	        value: function registerOnChange(fn) {
	            this._onChange.push(fn);
	        }
	    }]);
	    return FormControl;
	}(AbstractControl$1);
	/**
	 * Defines a part of a form, of fixed length, that can contain other controls.
	 *
	 * A `FormGroup` aggregates the values of each {@link FormControl} in the group.
	 * The status of a `FormGroup` depends on the status of its children.
	 * If one of the controls in a group is invalid, the entire group is invalid.
	 * Similarly, if a control changes its value, the entire group changes as well.
	 *
	 * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with {@link FormControl} and {@link FormArray}. {@link FormArray} can also contain other
	 * controls, but is of variable length.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var FormGroup = function (_AbstractControl2) {
	    inherits(FormGroup, _AbstractControl2);

	    function FormGroup(controls) {
	        var optionals = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var validator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        var asyncValidator = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	        classCallCheck(this, FormGroup);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(FormGroup).call(this, validator, asyncValidator));

	        _this4.controls = controls;
	        _this4._optionals = isPresent$6(optionals) ? optionals : {};
	        _this4._initObservables();
	        _this4._setParentForControls();
	        _this4.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        return _this4;
	    }
	    /**
	     * Register a control with the group's list of controls.
	     */


	    createClass(FormGroup, [{
	        key: 'registerControl',
	        value: function registerControl(name, control) {
	            if (this.controls[name]) return this.controls[name];
	            this.controls[name] = control;
	            control.setParent(this);
	            return control;
	        }
	        /**
	         * Add a control to this group.
	         */

	    }, {
	        key: 'addControl',
	        value: function addControl(name, control) {
	            this.registerControl(name, control);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Remove a control from this group.
	         */

	    }, {
	        key: 'removeControl',
	        value: function removeControl(name) {
	            StringMapWrapper$5.delete(this.controls, name);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Mark the named control as non-optional.
	         */

	    }, {
	        key: 'include',
	        value: function include(controlName) {
	            StringMapWrapper$5.set(this._optionals, controlName, true);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Mark the named control as optional.
	         */

	    }, {
	        key: 'exclude',
	        value: function exclude(controlName) {
	            StringMapWrapper$5.set(this._optionals, controlName, false);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Check whether there is a control with the given name in the group.
	         */

	    }, {
	        key: 'contains',
	        value: function contains(controlName) {
	            var c = StringMapWrapper$5.contains(this.controls, controlName);
	            return c && this._included(controlName);
	        }
	        /** @internal */

	    }, {
	        key: '_setParentForControls',
	        value: function _setParentForControls() {
	            var _this5 = this;

	            StringMapWrapper$5.forEach(this.controls, function (control, name) {
	                control.setParent(_this5);
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_updateValue',
	        value: function _updateValue() {
	            this._value = this._reduceValue();
	        }
	        /** @internal */

	    }, {
	        key: '_anyControlsHaveStatus',
	        value: function _anyControlsHaveStatus(status) {
	            var _this6 = this;

	            var res = false;
	            StringMapWrapper$5.forEach(this.controls, function (control, name) {
	                res = res || _this6.contains(name) && control.status == status;
	            });
	            return res;
	        }
	        /** @internal */

	    }, {
	        key: '_reduceValue',
	        value: function _reduceValue() {
	            return this._reduceChildren({}, function (acc, control, name) {
	                acc[name] = control.value;
	                return acc;
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_reduceChildren',
	        value: function _reduceChildren(initValue, fn) {
	            var _this7 = this;

	            var res = initValue;
	            StringMapWrapper$5.forEach(this.controls, function (control, name) {
	                if (_this7._included(name)) {
	                    res = fn(res, control, name);
	                }
	            });
	            return res;
	        }
	        /** @internal */

	    }, {
	        key: '_included',
	        value: function _included(controlName) {
	            var isOptional = StringMapWrapper$5.contains(this._optionals, controlName);
	            return !isOptional || StringMapWrapper$5.get(this._optionals, controlName);
	        }
	    }]);
	    return FormGroup;
	}(AbstractControl$1);
	/**
	 * Defines a part of a form, of variable length, that can contain other controls.
	 *
	 * A `FormArray` aggregates the values of each {@link FormControl} in the group.
	 * The status of a `FormArray` depends on the status of its children.
	 * If one of the controls in a group is invalid, the entire array is invalid.
	 * Similarly, if a control changes its value, the entire array changes as well.
	 *
	 * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with {@link FormControl} and {@link FormGroup}. {@link FormGroup} can also contain
	 * other controls, but is of fixed length.
	 *
	 * ## Adding or removing controls
	 *
	 * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods
	 * in `FormArray` itself. These methods ensure the controls are properly tracked in the
	 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
	 * the `FormArray` directly, as that will result in strange and unexpected behavior such
	 * as broken change detection.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/23DESOpbNnBpBHZt1BR4?p=preview))
	 *
	 * @experimental
	 */
	var FormArray = function (_AbstractControl3) {
	    inherits(FormArray, _AbstractControl3);

	    function FormArray(controls) {
	        var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	        var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	        classCallCheck(this, FormArray);

	        var _this8 = possibleConstructorReturn(this, Object.getPrototypeOf(FormArray).call(this, validator, asyncValidator));

	        _this8.controls = controls;
	        _this8._initObservables();
	        _this8._setParentForControls();
	        _this8.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	        return _this8;
	    }
	    /**
	     * Get the {@link AbstractControl} at the given `index` in the array.
	     */


	    createClass(FormArray, [{
	        key: 'at',
	        value: function at(index) {
	            return this.controls[index];
	        }
	        /**
	         * Insert a new {@link AbstractControl} at the end of the array.
	         */

	    }, {
	        key: 'push',
	        value: function push(control) {
	            this.controls.push(control);
	            control.setParent(this);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Insert a new {@link AbstractControl} at the given `index` in the array.
	         */

	    }, {
	        key: 'insert',
	        value: function insert(index, control) {
	            ListWrapper$5.insert(this.controls, index, control);
	            control.setParent(this);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Remove the control at the given `index` in the array.
	         */

	    }, {
	        key: 'removeAt',
	        value: function removeAt(index) {
	            ListWrapper$5.removeAt(this.controls, index);
	            this.updateValueAndValidity();
	        }
	        /**
	         * Length of the control array.
	         */

	    }, {
	        key: '_updateValue',

	        /** @internal */
	        value: function _updateValue() {
	            this._value = this.controls.map(function (control) {
	                return control.value;
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_anyControlsHaveStatus',
	        value: function _anyControlsHaveStatus(status) {
	            return this.controls.some(function (c) {
	                return c.status == status;
	            });
	        }
	        /** @internal */

	    }, {
	        key: '_setParentForControls',
	        value: function _setParentForControls() {
	            var _this9 = this;

	            this.controls.forEach(function (control) {
	                control.setParent(_this9);
	            });
	        }
	    }, {
	        key: 'length',
	        get: function get() {
	            return this.controls.length;
	        }
	    }]);
	    return FormArray;
	}(AbstractControl$1);

	/**
	 * A directive that contains multiple {@link NgControl}s.
	 *
	 * Only used by the forms module.
	 *
	 * @experimental
	 */
	var ControlContainer$1 = function (_AbstractControlDirec) {
	  inherits(ControlContainer, _AbstractControlDirec);

	  function ControlContainer() {
	    classCallCheck(this, ControlContainer);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(ControlContainer).apply(this, arguments));
	  }

	  createClass(ControlContainer, [{
	    key: 'formDirective',

	    /**
	     * Get the form to which this container belongs.
	     */
	    get: function get() {
	      return null;
	    }
	    /**
	     * Get the path to this container.
	     */

	  }, {
	    key: 'path',
	    get: function get() {
	      return null;
	    }
	  }]);
	  return ControlContainer;
	}(AbstractControlDirective$1);

	var formDirectiveProvider$2 =
	/*@ts2dart_const*/{ provide: ControlContainer$1, useExisting: forwardRef(function () {
	        return NgForm$1;
	    }) };
	var NgForm$1 = function (_ControlContainer) {
	    inherits(NgForm, _ControlContainer);

	    function NgForm(validators, asyncValidators) {
	        classCallCheck(this, NgForm);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgForm).call(this));

	        _this._submitted = false;
	        _this.ngSubmit = new EventEmitter$5();
	        _this.form = new FormGroup({}, null, composeValidators$1(validators), composeAsyncValidators$1(asyncValidators));
	        return _this;
	    }

	    createClass(NgForm, [{
	        key: 'addControl',
	        value: function addControl(dir) {
	            var _this2 = this;

	            PromiseWrapper$5.scheduleMicrotask(function () {
	                var container = _this2._findContainer(dir.path);
	                dir._control = container.registerControl(dir.name, dir.control);
	                setUpControl$1(dir.control, dir);
	                dir.control.updateValueAndValidity({ emitEvent: false });
	            });
	        }
	    }, {
	        key: 'getControl',
	        value: function getControl(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'removeControl',
	        value: function removeControl(dir) {
	            var _this3 = this;

	            PromiseWrapper$5.scheduleMicrotask(function () {
	                var container = _this3._findContainer(dir.path);
	                if (isPresent$6(container)) {
	                    container.removeControl(dir.name);
	                }
	            });
	        }
	    }, {
	        key: 'addFormGroup',
	        value: function addFormGroup(dir) {
	            var _this4 = this;

	            PromiseWrapper$5.scheduleMicrotask(function () {
	                var container = _this4._findContainer(dir.path);
	                var group = new FormGroup({});
	                setUpFormContainer(group, dir);
	                container.registerControl(dir.name, group);
	                group.updateValueAndValidity({ emitEvent: false });
	            });
	        }
	    }, {
	        key: 'removeFormGroup',
	        value: function removeFormGroup(dir) {
	            var _this5 = this;

	            PromiseWrapper$5.scheduleMicrotask(function () {
	                var container = _this5._findContainer(dir.path);
	                if (isPresent$6(container)) {
	                    container.removeControl(dir.name);
	                }
	            });
	        }
	    }, {
	        key: 'getFormGroup',
	        value: function getFormGroup(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'updateModel',
	        value: function updateModel(dir, value) {
	            var _this6 = this;

	            PromiseWrapper$5.scheduleMicrotask(function () {
	                var ctrl = _this6.form.find(dir.path);
	                ctrl.updateValue(value);
	            });
	        }
	    }, {
	        key: 'onSubmit',
	        value: function onSubmit() {
	            this._submitted = true;
	            ObservableWrapper$5.callEmit(this.ngSubmit, null);
	            return false;
	        }
	        /** @internal */

	    }, {
	        key: '_findContainer',
	        value: function _findContainer(path) {
	            path.pop();
	            return ListWrapper$5.isEmpty(path) ? this.form : this.form.find(path);
	        }
	    }, {
	        key: 'submitted',
	        get: function get() {
	            return this._submitted;
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this;
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.form;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return [];
	        }
	    }, {
	        key: 'controls',
	        get: function get() {
	            return this.form.controls;
	        }
	    }]);
	    return NgForm;
	}(ControlContainer$1);
	/** @nocollapse */
	NgForm$1.decorators = [{ type: Directive, args: [{
	        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',
	        providers: [formDirectiveProvider$2],
	        host: {
	            '(submit)': 'onSubmit()'
	        },
	        outputs: ['ngSubmit'],
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	NgForm$1.ctorParameters = [{ type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }];

	var formControlBinding$2 =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: NgControl$1,
	    useExisting: forwardRef(function () {
	        return NgModel$1;
	    })
	};
	var NgModel$1 = function (_NgControl) {
	    inherits(NgModel, _NgControl);

	    function NgModel(_parent, _validators, _asyncValidators, valueAccessors) {
	        classCallCheck(this, NgModel);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgModel).call(this));

	        _this._parent = _parent;
	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        /** @internal */
	        _this._control = new FormControl();
	        /** @internal */
	        _this._registered = false;
	        _this.update = new EventEmitter$5();
	        _this.valueAccessor = selectValueAccessor$1(_this, valueAccessors);
	        return _this;
	    }

	    createClass(NgModel, [{
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            this._checkName();
	            if (!this._registered) this._setUpControl();
	            if (isPropertyUpdated$1(changes, this.viewModel)) {
	                this._updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this.formDirective && this.formDirective.removeControl(this);
	        }
	    }, {
	        key: 'viewToModelUpdate',
	        value: function viewToModelUpdate(newValue) {
	            this.viewModel = newValue;
	            ObservableWrapper$5.callEmit(this.update, newValue);
	        }
	    }, {
	        key: '_setUpControl',
	        value: function _setUpControl() {
	            this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
	            this._registered = true;
	        }
	    }, {
	        key: '_isStandalone',
	        value: function _isStandalone() {
	            return !this._parent || this.options && this.options.standalone;
	        }
	    }, {
	        key: '_setUpStandalone',
	        value: function _setUpStandalone() {
	            setUpControl$1(this._control, this);
	            this._control.updateValueAndValidity({ emitEvent: false });
	        }
	    }, {
	        key: '_checkName',
	        value: function _checkName() {
	            if (this.options && this.options.name) this.name = this.options.name;
	            if (!this._isStandalone() && !this.name) {
	                throw new BaseException$5('If ngModel is used within a form tag, either the name attribute must be set\n                      or the form control must be defined as \'standalone\' in ngModelOptions.\n\n                      Example 1: <input [(ngModel)]="person.firstName" name="first">\n                      Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">\n                   ');
	            }
	        }
	    }, {
	        key: '_updateValue',
	        value: function _updateValue(value) {
	            var _this2 = this;

	            PromiseWrapper$5.scheduleMicrotask(function () {
	                _this2.control.updateValue(value);
	            });
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this._control;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return this._parent ? controlPath$1(this.name, this._parent) : [];
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this._parent ? this._parent.formDirective : null;
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators$1(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators$1(this._asyncValidators);
	        }
	    }]);
	    return NgModel;
	}(NgControl$1);
	/** @nocollapse */
	NgModel$1.decorators = [{ type: Directive, args: [{
	        selector: '[ngModel]:not([formControlName]):not([formControl])',
	        providers: [formControlBinding$2],
	        exportAs: 'ngModel'
	    }] }];
	/** @nocollapse */
	NgModel$1.ctorParameters = [{ type: ControlContainer$1, decorators: [{ type: Optional }, { type: Host }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR$1] }] }];
	/** @nocollapse */
	NgModel$1.propDecorators = {
	    'model': [{ type: Input, args: ['ngModel'] }],
	    'name': [{ type: Input }],
	    'options': [{ type: Input, args: ['ngModelOptions'] }],
	    'update': [{ type: Output, args: ['ngModelChange'] }]
	};

	/**
	  This is a base class for code shared between {@link NgModelGroup} and {@link FormGroupName}.
	 */
	var AbstractFormGroupDirective = function (_ControlContainer) {
	  inherits(AbstractFormGroupDirective, _ControlContainer);

	  function AbstractFormGroupDirective() {
	    classCallCheck(this, AbstractFormGroupDirective);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(AbstractFormGroupDirective).apply(this, arguments));
	  }

	  createClass(AbstractFormGroupDirective, [{
	    key: 'ngOnInit',
	    value: function ngOnInit() {
	      this.formDirective.addFormGroup(this);
	    }
	  }, {
	    key: 'ngOnDestroy',
	    value: function ngOnDestroy() {
	      this.formDirective.removeFormGroup(this);
	    }
	    /**
	     * Get the {@link FormGroup} backing this binding.
	     */

	  }, {
	    key: 'control',
	    get: function get() {
	      return this.formDirective.getFormGroup(this);
	    }
	    /**
	     * Get the path to this control group.
	     */

	  }, {
	    key: 'path',
	    get: function get() {
	      return controlPath$1(this.name, this._parent);
	    }
	    /**
	     * Get the {@link Form} to which this group belongs.
	     */

	  }, {
	    key: 'formDirective',
	    get: function get() {
	      return this._parent.formDirective;
	    }
	  }, {
	    key: 'validator',
	    get: function get() {
	      return composeValidators$1(this._validators);
	    }
	  }, {
	    key: 'asyncValidator',
	    get: function get() {
	      return composeAsyncValidators$1(this._asyncValidators);
	    }
	  }]);
	  return AbstractFormGroupDirective;
	}(ControlContainer$1);

	var modelGroupProvider =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: ControlContainer$1,
	    useExisting: forwardRef(function () {
	        return NgModelGroup;
	    })
	};
	var NgModelGroup = function (_AbstractFormGroupDir) {
	    inherits(NgModelGroup, _AbstractFormGroupDir);

	    function NgModelGroup(parent, validators, asyncValidators) {
	        classCallCheck(this, NgModelGroup);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NgModelGroup).call(this));

	        _this._parent = parent;
	        _this._validators = validators;
	        _this._asyncValidators = asyncValidators;
	        return _this;
	    }

	    return NgModelGroup;
	}(AbstractFormGroupDirective);
	/** @nocollapse */
	NgModelGroup.decorators = [{ type: Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' }] }];
	/** @nocollapse */
	NgModelGroup.ctorParameters = [{ type: ControlContainer$1, decorators: [{ type: Host }, { type: SkipSelf }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }];
	/** @nocollapse */
	NgModelGroup.propDecorators = {
	    'name': [{ type: Input, args: ['ngModelGroup'] }]
	};

	var formArrayNameProvider =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: ControlContainer$1,
	    useExisting: forwardRef(function () {
	        return FormArrayName;
	    })
	};
	var FormArrayName = function (_ControlContainer) {
	    inherits(FormArrayName, _ControlContainer);

	    function FormArrayName(parent, validators, asyncValidators) {
	        classCallCheck(this, FormArrayName);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(FormArrayName).call(this));

	        _this._parent = parent;
	        _this._validators = validators;
	        _this._asyncValidators = asyncValidators;
	        return _this;
	    }

	    createClass(FormArrayName, [{
	        key: 'ngOnInit',
	        value: function ngOnInit() {
	            this.formDirective.addFormArray(this);
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this.formDirective.removeFormArray(this);
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.formDirective.getFormArray(this);
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this._parent.formDirective;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return controlPath$1(this.name, this._parent);
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators$1(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators$1(this._asyncValidators);
	        }
	    }]);
	    return FormArrayName;
	}(ControlContainer$1);
	/** @nocollapse */
	FormArrayName.decorators = [{ type: Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] }] }];
	/** @nocollapse */
	FormArrayName.ctorParameters = [{ type: ControlContainer$1, decorators: [{ type: Host }, { type: SkipSelf }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }];
	/** @nocollapse */
	FormArrayName.propDecorators = {
	    'name': [{ type: Input, args: ['formArrayName'] }]
	};

	var formControlBinding$3 =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: NgControl$1,
	    useExisting: forwardRef(function () {
	        return FormControlDirective;
	    })
	};
	var FormControlDirective = function (_NgControl) {
	    inherits(FormControlDirective, _NgControl);

	    function FormControlDirective(_validators, _asyncValidators, valueAccessors) {
	        classCallCheck(this, FormControlDirective);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(FormControlDirective).call(this));

	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        _this.update = new EventEmitter$5();
	        _this.valueAccessor = selectValueAccessor$1(_this, valueAccessors);
	        return _this;
	    }

	    createClass(FormControlDirective, [{
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            if (this._isControlChanged(changes)) {
	                setUpControl$1(this.form, this);
	                this.form.updateValueAndValidity({ emitEvent: false });
	            }
	            if (isPropertyUpdated$1(changes, this.viewModel)) {
	                this.form.updateValue(this.model);
	                this.viewModel = this.model;
	            }
	        }
	    }, {
	        key: 'viewToModelUpdate',
	        value: function viewToModelUpdate(newValue) {
	            this.viewModel = newValue;
	            ObservableWrapper$5.callEmit(this.update, newValue);
	        }
	    }, {
	        key: '_isControlChanged',
	        value: function _isControlChanged(changes) {
	            return StringMapWrapper$5.contains(changes, 'form');
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return [];
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators$1(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators$1(this._asyncValidators);
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.form;
	        }
	    }]);
	    return FormControlDirective;
	}(NgControl$1);
	/** @nocollapse */
	FormControlDirective.decorators = [{ type: Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$3], exportAs: 'ngForm' }] }];
	/** @nocollapse */
	FormControlDirective.ctorParameters = [{ type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR$1] }] }];
	/** @nocollapse */
	FormControlDirective.propDecorators = {
	    'form': [{ type: Input, args: ['formControl'] }],
	    'model': [{ type: Input, args: ['ngModel'] }],
	    'update': [{ type: Output, args: ['ngModelChange'] }]
	};

	var controlNameBinding$1 =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: NgControl$1,
	    useExisting: forwardRef(function () {
	        return FormControlName;
	    })
	};
	var FormControlName = function (_NgControl) {
	    inherits(FormControlName, _NgControl);

	    function FormControlName(_parent, _validators, _asyncValidators, valueAccessors) {
	        classCallCheck(this, FormControlName);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(FormControlName).call(this));

	        _this._parent = _parent;
	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        _this._added = false;
	        _this.update = new EventEmitter$5();
	        _this.valueAccessor = selectValueAccessor$1(_this, valueAccessors);
	        return _this;
	    }

	    createClass(FormControlName, [{
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            if (!this._added) {
	                this.formDirective.addControl(this);
	                this._added = true;
	            }
	            if (isPropertyUpdated$1(changes, this.viewModel)) {
	                this.viewModel = this.model;
	                this.formDirective.updateModel(this, this.model);
	            }
	        }
	    }, {
	        key: 'ngOnDestroy',
	        value: function ngOnDestroy() {
	            this.formDirective.removeControl(this);
	        }
	    }, {
	        key: 'viewToModelUpdate',
	        value: function viewToModelUpdate(newValue) {
	            this.viewModel = newValue;
	            ObservableWrapper$5.callEmit(this.update, newValue);
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return controlPath$1(this.name, this._parent);
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this._parent.formDirective;
	        }
	    }, {
	        key: 'validator',
	        get: function get() {
	            return composeValidators$1(this._validators);
	        }
	    }, {
	        key: 'asyncValidator',
	        get: function get() {
	            return composeAsyncValidators$1(this._asyncValidators);
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.formDirective.getControl(this);
	        }
	    }]);
	    return FormControlName;
	}(NgControl$1);
	/** @nocollapse */
	FormControlName.decorators = [{ type: Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding$1] }] }];
	/** @nocollapse */
	FormControlName.ctorParameters = [{ type: ControlContainer$1, decorators: [{ type: Host }, { type: SkipSelf }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALUE_ACCESSOR$1] }] }];
	/** @nocollapse */
	FormControlName.propDecorators = {
	    'name': [{ type: Input, args: ['formControlName'] }],
	    'model': [{ type: Input, args: ['ngModel'] }],
	    'update': [{ type: Output, args: ['ngModelChange'] }]
	};

	var formDirectiveProvider$3 =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: ControlContainer$1,
	    useExisting: forwardRef(function () {
	        return FormGroupDirective;
	    })
	};
	var FormGroupDirective = function (_ControlContainer) {
	    inherits(FormGroupDirective, _ControlContainer);

	    function FormGroupDirective(_validators, _asyncValidators) {
	        classCallCheck(this, FormGroupDirective);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(FormGroupDirective).call(this));

	        _this._validators = _validators;
	        _this._asyncValidators = _asyncValidators;
	        _this._submitted = false;
	        _this.directives = [];
	        _this.form = null;
	        _this.ngSubmit = new EventEmitter$5();
	        return _this;
	    }

	    createClass(FormGroupDirective, [{
	        key: 'ngOnChanges',
	        value: function ngOnChanges(changes) {
	            this._checkFormPresent();
	            if (StringMapWrapper$5.contains(changes, 'form')) {
	                var sync = composeValidators$1(this._validators);
	                this.form.validator = Validators$1.compose([this.form.validator, sync]);
	                var async = composeAsyncValidators$1(this._asyncValidators);
	                this.form.asyncValidator = Validators$1.composeAsync([this.form.asyncValidator, async]);
	                this.form.updateValueAndValidity({ onlySelf: true, emitEvent: false });
	            }
	            this._updateDomValue();
	        }
	    }, {
	        key: 'addControl',
	        value: function addControl(dir) {
	            var ctrl = this.form.find(dir.path);
	            setUpControl$1(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	            this.directives.push(dir);
	        }
	    }, {
	        key: 'getControl',
	        value: function getControl(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'removeControl',
	        value: function removeControl(dir) {
	            ListWrapper$5.remove(this.directives, dir);
	        }
	    }, {
	        key: 'addFormGroup',
	        value: function addFormGroup(dir) {
	            var ctrl = this.form.find(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        }
	    }, {
	        key: 'removeFormGroup',
	        value: function removeFormGroup(dir) {}
	    }, {
	        key: 'getFormGroup',
	        value: function getFormGroup(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'addFormArray',
	        value: function addFormArray(dir) {
	            var ctrl = this.form.find(dir.path);
	            setUpFormContainer(ctrl, dir);
	            ctrl.updateValueAndValidity({ emitEvent: false });
	        }
	    }, {
	        key: 'removeFormArray',
	        value: function removeFormArray(dir) {}
	    }, {
	        key: 'getFormArray',
	        value: function getFormArray(dir) {
	            return this.form.find(dir.path);
	        }
	    }, {
	        key: 'updateModel',
	        value: function updateModel(dir, value) {
	            var ctrl = this.form.find(dir.path);
	            ctrl.updateValue(value);
	        }
	    }, {
	        key: 'onSubmit',
	        value: function onSubmit() {
	            this._submitted = true;
	            ObservableWrapper$5.callEmit(this.ngSubmit, null);
	            return false;
	        }
	        /** @internal */

	    }, {
	        key: '_updateDomValue',
	        value: function _updateDomValue() {
	            var _this2 = this;

	            this.directives.forEach(function (dir) {
	                var ctrl = _this2.form.find(dir.path);
	                dir.valueAccessor.writeValue(ctrl.value);
	            });
	        }
	    }, {
	        key: '_checkFormPresent',
	        value: function _checkFormPresent() {
	            if (isBlank$6(this.form)) {
	                throw new BaseException$5('formGroup expects a FormGroup instance. Please pass one in.\n           Example: <form [formGroup]="myFormGroup">\n      ');
	            }
	        }
	    }, {
	        key: 'submitted',
	        get: function get() {
	            return this._submitted;
	        }
	    }, {
	        key: 'formDirective',
	        get: function get() {
	            return this;
	        }
	    }, {
	        key: 'control',
	        get: function get() {
	            return this.form;
	        }
	    }, {
	        key: 'path',
	        get: function get() {
	            return [];
	        }
	    }]);
	    return FormGroupDirective;
	}(ControlContainer$1);
	/** @nocollapse */
	FormGroupDirective.decorators = [{ type: Directive, args: [{
	        selector: '[formGroup]',
	        providers: [formDirectiveProvider$3],
	        host: { '(submit)': 'onSubmit()' },
	        exportAs: 'ngForm'
	    }] }];
	/** @nocollapse */
	FormGroupDirective.ctorParameters = [{ type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }];
	/** @nocollapse */
	FormGroupDirective.propDecorators = {
	    'form': [{ type: Input, args: ['formGroup'] }],
	    'ngSubmit': [{ type: Output }]
	};

	var formGroupNameProvider =
	/*@ts2dart_const*/ /* @ts2dart_Provider */{
	    provide: ControlContainer$1,
	    useExisting: forwardRef(function () {
	        return FormGroupName;
	    })
	};
	var FormGroupName = function (_AbstractFormGroupDir) {
	    inherits(FormGroupName, _AbstractFormGroupDir);

	    function FormGroupName(parent, validators, asyncValidators) {
	        classCallCheck(this, FormGroupName);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(FormGroupName).call(this));

	        _this._parent = parent;
	        _this._validators = validators;
	        _this._asyncValidators = asyncValidators;
	        return _this;
	    }

	    return FormGroupName;
	}(AbstractFormGroupDirective);
	/** @nocollapse */
	FormGroupName.decorators = [{ type: Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] }] }];
	/** @nocollapse */
	FormGroupName.ctorParameters = [{ type: ControlContainer$1, decorators: [{ type: Host }, { type: SkipSelf }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_VALIDATORS$1] }] }, { type: Array, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NG_ASYNC_VALIDATORS$1] }] }];
	/** @nocollapse */
	FormGroupName.propDecorators = {
	    'name': [{ type: Input, args: ['formGroupName'] }]
	};

	var REQUIRED$1 = Validators$1.required;
	var REQUIRED_VALIDATOR$1 = {
	    provide: NG_VALIDATORS$1,
	    useValue: REQUIRED$1,
	    multi: true
	};
	var RequiredValidator$1 = function RequiredValidator() {
	    classCallCheck(this, RequiredValidator);
	};
	/** @nocollapse */
	RequiredValidator$1.decorators = [{ type: Directive, args: [{
	        selector: '[required][formControlName],[required][formControl],[required][ngModel]',
	        providers: [REQUIRED_VALIDATOR$1]
	    }] }];
	/**
	 * Provivder which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.
	 *
	 * ## Example:
	 *
	 * {@example common/forms/ts/validators/validators.ts region='min'}
	 */
	var MIN_LENGTH_VALIDATOR$1 = {
	    provide: NG_VALIDATORS$1,
	    useExisting: forwardRef(function () {
	        return MinLengthValidator$1;
	    }),
	    multi: true
	};
	var MinLengthValidator$1 = function () {
	    function MinLengthValidator(minLength) {
	        classCallCheck(this, MinLengthValidator);

	        this._validator = Validators$1.minLength(NumberWrapper$5.parseInt(minLength, 10));
	    }

	    createClass(MinLengthValidator, [{
	        key: 'validate',
	        value: function validate(c) {
	            return this._validator(c);
	        }
	    }]);
	    return MinLengthValidator;
	}();
	/** @nocollapse */
	MinLengthValidator$1.decorators = [{ type: Directive, args: [{
	        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
	        providers: [MIN_LENGTH_VALIDATOR$1]
	    }] }];
	/** @nocollapse */
	MinLengthValidator$1.ctorParameters = [{ type: undefined, decorators: [{ type: Attribute, args: ['minlength'] }] }];
	/**
	 * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.
	 *
	 * ## Example:
	 *
	 * {@example common/forms/ts/validators/validators.ts region='max'}
	 */
	var MAX_LENGTH_VALIDATOR$1 = {
	    provide: NG_VALIDATORS$1,
	    useExisting: forwardRef(function () {
	        return MaxLengthValidator$1;
	    }),
	    multi: true
	};
	var MaxLengthValidator$1 = function () {
	    function MaxLengthValidator(maxLength) {
	        classCallCheck(this, MaxLengthValidator);

	        this._validator = Validators$1.maxLength(NumberWrapper$5.parseInt(maxLength, 10));
	    }

	    createClass(MaxLengthValidator, [{
	        key: 'validate',
	        value: function validate(c) {
	            return this._validator(c);
	        }
	    }]);
	    return MaxLengthValidator;
	}();
	/** @nocollapse */
	MaxLengthValidator$1.decorators = [{ type: Directive, args: [{
	        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
	        providers: [MAX_LENGTH_VALIDATOR$1]
	    }] }];
	/** @nocollapse */
	MaxLengthValidator$1.ctorParameters = [{ type: undefined, decorators: [{ type: Attribute, args: ['maxlength'] }] }];
	var PATTERN_VALIDATOR$1 = {
	    provide: NG_VALIDATORS$1,
	    useExisting: forwardRef(function () {
	        return PatternValidator$1;
	    }),
	    multi: true
	};
	var PatternValidator$1 = function () {
	    function PatternValidator(pattern) {
	        classCallCheck(this, PatternValidator);

	        this._validator = Validators$1.pattern(pattern);
	    }

	    createClass(PatternValidator, [{
	        key: 'validate',
	        value: function validate(c) {
	            return this._validator(c);
	        }
	    }]);
	    return PatternValidator;
	}();
	/** @nocollapse */
	PatternValidator$1.decorators = [{ type: Directive, args: [{
	        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
	        providers: [PATTERN_VALIDATOR$1]
	    }] }];
	/** @nocollapse */
	PatternValidator$1.ctorParameters = [{ type: undefined, decorators: [{ type: Attribute, args: ['pattern'] }] }];

	/**
	 *
	 * A list of all the form directives used as part of a `@Component` annotation.
	 *
	 *  This is a shorthand for importing them each individually.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * @Component({
	 *   selector: 'my-app',
	 *   directives: [FORM_DIRECTIVES]
	 * })
	 * class MyApp {}
	 * ```
	 * @experimental
	 */
	var NEW_FORM_DIRECTIVES = [NgModel$1, NgModelGroup, NgForm$1, NgSelectOption$1, NgSelectMultipleOption$1, DefaultValueAccessor$1, NumberValueAccessor$1, CheckboxControlValueAccessor$1, SelectControlValueAccessor$1, SelectMultipleControlValueAccessor$1, RadioControlValueAccessor$1, NgControlStatus$1, RequiredValidator$1, MinLengthValidator$1, MaxLengthValidator$1, PatternValidator$1];
	/**
	 * @experimental
	 */
	var REACTIVE_FORM_DIRECTIVES =
	/*@ts2dart_const*/[FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];

	var NewFormBuilder = function () {
	    function FormBuilder() {
	        classCallCheck(this, FormBuilder);
	    }

	    createClass(FormBuilder, [{
	        key: 'group',

	        /**
	         * Construct a new {@link FormGroup} with the given map of configuration.
	         * Valid keys for the `extra` parameter map are `optionals` and `validator`.
	         *
	         * See the {@link FormGroup} constructor for more details.
	         */
	        value: function group(controlsConfig) {
	            var extra = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	            var controls = this._reduceControls(controlsConfig);
	            var optionals = isPresent$6(extra) ? StringMapWrapper$5.get(extra, 'optionals') : null;
	            var validator = isPresent$6(extra) ? StringMapWrapper$5.get(extra, 'validator') : null;
	            var asyncValidator = isPresent$6(extra) ? StringMapWrapper$5.get(extra, 'asyncValidator') : null;
	            return new FormGroup(controls, optionals, validator, asyncValidator);
	        }
	        /**
	         * Construct a new {@link FormControl} with the given `value`,`validator`, and `asyncValidator`.
	         */

	    }, {
	        key: 'control',
	        value: function control(value) {
	            var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return new FormControl(value, validator, asyncValidator);
	        }
	        /**
	         * Construct an array of {@link FormControl}s from the given `controlsConfig` array of
	         * configuration, with the given optional `validator` and `asyncValidator`.
	         */

	    }, {
	        key: 'array',
	        value: function array(controlsConfig) {
	            var _this = this;

	            var validator = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var asyncValidator = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var controls = controlsConfig.map(function (c) {
	                return _this._createControl(c);
	            });
	            return new FormArray(controls, validator, asyncValidator);
	        }
	        /** @internal */

	    }, {
	        key: '_reduceControls',
	        value: function _reduceControls(controlsConfig) {
	            var _this2 = this;

	            var controls = {};
	            StringMapWrapper$5.forEach(controlsConfig, function (controlConfig, controlName) {
	                controls[controlName] = _this2._createControl(controlConfig);
	            });
	            return controls;
	        }
	        /** @internal */

	    }, {
	        key: '_createControl',
	        value: function _createControl(controlConfig) {
	            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup || controlConfig instanceof FormArray) {
	                return controlConfig;
	            } else if (isArray$7(controlConfig)) {
	                var value = controlConfig[0];
	                var validator = controlConfig.length > 1 ? controlConfig[1] : null;
	                var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;
	                return this.control(value, validator, asyncValidator);
	            } else {
	                return this.control(controlConfig);
	            }
	        }
	    }]);
	    return FormBuilder;
	}();
	/** @nocollapse */
	NewFormBuilder.decorators = [{ type: Injectable }];

	/**
	 * Shorthand set of providers used for building Angular forms.
	 *
	 * ### Example
	 *
	 * ```typescript
	 * bootstrap(MyApp, [FORM_PROVIDERS]);
	 * ```
	 *
	 * @experimental
	 */
	var FORM_PROVIDERS$1 = [NewFormBuilder, NewRadioControlRegistry];
	function flatten(platformDirectives) {
	    var flattenedDirectives = [];
	    platformDirectives.forEach(function (directives) {
	        if (Array.isArray(directives)) {
	            flattenedDirectives = flattenedDirectives.concat(directives);
	        } else {
	            flattenedDirectives.push(directives);
	        }
	    });
	    return flattenedDirectives;
	}
	/**
	 * @experimental
	 */
	function disableDeprecatedForms() {
	    return [{
	        provide: CompilerConfig,
	        useFactory: function useFactory(platformDirectives, platformPipes) {
	            var flattenedDirectives = flatten(platformDirectives);
	            ListWrapper$5.remove(flattenedDirectives, OLD_FORM_DIRECTIVES);
	            return new CompilerConfig({ platformDirectives: flattenedDirectives, platformPipes: platformPipes });
	        },
	        deps: [PLATFORM_DIRECTIVES, PLATFORM_PIPES]
	    }];
	}
	/**
	 * @experimental
	 */
	function provideForms() {
	    return [{ provide: PLATFORM_DIRECTIVES, useValue: NEW_FORM_DIRECTIVES, multi: true }, FORM_PROVIDERS$1];
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var globalScope$6;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope$6 = self;
	    } else {
	        globalScope$6 = global;
	    }
	} else {
	    globalScope$6 = window;
	}
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var global$7 = globalScope$6;
	var Date$7 = global$7.Date;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	global$7.assert = function assert(condition) {
	    // TODO: to be fixed properly via #2830, noop for now
	};
	function isPresent$7(obj) {
	    return obj !== undefined && obj !== null;
	}
	function isBlank$7(obj) {
	    return obj === undefined || obj === null;
	}
	function isString$7(obj) {
	    return typeof obj === 'string';
	}
	function isArray$8(obj) {
	    return Array.isArray(obj);
	}
	var StringWrapper$6 = function () {
	    function StringWrapper() {
	        classCallCheck(this, StringWrapper);
	    }

	    createClass(StringWrapper, null, [{
	        key: 'fromCharCode',
	        value: function fromCharCode(code) {
	            return String.fromCharCode(code);
	        }
	    }, {
	        key: 'charCodeAt',
	        value: function charCodeAt(s, index) {
	            return s.charCodeAt(index);
	        }
	    }, {
	        key: 'split',
	        value: function split(s, regExp) {
	            return s.split(regExp);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(s, s2) {
	            return s === s2;
	        }
	    }, {
	        key: 'stripLeft',
	        value: function stripLeft(s, charVal) {
	            if (s && s.length) {
	                var pos = 0;
	                for (var i = 0; i < s.length; i++) {
	                    if (s[i] != charVal) break;
	                    pos++;
	                }
	                s = s.substring(pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'stripRight',
	        value: function stripRight(s, charVal) {
	            if (s && s.length) {
	                var pos = s.length;
	                for (var i = s.length - 1; i >= 0; i--) {
	                    if (s[i] != charVal) break;
	                    pos--;
	                }
	                s = s.substring(0, pos);
	            }
	            return s;
	        }
	    }, {
	        key: 'replace',
	        value: function replace(s, from, _replace) {
	            return s.replace(from, _replace);
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(s, from, replace) {
	            return s.replace(from, replace);
	        }
	    }, {
	        key: 'slice',
	        value: function slice(s) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return s.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'replaceAllMapped',
	        value: function replaceAllMapped(s, from, cb) {
	            return s.replace(from, function () {
	                for (var _len = arguments.length, matches = Array(_len), _key = 0; _key < _len; _key++) {
	                    matches[_key] = arguments[_key];
	                }

	                // Remove offset & string from the result array
	                matches.splice(-2, 2);
	                // The callback receives match, p1, ..., pn
	                return cb(matches);
	            });
	        }
	    }, {
	        key: 'contains',
	        value: function contains(s, substr) {
	            return s.indexOf(substr) != -1;
	        }
	    }, {
	        key: 'compare',
	        value: function compare(a, b) {
	            if (a < b) {
	                return -1;
	            } else if (a > b) {
	                return 1;
	            } else {
	                return 0;
	            }
	        }
	    }]);
	    return StringWrapper;
	}();

	var StringJoiner$6 = function () {
	    function StringJoiner() {
	        var parts = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        classCallCheck(this, StringJoiner);

	        this.parts = parts;
	    }

	    createClass(StringJoiner, [{
	        key: 'add',
	        value: function add(part) {
	            this.parts.push(part);
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return this.parts.join('');
	        }
	    }]);
	    return StringJoiner;
	}();
	var NumberParseError$6 = function (_Error) {
	    inherits(NumberParseError, _Error);

	    function NumberParseError(message) {
	        classCallCheck(this, NumberParseError);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(NumberParseError).call(this));

	        _this.message = message;
	        return _this;
	    }

	    createClass(NumberParseError, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return NumberParseError;
	}(Error);
	var NumberWrapper$6 = function () {
	    function NumberWrapper() {
	        classCallCheck(this, NumberWrapper);
	    }

	    createClass(NumberWrapper, null, [{
	        key: 'toFixed',
	        value: function toFixed(n, fractionDigits) {
	            return n.toFixed(fractionDigits);
	        }
	    }, {
	        key: 'equal',
	        value: function equal(a, b) {
	            return a === b;
	        }
	    }, {
	        key: 'parseIntAutoRadix',
	        value: function parseIntAutoRadix(text) {
	            var result = parseInt(text);
	            if (isNaN(result)) {
	                throw new NumberParseError$6('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        }
	    }, {
	        key: 'parseInt',
	        value: function (_parseInt) {
	            function parseInt(_x4, _x5) {
	                return _parseInt.apply(this, arguments);
	            }

	            parseInt.toString = function () {
	                return _parseInt.toString();
	            };

	            return parseInt;
	        }(function (text, radix) {
	            if (radix == 10) {
	                if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else if (radix == 16) {
	                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                    return parseInt(text, radix);
	                }
	            } else {
	                var result = parseInt(text, radix);
	                if (!isNaN(result)) {
	                    return result;
	                }
	            }
	            throw new NumberParseError$6('Invalid integer literal when parsing ' + text + ' in base ' + radix);
	        })
	        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.

	    }, {
	        key: 'parseFloat',
	        value: function (_parseFloat) {
	            function parseFloat(_x6) {
	                return _parseFloat.apply(this, arguments);
	            }

	            parseFloat.toString = function () {
	                return _parseFloat.toString();
	            };

	            return parseFloat;
	        }(function (text) {
	            return parseFloat(text);
	        })
	    }, {
	        key: 'isNumeric',
	        value: function isNumeric(value) {
	            return !isNaN(value - parseFloat(value));
	        }
	    }, {
	        key: 'isNaN',
	        value: function (_isNaN) {
	            function isNaN(_x7) {
	                return _isNaN.apply(this, arguments);
	            }

	            isNaN.toString = function () {
	                return _isNaN.toString();
	            };

	            return isNaN;
	        }(function (value) {
	            return isNaN(value);
	        })
	    }, {
	        key: 'isInteger',
	        value: function isInteger(value) {
	            return Number.isInteger(value);
	        }
	    }, {
	        key: 'NaN',
	        get: function get() {
	            return NaN;
	        }
	    }]);
	    return NumberWrapper;
	}();
	var RegExpWrapper$6 = function () {
	    function RegExpWrapper() {
	        classCallCheck(this, RegExpWrapper);
	    }

	    createClass(RegExpWrapper, null, [{
	        key: 'create',
	        value: function create(regExpStr) {
	            var flags = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	            flags = flags.replace(/g/g, '');
	            return new global$7.RegExp(regExpStr, flags + 'g');
	        }
	    }, {
	        key: 'firstMatch',
	        value: function firstMatch(regExp, input) {
	            // Reset multimatch regex state
	            regExp.lastIndex = 0;
	            return regExp.exec(input);
	        }
	    }, {
	        key: 'test',
	        value: function test(regExp, input) {
	            regExp.lastIndex = 0;
	            return regExp.test(input);
	        }
	    }, {
	        key: 'matcher',
	        value: function matcher(regExp, input) {
	            // Reset regex state for the case
	            // someone did not loop over all matches
	            // last time.
	            regExp.lastIndex = 0;
	            return { re: regExp, input: input };
	        }
	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(regExp, input, replace) {
	            var c = regExp.exec(input);
	            var res = '';
	            regExp.lastIndex = 0;
	            var prev = 0;
	            while (c) {
	                res += input.substring(prev, c.index);
	                res += replace(c);
	                prev = c.index + c[0].length;
	                regExp.lastIndex = prev;
	                c = regExp.exec(input);
	            }
	            res += input.substring(prev);
	            return res;
	        }
	    }]);
	    return RegExpWrapper;
	}();
	var RegExpMatcherWrapper$6 = function () {
	    function RegExpMatcherWrapper() {
	        classCallCheck(this, RegExpMatcherWrapper);
	    }

	    createClass(RegExpMatcherWrapper, null, [{
	        key: 'next',
	        value: function next(matcher) {
	            return matcher.re.exec(matcher.input);
	        }
	    }]);
	    return RegExpMatcherWrapper;
	}();
	var FunctionWrapper$6 = function () {
	    function FunctionWrapper() {
	        classCallCheck(this, FunctionWrapper);
	    }

	    createClass(FunctionWrapper, null, [{
	        key: 'apply',
	        value: function apply(fn, posArgs) {
	            return fn.apply(null, posArgs);
	        }
	    }, {
	        key: 'bind',
	        value: function bind(fn, scope) {
	            return fn.bind(scope);
	        }
	    }]);
	    return FunctionWrapper;
	}();
	function isJsObject$6(o) {
	    return o !== null && (typeof o === 'function' || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object');
	}
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json$6 = function () {
	    function Json() {
	        classCallCheck(this, Json);
	    }

	    createClass(Json, null, [{
	        key: 'parse',
	        value: function parse(s) {
	            return global$7.JSON.parse(s);
	        }
	    }, {
	        key: 'stringify',
	        value: function stringify(data) {
	            // Dart doesn't take 3 arguments
	            return global$7.JSON.stringify(data, null, 2);
	        }
	    }]);
	    return Json;
	}();
	var DateWrapper$6 = function () {
	    function DateWrapper() {
	        classCallCheck(this, DateWrapper);
	    }

	    createClass(DateWrapper, null, [{
	        key: 'create',
	        value: function create(year) {
	            var month = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];
	            var day = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
	            var hour = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	            var minutes = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];
	            var seconds = arguments.length <= 5 || arguments[5] === undefined ? 0 : arguments[5];
	            var milliseconds = arguments.length <= 6 || arguments[6] === undefined ? 0 : arguments[6];

	            return new Date$7(year, month - 1, day, hour, minutes, seconds, milliseconds);
	        }
	    }, {
	        key: 'fromISOString',
	        value: function fromISOString(str) {
	            return new Date$7(str);
	        }
	    }, {
	        key: 'fromMillis',
	        value: function fromMillis(ms) {
	            return new Date$7(ms);
	        }
	    }, {
	        key: 'toMillis',
	        value: function toMillis(date) {
	            return date.getTime();
	        }
	    }, {
	        key: 'now',
	        value: function now() {
	            return new Date$7();
	        }
	    }, {
	        key: 'toJson',
	        value: function toJson(date) {
	            return date.toJSON();
	        }
	    }]);
	    return DateWrapper;
	}();
	var _symbolIterator$6 = null;
	function getSymbolIterator$6() {
	    if (isBlank$7(_symbolIterator$6)) {
	        if (isPresent$7(globalScope$6.Symbol) && isPresent$7(Symbol.iterator)) {
	            _symbolIterator$6 = Symbol.iterator;
	        } else {
	            // es6-shim specific logic
	            var keys = Object.getOwnPropertyNames(Map.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
	                    _symbolIterator$6 = key;
	                }
	            }
	        }
	    }
	    return _symbolIterator$6;
	}

	var _nextRequestId = 0;
	var JSONP_HOME = '__ng_jsonp__';
	var _jsonpConnections = null;
	function _getJsonpConnections() {
	    if (_jsonpConnections === null) {
	        _jsonpConnections = global$7[JSONP_HOME] = {};
	    }
	    return _jsonpConnections;
	}
	var BrowserJsonp = function () {
	    function BrowserJsonp() {
	        classCallCheck(this, BrowserJsonp);
	    }

	    createClass(BrowserJsonp, [{
	        key: 'build',

	        // Construct a <script> element with the specified URL
	        value: function build(url) {
	            var node = document.createElement('script');
	            node.src = url;
	            return node;
	        }
	    }, {
	        key: 'nextRequestID',
	        value: function nextRequestID() {
	            return '__req' + _nextRequestId++;
	        }
	    }, {
	        key: 'requestCallback',
	        value: function requestCallback(id) {
	            return JSONP_HOME + '.' + id + '.finished';
	        }
	    }, {
	        key: 'exposeConnection',
	        value: function exposeConnection(id, connection) {
	            var connections = _getJsonpConnections();
	            connections[id] = connection;
	        }
	    }, {
	        key: 'removeConnection',
	        value: function removeConnection(id) {
	            var connections = _getJsonpConnections();
	            connections[id] = null;
	        }
	        // Attach the <script> element to the DOM

	    }, {
	        key: 'send',
	        value: function send(node) {
	            document.body.appendChild(node);
	        }
	        // Remove <script> element from the DOM

	    }, {
	        key: 'cleanup',
	        value: function cleanup(node) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(node);
	            }
	        }
	    }]);
	    return BrowserJsonp;
	}();
	/** @nocollapse */
	BrowserJsonp.decorators = [{ type: Injectable }];

	var BrowserXhr = function () {
	    function BrowserXhr() {
	        classCallCheck(this, BrowserXhr);
	    }

	    createClass(BrowserXhr, [{
	        key: 'build',
	        value: function build() {
	            return new XMLHttpRequest();
	        }
	    }]);
	    return BrowserXhr;
	}();
	/** @nocollapse */
	BrowserXhr.decorators = [{ type: Injectable }];
	/** @nocollapse */
	BrowserXhr.ctorParameters = [];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Supported http methods.
	 * @experimental
	 */
	var RequestMethod;
	(function (RequestMethod) {
	  RequestMethod[RequestMethod["Get"] = 0] = "Get";
	  RequestMethod[RequestMethod["Post"] = 1] = "Post";
	  RequestMethod[RequestMethod["Put"] = 2] = "Put";
	  RequestMethod[RequestMethod["Delete"] = 3] = "Delete";
	  RequestMethod[RequestMethod["Options"] = 4] = "Options";
	  RequestMethod[RequestMethod["Head"] = 5] = "Head";
	  RequestMethod[RequestMethod["Patch"] = 6] = "Patch";
	})(RequestMethod || (RequestMethod = {}));
	/**
	 * All possible states in which a connection can be, based on
	 * [States](http://www.w3.org/TR/XMLHttpRequest/#states) from the `XMLHttpRequest` spec, but with an
	 * additional "CANCELLED" state.
	 * @experimental
	 */
	var ReadyState;
	(function (ReadyState) {
	  ReadyState[ReadyState["Unsent"] = 0] = "Unsent";
	  ReadyState[ReadyState["Open"] = 1] = "Open";
	  ReadyState[ReadyState["HeadersReceived"] = 2] = "HeadersReceived";
	  ReadyState[ReadyState["Loading"] = 3] = "Loading";
	  ReadyState[ReadyState["Done"] = 4] = "Done";
	  ReadyState[ReadyState["Cancelled"] = 5] = "Cancelled";
	})(ReadyState || (ReadyState = {}));
	/**
	 * Acceptable response types to be associated with a {@link Response}, based on
	 * [ResponseType](https://fetch.spec.whatwg.org/#responsetype) from the Fetch spec.
	 * @experimental
	 */
	var ResponseType;
	(function (ResponseType) {
	  ResponseType[ResponseType["Basic"] = 0] = "Basic";
	  ResponseType[ResponseType["Cors"] = 1] = "Cors";
	  ResponseType[ResponseType["Default"] = 2] = "Default";
	  ResponseType[ResponseType["Error"] = 3] = "Error";
	  ResponseType[ResponseType["Opaque"] = 4] = "Opaque";
	})(ResponseType || (ResponseType = {}));
	/**
	 * Supported content type to be automatically associated with a {@link Request}.
	 * @experimental
	 */
	var ContentType;
	(function (ContentType) {
	  ContentType[ContentType["NONE"] = 0] = "NONE";
	  ContentType[ContentType["JSON"] = 1] = "JSON";
	  ContentType[ContentType["FORM"] = 2] = "FORM";
	  ContentType[ContentType["FORM_DATA"] = 3] = "FORM_DATA";
	  ContentType[ContentType["TEXT"] = 4] = "TEXT";
	  ContentType[ContentType["BLOB"] = 5] = "BLOB";
	  ContentType[ContentType["ARRAY_BUFFER"] = 6] = "ARRAY_BUFFER";
	})(ContentType || (ContentType = {}));

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A base class for the WrappedException that can be used to identify
	 * a WrappedException from ExceptionHandler without adding circular
	 * dependency.
	 */
	var BaseWrappedException$6 = function (_Error) {
	  inherits(BaseWrappedException, _Error);

	  function BaseWrappedException(message) {
	    classCallCheck(this, BaseWrappedException);
	    return possibleConstructorReturn(this, Object.getPrototypeOf(BaseWrappedException).call(this, message));
	  }

	  createClass(BaseWrappedException, [{
	    key: 'wrapperMessage',
	    get: function get() {
	      return '';
	    }
	  }, {
	    key: 'wrapperStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalException',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'originalStack',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'message',
	    get: function get() {
	      return '';
	    }
	  }]);
	  return BaseWrappedException;
	}(Error);

	var Map$7 = global$7.Map;
	var Set$7 = global$7.Set;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs$6 = function () {
	    try {
	        if (new Map$7([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) {
	                return new Map$7(pairs);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new Map$7();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	}();
	var createMapFromMap$6 = function () {
	    try {
	        if (new Map$7(new Map$7())) {
	            return function createMapFromMap(m) {
	                return new Map$7(m);
	            };
	        }
	    } catch (e) {}
	    return function createMapAndPopulateFromMap(m) {
	        var map = new Map$7();
	        m.forEach(function (v, k) {
	            map.set(k, v);
	        });
	        return map;
	    };
	}();
	var _clearValues$6 = function () {
	    if (new Map$7().keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!(k = keyIterator.next()).done) {
	                m.set(k.value, null);
	            }
	        };
	    } else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) {
	                m.set(k, null);
	            });
	        };
	    }
	}();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap$6 = function () {
	    try {
	        if (new Map$7().values().next) {
	            return function createArrayFromMap(m, getValues) {
	                return getValues ? Array.from(m.values()) : Array.from(m.keys());
	            };
	        }
	    } catch (e) {}
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper$6.createFixedSize(m.size),
	            i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	}();
	var MapWrapper$6 = function () {
	    function MapWrapper() {
	        classCallCheck(this, MapWrapper);
	    }

	    createClass(MapWrapper, null, [{
	        key: 'clone',
	        value: function clone(m) {
	            return createMapFromMap$6(m);
	        }
	    }, {
	        key: 'createFromStringMap',
	        value: function createFromStringMap(stringMap) {
	            var result = new Map$7();
	            for (var prop in stringMap) {
	                result.set(prop, stringMap[prop]);
	            }
	            return result;
	        }
	    }, {
	        key: 'toStringMap',
	        value: function toStringMap(m) {
	            var r = {};
	            m.forEach(function (v, k) {
	                return r[k] = v;
	            });
	            return r;
	        }
	    }, {
	        key: 'createFromPairs',
	        value: function createFromPairs(pairs) {
	            return createMapFromPairs$6(pairs);
	        }
	    }, {
	        key: 'clearValues',
	        value: function clearValues(m) {
	            _clearValues$6(m);
	        }
	    }, {
	        key: 'iterable',
	        value: function iterable(m) {
	            return m;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(m) {
	            return _arrayFromMap$6(m, false);
	        }
	    }, {
	        key: 'values',
	        value: function values(m) {
	            return _arrayFromMap$6(m, true);
	        }
	    }]);
	    return MapWrapper;
	}();
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper$6 = function () {
	    function StringMapWrapper() {
	        classCallCheck(this, StringMapWrapper);
	    }

	    createClass(StringMapWrapper, null, [{
	        key: 'create',
	        value: function create() {
	            // Note: We are not using Object.create(null) here due to
	            // performance!
	            // http://jsperf.com/ng2-object-create-null
	            return {};
	        }
	    }, {
	        key: 'contains',
	        value: function contains(map, key) {
	            return map.hasOwnProperty(key);
	        }
	    }, {
	        key: 'get',
	        value: function get(map, key) {
	            return map.hasOwnProperty(key) ? map[key] : undefined;
	        }
	    }, {
	        key: 'set',
	        value: function set(map, key, value) {
	            map[key] = value;
	        }
	    }, {
	        key: 'keys',
	        value: function keys(map) {
	            return Object.keys(map);
	        }
	    }, {
	        key: 'values',
	        value: function values(map) {
	            return Object.keys(map).reduce(function (r, a) {
	                r.push(map[a]);
	                return r;
	            }, []);
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(map) {
	            for (var prop in map) {
	                return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(map, key) {
	            delete map[key];
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(map, callback) {
	            for (var prop in map) {
	                if (map.hasOwnProperty(prop)) {
	                    callback(map[prop], prop);
	                }
	            }
	        }
	    }, {
	        key: 'merge',
	        value: function merge(m1, m2) {
	            var m = {};
	            for (var attr in m1) {
	                if (m1.hasOwnProperty(attr)) {
	                    m[attr] = m1[attr];
	                }
	            }
	            for (var attr in m2) {
	                if (m2.hasOwnProperty(attr)) {
	                    m[attr] = m2[attr];
	                }
	            }
	            return m;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(m1, m2) {
	            var k1 = Object.keys(m1);
	            var k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            var key;
	            for (var i = 0; i < k1.length; i++) {
	                key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }]);
	    return StringMapWrapper;
	}();
	var ListWrapper$6 = function () {
	    function ListWrapper() {
	        classCallCheck(this, ListWrapper);
	    }

	    createClass(ListWrapper, null, [{
	        key: 'createFixedSize',

	        // JS has no way to express a statically fixed size list, but dart does so we
	        // keep both methods.
	        value: function createFixedSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'createGrowableSize',
	        value: function createGrowableSize(size) {
	            return new Array(size);
	        }
	    }, {
	        key: 'clone',
	        value: function clone(array) {
	            return array.slice(0);
	        }
	    }, {
	        key: 'forEachWithIndex',
	        value: function forEachWithIndex(array, fn) {
	            for (var i = 0; i < array.length; i++) {
	                fn(array[i], i);
	            }
	        }
	    }, {
	        key: 'first',
	        value: function first(array) {
	            if (!array) return null;
	            return array[0];
	        }
	    }, {
	        key: 'last',
	        value: function last(array) {
	            if (!array || array.length == 0) return null;
	            return array[array.length - 1];
	        }
	    }, {
	        key: 'indexOf',
	        value: function indexOf(array, value) {
	            var startIndex = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	            return array.indexOf(value, startIndex);
	        }
	    }, {
	        key: 'contains',
	        value: function contains(list, el) {
	            return list.indexOf(el) !== -1;
	        }
	    }, {
	        key: 'reversed',
	        value: function reversed(array) {
	            var a = ListWrapper.clone(array);
	            return a.reverse();
	        }
	    }, {
	        key: 'concat',
	        value: function concat(a, b) {
	            return a.concat(b);
	        }
	    }, {
	        key: 'insert',
	        value: function insert(list, index, value) {
	            list.splice(index, 0, value);
	        }
	    }, {
	        key: 'removeAt',
	        value: function removeAt(list, index) {
	            var res = list[index];
	            list.splice(index, 1);
	            return res;
	        }
	    }, {
	        key: 'removeAll',
	        value: function removeAll(list, items) {
	            for (var i = 0; i < items.length; ++i) {
	                var index = list.indexOf(items[i]);
	                list.splice(index, 1);
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(list, el) {
	            var index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: 'clear',
	        value: function clear(list) {
	            list.length = 0;
	        }
	    }, {
	        key: 'isEmpty',
	        value: function isEmpty(list) {
	            return list.length == 0;
	        }
	    }, {
	        key: 'fill',
	        value: function fill(list, value) {
	            var start = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	            var end = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	            list.fill(value, start, end === null ? list.length : end);
	        }
	    }, {
	        key: 'equals',
	        value: function equals(a, b) {
	            if (a.length != b.length) return false;
	            for (var i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i]) return false;
	            }
	            return true;
	        }
	    }, {
	        key: 'slice',
	        value: function slice(l) {
	            var from = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	            var to = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            return l.slice(from, to === null ? undefined : to);
	        }
	    }, {
	        key: 'splice',
	        value: function splice(l, from, length) {
	            return l.splice(from, length);
	        }
	    }, {
	        key: 'sort',
	        value: function sort(l, compareFn) {
	            if (isPresent$7(compareFn)) {
	                l.sort(compareFn);
	            } else {
	                l.sort();
	            }
	        }
	    }, {
	        key: 'toString',
	        value: function toString(l) {
	            return l.toString();
	        }
	    }, {
	        key: 'toJSON',
	        value: function toJSON(l) {
	            return JSON.stringify(l);
	        }
	    }, {
	        key: 'maximum',
	        value: function maximum(list, predicate) {
	            if (list.length == 0) {
	                return null;
	            }
	            var solution = null;
	            var maxValue = -Infinity;
	            for (var index = 0; index < list.length; index++) {
	                var candidate = list[index];
	                if (isBlank$7(candidate)) {
	                    continue;
	                }
	                var candidateValue = predicate(candidate);
	                if (candidateValue > maxValue) {
	                    solution = candidate;
	                    maxValue = candidateValue;
	                }
	            }
	            return solution;
	        }
	    }, {
	        key: 'flatten',
	        value: function flatten(list) {
	            var target = [];
	            _flattenArray$6(list, target);
	            return target;
	        }
	    }, {
	        key: 'addAll',
	        value: function addAll(list, source) {
	            for (var i = 0; i < source.length; i++) {
	                list.push(source[i]);
	            }
	        }
	    }]);
	    return ListWrapper;
	}();
	function _flattenArray$6(source, target) {
	    if (isPresent$7(source)) {
	        for (var i = 0; i < source.length; i++) {
	            var item = source[i];
	            if (isArray$8(item)) {
	                _flattenArray$6(item, target);
	            } else {
	                target.push(item);
	            }
	        }
	    }
	    return target;
	}
	function isListLikeIterable$6(obj) {
	    if (!isJsObject$6(obj)) return false;
	    return isArray$8(obj) || !(obj instanceof Map$7) && getSymbolIterator$6() in obj; // JS Iterable have a Symbol.iterator prop
	}
	function iterateListLike$6(obj, fn) {
	    if (isArray$8(obj)) {
	        for (var i = 0; i < obj.length; i++) {
	            fn(obj[i]);
	        }
	    } else {
	        var iterator = obj[getSymbolIterator$6()]();
	        var item;
	        while (!(item = iterator.next()).done) {
	            fn(item.value);
	        }
	    }
	}
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList$6 = function () {
	    var test = new Set$7([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) {
	            return new Set$7(lst);
	        };
	    } else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new Set$7(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	}();
	var SetWrapper$6 = function () {
	    function SetWrapper() {
	        classCallCheck(this, SetWrapper);
	    }

	    createClass(SetWrapper, null, [{
	        key: 'createFromList',
	        value: function createFromList(lst) {
	            return createSetFromList$6(lst);
	        }
	    }, {
	        key: 'has',
	        value: function has(s, key) {
	            return s.has(key);
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(m, k) {
	            m.delete(k);
	        }
	    }]);
	    return SetWrapper;
	}();

	var _ArrayLogger$6 = function () {
	    function _ArrayLogger() {
	        classCallCheck(this, _ArrayLogger);

	        this.res = [];
	    }

	    createClass(_ArrayLogger, [{
	        key: 'log',
	        value: function log(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logError',
	        value: function logError(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroup',
	        value: function logGroup(s) {
	            this.res.push(s);
	        }
	    }, {
	        key: 'logGroupEnd',
	        value: function logGroupEnd() {}
	    }]);
	    return _ArrayLogger;
	}();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * ### Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, {provide: ExceptionHandler, useClass: MyExceptionHandler}])
	 *
	 * ```
	 * @stable
	 */


	var ExceptionHandler$6 = function () {
	    function ExceptionHandler(_logger) {
	        var _rethrowException = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

	        classCallCheck(this, ExceptionHandler);

	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }

	    createClass(ExceptionHandler, [{
	        key: 'call',
	        value: function call(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var originalException = this._findOriginalException(exception);
	            var originalStack = this._findOriginalStack(exception);
	            var context = this._findContext(exception);
	            this._logger.logGroup('EXCEPTION: ' + this._extractMessage(exception));
	            if (isPresent$7(stackTrace) && isBlank$7(originalStack)) {
	                this._logger.logError('STACKTRACE:');
	                this._logger.logError(this._longStackTrace(stackTrace));
	            }
	            if (isPresent$7(reason)) {
	                this._logger.logError('REASON: ' + reason);
	            }
	            if (isPresent$7(originalException)) {
	                this._logger.logError('ORIGINAL EXCEPTION: ' + this._extractMessage(originalException));
	            }
	            if (isPresent$7(originalStack)) {
	                this._logger.logError('ORIGINAL STACKTRACE:');
	                this._logger.logError(this._longStackTrace(originalStack));
	            }
	            if (isPresent$7(context)) {
	                this._logger.logError('ERROR CONTEXT:');
	                this._logger.logError(context);
	            }
	            this._logger.logGroupEnd();
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	            if (this._rethrowException) throw exception;
	        }
	        /** @internal */

	    }, {
	        key: '_extractMessage',
	        value: function _extractMessage(exception) {
	            return exception instanceof BaseWrappedException$6 ? exception.wrapperMessage : exception.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_longStackTrace',
	        value: function _longStackTrace(stackTrace) {
	            return isListLikeIterable$6(stackTrace) ? stackTrace.join('\n\n-----async gap-----\n') : stackTrace.toString();
	        }
	        /** @internal */

	    }, {
	        key: '_findContext',
	        value: function _findContext(exception) {
	            try {
	                if (!(exception instanceof BaseWrappedException$6)) return null;
	                return isPresent$7(exception.context) ? exception.context : this._findContext(exception.originalException);
	            } catch (e) {
	                // exception.context can throw an exception. if it happens, we ignore the context.
	                return null;
	            }
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalException',
	        value: function _findOriginalException(exception) {
	            if (!(exception instanceof BaseWrappedException$6)) return null;
	            var e = exception.originalException;
	            while (e instanceof BaseWrappedException$6 && isPresent$7(e.originalException)) {
	                e = e.originalException;
	            }
	            return e;
	        }
	        /** @internal */

	    }, {
	        key: '_findOriginalStack',
	        value: function _findOriginalStack(exception) {
	            if (!(exception instanceof BaseWrappedException$6)) return null;
	            var e = exception;
	            var stack = exception.originalStack;
	            while (e instanceof BaseWrappedException$6 && isPresent$7(e.originalException)) {
	                e = e.originalException;
	                if (e instanceof BaseWrappedException$6 && isPresent$7(e.originalException)) {
	                    stack = e.originalStack;
	                }
	            }
	            return stack;
	        }
	    }], [{
	        key: 'exceptionToString',
	        value: function exceptionToString(exception) {
	            var stackTrace = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	            var reason = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	            var l = new _ArrayLogger$6();
	            var e = new ExceptionHandler(l, false);
	            e.call(exception, stackTrace, reason);
	            return l.res.join('\n');
	        }
	    }]);
	    return ExceptionHandler;
	}();

	/**
	 * @stable
	 */
	var BaseException$6 = function (_Error) {
	    inherits(BaseException, _Error);

	    function BaseException() {
	        var message = arguments.length <= 0 || arguments[0] === undefined ? '--' : arguments[0];
	        classCallCheck(this, BaseException);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(BaseException).call(this, message));

	        _this.message = message;
	        _this.stack = new Error(message).stack;
	        return _this;
	    }

	    createClass(BaseException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }]);
	    return BaseException;
	}(Error);
	/**
	 * Wraps an exception and provides additional context or information.
	 * @stable
	 */
	var WrappedException$6 = function (_BaseWrappedException) {
	    inherits(WrappedException, _BaseWrappedException);

	    function WrappedException(_wrapperMessage, _originalException /** TODO #9100 */, _originalStack /** TODO #9100 */, _context /** TODO #9100 */) {
	        classCallCheck(this, WrappedException);

	        var _this2 = possibleConstructorReturn(this, Object.getPrototypeOf(WrappedException).call(this, _wrapperMessage));

	        _this2._wrapperMessage = _wrapperMessage;
	        _this2._originalException = _originalException;
	        _this2._originalStack = _originalStack;
	        _this2._context = _context;
	        _this2._wrapperStack = new Error(_wrapperMessage).stack;
	        return _this2;
	    }

	    createClass(WrappedException, [{
	        key: 'toString',
	        value: function toString() {
	            return this.message;
	        }
	    }, {
	        key: 'wrapperMessage',
	        get: function get() {
	            return this._wrapperMessage;
	        }
	    }, {
	        key: 'wrapperStack',
	        get: function get() {
	            return this._wrapperStack;
	        }
	    }, {
	        key: 'originalException',
	        get: function get() {
	            return this._originalException;
	        }
	    }, {
	        key: 'originalStack',
	        get: function get() {
	            return this._originalStack;
	        }
	    }, {
	        key: 'context',
	        get: function get() {
	            return this._context;
	        }
	    }, {
	        key: 'message',
	        get: function get() {
	            return ExceptionHandler$6.exceptionToString(this);
	        }
	    }]);
	    return WrappedException;
	}(BaseWrappedException$6);
	function makeTypeError$6(message) {
	    return new TypeError(message);
	}

	/**
	 * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
	 * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).
	 *
	 * The only known difference between this `Headers` implementation and the spec is the
	 * lack of an `entries` method.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/MTdwT6?p=preview))
	 *
	 * ```
	 * import {Headers} from '@angular/http';
	 *
	 * var firstHeaders = new Headers();
	 * firstHeaders.append('Content-Type', 'image/jpeg');
	 * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'
	 *
	 * // Create headers from Plain Old JavaScript Object
	 * var secondHeaders = new Headers({
	 *   'X-My-Custom-Header': 'Angular'
	 * });
	 * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'
	 *
	 * var thirdHeaders = new Headers(secondHeaders);
	 * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'
	 * ```
	 *
	 * @experimental
	 */
	var Headers = function () {
	    function Headers(headers) {
	        var _this = this;

	        classCallCheck(this, Headers);

	        if (headers instanceof Headers) {
	            this._headersMap = headers._headersMap;
	            return;
	        }
	        this._headersMap = new Map$7();
	        if (isBlank$7(headers)) {
	            return;
	        }
	        // headers instanceof StringMap
	        StringMapWrapper$6.forEach(headers, function (v, k) {
	            _this._headersMap.set(k, isListLikeIterable$6(v) ? v : [v]);
	        });
	    }
	    /**
	     * Returns a new Headers instance from the given DOMString of Response Headers
	     */


	    createClass(Headers, [{
	        key: 'append',

	        /**
	         * Appends a header to existing list of header values for a given header name.
	         */
	        value: function append(name, value) {
	            var mapName = this._headersMap.get(name);
	            var list = isListLikeIterable$6(mapName) ? mapName : [];
	            list.push(value);
	            this._headersMap.set(name, list);
	        }
	        /**
	         * Deletes all header values for the given name.
	         */

	    }, {
	        key: 'delete',
	        value: function _delete(name) {
	            this._headersMap.delete(name);
	        }
	    }, {
	        key: 'forEach',
	        value: function forEach(fn) {
	            this._headersMap.forEach(fn);
	        }
	        /**
	         * Returns first header that matches given name.
	         */

	    }, {
	        key: 'get',
	        value: function get(header) {
	            return ListWrapper$6.first(this._headersMap.get(header));
	        }
	        /**
	         * Check for existence of header by given name.
	         */

	    }, {
	        key: 'has',
	        value: function has(header) {
	            return this._headersMap.has(header);
	        }
	        /**
	         * Provides names of set headers
	         */

	    }, {
	        key: 'keys',
	        value: function keys() {
	            return MapWrapper$6.keys(this._headersMap);
	        }
	        /**
	         * Sets or overrides header value for given name.
	         */

	    }, {
	        key: 'set',
	        value: function set(header, value) {
	            var list = [];
	            if (isListLikeIterable$6(value)) {
	                var pushValue = value.join(',');
	                list.push(pushValue);
	            } else {
	                list.push(value);
	            }
	            this._headersMap.set(header, list);
	        }
	        /**
	         * Returns values of all headers.
	         */

	    }, {
	        key: 'values',
	        value: function values() {
	            return MapWrapper$6.values(this._headersMap);
	        }
	        /**
	         * Returns string of all headers.
	         */

	    }, {
	        key: 'toJSON',
	        value: function toJSON() {
	            var serializableHeaders = {};
	            this._headersMap.forEach(function (values, name) {
	                var list = [];
	                iterateListLike$6(values, function (val /** TODO #9100 */) {
	                    return list = ListWrapper$6.concat(list, val.split(','));
	                });
	                serializableHeaders[name] = list;
	            });
	            return serializableHeaders;
	        }
	        /**
	         * Returns list of header values for a given name.
	         */

	    }, {
	        key: 'getAll',
	        value: function getAll(header) {
	            var headers = this._headersMap.get(header);
	            return isListLikeIterable$6(headers) ? headers : [];
	        }
	        /**
	         * This method is not implemented.
	         */

	    }, {
	        key: 'entries',
	        value: function entries() {
	            throw new BaseException$6('"entries" method is not implemented on Headers class');
	        }
	    }], [{
	        key: 'fromResponseHeaderString',
	        value: function fromResponseHeaderString(headersString) {
	            return headersString.trim().split('\n').map(function (val) {
	                return val.split(':');
	            }).map(function (_ref) {
	                var _ref2 = toArray(_ref);

	                var key = _ref2[0];

	                var parts = _ref2.slice(1);

	                return [key.trim(), parts.join(':').trim()];
	            }).reduce(function (headers, _ref3) {
	                var _ref4 = slicedToArray(_ref3, 2);

	                var key = _ref4[0];
	                var value = _ref4[1];
	                return !headers.set(key, value) && headers;
	            }, new Headers());
	        }
	    }]);
	    return Headers;
	}();

	/**
	 * Creates a response options object to be optionally provided when instantiating a
	 * {@link Response}.
	 *
	 * This class is based on the `ResponseInit` description in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#responseinit).
	 *
	 * All values are null by default. Typical defaults can be found in the
	 * {@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.
	 *
	 * This class may be used in tests to build {@link Response Responses} for
	 * mock responses (see {@link MockBackend}).
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))
	 *
	 * ```typescript
	 * import {ResponseOptions, Response} from '@angular/http';
	 *
	 * var options = new ResponseOptions({
	 *   body: '{"name":"Jeff"}'
	 * });
	 * var res = new Response(options);
	 *
	 * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	 * ```
	 *
	 * @experimental
	 */
	var ResponseOptions = function () {
	    function ResponseOptions() {
	        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var body = _ref.body;
	        var status = _ref.status;
	        var headers = _ref.headers;
	        var statusText = _ref.statusText;
	        var type = _ref.type;
	        var url = _ref.url;
	        classCallCheck(this, ResponseOptions);

	        this.body = isPresent$7(body) ? body : null;
	        this.status = isPresent$7(status) ? status : null;
	        this.headers = isPresent$7(headers) ? headers : null;
	        this.statusText = isPresent$7(statusText) ? statusText : null;
	        this.type = isPresent$7(type) ? type : null;
	        this.url = isPresent$7(url) ? url : null;
	    }
	    /**
	     * Creates a copy of the `ResponseOptions` instance, using the optional input as values to
	     * override
	     * existing values. This method will not change the values of the instance on which it is being
	     * called.
	     *
	     * This may be useful when sharing a base `ResponseOptions` object inside tests,
	     * where certain properties may change from test to test.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))
	     *
	     * ```typescript
	     * import {ResponseOptions, Response} from '@angular/http';
	     *
	     * var options = new ResponseOptions({
	     *   body: {name: 'Jeff'}
	     * });
	     * var res = new Response(options.merge({
	     *   url: 'https://google.com'
	     * }));
	     * console.log('options.url:', options.url); // null
	     * console.log('res.json():', res.json()); // Object {name: "Jeff"}
	     * console.log('res.url:', res.url); // https://google.com
	     * ```
	     */


	    createClass(ResponseOptions, [{
	        key: 'merge',
	        value: function merge(options) {
	            return new ResponseOptions({
	                body: isPresent$7(options) && isPresent$7(options.body) ? options.body : this.body,
	                status: isPresent$7(options) && isPresent$7(options.status) ? options.status : this.status,
	                headers: isPresent$7(options) && isPresent$7(options.headers) ? options.headers : this.headers,
	                statusText: isPresent$7(options) && isPresent$7(options.statusText) ? options.statusText : this.statusText,
	                type: isPresent$7(options) && isPresent$7(options.type) ? options.type : this.type,
	                url: isPresent$7(options) && isPresent$7(options.url) ? options.url : this.url
	            });
	        }
	    }]);
	    return ResponseOptions;
	}();
	var BaseResponseOptions = function (_ResponseOptions) {
	    inherits(BaseResponseOptions, _ResponseOptions);

	    function BaseResponseOptions() {
	        classCallCheck(this, BaseResponseOptions);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(BaseResponseOptions).call(this, { status: 200, statusText: 'Ok', type: ResponseType.Default, headers: new Headers() }));
	    }

	    return BaseResponseOptions;
	}(ResponseOptions);
	/** @nocollapse */
	BaseResponseOptions.decorators = [{ type: Injectable }];
	/** @nocollapse */
	BaseResponseOptions.ctorParameters = [];

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Abstract class from which real backends are derived.
	 *
	 * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
	 * {@link Request}.
	 *
	 * @experimental
	 */
	var ConnectionBackend = function ConnectionBackend() {
	  classCallCheck(this, ConnectionBackend);
	};
	/**
	 * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.
	 *
	 * @experimental
	 */
	var XSRFStrategy = function XSRFStrategy() {
	  classCallCheck(this, XSRFStrategy);
	};

	function normalizeMethodName(method) {
	    if (isString$7(method)) {
	        var originalMethod = method;
	        method = method.replace(/(\w)(\w*)/g, function (g0, g1, g2) {
	            return g1.toUpperCase() + g2.toLowerCase();
	        });
	        method = RequestMethod[method];
	        if (typeof method !== 'number') throw makeTypeError$6('Invalid request method. The method "' + originalMethod + '" is not supported.');
	    }
	    return method;
	}
	var isSuccess = function isSuccess(status) {
	    return status >= 200 && status < 300;
	};
	function getResponseURL(xhr) {
	    if ('responseURL' in xhr) {
	        return xhr.responseURL;
	    }
	    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
	        return xhr.getResponseHeader('X-Request-URL');
	    }
	    return;
	}

	/**
	 * Creates `Response` instances from provided values.
	 *
	 * Though this object isn't
	 * usually instantiated by end-users, it is the primary object interacted with when it comes time to
	 * add data to a view.
	 *
	 * ### Example
	 *
	 * ```
	 * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
	 * ```
	 *
	 * The Response's interface is inspired by the Response constructor defined in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
	 * can be accessed many times. There are other differences in the implementation, but this is the
	 * most significant.
	 *
	 * @experimental
	 */
	var Response = function () {
	    function Response(responseOptions) {
	        classCallCheck(this, Response);

	        this._body = responseOptions.body;
	        this.status = responseOptions.status;
	        this.ok = this.status >= 200 && this.status <= 299;
	        this.statusText = responseOptions.statusText;
	        this.headers = responseOptions.headers;
	        this.type = responseOptions.type;
	        this.url = responseOptions.url;
	    }
	    /**
	     * Not yet implemented
	     */
	    // TODO: Blob return type


	    createClass(Response, [{
	        key: 'blob',
	        value: function blob() {
	            throw new BaseException$6('"blob()" method not implemented on Response superclass');
	        }
	        /**
	         * Attempts to return body as parsed `JSON` object, or raises an exception.
	         */

	    }, {
	        key: 'json',
	        value: function json() {
	            var jsonResponse;
	            if (isJsObject$6(this._body)) {
	                jsonResponse = this._body;
	            } else if (isString$7(this._body)) {
	                jsonResponse = Json$6.parse(this._body);
	            }
	            return jsonResponse;
	        }
	        /**
	         * Returns the body as a string, presuming `toString()` can be called on the response body.
	         */

	    }, {
	        key: 'text',
	        value: function text() {
	            return this._body.toString();
	        }
	        /**
	         * Not yet implemented
	         */
	        // TODO: ArrayBuffer return type

	    }, {
	        key: 'arrayBuffer',
	        value: function arrayBuffer() {
	            throw new BaseException$6('"arrayBuffer()" method not implemented on Response superclass');
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            return 'Response with status: ' + this.status + ' ' + this.statusText + ' for URL: ' + this.url;
	        }
	    }]);
	    return Response;
	}();

	var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
	var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
	/**
	 * Abstract base class for an in-flight JSONP request.
	 *
	 * @experimental
	 */
	var JSONPConnection = function JSONPConnection() {
	    classCallCheck(this, JSONPConnection);
	};
	var JSONPConnection_ = function (_JSONPConnection) {
	    inherits(JSONPConnection_, _JSONPConnection);

	    function JSONPConnection_(req, _dom, baseResponseOptions) {
	        classCallCheck(this, JSONPConnection_);

	        var _this = possibleConstructorReturn(this, Object.getPrototypeOf(JSONPConnection_).call(this));

	        _this._dom = _dom;
	        _this.baseResponseOptions = baseResponseOptions;
	        _this._finished = false;
	        if (req.method !== RequestMethod.Get) {
	            throw makeTypeError$6(JSONP_ERR_WRONG_METHOD);
	        }
	        _this.request = req;
	        _this.response = new Observable(function (responseObserver) {
	            _this.readyState = ReadyState.Loading;
	            var id = _this._id = _dom.nextRequestID();
	            _dom.exposeConnection(id, _this);
	            // Workaround Dart
	            // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);
	            var callback = _dom.requestCallback(_this._id);
	            var url = req.url;
	            if (url.indexOf('=JSONP_CALLBACK&') > -1) {
	                url = StringWrapper$6.replace(url, '=JSONP_CALLBACK&', '=' + callback + '&');
	            } else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
	                url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ('=' + callback);
	            }
	            var script = _this._script = _dom.build(url);
	            var onLoad = function onLoad(event) {
	                if (_this.readyState === ReadyState.Cancelled) return;
	                _this.readyState = ReadyState.Done;
	                _dom.cleanup(script);
	                if (!_this._finished) {
	                    var _responseOptions = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: ResponseType.Error, url: url });
	                    if (isPresent$7(baseResponseOptions)) {
	                        _responseOptions = baseResponseOptions.merge(_responseOptions);
	                    }
	                    responseObserver.error(new Response(_responseOptions));
	                    return;
	                }
	                var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });
	                if (isPresent$7(_this.baseResponseOptions)) {
	                    responseOptions = _this.baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.next(new Response(responseOptions));
	                responseObserver.complete();
	            };
	            var onError = function onError(error) {
	                if (_this.readyState === ReadyState.Cancelled) return;
	                _this.readyState = ReadyState.Done;
	                _dom.cleanup(script);
	                var responseOptions = new ResponseOptions({ body: error.message, type: ResponseType.Error });
	                if (isPresent$7(baseResponseOptions)) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.error(new Response(responseOptions));
	            };
	            script.addEventListener('load', onLoad);
	            script.addEventListener('error', onError);
	            _dom.send(script);
	            return function () {
	                _this.readyState = ReadyState.Cancelled;
	                script.removeEventListener('load', onLoad);
	                script.removeEventListener('error', onError);
	                if (isPresent$7(script)) {
	                    _this._dom.cleanup(script);
	                }
	            };
	        });
	        return _this;
	    }

	    createClass(JSONPConnection_, [{
	        key: 'finished',
	        value: function finished(data) {
	            // Don't leak connections
	            this._finished = true;
	            this._dom.removeConnection(this._id);
	            if (this.readyState === ReadyState.Cancelled) return;
	            this._responseData = data;
	        }
	    }]);
	    return JSONPConnection_;
	}(JSONPConnection);
	/**
	 * A {@link ConnectionBackend} that uses the JSONP strategy of making requests.
	 *
	 * @experimental
	 */
	var JSONPBackend = function (_ConnectionBackend) {
	    inherits(JSONPBackend, _ConnectionBackend);

	    function JSONPBackend() {
	        classCallCheck(this, JSONPBackend);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(JSONPBackend).apply(this, arguments));
	    }

	    return JSONPBackend;
	}(ConnectionBackend);
	var JSONPBackend_ = function (_JSONPBackend) {
	    inherits(JSONPBackend_, _JSONPBackend);

	    function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
	        classCallCheck(this, JSONPBackend_);

	        var _this3 = possibleConstructorReturn(this, Object.getPrototypeOf(JSONPBackend_).call(this));

	        _this3._browserJSONP = _browserJSONP;
	        _this3._baseResponseOptions = _baseResponseOptions;
	        return _this3;
	    }

	    createClass(JSONPBackend_, [{
	        key: 'createConnection',
	        value: function createConnection(request) {
	            return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
	        }
	    }]);
	    return JSONPBackend_;
	}(JSONPBackend);
	/** @nocollapse */
	JSONPBackend_.decorators = [{ type: Injectable }];
	/** @nocollapse */
	JSONPBackend_.ctorParameters = [{ type: BrowserJsonp }, { type: ResponseOptions }];

	var XSSI_PREFIX = /^\)\]\}',?\n/;
	/**
	 * Creates connections using `XMLHttpRequest`. Given a fully-qualified
	 * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
	 * request.
	 *
	 * This class would typically not be created or interacted with directly inside applications, though
	 * the {@link MockConnection} may be interacted with in tests.
	 *
	 * @experimental
	 */
	var XHRConnection = function () {
	    function XHRConnection(req, browserXHR, baseResponseOptions) {
	        var _this = this;

	        classCallCheck(this, XHRConnection);

	        this.request = req;
	        this.response = new Observable(function (responseObserver) {
	            var _xhr = browserXHR.build();
	            _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);
	            if (isPresent$7(req.withCredentials)) {
	                _xhr.withCredentials = req.withCredentials;
	            }
	            // load event handler
	            var onLoad = function onLoad() {
	                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	                // response/responseType properties were introduced in XHR Level2 spec (supported by
	                // IE10)
	                var body = isPresent$7(_xhr.response) ? _xhr.response : _xhr.responseText;
	                // Implicitly strip a potential XSSI prefix.
	                if (isString$7(body)) body = body.replace(XSSI_PREFIX, '');
	                var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
	                var url = getResponseURL(_xhr);
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status = _xhr.status === 1223 ? 204 : _xhr.status;
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status === 0) {
	                    status = body ? 200 : 0;
	                }
	                var statusText = _xhr.statusText || 'OK';
	                var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });
	                if (isPresent$7(baseResponseOptions)) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                var response = new Response(responseOptions);
	                response.ok = isSuccess(status);
	                if (response.ok) {
	                    responseObserver.next(response);
	                    // TODO(gdi2290): defer complete if array buffer until done
	                    responseObserver.complete();
	                    return;
	                }
	                responseObserver.error(response);
	            };
	            // error event handler
	            var onError = function onError(err) {
	                var responseOptions = new ResponseOptions({
	                    body: err,
	                    type: ResponseType.Error,
	                    status: _xhr.status,
	                    statusText: _xhr.statusText
	                });
	                if (isPresent$7(baseResponseOptions)) {
	                    responseOptions = baseResponseOptions.merge(responseOptions);
	                }
	                responseObserver.error(new Response(responseOptions));
	            };
	            _this.setDetectedContentType(req, _xhr);
	            if (isPresent$7(req.headers)) {
	                req.headers.forEach(function (values, name) {
	                    return _xhr.setRequestHeader(name, values.join(','));
	                });
	            }
	            _xhr.addEventListener('load', onLoad);
	            _xhr.addEventListener('error', onError);
	            _xhr.send(_this.request.getBody());
	            return function () {
	                _xhr.removeEventListener('load', onLoad);
	                _xhr.removeEventListener('error', onError);
	                _xhr.abort();
	            };
	        });
	    }

	    createClass(XHRConnection, [{
	        key: 'setDetectedContentType',
	        value: function setDetectedContentType(req /** TODO #9100 */, _xhr /** TODO #9100 */) {
	            // Skip if a custom Content-Type header is provided
	            if (isPresent$7(req.headers) && isPresent$7(req.headers.get('Content-Type'))) {
	                return;
	            }
	            // Set the detected content type
	            switch (req.contentType) {
	                case ContentType.NONE:
	                    break;
	                case ContentType.JSON:
	                    _xhr.setRequestHeader('Content-Type', 'application/json');
	                    break;
	                case ContentType.FORM:
	                    _xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');
	                    break;
	                case ContentType.TEXT:
	                    _xhr.setRequestHeader('Content-Type', 'text/plain');
	                    break;
	                case ContentType.BLOB:
	                    var blob = req.blob();
	                    if (blob.type) {
	                        _xhr.setRequestHeader('Content-Type', blob.type);
	                    }
	                    break;
	            }
	        }
	    }]);
	    return XHRConnection;
	}();
	/**
	 * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application
	 * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF) for more
	 * information on XSRF.
	 *
	 * Applications can configure custom cookie and header names by binding an instance of this class
	 * with different `cookieName` and `headerName` values. See the main HTTP documentation for more
	 * details.
	 *
	 * @experimental
	 */
	var CookieXSRFStrategy = function () {
	    function CookieXSRFStrategy() {
	        var _cookieName = arguments.length <= 0 || arguments[0] === undefined ? 'XSRF-TOKEN' : arguments[0];

	        var _headerName = arguments.length <= 1 || arguments[1] === undefined ? 'X-XSRF-TOKEN' : arguments[1];

	        classCallCheck(this, CookieXSRFStrategy);

	        this._cookieName = _cookieName;
	        this._headerName = _headerName;
	    }

	    createClass(CookieXSRFStrategy, [{
	        key: 'configureRequest',
	        value: function configureRequest(req) {
	            var xsrfToken = __platform_browser_private__.getDOM().getCookie(this._cookieName);
	            if (xsrfToken && !req.headers.has(this._headerName)) {
	                req.headers.set(this._headerName, xsrfToken);
	            }
	        }
	    }]);
	    return CookieXSRFStrategy;
	}();
	var XHRBackend = function () {
	    function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {
	        classCallCheck(this, XHRBackend);

	        this._browserXHR = _browserXHR;
	        this._baseResponseOptions = _baseResponseOptions;
	        this._xsrfStrategy = _xsrfStrategy;
	    }

	    createClass(XHRBackend, [{
	        key: 'createConnection',
	        value: function createConnection(request) {
	            this._xsrfStrategy.configureRequest(request);
	            return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
	        }
	    }]);
	    return XHRBackend;
	}();
	/** @nocollapse */
	XHRBackend.decorators = [{ type: Injectable }];
	/** @nocollapse */
	XHRBackend.ctorParameters = [{ type: BrowserXhr }, { type: ResponseOptions }, { type: XSRFStrategy }];

	function paramParser() {
	    var rawParams = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	    var map = new Map$7();
	    if (rawParams.length > 0) {
	        var params = rawParams.split('&');
	        params.forEach(function (param) {
	            var split = param.split('=', 2);
	            var key = split[0];
	            var val = split[1];
	            var list = isPresent$7(map.get(key)) ? map.get(key) : [];
	            list.push(val);
	            map.set(key, list);
	        });
	    }
	    return map;
	}
	/**
	 * @experimental
	 **/
	var QueryEncoder = function () {
	    function QueryEncoder() {
	        classCallCheck(this, QueryEncoder);
	    }

	    createClass(QueryEncoder, [{
	        key: 'encodeKey',
	        value: function encodeKey(k) {
	            return standardEncoding(k);
	        }
	    }, {
	        key: 'encodeValue',
	        value: function encodeValue(v) {
	            return standardEncoding(v);
	        }
	    }]);
	    return QueryEncoder;
	}();
	function standardEncoding(v) {
	    return encodeURIComponent(v).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/gi, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%2B/gi, '+').replace(/%3D/gi, ';').replace(/%3F/gi, '?').replace(/%2F/gi, '/');
	}
	/**
	 * Map-like representation of url search parameters, based on
	 * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,
	 * with several extensions for merging URLSearchParams objects:
	 *   - setAll()
	 *   - appendAll()
	 *   - replaceAll()
	 *
	 * This class accepts an optional second parameter of ${@link QueryEncoder},
	 * which is used to serialize parameters before making a request. By default,
	 * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,
	 * and then un-encodes certain characters that are allowed to be part of the query
	 * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.
	 *
	 * These are the characters that are not encoded: `! $ \' ( ) * + , ; A 9 - . _ ~ ? /`
	 *
	 * If the set of allowed query characters is not acceptable for a particular backend,
	 * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.
	 *
	 * ```
	 * import {URLSearchParams, QueryEncoder} from '@angular/http';
	 * class MyQueryEncoder extends QueryEncoder {
	 *   encodeKey(k: string): string {
	 *     return myEncodingFunction(k);
	 *   }
	 *
	 *   encodeValue(v: string): string {
	 *     return myEncodingFunction(v);
	 *   }
	 * }
	 *
	 * let params = new URLSearchParams('', new MyQueryEncoder());
	 * ```
	 * @experimental
	 */
	var URLSearchParams = function () {
	    function URLSearchParams() {
	        var rawParams = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
	        var queryEncoder = arguments.length <= 1 || arguments[1] === undefined ? new QueryEncoder() : arguments[1];
	        classCallCheck(this, URLSearchParams);

	        this.rawParams = rawParams;
	        this.queryEncoder = queryEncoder;
	        this.paramsMap = paramParser(rawParams);
	    }

	    createClass(URLSearchParams, [{
	        key: 'clone',
	        value: function clone() {
	            var clone = new URLSearchParams();
	            clone.appendAll(this);
	            return clone;
	        }
	    }, {
	        key: 'has',
	        value: function has(param) {
	            return this.paramsMap.has(param);
	        }
	    }, {
	        key: 'get',
	        value: function get(param) {
	            var storedParam = this.paramsMap.get(param);
	            if (isListLikeIterable$6(storedParam)) {
	                return ListWrapper$6.first(storedParam);
	            } else {
	                return null;
	            }
	        }
	    }, {
	        key: 'getAll',
	        value: function getAll(param) {
	            var mapParam = this.paramsMap.get(param);
	            return isPresent$7(mapParam) ? mapParam : [];
	        }
	    }, {
	        key: 'set',
	        value: function set(param, val) {
	            var mapParam = this.paramsMap.get(param);
	            var list = isPresent$7(mapParam) ? mapParam : [];
	            ListWrapper$6.clear(list);
	            list.push(val);
	            this.paramsMap.set(param, list);
	        }
	        // A merge operation
	        // For each name-values pair in `searchParams`, perform `set(name, values[0])`
	        //
	        // E.g: "a=[1,2,3], c=[8]" + "a=[4,5,6], b=[7]" = "a=[4], c=[8], b=[7]"
	        //
	        // TODO(@caitp): document this better

	    }, {
	        key: 'setAll',
	        value: function setAll(searchParams) {
	            var _this = this;

	            searchParams.paramsMap.forEach(function (value, param) {
	                var mapParam = _this.paramsMap.get(param);
	                var list = isPresent$7(mapParam) ? mapParam : [];
	                ListWrapper$6.clear(list);
	                list.push(value[0]);
	                _this.paramsMap.set(param, list);
	            });
	        }
	    }, {
	        key: 'append',
	        value: function append(param, val) {
	            var mapParam = this.paramsMap.get(param);
	            var list = isPresent$7(mapParam) ? mapParam : [];
	            list.push(val);
	            this.paramsMap.set(param, list);
	        }
	        // A merge operation
	        // For each name-values pair in `searchParams`, perform `append(name, value)`
	        // for each value in `values`.
	        //
	        // E.g: "a=[1,2], c=[8]" + "a=[3,4], b=[7]" = "a=[1,2,3,4], c=[8], b=[7]"
	        //
	        // TODO(@caitp): document this better

	    }, {
	        key: 'appendAll',
	        value: function appendAll(searchParams) {
	            var _this2 = this;

	            searchParams.paramsMap.forEach(function (value, param) {
	                var mapParam = _this2.paramsMap.get(param);
	                var list = isPresent$7(mapParam) ? mapParam : [];
	                for (var i = 0; i < value.length; ++i) {
	                    list.push(value[i]);
	                }
	                _this2.paramsMap.set(param, list);
	            });
	        }
	        // A merge operation
	        // For each name-values pair in `searchParams`, perform `delete(name)`,
	        // followed by `set(name, values)`
	        //
	        // E.g: "a=[1,2,3], c=[8]" + "a=[4,5,6], b=[7]" = "a=[4,5,6], c=[8], b=[7]"
	        //
	        // TODO(@caitp): document this better

	    }, {
	        key: 'replaceAll',
	        value: function replaceAll(searchParams) {
	            var _this3 = this;

	            searchParams.paramsMap.forEach(function (value, param) {
	                var mapParam = _this3.paramsMap.get(param);
	                var list = isPresent$7(mapParam) ? mapParam : [];
	                ListWrapper$6.clear(list);
	                for (var i = 0; i < value.length; ++i) {
	                    list.push(value[i]);
	                }
	                _this3.paramsMap.set(param, list);
	            });
	        }
	    }, {
	        key: 'toString',
	        value: function toString() {
	            var _this4 = this;

	            var paramsList = [];
	            this.paramsMap.forEach(function (values, k) {
	                values.forEach(function (v) {
	                    return paramsList.push(_this4.queryEncoder.encodeKey(k) + '=' + _this4.queryEncoder.encodeValue(v));
	                });
	            });
	            return paramsList.join('&');
	        }
	    }, {
	        key: 'delete',
	        value: function _delete(param) {
	            this.paramsMap.delete(param);
	        }
	    }]);
	    return URLSearchParams;
	}();

	/**
	 * Creates a request options object to be optionally provided when instantiating a
	 * {@link Request}.
	 *
	 * This class is based on the `RequestInit` description in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#requestinit).
	 *
	 * All values are null by default. Typical defaults can be found in the {@link BaseRequestOptions}
	 * class, which sub-classes `RequestOptions`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7Wvi3lfLq41aQPKlxB4O?p=preview))
	 *
	 * ```typescript
	 * import {RequestOptions, Request, RequestMethod} from '@angular/http';
	 *
	 * var options = new RequestOptions({
	 *   method: RequestMethod.Post,
	 *   url: 'https://google.com'
	 * });
	 * var req = new Request(options);
	 * console.log('req.method:', RequestMethod[req.method]); // Post
	 * console.log('options.url:', options.url); // https://google.com
	 * ```
	 *
	 * @experimental
	 */
	var RequestOptions = function () {
	    function RequestOptions() {
	        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var method = _ref.method;
	        var headers = _ref.headers;
	        var body = _ref.body;
	        var url = _ref.url;
	        var search = _ref.search;
	        var withCredentials = _ref.withCredentials;
	        classCallCheck(this, RequestOptions);

	        this.method = isPresent$7(method) ? normalizeMethodName(method) : null;
	        this.headers = isPresent$7(headers) ? headers : null;
	        this.body = isPresent$7(body) ? body : null;
	        this.url = isPresent$7(url) ? url : null;
	        this.search = isPresent$7(search) ? isString$7(search) ? new URLSearchParams(search) : search : null;
	        this.withCredentials = isPresent$7(withCredentials) ? withCredentials : null;
	    }
	    /**
	     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
	     * existing values. This method will not change the values of the instance on which it is being
	     * called.
	     *
	     * Note that `headers` and `search` will override existing values completely if present in
	     * the `options` object. If these values should be merged, it should be done prior to calling
	     * `merge` on the `RequestOptions` instance.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/6w8XA8YTkDRcPYpdB9dk?p=preview))
	     *
	     * ```typescript
	     * import {RequestOptions, Request, RequestMethod} from '@angular/http';
	     *
	     * var options = new RequestOptions({
	     *   method: RequestMethod.Post
	     * });
	     * var req = new Request(options.merge({
	     *   url: 'https://google.com'
	     * }));
	     * console.log('req.method:', RequestMethod[req.method]); // Post
	     * console.log('options.url:', options.url); // null
	     * console.log('req.url:', req.url); // https://google.com
	     * ```
	     */


	    createClass(RequestOptions, [{
	        key: 'merge',
	        value: function merge(options) {
	            return new RequestOptions({
	                method: isPresent$7(options) && isPresent$7(options.method) ? options.method : this.method,
	                headers: isPresent$7(options) && isPresent$7(options.headers) ? options.headers : this.headers,
	                body: isPresent$7(options) && isPresent$7(options.body) ? options.body : this.body,
	                url: isPresent$7(options) && isPresent$7(options.url) ? options.url : this.url,
	                search: isPresent$7(options) && isPresent$7(options.search) ? isString$7(options.search) ? new URLSearchParams(options.search) : options.search.clone() : this.search,
	                withCredentials: isPresent$7(options) && isPresent$7(options.withCredentials) ? options.withCredentials : this.withCredentials
	            });
	        }
	    }]);
	    return RequestOptions;
	}();
	var BaseRequestOptions = function (_RequestOptions) {
	    inherits(BaseRequestOptions, _RequestOptions);

	    function BaseRequestOptions() {
	        classCallCheck(this, BaseRequestOptions);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(BaseRequestOptions).call(this, { method: RequestMethod.Get, headers: new Headers() }));
	    }

	    return BaseRequestOptions;
	}(RequestOptions);
	/** @nocollapse */
	BaseRequestOptions.decorators = [{ type: Injectable }];
	/** @nocollapse */
	BaseRequestOptions.ctorParameters = [];

	// TODO(jeffbcross): properly implement body accessors
	/**
	 * Creates `Request` instances from provided values.
	 *
	 * The Request's interface is inspired by the Request constructor defined in the [Fetch
	 * Spec](https://fetch.spec.whatwg.org/#request-class),
	 * but is considered a static value whose body can be accessed many times. There are other
	 * differences in the implementation, but this is the most significant.
	 *
	 * `Request` instances are typically created by higher-level classes, like {@link Http} and
	 * {@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
	 * One such example is when creating services that wrap higher-level services, like {@link Http},
	 * where it may be useful to generate a `Request` with arbitrary headers and search params.
	 *
	 * ```typescript
	 * import {Injectable, Injector} from '@angular/core';
	 * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '@angular/http';
	 *
	 * @Injectable()
	 * class AutoAuthenticator {
	 *   constructor(public http:Http) {}
	 *   request(url:string) {
	 *     return this.http.request(new Request({
	 *       method: RequestMethod.Get,
	 *       url: url,
	 *       search: 'password=123'
	 *     }));
	 *   }
	 * }
	 *
	 * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
	 * var authenticator = injector.get(AutoAuthenticator);
	 * authenticator.request('people.json').subscribe(res => {
	 *   //URL should have included '?password=123'
	 *   console.log('people', res.json());
	 * });
	 * ```
	 *
	 * @experimental
	 */
	var Request = function () {
	    function Request(requestOptions) {
	        classCallCheck(this, Request);

	        // TODO: assert that url is present
	        var url = requestOptions.url;
	        this.url = requestOptions.url;
	        if (isPresent$7(requestOptions.search)) {
	            var search = requestOptions.search.toString();
	            if (search.length > 0) {
	                var prefix = '?';
	                if (StringWrapper$6.contains(this.url, '?')) {
	                    prefix = this.url[this.url.length - 1] == '&' ? '' : '&';
	                }
	                // TODO: just delete search-query-looking string in url?
	                this.url = url + prefix + search;
	            }
	        }
	        this._body = requestOptions.body;
	        this.contentType = this.detectContentType();
	        this.method = normalizeMethodName(requestOptions.method);
	        // TODO(jeffbcross): implement behavior
	        // Defaults to 'omit', consistent with browser
	        // TODO(jeffbcross): implement behavior
	        this.headers = new Headers(requestOptions.headers);
	        this.withCredentials = requestOptions.withCredentials;
	    }
	    /**
	     * Returns the request's body as string, assuming that body exists. If body is undefined, return
	     * empty
	     * string.
	     */


	    createClass(Request, [{
	        key: 'text',
	        value: function text() {
	            return isPresent$7(this._body) ? this._body.toString() : '';
	        }
	        /**
	         * Returns the request's body as JSON string, assuming that body exists. If body is undefined,
	         * return
	         * empty
	         * string.
	         */

	    }, {
	        key: 'json',
	        value: function json() {
	            return isPresent$7(this._body) ? JSON.stringify(this._body) : '';
	        }
	        /**
	         * Returns the request's body as array buffer, assuming that body exists. If body is undefined,
	         * return
	         * null.
	         */

	    }, {
	        key: 'arrayBuffer',
	        value: function arrayBuffer() {
	            if (this._body instanceof ArrayBuffer) return this._body;
	            throw 'The request body isn\'t an array buffer';
	        }
	        /**
	         * Returns the request's body as blob, assuming that body exists. If body is undefined, return
	         * null.
	         */

	    }, {
	        key: 'blob',
	        value: function blob() {
	            if (this._body instanceof Blob) return this._body;
	            if (this._body instanceof ArrayBuffer) return new Blob([this._body]);
	            throw 'The request body isn\'t either a blob or an array buffer';
	        }
	        /**
	         * Returns the content type of request's body based on its type.
	         */

	    }, {
	        key: 'detectContentType',
	        value: function detectContentType() {
	            if (this._body == null) {
	                return ContentType.NONE;
	            } else if (this._body instanceof URLSearchParams) {
	                return ContentType.FORM;
	            } else if (this._body instanceof FormData) {
	                return ContentType.FORM_DATA;
	            } else if (this._body instanceof Blob) {
	                return ContentType.BLOB;
	            } else if (this._body instanceof ArrayBuffer) {
	                return ContentType.ARRAY_BUFFER;
	            } else if (this._body && _typeof(this._body) == 'object') {
	                return ContentType.JSON;
	            } else {
	                return ContentType.TEXT;
	            }
	        }
	        /**
	         * Returns the request's body according to its type. If body is undefined, return
	         * null.
	         */

	    }, {
	        key: 'getBody',
	        value: function getBody() {
	            switch (this.contentType) {
	                case ContentType.JSON:
	                    return this.json();
	                case ContentType.FORM:
	                    return this.text();
	                case ContentType.FORM_DATA:
	                    return this._body;
	                case ContentType.TEXT:
	                    return this.text();
	                case ContentType.BLOB:
	                    return this.blob();
	                case ContentType.ARRAY_BUFFER:
	                    return this.arrayBuffer();
	                default:
	                    return null;
	            }
	        }
	    }]);
	    return Request;
	}();
	var noop$7 = function noop() {};
	var w = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' ? window : noop$7;
	var FormData = w['FormData'] || noop$7;
	var Blob = w['Blob'] || noop$7;
	var ArrayBuffer = w['ArrayBuffer'] || noop$7;

	function httpRequest(backend, request) {
	    return backend.createConnection(request).response;
	}
	function mergeOptions(defaultOpts, providedOpts, method, url) {
	    var newOptions = defaultOpts;
	    if (isPresent$7(providedOpts)) {
	        // Hack so Dart can used named parameters
	        return newOptions.merge(new RequestOptions({
	            method: providedOpts.method || method,
	            url: providedOpts.url || url,
	            search: providedOpts.search,
	            headers: providedOpts.headers,
	            body: providedOpts.body,
	            withCredentials: providedOpts.withCredentials
	        }));
	    }
	    if (isPresent$7(method)) {
	        return newOptions.merge(new RequestOptions({ method: method, url: url }));
	    } else {
	        return newOptions.merge(new RequestOptions({ url: url }));
	    }
	}
	var Http = function () {
	    function Http(_backend, _defaultOptions) {
	        classCallCheck(this, Http);

	        this._backend = _backend;
	        this._defaultOptions = _defaultOptions;
	    }
	    /**
	     * Performs any type of http request. First argument is required, and can either be a url or
	     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
	     * object can be provided as the 2nd argument. The options object will be merged with the values
	     * of {@link BaseRequestOptions} before performing the request.
	     */


	    createClass(Http, [{
	        key: 'request',
	        value: function request(url, options) {
	            var responseObservable;
	            if (isString$7(url)) {
	                responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));
	            } else if (url instanceof Request) {
	                responseObservable = httpRequest(this._backend, url);
	            } else {
	                throw makeTypeError$6('First argument must be a url string or Request instance.');
	            }
	            return responseObservable;
	        }
	        /**
	         * Performs a request with `get` http method.
	         */

	    }, {
	        key: 'get',
	        value: function get(url, options) {
	            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));
	        }
	        /**
	         * Performs a request with `post` http method.
	         */

	    }, {
	        key: 'post',
	        value: function post(url, body, options) {
	            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));
	        }
	        /**
	         * Performs a request with `put` http method.
	         */

	    }, {
	        key: 'put',
	        value: function put(url, body, options) {
	            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));
	        }
	        /**
	         * Performs a request with `delete` http method.
	         */

	    }, {
	        key: 'delete',
	        value: function _delete(url, options) {
	            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));
	        }
	        /**
	         * Performs a request with `patch` http method.
	         */

	    }, {
	        key: 'patch',
	        value: function patch(url, body, options) {
	            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));
	        }
	        /**
	         * Performs a request with `head` http method.
	         */

	    }, {
	        key: 'head',
	        value: function head(url, options) {
	            return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));
	        }
	    }]);
	    return Http;
	}();
	/** @nocollapse */
	Http.decorators = [{ type: Injectable }];
	/** @nocollapse */
	Http.ctorParameters = [{ type: ConnectionBackend }, { type: RequestOptions }];
	var Jsonp = function (_Http) {
	    inherits(Jsonp, _Http);

	    function Jsonp(backend, defaultOptions) {
	        classCallCheck(this, Jsonp);
	        return possibleConstructorReturn(this, Object.getPrototypeOf(Jsonp).call(this, backend, defaultOptions));
	    }
	    /**
	     * Performs any type of http request. First argument is required, and can either be a url or
	     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
	     * object can be provided as the 2nd argument. The options object will be merged with the values
	     * of {@link BaseRequestOptions} before performing the request.
	     *
	     * @security Regular XHR is the safest alternative to JSONP for most applications, and is
	     * supported by all current browsers. Because JSONP creates a `<script>` element with
	     * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted
	     * source could expose your application to XSS risks. Data exposed by JSONP may also be
	     * readable by malicious third-party websites. In addition, JSONP introduces potential risk for
	     * future security issues (e.g. content sniffing).  For more detail, see the
	     * [Security Guide](http://g.co/ng/security).
	     */


	    createClass(Jsonp, [{
	        key: 'request',
	        value: function request(url, options) {
	            var responseObservable;
	            if (isString$7(url)) {
	                url = new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url));
	            }
	            if (url instanceof Request) {
	                if (url.method !== RequestMethod.Get) {
	                    makeTypeError$6('JSONP requests must use GET request method.');
	                }
	                responseObservable = httpRequest(this._backend, url);
	            } else {
	                throw makeTypeError$6('First argument must be a url string or Request instance.');
	            }
	            return responseObservable;
	        }
	    }]);
	    return Jsonp;
	}(Http);
	/** @nocollapse */
	Jsonp.decorators = [{ type: Injectable }];
	/** @nocollapse */
	Jsonp.ctorParameters = [{ type: ConnectionBackend }, { type: RequestOptions }];

	/**
	 * Provides a basic set of injectables to use the {@link Http} service in any application.
	 *
	 * The `HTTP_PROVIDERS` should be included either in a component's injector,
	 * or in the root injector when bootstrapping an application.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/snj7Nv?p=preview))
	 *
	 * ```
	 * import {Component} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {NgFor} from '@angular/common';
	 * import {HTTP_PROVIDERS, Http} from '@angular/http';
	 *
	 * @Component({
	 *   selector: 'app',
	 *   providers: [HTTP_PROVIDERS],
	 *   template: `
	 *     <div>
	 *       <h1>People</h1>
	 *       <ul>
	 *         <li *ngFor="let person of people">
	 *           {{person.name}}
	 *         </li>
	 *       </ul>
	 *     </div>
	 *   `,
	 *   directives: [NgFor]
	 * })
	 * export class App {
	 *   people: Object[];
	 *   constructor(http:Http) {
	 *     http.get('people.json').subscribe(res => {
	 *       this.people = res.json();
	 *     });
	 *   }
	 *   active:boolean = false;
	 *   toggleActiveState() {
	 *     this.active = !this.active;
	 *   }
	 * }
	 *
	 * bootstrap(App)
	 *   .catch(err => console.error(err));
	 * ```
	 *
	 * The primary public API included in `HTTP_PROVIDERS` is the {@link Http} class.
	 * However, other providers required by `Http` are included,
	 * which may be beneficial to override in certain cases.
	 *
	 * The providers included in `HTTP_PROVIDERS` include:
	 *  * {@link Http}
	 *  * {@link XHRBackend}
	 *  * {@link XSRFStrategy} - Bound to {@link CookieXSRFStrategy} class (see below)
	 *  * `BrowserXHR` - Private factory to create `XMLHttpRequest` instances
	 *  * {@link RequestOptions} - Bound to {@link BaseRequestOptions} class
	 *  * {@link ResponseOptions} - Bound to {@link BaseResponseOptions} class
	 *
	 * There may be cases where it makes sense to extend the base request options,
	 * such as to add a search string to be appended to all URLs.
	 * To accomplish this, a new provider for {@link RequestOptions} should
	 * be added in the same injector as `HTTP_PROVIDERS`.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/aCMEXi?p=preview))
	 *
	 * ```
	 * import {provide} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {HTTP_PROVIDERS, BaseRequestOptions, RequestOptions} from '@angular/http';
	 *
	 * class MyOptions extends BaseRequestOptions {
	 *   search: string = 'coreTeam=true';
	 * }
	 *
	 * bootstrap(App, [HTTP_PROVIDERS, {provide: RequestOptions, useClass: MyOptions}])
	 *   .catch(err => console.error(err));
	 * ```
	 *
	 * Likewise, to use a mock backend for unit tests, the {@link XHRBackend}
	 * provider should be bound to {@link MockBackend}.
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/7LWALD?p=preview))
	 *
	 * ```
	 * import {provide} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {HTTP_PROVIDERS, Http, Response, XHRBackend} from '@angular/http';
	 * import {MockBackend} from '@angular/http/testing';
	 *
	 * var people = [{name: 'Jeff'}, {name: 'Tobias'}];
	 *
	 * var injector = Injector.resolveAndCreate([
	 *   HTTP_PROVIDERS,
	 *   MockBackend,
	 *   {provide: XHRBackend, useExisting: MockBackend}
	 * ]);
	 * var http = injector.get(Http);
	 * var backend = injector.get(MockBackend);
	 *
	 * // Listen for any new requests
	 * backend.connections.observer({
	 *   next: connection => {
	 *     var response = new Response({body: people});
	 *     setTimeout(() => {
	 *       // Send a response to the request
	 *       connection.mockRespond(response);
	 *     });
	 *   }
	 * });
	 *
	 * http.get('people.json').observer({
	 *   next: res => {
	 *     // Response came from mock backend
	 *     console.log('first person', res.json()[0].name);
	 *   }
	 * });
	 * ```
	 *
	 * `XSRFStrategy` allows customizing how the application protects itself against Cross Site Request
	 * Forgery (XSRF) attacks. By default, Angular will look for a cookie called `'XSRF-TOKEN'`, and set
	 * an HTTP request header called `'X-XSRF-TOKEN'` with the value of the cookie on each request,
	 * allowing the server side to validate that the request comes from its own front end.
	 *
	 * Applications can override the names used by configuring a different `XSRFStrategy` instance. Most
	 * commonly, applications will configure a `CookieXSRFStrategy` with different cookie or header
	 * names, but if needed, they can supply a completely custom implementation.
	 *
	 * See the security documentation for more information.
	 *
	 * ### Example
	 *
	 * ```
	 * import {provide} from '@angular/core';
	 * import {bootstrap} from '@angular/platform-browser/browser';
	 * import {HTTP_PROVIDERS, XSRFStrategy, CookieXSRFStrategy} from '@angular/http';
	 *
	 * bootstrap(
	 *     App,
	 *     [HTTP_PROVIDERS, {provide: XSRFStrategy,
	 *         useValue: new CookieXSRFStrategy('MY-XSRF-COOKIE-NAME', 'X-MY-XSRF-HEADER-NAME')}])
	 *   .catch(err => console.error(err));
	 * ```
	 *
	 * @experimental
	 */
	var HTTP_PROVIDERS = [
	// TODO(pascal): use factory type annotations once supported in DI
	// issue: https://github.com/angular/angular/issues/3183
	{ provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] }, BrowserXhr, { provide: RequestOptions, useClass: BaseRequestOptions }, { provide: ResponseOptions, useClass: BaseResponseOptions }, XHRBackend, { provide: XSRFStrategy, useValue: new CookieXSRFStrategy() }];
	/**
	 * @experimental
	 */
	function httpFactory(xhrBackend, requestOptions) {
	  return new Http(xhrBackend, requestOptions);
	}

	var DISABLE_SCROLL = 'disable-scroll';
	var Backdrop = (function () {
	    function Backdrop(elementRef) {
	        this.elementRef = elementRef;
	        this.pushed = false;
	        this.disableScroll = true;
	    }
	    Backdrop.push = function () {
	        if (this.nuBackDrops === 0) {
	            nativeRaf(function () {
	                console.debug('adding .disable-scroll to body');
	                document.body.classList.add(DISABLE_SCROLL);
	            });
	        }
	        this.nuBackDrops++;
	    };
	    Backdrop.pop = function () {
	        if (this.nuBackDrops > 0) {
	            this.nuBackDrops--;
	            if (this.nuBackDrops === 0) {
	                nativeRaf(function () {
	                    console.debug('removing .disable-scroll from body');
	                    document.body.classList.remove(DISABLE_SCROLL);
	                });
	            }
	        }
	    };
	    Backdrop.prototype.ngOnInit = function () {
	        if (isTrueProperty(this.disableScroll)) {
	            Backdrop.push();
	            this.pushed = true;
	        }
	    };
	    Backdrop.prototype.ngOnDestroy = function () {
	        if (this.pushed) {
	            Backdrop.pop();
	            this.pushed = false;
	        }
	    };
	    Backdrop.nuBackDrops = 0;
	    /** @nocollapse */
	    Backdrop.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-backdrop',
	                    host: {
	                        'role': 'presentation',
	                        'tappable': '',
	                        'disable-activated': ''
	                    },
	                },] },
	    ];
	    /** @nocollapse */
	    Backdrop.ctorParameters = [
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    Backdrop.propDecorators = {
	        'disableScroll': [{ type: Input },],
	    };
	    return Backdrop;
	}());

	var Icon = (function () {
	    function Icon(config, _elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._name = '';
	        this._ios = '';
	        this._md = '';
	        this._css = '';
	        this.mode = config.get('iconMode');
	    }
	    /**
	     * @private
	     */
	    Icon.prototype.ngOnDestroy = function () {
	        if (this._css) {
	            this._renderer.setElementClass(this._elementRef.nativeElement, this._css, false);
	        }
	    };
	    Object.defineProperty(Icon.prototype, "name", {
	        get: function () {
	            return this._name;
	        },
	        set: function (val) {
	            if (!(/^md-|^ios-|^logo-/.test(val))) {
	                // this does not have one of the defaults
	                // so lets auto add in the mode prefix for them
	                val = this.mode + '-' + val;
	            }
	            this._name = val;
	            this.update();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Icon.prototype, "ios", {
	        get: function () {
	            return this._ios;
	        },
	        set: function (val) {
	            this._ios = val;
	            this.update();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Icon.prototype, "md", {
	        get: function () {
	            return this._md;
	        },
	        set: function (val) {
	            this._md = val;
	            this.update();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Icon.prototype, "isActive", {
	        get: function () {
	            return (this._isActive === undefined || this._isActive === true || this._isActive === 'true');
	        },
	        set: function (val) {
	            this._isActive = val;
	            this.update();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Icon.prototype.update = function () {
	        var css = 'ion-';
	        if (this._ios && this.mode === 'ios') {
	            css += this._ios;
	        }
	        else if (this._md && this.mode === 'md') {
	            css += this._md;
	        }
	        else {
	            css += this._name;
	        }
	        if (this.mode === 'ios' && !this.isActive && css.indexOf('logo') < 0) {
	            css += '-outline';
	        }
	        if (this._css !== css) {
	            if (this._css) {
	                this._renderer.setElementClass(this._elementRef.nativeElement, this._css, false);
	            }
	            this._css = css;
	            this._renderer.setElementClass(this._elementRef.nativeElement, css, true);
	            this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-label', css.replace('ion-', '').replace('ios-', '').replace('md-', '').replace('-', ' '));
	        }
	    };
	    /**
	     * @private
	     * @param {string} add class name
	     */
	    Icon.prototype.addClass = function (className) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, className, true);
	    };
	    /** @nocollapse */
	    Icon.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-icon',
	                    host: {
	                        'role': 'img'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    Icon.ctorParameters = [
	        { type: Config, },
	        { type: ElementRef, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    Icon.propDecorators = {
	        'name': [{ type: Input },],
	        'ios': [{ type: Input },],
	        'md': [{ type: Input },],
	        'isActive': [{ type: Input },],
	    };
	    return Icon;
	}());

	var __extends$8 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ActionSheetCmp = (function () {
	    function ActionSheetCmp(_viewCtrl, _config, _elementRef, _form, params, renderer) {
	        this._viewCtrl = _viewCtrl;
	        this._config = _config;
	        this._elementRef = _elementRef;
	        this._form = _form;
	        this.d = params.data;
	        if (this.d.cssClass) {
	            renderer.setElementClass(_elementRef.nativeElement, this.d.cssClass, true);
	        }
	        this.id = (++actionSheetIds);
	        if (this.d.title) {
	            this.hdrId = 'acst-hdr-' + this.id;
	        }
	        if (this.d.subTitle) {
	            this.descId = 'acst-subhdr-' + this.id;
	        }
	    }
	    ActionSheetCmp.prototype.ionViewLoaded = function () {
	        var _this = this;
	        // normalize the data
	        var buttons = [];
	        this.d.buttons.forEach(function (button) {
	            if (typeof button === 'string') {
	                button = { text: button };
	            }
	            if (!button.cssClass) {
	                button.cssClass = '';
	            }
	            if (button.role === 'cancel') {
	                _this.d.cancelButton = button;
	            }
	            else {
	                if (button.role === 'destructive') {
	                    button.cssClass = (button.cssClass + ' ' || '') + 'action-sheet-destructive';
	                }
	                else if (button.role === 'selected') {
	                    button.cssClass = (button.cssClass + ' ' || '') + 'action-sheet-selected';
	                }
	                buttons.push(button);
	            }
	        });
	        this.d.buttons = buttons;
	    };
	    ActionSheetCmp.prototype.ionViewDidEnter = function () {
	        this._form.focusOut();
	        var focusableEle = this._elementRef.nativeElement.querySelector('button');
	        if (focusableEle) {
	            focusableEle.focus();
	        }
	        this.enabled = true;
	    };
	    ActionSheetCmp.prototype._keyUp = function (ev) {
	        if (this.enabled && this._viewCtrl.isLast()) {
	            if (ev.keyCode === Key.ESCAPE) {
	                console.debug('actionsheet, escape button');
	                this.bdClick();
	            }
	        }
	    };
	    ActionSheetCmp.prototype.click = function (button, dismissDelay) {
	        var _this = this;
	        if (!this.enabled) {
	            return;
	        }
	        var shouldDismiss = true;
	        if (button.handler) {
	            // a handler has been provided, execute it
	            if (button.handler() === false) {
	                // if the return value of the handler is false then do not dismiss
	                shouldDismiss = false;
	            }
	        }
	        if (shouldDismiss) {
	            setTimeout(function () {
	                _this.dismiss(button.role);
	            }, dismissDelay || this._config.get('pageTransitionDelay'));
	        }
	    };
	    ActionSheetCmp.prototype.bdClick = function () {
	        if (this.enabled && this.d.enableBackdropDismiss) {
	            if (this.d.cancelButton) {
	                this.click(this.d.cancelButton, 1);
	            }
	            else {
	                this.dismiss('backdrop');
	            }
	        }
	    };
	    ActionSheetCmp.prototype.dismiss = function (role) {
	        return this._viewCtrl.dismiss(null, role);
	    };
	    /** @nocollapse */
	    ActionSheetCmp.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-action-sheet',
	                    template: "\n    <ion-backdrop (click)=\"bdClick()\"></ion-backdrop>\n    <div class=\"action-sheet-wrapper\">\n      <div class=\"action-sheet-container\">\n        <div class=\"action-sheet-group\">\n          <div class=\"action-sheet-title\" id=\"{{hdrId}}\" *ngIf=\"d.title\">{{d.title}}</div>\n          <div class=\"action-sheet-sub-title\" id=\"{{descId}}\" *ngIf=\"d.subTitle\">{{d.subTitle}}</div>\n          <button category=\"action-sheet-button\" (click)=\"click(b)\" *ngFor=\"let b of d.buttons\" class=\"disable-hover\" [ngClass]=\"b.cssClass\">\n            <ion-icon [name]=\"b.icon\" *ngIf=\"b.icon\" class=\"action-sheet-icon\"></ion-icon>\n            {{b.text}}\n          </button>\n        </div>\n        <div class=\"action-sheet-group\" *ngIf=\"d.cancelButton\">\n          <button category=\"action-sheet-button\" (click)=\"click(d.cancelButton)\" class=\"action-sheet-cancel disable-hover\" [ngClass]=\"d.cancelButton.cssClass\">\n            <ion-icon [name]=\"d.cancelButton.icon\" *ngIf=\"d.cancelButton.icon\" class=\"action-sheet-icon\"></ion-icon>\n            {{d.cancelButton.text}}\n          </button>\n        </div>\n      </div>\n    </div>\n    ",
	                    directives: [Backdrop, Icon, NgClass, NgFor, NgIf],
	                    host: {
	                        'role': 'dialog',
	                        '[attr.aria-labelledby]': 'hdrId',
	                        '[attr.aria-describedby]': 'descId'
	                    },
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    ActionSheetCmp.ctorParameters = [
	        { type: ViewController, },
	        { type: Config, },
	        { type: ElementRef, },
	        { type: Form, },
	        { type: NavParams, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    ActionSheetCmp.propDecorators = {
	        '_keyUp': [{ type: HostListener, args: ['body:keyup', ['$event'],] },],
	    };
	    return ActionSheetCmp;
	}());
	var ActionSheetSlideIn = (function (_super) {
	    __extends$8(ActionSheetSlideIn, _super);
	    function ActionSheetSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
	        backdrop.fromTo('opacity', 0.01, 0.4);
	        wrapper.fromTo('translateY', '100%', '0%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
	    }
	    return ActionSheetSlideIn;
	}(Transition));
	Transition.register('action-sheet-slide-in', ActionSheetSlideIn);
	var ActionSheetSlideOut = (function (_super) {
	    __extends$8(ActionSheetSlideOut, _super);
	    function ActionSheetSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
	        backdrop.fromTo('opacity', 0.4, 0);
	        wrapper.fromTo('translateY', '0%', '100%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(300).add(backdrop).add(wrapper);
	    }
	    return ActionSheetSlideOut;
	}(Transition));
	Transition.register('action-sheet-slide-out', ActionSheetSlideOut);
	var ActionSheetMdSlideIn = (function (_super) {
	    __extends$8(ActionSheetMdSlideIn, _super);
	    function ActionSheetMdSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
	        backdrop.fromTo('opacity', 0.01, 0.26);
	        wrapper.fromTo('translateY', '100%', '0%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
	    }
	    return ActionSheetMdSlideIn;
	}(Transition));
	Transition.register('action-sheet-md-slide-in', ActionSheetMdSlideIn);
	var ActionSheetMdSlideOut = (function (_super) {
	    __extends$8(ActionSheetMdSlideOut, _super);
	    function ActionSheetMdSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
	        backdrop.fromTo('opacity', 0.26, 0);
	        wrapper.fromTo('translateY', '0%', '100%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(backdrop).add(wrapper);
	    }
	    return ActionSheetMdSlideOut;
	}(Transition));
	Transition.register('action-sheet-md-slide-out', ActionSheetMdSlideOut);
	var ActionSheetWpSlideIn = (function (_super) {
	    __extends$8(ActionSheetWpSlideIn, _super);
	    function ActionSheetWpSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
	        backdrop.fromTo('opacity', 0.01, 0.16);
	        wrapper.fromTo('translateY', '100%', '0%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
	    }
	    return ActionSheetWpSlideIn;
	}(Transition));
	Transition.register('action-sheet-wp-slide-in', ActionSheetWpSlideIn);
	var ActionSheetWpSlideOut = (function (_super) {
	    __extends$8(ActionSheetWpSlideOut, _super);
	    function ActionSheetWpSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.action-sheet-wrapper'));
	        backdrop.fromTo('opacity', 0.1, 0);
	        wrapper.fromTo('translateY', '0%', '100%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(backdrop).add(wrapper);
	    }
	    return ActionSheetWpSlideOut;
	}(Transition));
	Transition.register('action-sheet-wp-slide-out', ActionSheetWpSlideOut);
	var actionSheetIds = -1;

	var __extends$7 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var ActionSheet = (function (_super) {
	    __extends$7(ActionSheet, _super);
	    function ActionSheet(app, opts) {
	        opts.buttons = opts.buttons || [];
	        opts.enableBackdropDismiss = isPresent$5(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
	        _super.call(this, ActionSheetCmp, opts);
	        this._app = app;
	        this.isOverlay = true;
	        // by default, actionsheets should not fire lifecycle events of other views
	        // for example, when an actionsheets enters, the current active view should
	        // not fire its lifecycle events because it's not conceptually leaving
	        this.fireOtherLifecycles = false;
	    }
	    /**
	     * @private
	     */
	    ActionSheet.prototype.getTransitionName = function (direction) {
	        var key = 'actionSheet' + (direction === 'back' ? 'Leave' : 'Enter');
	        return this._nav && this._nav.config.get(key);
	    };
	    /**
	     * @param {string} title Action sheet title
	     */
	    ActionSheet.prototype.setTitle = function (title) {
	        this.data.title = title;
	    };
	    /**
	     * @param {string} subTitle Action sheet subtitle
	     */
	    ActionSheet.prototype.setSubTitle = function (subTitle) {
	        this.data.subTitle = subTitle;
	    };
	    /**
	     * @param {object} button Action sheet button
	     */
	    ActionSheet.prototype.addButton = function (button) {
	        this.data.buttons.push(button);
	    };
	    /**
	     * Present the action sheet instance.
	     *
	     * @param {NavOptions} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    ActionSheet.prototype.present = function (navOptions) {
	        if (navOptions === void 0) { navOptions = {}; }
	        return this._app.present(this, navOptions);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please inject ActionSheetController instead
	     */
	    ActionSheet.create = function (opt) {
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('ActionSheet.create(..) has been deprecated. Please inject ActionSheetController instead');
	    };
	    return ActionSheet;
	}(ViewController));
	var ActionSheetController = (function () {
	    function ActionSheetController(_app) {
	        this._app = _app;
	    }
	    /**
	     * Open an action sheet with a title, subTitle, and an array of buttons
	     * @param {ActionSheetOptions} opts Action sheet options
	     */
	    ActionSheetController.prototype.create = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        return new ActionSheet(this._app, opts);
	    };
	    /** @nocollapse */
	    ActionSheetController.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    ActionSheetController.ctorParameters = [
	        { type: App, },
	    ];
	    return ActionSheetController;
	}());

	var __extends$10 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AlertCmp = (function () {
	    function AlertCmp(_viewCtrl, _elementRef, _config, params, renderer) {
	        this._viewCtrl = _viewCtrl;
	        this._elementRef = _elementRef;
	        this._config = _config;
	        this.d = params.data;
	        if (this.d.cssClass) {
	            this.d.cssClass.split(' ').forEach(function (cssClass) {
	                renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
	            });
	        }
	        this.id = (++alertIds);
	        this.descId = '';
	        this.hdrId = 'alert-hdr-' + this.id;
	        this.subHdrId = 'alert-subhdr-' + this.id;
	        this.msgId = 'alert-msg-' + this.id;
	        this.activeId = '';
	        this.lastClick = 0;
	        if (this.d.message) {
	            this.descId = this.msgId;
	        }
	        else if (this.d.subTitle) {
	            this.descId = this.subHdrId;
	        }
	        if (!this.d.message) {
	            this.d.message = '';
	        }
	    }
	    AlertCmp.prototype.ionViewLoaded = function () {
	        var _this = this;
	        // normalize the data
	        var data = this.d;
	        data.buttons = data.buttons.map(function (button) {
	            if (typeof button === 'string') {
	                return { text: button };
	            }
	            return button;
	        });
	        data.inputs = data.inputs.map(function (input, index) {
	            return {
	                type: input.type || 'text',
	                name: isPresent$5(input.name) ? input.name : index,
	                placeholder: isPresent$5(input.placeholder) ? input.placeholder : '',
	                value: isPresent$5(input.value) ? input.value : '',
	                label: input.label,
	                checked: !!input.checked,
	                disabled: !!input.disabled,
	                id: 'alert-input-' + _this.id + '-' + index
	            };
	        });
	        // An alert can be created with several different inputs. Radios,
	        // checkboxes and inputs are all accepted, but they cannot be mixed.
	        var inputTypes = [];
	        data.inputs.forEach(function (input) {
	            if (inputTypes.indexOf(input.type) < 0) {
	                inputTypes.push(input.type);
	            }
	        });
	        if (inputTypes.length > 1 && (inputTypes.indexOf('checkbox') > -1 || inputTypes.indexOf('radio') > -1)) {
	            console.warn('Alert cannot mix input types: ' + (inputTypes.join('/')) + '. Please see alert docs for more info.');
	        }
	        this.inputType = inputTypes.length ? inputTypes[0] : null;
	        var checkedInput = this.d.inputs.find(function (input) { return input.checked; });
	        if (checkedInput) {
	            this.activeId = checkedInput.id;
	        }
	    };
	    AlertCmp.prototype._keyUp = function (ev) {
	        if (this.enabled && this._viewCtrl.isLast()) {
	            if (ev.keyCode === Key.ENTER) {
	                if (this.lastClick + 1000 < Date.now()) {
	                    // do not fire this click if there recently was already a click
	                    // this can happen when the button has focus and used the enter
	                    // key to click the button. However, both the click handler and
	                    // this keyup event will fire, so only allow one of them to go.
	                    console.debug('alert, enter button');
	                    var button = this.d.buttons[this.d.buttons.length - 1];
	                    this.btnClick(button);
	                }
	            }
	            else if (ev.keyCode === Key.ESCAPE) {
	                console.debug('alert, escape button');
	                this.bdClick();
	            }
	        }
	    };
	    AlertCmp.prototype.ionViewDidEnter = function () {
	        var activeElement = document.activeElement;
	        if (document.activeElement) {
	            activeElement.blur();
	        }
	        var focusableEle = this._elementRef.nativeElement.querySelector('input,button');
	        if (focusableEle) {
	            focusableEle.focus();
	        }
	        this.enabled = true;
	    };
	    AlertCmp.prototype.btnClick = function (button, dismissDelay) {
	        var _this = this;
	        if (!this.enabled) {
	            return;
	        }
	        // keep the time of the most recent button click
	        this.lastClick = Date.now();
	        var shouldDismiss = true;
	        if (button.handler) {
	            // a handler has been provided, execute it
	            // pass the handler the values from the inputs
	            if (button.handler(this.getValues()) === false) {
	                // if the return value of the handler is false then do not dismiss
	                shouldDismiss = false;
	            }
	        }
	        if (shouldDismiss) {
	            setTimeout(function () {
	                _this.dismiss(button.role);
	            }, dismissDelay || this._config.get('pageTransitionDelay'));
	        }
	    };
	    AlertCmp.prototype.rbClick = function (checkedInput) {
	        if (this.enabled) {
	            this.d.inputs.forEach(function (input) {
	                input.checked = (checkedInput === input);
	            });
	            this.activeId = checkedInput.id;
	        }
	    };
	    AlertCmp.prototype.cbClick = function (checkedInput) {
	        if (this.enabled) {
	            checkedInput.checked = !checkedInput.checked;
	        }
	    };
	    AlertCmp.prototype.bdClick = function () {
	        if (this.enabled && this.d.enableBackdropDismiss) {
	            var cancelBtn = this.d.buttons.find(function (b) { return b.role === 'cancel'; });
	            if (cancelBtn) {
	                this.btnClick(cancelBtn, 1);
	            }
	            else {
	                this.dismiss('backdrop');
	            }
	        }
	    };
	    AlertCmp.prototype.dismiss = function (role) {
	        return this._viewCtrl.dismiss(this.getValues(), role);
	    };
	    AlertCmp.prototype.getValues = function () {
	        if (this.inputType === 'radio') {
	            // this is an alert with radio buttons (single value select)
	            // return the one value which is checked, otherwise undefined
	            var checkedInput = this.d.inputs.find(function (i) { return i.checked; });
	            return checkedInput ? checkedInput.value : undefined;
	        }
	        if (this.inputType === 'checkbox') {
	            // this is an alert with checkboxes (multiple value select)
	            // return an array of all the checked values
	            return this.d.inputs.filter(function (i) { return i.checked; }).map(function (i) { return i.value; });
	        }
	        // this is an alert with text inputs
	        // return an object of all the values with the input name as the key
	        var values = {};
	        this.d.inputs.forEach(function (i) {
	            values[i.name] = i.value;
	        });
	        return values;
	    };
	    /** @nocollapse */
	    AlertCmp.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-alert',
	                    template: "\n    <ion-backdrop (click)=\"bdClick()\"></ion-backdrop>\n    <div class=\"alert-wrapper\">\n      <div class=\"alert-head\">\n        <h2 id=\"{{hdrId}}\" class=\"alert-title\" *ngIf=\"d.title\" [innerHTML]=\"d.title\"></h2>\n        <h3 id=\"{{subHdrId}}\" class=\"alert-sub-title\" *ngIf=\"d.subTitle\" [innerHTML]=\"d.subTitle\"></h3>\n      </div>\n      <div id=\"{{msgId}}\" class=\"alert-message\" [innerHTML]=\"d.message\"></div>\n      <div *ngIf=\"d.inputs.length\" [ngSwitch]=\"inputType\">\n\n        <template ngSwitchCase=\"radio\">\n          <div class=\"alert-radio-group\" role=\"radiogroup\" [attr.aria-labelledby]=\"hdrId\" [attr.aria-activedescendant]=\"activeId\">\n            <button category=\"alert-radio-button\" *ngFor=\"let i of d.inputs\" (click)=\"rbClick(i)\" [attr.aria-checked]=\"i.checked\" [disabled]=\"i.disabled\" [attr.id]=\"i.id\" class=\"alert-tappable alert-radio\" role=\"radio\">\n              <div class=\"alert-radio-icon\"><div class=\"alert-radio-inner\"></div></div>\n              <div class=\"alert-radio-label\">\n                {{i.label}}\n              </div>\n            </button>\n          </div>\n        </template>\n\n        <template ngSwitchCase=\"checkbox\">\n          <div class=\"alert-checkbox-group\">\n            <button category=\"alert-checkbox-button\" *ngFor=\"let i of d.inputs\" (click)=\"cbClick(i)\" [attr.aria-checked]=\"i.checked\" [disabled]=\"i.disabled\" class=\"alert-tappable alert-checkbox\" role=\"checkbox\">\n              <div class=\"alert-checkbox-icon\"><div class=\"alert-checkbox-inner\"></div></div>\n              <div class=\"alert-checkbox-label\">\n                {{i.label}}\n              </div>\n            </button>\n          </div>\n        </template>\n\n        <template ngSwitchDefault>\n          <div class=\"alert-input-group\">\n            <div *ngFor=\"let i of d.inputs\" class=\"alert-input-wrapper\">\n              <input [placeholder]=\"i.placeholder\" [(ngModel)]=\"i.value\" [type]=\"i.type\" class=\"alert-input\">\n            </div>\n          </div>\n        </template>\n\n      </div>\n      <div class=\"alert-button-group\" [ngClass]=\"{vertical: d.buttons.length>2}\">\n        <button category=\"alert-button\" *ngFor=\"let b of d.buttons\" (click)=\"btnClick(b)\" [ngClass]=\"b.cssClass\">\n          {{b.text}}\n        </button>\n      </div>\n    </div>\n    ",
	                    directives: [Backdrop, NgClass, NgFor, NgIf, NgModel$1, NgSwitch, NgSwitchCase, NgSwitchDefault],
	                    host: {
	                        'role': 'dialog',
	                        '[attr.aria-labelledby]': 'hdrId',
	                        '[attr.aria-describedby]': 'descId'
	                    },
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    AlertCmp.ctorParameters = [
	        { type: ViewController, },
	        { type: ElementRef, },
	        { type: Config, },
	        { type: NavParams, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    AlertCmp.propDecorators = {
	        '_keyUp': [{ type: HostListener, args: ['body:keyup', ['$event'],] },],
	    };
	    return AlertCmp;
	}());
	/**
	 * Animations for alerts
	 */
	var AlertPopIn = (function (_super) {
	    __extends$10(AlertPopIn, _super);
	    function AlertPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
	        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
	        backdrop.fromTo('opacity', 0.01, 0.3);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return AlertPopIn;
	}(Transition));
	Transition.register('alert-pop-in', AlertPopIn);
	var AlertPopOut = (function (_super) {
	    __extends$10(AlertPopOut, _super);
	    function AlertPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
	        backdrop.fromTo('opacity', 0.3, 0);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return AlertPopOut;
	}(Transition));
	Transition.register('alert-pop-out', AlertPopOut);
	var AlertMdPopIn = (function (_super) {
	    __extends$10(AlertMdPopIn, _super);
	    function AlertMdPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
	        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
	        backdrop.fromTo('opacity', 0.01, 0.5);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return AlertMdPopIn;
	}(Transition));
	Transition.register('alert-md-pop-in', AlertMdPopIn);
	var AlertMdPopOut = (function (_super) {
	    __extends$10(AlertMdPopOut, _super);
	    function AlertMdPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
	        backdrop.fromTo('opacity', 0.5, 0);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return AlertMdPopOut;
	}(Transition));
	Transition.register('alert-md-pop-out', AlertMdPopOut);
	var AlertWpPopIn = (function (_super) {
	    __extends$10(AlertWpPopIn, _super);
	    function AlertWpPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
	        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.3, 1);
	        backdrop.fromTo('opacity', 0.01, 0.5);
	        this
	            .easing('cubic-bezier(0,0 0.05,1)')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return AlertWpPopIn;
	}(Transition));
	Transition.register('alert-wp-pop-in', AlertWpPopIn);
	var AlertWpPopOut = (function (_super) {
	    __extends$10(AlertWpPopOut, _super);
	    function AlertWpPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.alert-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 1.3);
	        backdrop.fromTo('opacity', 0.5, 0);
	        this
	            .easing('ease-out')
	            .duration(150)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return AlertWpPopOut;
	}(Transition));
	Transition.register('alert-wp-pop-out', AlertWpPopOut);
	var alertIds = -1;

	var __extends$9 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var Alert = (function (_super) {
	    __extends$9(Alert, _super);
	    function Alert(app, opts) {
	        if (opts === void 0) { opts = {}; }
	        opts.inputs = opts.inputs || [];
	        opts.buttons = opts.buttons || [];
	        opts.enableBackdropDismiss = isPresent$5(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
	        _super.call(this, AlertCmp, opts);
	        this._app = app;
	        this.isOverlay = true;
	        // by default, alerts should not fire lifecycle events of other views
	        // for example, when an alert enters, the current active view should
	        // not fire its lifecycle events because it's not conceptually leaving
	        this.fireOtherLifecycles = false;
	    }
	    /**
	    * @private
	    */
	    Alert.prototype.getTransitionName = function (direction) {
	        var key = (direction === 'back' ? 'alertLeave' : 'alertEnter');
	        return this._nav && this._nav.config.get(key);
	    };
	    /**
	     * @param {string} title Alert title
	     */
	    Alert.prototype.setTitle = function (title) {
	        this.data.title = title;
	    };
	    /**
	     * @param {string} subTitle Alert subtitle
	     */
	    Alert.prototype.setSubTitle = function (subTitle) {
	        this.data.subTitle = subTitle;
	    };
	    /**
	     * @private
	     */
	    Alert.prototype.setBody = function (message) {
	        // deprecated warning
	        console.warn('Alert setBody() has been renamed to setMessage()');
	        this.setMessage(message);
	    };
	    /**
	     * @param {string} message  Alert message content
	     */
	    Alert.prototype.setMessage = function (message) {
	        this.data.message = message;
	    };
	    /**
	     * @param {object} input Alert input
	     */
	    Alert.prototype.addInput = function (input) {
	        this.data.inputs.push(input);
	    };
	    /**
	     * @param {any} button Alert button
	     */
	    Alert.prototype.addButton = function (button) {
	        this.data.buttons.push(button);
	    };
	    /**
	     * @param {string} cssClass CSS class name to add to the alert's outer wrapper
	     */
	    Alert.prototype.setCssClass = function (cssClass) {
	        this.data.cssClass = cssClass;
	    };
	    /**
	     * Present the alert instance.
	     *
	     * @param {NavOptions} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    Alert.prototype.present = function (navOptions) {
	        if (navOptions === void 0) { navOptions = {}; }
	        return this._app.present(this, navOptions);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please inject AlertController instead
	     */
	    Alert.create = function (opt) {
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('Alert.create(..) has been deprecated. Please inject AlertController instead');
	    };
	    return Alert;
	}(ViewController));
	var AlertController = (function () {
	    function AlertController(_app) {
	        this._app = _app;
	    }
	    /**
	     * Display an alert with a title, inputs, and buttons
	     * @param {AlertOptions} opts Alert. See the table below
	     */
	    AlertController.prototype.create = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        return new Alert(this._app, opts);
	    };
	    /** @nocollapse */
	    AlertController.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    AlertController.ctorParameters = [
	        { type: App, },
	    ];
	    return AlertController;
	}());

	/**
	 * @name Events
	 * @description
	 * Events is a publish-subscribe style event system for sending and responding to application-level
	 * events across your app.
	 *
	 * @usage
	 * ```ts
	 * import {Events} from 'ionic-angular';
	 *
	 * constructor(public events: Events) {}
	 *
	 * // first page (publish an event when a user is created)
	 * function createUser(user) {
	 *   console.log('User created!')
	 *   events.publish('user:created', user);
	 * }
	 *
	 * // second page (listen for the user created event)
	 * events.subscribe('user:created', (userEventData) => {
	 *   // userEventData is an array of parameters, so grab our first and only arg
	 *   console.log('Welcome', userEventData[0]);
	 * });
	 *
	 * ```
	 * @demo /docs/v2/demos/events/
	 */
	var Events = (function () {
	    function Events() {
	        this._channels = [];
	    }
	    /**
	     * Subscribe to an event topic. Events that get posted to that topic will trigger the provided handler.
	     *
	     * @param {string} topic the topic to subscribe to
	     * @param {function} handler the event handler
	     */
	    Events.prototype.subscribe = function (topic) {
	        var _this = this;
	        var handlers = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            handlers[_i - 1] = arguments[_i];
	        }
	        if (!this._channels[topic]) {
	            this._channels[topic] = [];
	        }
	        handlers.forEach(function (handler) {
	            _this._channels[topic].push(handler);
	        });
	    };
	    /**
	     * Unsubscribe from the given topic. Your handler will no longer receive events published to this topic.
	     *
	     * @param {string} topic the topic to unsubscribe from
	     * @param {function} handler the event handler
	     *
	     * @return true if a handler was removed
	     */
	    Events.prototype.unsubscribe = function (topic, handler) {
	        var t = this._channels[topic];
	        if (!t) {
	            // Wasn't found, wasn't removed
	            return false;
	        }
	        if (!handler) {
	            // Remove all handlers for this topic
	            delete this._channels[topic];
	            return true;
	        }
	        // We need to find and remove a specific handler
	        var i = t.indexOf(handler);
	        if (i < 0) {
	            // Wasn't found, wasn't removed
	            return false;
	        }
	        t.splice(i, 1);
	        // If the channel is empty now, remove it from the channel map
	        if (!t.length) {
	            delete this._channels[topic];
	        }
	        return true;
	    };
	    /**
	     * Publish an event to the given topic.
	     *
	     * @param {string} topic the topic to publish to
	     * @param {any} eventData the data to send as the event
	     */
	    Events.prototype.publish = function (topic) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var t = this._channels[topic];
	        if (!t) {
	            return null;
	        }
	        var responses = [];
	        t.forEach(function (handler) {
	            responses.push(handler(args));
	        });
	        return responses;
	    };
	    return Events;
	}());

	var FeatureDetect = (function () {
	    function FeatureDetect() {
	        this._results = {};
	    }
	    FeatureDetect.prototype.run = function (window, document) {
	        for (var name_1 in featureDetects) {
	            this._results[name_1] = featureDetects[name_1](window, document, document.body);
	        }
	    };
	    FeatureDetect.prototype.has = function (featureName) {
	        return !!this._results[featureName];
	    };
	    FeatureDetect.add = function (name, fn) {
	        featureDetects[name] = fn;
	    };
	    return FeatureDetect;
	}());
	var featureDetects = {};
	FeatureDetect.add('hairlines', function (window, document, body) {
	    /**
	    * Hairline Shim
	    * Add the "hairline" CSS class name to the body tag
	    * if the browser supports subpixels.
	    */
	    var canDo = false;
	    if (window.devicePixelRatio >= 2) {
	        var hairlineEle = document.createElement('div');
	        hairlineEle.style.border = '.5px solid transparent';
	        body.appendChild(hairlineEle);
	        if (hairlineEle.offsetHeight === 1) {
	            body.classList.add('hairlines');
	            canDo = true;
	        }
	        body.removeChild(hairlineEle);
	    }
	    return canDo;
	});
	FeatureDetect.add('backdrop-filter', function (window, document, body) {
	    /**
	    * backdrop-filter Shim
	    * Checks if css backdrop-filter is implemented by the browser.
	    */
	    var styles = body.style;
	    var backdrop = styles['backdrop-filter'] !== undefined ||
	        styles['-webkit-backdrop-filter'] !== undefined;
	    if (backdrop) {
	        body.classList.add('backdrop-filter');
	    }
	    return backdrop;
	});

	var __extends$12 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Gesture attached to the content which the menu is assigned to
	 */
	var MenuContentGesture = (function (_super) {
	    __extends$12(MenuContentGesture, _super);
	    function MenuContentGesture(menu, contentEle, options) {
	        if (options === void 0) { options = {}; }
	        _super.call(this, contentEle, assign({
	            direction: 'x',
	            edge: menu.side,
	            threshold: 0,
	            maxEdgeStart: menu.maxEdgeStart || 75
	        }, options));
	        this.menu = menu;
	    }
	    MenuContentGesture.prototype.canStart = function (ev) {
	        var menu = this.menu;
	        if (!menu.enabled || !menu.swipeEnabled) {
	            console.debug('menu can not start, isEnabled:', menu.enabled, 'isSwipeEnabled:', menu.swipeEnabled, 'side:', menu.side);
	            return false;
	        }
	        if (ev.distance > 50) {
	            // the distance is longer than you'd expect a side menu swipe to be
	            console.debug('menu can not start, distance too far:', ev.distance, 'side:', menu.side);
	            return false;
	        }
	        console.debug('menu canStart,', menu.side, 'isOpen', menu.isOpen, 'angle', ev.angle, 'distance', ev.distance);
	        if (menu.side === 'right') {
	            // right side
	            if (menu.isOpen) {
	                // right side, opened
	                return true;
	            }
	            else {
	                // right side, closed
	                if ((ev.angle > 140 && ev.angle <= 180) || (ev.angle > -140 && ev.angle <= -180)) {
	                    return _super.prototype.canStart.call(this, ev);
	                }
	            }
	        }
	        else {
	            // left side
	            if (menu.isOpen) {
	                // left side, opened
	                return true;
	            }
	            else {
	                // left side, closed
	                if (ev.angle > -40 && ev.angle < 40) {
	                    return _super.prototype.canStart.call(this, ev);
	                }
	            }
	        }
	        // didn't pass the test, don't open this menu
	        return false;
	    };
	    // Set CSS, then wait one frame for it to apply before sliding starts
	    MenuContentGesture.prototype.onSlideBeforeStart = function (slide, ev) {
	        console.debug('menu gesture, onSlideBeforeStart', this.menu.side);
	        this.menu.swipeStart();
	    };
	    MenuContentGesture.prototype.onSlide = function (slide, ev) {
	        var z = (this.menu.side === 'right' ? slide.min : slide.max);
	        var stepValue = (slide.distance / z);
	        console.debug('menu gesture, onSlide', this.menu.side, 'distance', slide.distance, 'min', slide.min, 'max', slide.max, 'z', z, 'stepValue', stepValue);
	        ev.srcEvent.preventDefault();
	        ev.preventDefault();
	        this.menu.swipeProgress(stepValue);
	    };
	    MenuContentGesture.prototype.onSlideEnd = function (slide, ev) {
	        var z = (this.menu.side === 'right' ? slide.min : slide.max);
	        var currentStepValue = (slide.distance / z);
	        z = Math.abs(z * 0.5);
	        var shouldCompleteRight = (ev.velocityX >= 0)
	            && (ev.velocityX > 0.2 || slide.delta > z);
	        var shouldCompleteLeft = (ev.velocityX <= 0)
	            && (ev.velocityX < -0.2 || slide.delta < -z);
	        console.debug('menu gesture, onSlide', this.menu.side, 'distance', slide.distance, 'delta', slide.delta, 'velocityX', ev.velocityX, 'min', slide.min, 'max', slide.max, 'shouldCompleteLeft', shouldCompleteLeft, 'shouldCompleteRight', shouldCompleteRight, 'currentStepValue', currentStepValue);
	        this.menu.swipeEnd(shouldCompleteLeft, shouldCompleteRight, currentStepValue);
	    };
	    MenuContentGesture.prototype.getElementStartPos = function (slide, ev) {
	        if (this.menu.side === 'right') {
	            // right menu
	            return this.menu.isOpen ? slide.min : slide.max;
	        }
	        // left menu
	        return this.menu.isOpen ? slide.max : slide.min;
	    };
	    MenuContentGesture.prototype.getSlideBoundaries = function () {
	        if (this.menu.side === 'right') {
	            // right menu
	            return {
	                min: -this.menu.width(),
	                max: 0
	            };
	        }
	        // left menu
	        return {
	            min: 0,
	            max: this.menu.width()
	        };
	    };
	    return MenuContentGesture;
	}(SlideEdgeGesture));
	/**
	 * Gesture attached to the actual menu itself
	 */
	var MenuTargetGesture = (function (_super) {
	    __extends$12(MenuTargetGesture, _super);
	    function MenuTargetGesture(menu, menuEle) {
	        _super.call(this, menu, menuEle, {
	            maxEdgeStart: 0
	        });
	    }
	    return MenuTargetGesture;
	}(MenuContentGesture));

	var __extends$11 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Menu = (function (_super) {
	    __extends$11(Menu, _super);
	    function Menu(_menuCtrl, _elementRef, _config, _platform, _renderer, _keyboard, _zone) {
	        _super.call(this, _elementRef);
	        this._menuCtrl = _menuCtrl;
	        this._elementRef = _elementRef;
	        this._config = _config;
	        this._platform = _platform;
	        this._renderer = _renderer;
	        this._keyboard = _keyboard;
	        this._zone = _zone;
	        this._preventTime = 0;
	        this._isEnabled = true;
	        this._isSwipeEnabled = true;
	        this._isPers = false;
	        this._init = false;
	        /**
	         * @private
	         */
	        this.isOpen = false;
	        this.ionDrag = new EventEmitter();
	        this.ionOpen = new EventEmitter();
	        this.ionClose = new EventEmitter();
	    }
	    Object.defineProperty(Menu.prototype, "enabled", {
	        get: function () {
	            return this._isEnabled;
	        },
	        set: function (val) {
	            this._isEnabled = isTrueProperty(val);
	            this._setListeners();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Menu.prototype, "swipeEnabled", {
	        get: function () {
	            return this._isSwipeEnabled;
	        },
	        set: function (val) {
	            this._isSwipeEnabled = isTrueProperty(val);
	            this._setListeners();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Menu.prototype, "persistent", {
	        get: function () {
	            return this._isPers;
	        },
	        set: function (val) {
	            this._isPers = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Menu.prototype.ngOnInit = function () {
	        var self = this;
	        self._init = true;
	        var content = self.content;
	        self._cntEle = (content instanceof Node) ? content : content && content.getNativeElement && content.getNativeElement();
	        // requires content element
	        if (!self._cntEle) {
	            return console.error('Menu: must have a [content] element to listen for drag events on. Example:\n\n<ion-menu [content]="content"></ion-menu>\n\n<ion-nav #content></ion-nav>');
	        }
	        // normalize the "side"
	        if (self.side !== 'left' && self.side !== 'right') {
	            self.side = 'left';
	        }
	        self._renderer.setElementAttribute(self._elementRef.nativeElement, 'side', self.side);
	        // normalize the "type"
	        if (!self.type) {
	            self.type = self._config.get('menuType');
	        }
	        self._renderer.setElementAttribute(self._elementRef.nativeElement, 'type', self.type);
	        // add the gestures
	        self._cntGesture = new MenuContentGesture(self, self.getContentElement());
	        self._menuGesture = new MenuTargetGesture(self, self.getNativeElement());
	        // register listeners if this menu is enabled
	        // check if more than one menu is on the same side
	        var hasEnabledSameSideMenu = self._menuCtrl.getMenus().some(function (m) {
	            return m.side === self.side && m.enabled;
	        });
	        if (hasEnabledSameSideMenu) {
	            // auto-disable if another menu on the same side is already enabled
	            self._isEnabled = false;
	        }
	        self._setListeners();
	        // create a reusable click handler on this instance, but don't assign yet
	        self.onContentClick = function (ev) {
	            if (self._isEnabled) {
	                ev.preventDefault();
	                ev.stopPropagation();
	                self.close();
	            }
	        };
	        self._cntEle.classList.add('menu-content');
	        self._cntEle.classList.add('menu-content-' + self.type);
	        // register this menu with the app's menu controller
	        self._menuCtrl.register(self);
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.bdClick = function (ev) {
	        console.debug('backdrop clicked');
	        ev.preventDefault();
	        ev.stopPropagation();
	        this._menuCtrl.close();
	    };
	    /**
	     * @private
	     */
	    Menu.prototype._setListeners = function () {
	        var self = this;
	        if (self._init) {
	            // only listen/unlisten if the menu has initialized
	            if (self._isEnabled && self._isSwipeEnabled && !self._cntGesture.isListening) {
	                // should listen, but is not currently listening
	                console.debug('menu, gesture listen', self.side);
	                self._zone.runOutsideAngular(function () {
	                    self._cntGesture.listen();
	                    self._menuGesture.listen();
	                });
	            }
	            else if (self._cntGesture.isListening && (!self._isEnabled || !self._isSwipeEnabled)) {
	                // should not listen, but is currently listening
	                console.debug('menu, gesture unlisten', self.side);
	                self._cntGesture.unlisten();
	                self._menuGesture.unlisten();
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Menu.prototype._getType = function () {
	        if (!this._type) {
	            this._type = MenuController.create(this.type, this, this._platform);
	            if (this._config.get('animate') === false) {
	                this._type.ani.duration(0);
	            }
	        }
	        return this._type;
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.setOpen = function (shouldOpen) {
	        var _this = this;
	        // _isPrevented is used to prevent unwanted opening/closing after swiping open/close
	        // or swiping open the menu while pressing down on the MenuToggle button
	        if ((shouldOpen && this.isOpen) || this._isPrevented()) {
	            return Promise.resolve(this.isOpen);
	        }
	        this._before();
	        return new Promise(function (resolve) {
	            _this._getType().setOpen(shouldOpen, function () {
	                _this._after(shouldOpen);
	                resolve(_this.isOpen);
	            });
	        });
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.swipeStart = function () {
	        // user started swiping the menu open/close
	        if (this._isEnabled && this._isSwipeEnabled && !this._isPrevented()) {
	            this._before();
	            this._getType().setProgressStart(this.isOpen);
	        }
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.swipeProgress = function (stepValue) {
	        // user actively dragging the menu
	        if (this._isEnabled && this._isSwipeEnabled) {
	            this._prevent();
	            this._getType().setProgessStep(stepValue);
	            this.ionDrag.emit(stepValue);
	        }
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.swipeEnd = function (shouldCompleteLeft, shouldCompleteRight, stepValue) {
	        var _this = this;
	        // user has finished dragging the menu
	        if (this._isEnabled && this._isSwipeEnabled) {
	            this._prevent();
	            var opening = !this.isOpen;
	            var shouldComplete = false;
	            if (opening) {
	                shouldComplete = (this.side === 'right') ? shouldCompleteLeft : shouldCompleteRight;
	            }
	            else {
	                shouldComplete = (this.side === 'right') ? shouldCompleteRight : shouldCompleteLeft;
	            }
	            this._getType().setProgressEnd(shouldComplete, stepValue, function (isOpen) {
	                console.debug('menu, swipeEnd', _this.side);
	                _this._after(isOpen);
	            });
	        }
	    };
	    Menu.prototype._before = function () {
	        // this places the menu into the correct location before it animates in
	        // this css class doesn't actually kick off any animations
	        if (this._isEnabled) {
	            this.getNativeElement().classList.add('show-menu');
	            this.getBackdropElement().classList.add('show-backdrop');
	            this._prevent();
	            this._keyboard.close();
	        }
	    };
	    Menu.prototype._after = function (isOpen) {
	        // keep opening/closing the menu disabled for a touch more yet
	        // only add listeners/css if it's enabled and isOpen
	        // and only remove listeners/css if it's not open
	        // emit opened/closed events
	        if ((this._isEnabled && isOpen) || !isOpen) {
	            this._prevent();
	            this.isOpen = isOpen;
	            this._cntEle.classList[isOpen ? 'add' : 'remove']('menu-content-open');
	            this._cntEle.removeEventListener('click', this.onContentClick);
	            if (isOpen) {
	                this._cntEle.addEventListener('click', this.onContentClick);
	                this.ionOpen.emit(true);
	            }
	            else {
	                this.getNativeElement().classList.remove('show-menu');
	                this.getBackdropElement().classList.remove('show-backdrop');
	                this.ionClose.emit(true);
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.tempDisable = function (temporarilyDisable) {
	        if (temporarilyDisable) {
	            this._prevEnabled = this._isEnabled;
	            this._getType().setProgessStep(0);
	            this.enable(false);
	        }
	        else {
	            this.enable(this._prevEnabled);
	            this._after(false);
	        }
	    };
	    Menu.prototype._prevent = function () {
	        // used to prevent unwanted opening/closing after swiping open/close
	        // or swiping open the menu while pressing down on the MenuToggle
	        this._preventTime = Date.now() + 20;
	    };
	    Menu.prototype._isPrevented = function () {
	        return this._preventTime > Date.now();
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.open = function () {
	        return this.setOpen(true);
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.close = function () {
	        return this.setOpen(false);
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.toggle = function () {
	        return this.setOpen(!this.isOpen);
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.enable = function (shouldEnable) {
	        var _this = this;
	        this.enabled = shouldEnable;
	        if (!shouldEnable && this.isOpen) {
	            // close if this menu is open, and should not be enabled
	            this.close();
	        }
	        if (shouldEnable) {
	            // if this menu should be enabled
	            // then find all the other menus on this same side
	            // and automatically disable other same side menus
	            var sameSideMenus = this._menuCtrl
	                .getMenus()
	                .filter(function (m) { return m.side === _this.side && m !== _this; })
	                .map(function (m) { return m.enabled = false; });
	        }
	        return this;
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.swipeEnable = function (shouldEnable) {
	        this.swipeEnabled = shouldEnable;
	        return this;
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.getMenuElement = function () {
	        return this.getNativeElement();
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.getContentElement = function () {
	        return this._cntEle;
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.getBackdropElement = function () {
	        return this.backdrop.elementRef.nativeElement;
	    };
	    /**
	     * @private
	     */
	    Menu.prototype.ngOnDestroy = function () {
	        this._menuCtrl.unregister(this);
	        this._cntGesture && this._cntGesture.destroy();
	        this._menuGesture && this._menuGesture.destroy();
	        this._type && this._type.destroy();
	        this._resizeUnreg && this._resizeUnreg();
	        this._cntEle = null;
	    };
	    /** @nocollapse */
	    Menu.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-menu',
	                    host: {
	                        'role': 'navigation'
	                    },
	                    template: "\n    <ng-content></ng-content>\n    <ion-backdrop (click)=\"bdClick($event)\" disableScroll=\"false\"></ion-backdrop>\n  ",
	                    directives: [Backdrop],
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Menu.ctorParameters = [
	        { type: MenuController, },
	        { type: ElementRef, },
	        { type: Config, },
	        { type: Platform, },
	        { type: Renderer, },
	        { type: Keyboard, },
	        { type: NgZone, },
	    ];
	    /** @nocollapse */
	    Menu.propDecorators = {
	        'backdrop': [{ type: ViewChild, args: [Backdrop,] },],
	        'content': [{ type: Input },],
	        'id': [{ type: Input },],
	        'side': [{ type: Input },],
	        'type': [{ type: Input },],
	        'enabled': [{ type: Input },],
	        'swipeEnabled': [{ type: Input },],
	        'persistent': [{ type: Input },],
	        'maxEdgeStart': [{ type: Input },],
	        'ionDrag': [{ type: Output },],
	        'ionOpen': [{ type: Output },],
	        'ionClose': [{ type: Output },],
	    };
	    return Menu;
	}(Ion));

	var __extends$14 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Header = (function () {
	    function Header(viewCtrl) {
	        viewCtrl && viewCtrl.setHeader(this);
	    }
	    /** @nocollapse */
	    Header.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-header'
	                },] },
	    ];
	    /** @nocollapse */
	    Header.ctorParameters = [
	        { type: ViewController, decorators: [{ type: Optional },] },
	    ];
	    return Header;
	}());
	var Footer = (function () {
	    function Footer(viewCtrl) {
	        viewCtrl && viewCtrl.setFooter(this);
	    }
	    /** @nocollapse */
	    Footer.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-footer'
	                },] },
	    ];
	    /** @nocollapse */
	    Footer.ctorParameters = [
	        { type: ViewController, decorators: [{ type: Optional },] },
	    ];
	    return Footer;
	}());
	/**
	 * @private
	 */
	var ToolbarBase = (function (_super) {
	    __extends$14(ToolbarBase, _super);
	    function ToolbarBase(elementRef) {
	        _super.call(this, elementRef);
	        this.itemRefs = [];
	        this.titleRef = null;
	    }
	    /**
	     * @private
	     */
	    ToolbarBase.prototype.setTitleCmp = function (titleCmp) {
	        this.titleCmp = titleCmp;
	    };
	    /**
	     * @private
	     * Returns the toolbar title text if it exists or an empty string
	     */
	    ToolbarBase.prototype.getTitleText = function () {
	        return (this.titleCmp && this.titleCmp.getTitleText()) || '';
	    };
	    /**
	     * @private
	     */
	    ToolbarBase.prototype.getTitleRef = function () {
	        return this.titleCmp && this.titleCmp.elementRef;
	    };
	    /**
	     * @private
	     * A toolbar items include the left and right side `ion-buttons`,
	     * and every `menu-toggle`. It does not include the `ion-title`.
	     * @returns {TODO} Array of this toolbar's item ElementRefs.
	     */
	    ToolbarBase.prototype.getItemRefs = function () {
	        return this.itemRefs;
	    };
	    /**
	     * @private
	     */
	    ToolbarBase.prototype.addItemRef = function (itemElementRef) {
	        this.itemRefs.push(itemElementRef);
	    };
	    return ToolbarBase;
	}(Ion));
	var Toolbar = (function (_super) {
	    __extends$14(Toolbar, _super);
	    function Toolbar(viewCtrl, header, footer, config, elementRef) {
	        _super.call(this, elementRef);
	        if (viewCtrl && (header || footer)) {
	            // only toolbars within headers and footer are view toolbars
	            // toolbars within the content are not view toolbars, since they
	            // are apart of the content, and could be anywhere within the content
	            viewCtrl.setToolbarRef(elementRef);
	        }
	        this._sbPadding = config.getBoolean('statusbarPadding');
	    }
	    /** @nocollapse */
	    Toolbar.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-toolbar',
	                    template: "\n    <div class=\"toolbar-background\"></div>\n    <ng-content select=\"[menuToggle],ion-buttons[left]\"></ng-content>\n    <ng-content select=\"ion-buttons[start]\"></ng-content>\n    <ng-content select=\"ion-buttons[end],ion-buttons[right]\"></ng-content>\n    <div class=\"toolbar-content\">\n      <ng-content></ng-content>\n    </div>\n  ",
	                    host: {
	                        'class': 'toolbar',
	                        '[class.statusbar-padding]': '_sbPadding'
	                    },
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                },] },
	    ];
	    /** @nocollapse */
	    Toolbar.ctorParameters = [
	        { type: ViewController, decorators: [{ type: Optional },] },
	        { type: Header, decorators: [{ type: Optional },] },
	        { type: Footer, decorators: [{ type: Optional },] },
	        { type: Config, },
	        { type: ElementRef, },
	    ];
	    return Toolbar;
	}(ToolbarBase));

	var __extends$13 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BackButton = (function (_super) {
	    __extends$13(BackButton, _super);
	    function BackButton(_nav, elementRef, navbar) {
	        _super.call(this, elementRef);
	        this._nav = _nav;
	        navbar && navbar.setBackButtonRef(elementRef);
	    }
	    BackButton.prototype.goBack = function (ev) {
	        ev.stopPropagation();
	        ev.preventDefault();
	        this._nav && this._nav.pop();
	    };
	    /** @nocollapse */
	    BackButton.decorators = [
	        { type: Directive, args: [{
	                    selector: '.back-button',
	                    host: {
	                        '(click)': 'goBack($event)'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    BackButton.ctorParameters = [
	        { type: NavController, decorators: [{ type: Optional },] },
	        { type: ElementRef, },
	        { type: Navbar, decorators: [{ type: Optional }, { type: Inject, args: [forwardRef(function () { return Navbar; }),] },] },
	    ];
	    return BackButton;
	}(Ion));
	var BackButtonText = (function () {
	    function BackButtonText(elementRef, navbar) {
	        navbar.setBackButtonTextRef(elementRef);
	    }
	    /** @nocollapse */
	    BackButtonText.decorators = [
	        { type: Directive, args: [{
	                    selector: '.back-button-text'
	                },] },
	    ];
	    /** @nocollapse */
	    BackButtonText.ctorParameters = [
	        { type: ElementRef, },
	        { type: Navbar, decorators: [{ type: Inject, args: [forwardRef(function () { return Navbar; }),] },] },
	    ];
	    return BackButtonText;
	}());
	var ToolbarBackground = (function () {
	    function ToolbarBackground(elementRef, navbar) {
	        navbar.setBackgroundRef(elementRef);
	    }
	    /** @nocollapse */
	    ToolbarBackground.decorators = [
	        { type: Directive, args: [{
	                    selector: '.toolbar-background'
	                },] },
	    ];
	    /** @nocollapse */
	    ToolbarBackground.ctorParameters = [
	        { type: ElementRef, },
	        { type: Navbar, decorators: [{ type: Inject, args: [forwardRef(function () { return Navbar; }),] },] },
	    ];
	    return ToolbarBackground;
	}());
	var Navbar = (function (_super) {
	    __extends$13(Navbar, _super);
	    function Navbar(_app, viewCtrl, elementRef, config) {
	        _super.call(this, elementRef);
	        this._app = _app;
	        this._hidden = false;
	        this._hideBb = false;
	        viewCtrl && viewCtrl.setNavbar(this);
	        this._bbIcon = config.get('backButtonIcon');
	        this._bbText = config.get('backButtonText');
	        this._sbPadding = config.getBoolean('statusbarPadding', false);
	    }
	    Object.defineProperty(Navbar.prototype, "hideBackButton", {
	        get: function () {
	            return this._hideBb;
	        },
	        set: function (val) {
	            this._hideBb = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Navbar.prototype.setBackButtonText = function (text) {
	        this._bbText = text;
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.getBackButtonRef = function () {
	        return this._bbRef;
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.setBackButtonRef = function (backButtonElementRef) {
	        this._bbRef = backButtonElementRef;
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.getBackButtonTextRef = function () {
	        return this._bbtRef;
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.setBackButtonTextRef = function (backButtonTextElementRef) {
	        this._bbtRef = backButtonTextElementRef;
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.setBackgroundRef = function (backgrouneElementRef) {
	        this._bgRef = backgrouneElementRef;
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.getBackgroundRef = function () {
	        return this._bgRef;
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.didEnter = function () {
	        try {
	            this._app.setTitle(this.getTitleText());
	        }
	        catch (e) {
	            console.error(e);
	        }
	    };
	    /**
	     * @private
	     */
	    Navbar.prototype.setHidden = function (isHidden) {
	        // used to display none/block the navbar
	        this._hidden = isHidden;
	    };
	    /** @nocollapse */
	    Navbar.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-navbar',
	                    template: "\n    <div class=\"toolbar-background\"></div>\n    <button category=\"bar-button\" class=\"back-button\" [hidden]=\"_hideBb\">\n      <span class=\"button-inner\">\n        <ion-icon class=\"back-button-icon\" [name]=\"_bbIcon\"></ion-icon>\n        <span class=\"back-button-text\">\n          <span class=\"back-default\">{{_bbText}}</span>\n        </span>\n      </span>\n    </button>\n    <ng-content select=\"[menuToggle],ion-buttons[left]\"></ng-content>\n    <ng-content select=\"ion-buttons[start]\"></ng-content>\n    <ng-content select=\"ion-buttons[end],ion-buttons[right]\"></ng-content>\n    <div class=\"toolbar-content\">\n      <ng-content></ng-content>\n    </div>\n  ",
	                    directives: [BackButton, BackButtonText, Icon, ToolbarBackground],
	                    host: {
	                        '[hidden]': '_hidden',
	                        'class': 'toolbar',
	                        '[class.statusbar-padding]': '_sbPadding'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    Navbar.ctorParameters = [
	        { type: App, },
	        { type: ViewController, decorators: [{ type: Optional },] },
	        { type: ElementRef, },
	        { type: Config, },
	    ];
	    /** @nocollapse */
	    Navbar.propDecorators = {
	        'hideBackButton': [{ type: Input },],
	    };
	    return Navbar;
	}(ToolbarBase));
	var NavbarTemplate = (function () {
	    function NavbarTemplate() {
	        // deprecated warning: added 2016-06-14, beta.10
	        console.warn('ion-navbar no longer requires *navbar attribute. Please restructure header to:\n' +
	            '<ion-header>\n' +
	            '  <ion-navbar>\n' +
	            '    ...\n' +
	            '  </ion-navbar>\n' +
	            '</ion-header>');
	    }
	    /** @nocollapse */
	    NavbarTemplate.decorators = [
	        { type: Directive, args: [{
	                    selector: 'template[navbar]'
	                },] },
	    ];
	    /** @nocollapse */
	    NavbarTemplate.ctorParameters = [];
	    return NavbarTemplate;
	}());

	var MenuToggle = (function () {
	    function MenuToggle(_menu, elementRef, _viewCtrl, _navbar) {
	        this._menu = _menu;
	        this._viewCtrl = _viewCtrl;
	        this._navbar = _navbar;
	        this._inNavbar = !!_navbar;
	    }
	    MenuToggle.prototype.toggle = function () {
	        var menu = this._menu.get(this.menuToggle);
	        menu && menu.toggle();
	    };
	    Object.defineProperty(MenuToggle.prototype, "isHidden", {
	        /**
	        * @private
	        */
	        get: function () {
	            if (this._inNavbar && this._viewCtrl) {
	                if (this._viewCtrl.isFirst()) {
	                    // this is the first view, so it should always show
	                    return false;
	                }
	                var menu = this._menu.get(this.menuToggle);
	                if (menu) {
	                    // this is not the root view, so see if this menu
	                    // is configured to still be enabled if it's not the root view
	                    return !menu.persistent;
	                }
	            }
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    MenuToggle.decorators = [
	        { type: Directive, args: [{
	                    selector: '[menuToggle]',
	                    host: {
	                        '[hidden]': 'isHidden',
	                        'menuToggle': '' // ensures the attr is there for css when using [menuToggle]
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    MenuToggle.ctorParameters = [
	        { type: MenuController, },
	        { type: ElementRef, },
	        { type: ViewController, decorators: [{ type: Optional },] },
	        { type: Navbar, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    MenuToggle.propDecorators = {
	        'menuToggle': [{ type: Input },],
	        'toggle': [{ type: HostListener, args: ['click',] },],
	    };
	    return MenuToggle;
	}());

	var MenuClose = (function () {
	    function MenuClose(_menu) {
	        this._menu = _menu;
	    }
	    MenuClose.prototype.close = function () {
	        var menu = this._menu.get(this.menuClose);
	        menu && menu.close();
	    };
	    /** @nocollapse */
	    MenuClose.decorators = [
	        { type: Directive, args: [{
	                    selector: '[menuClose]'
	                },] },
	    ];
	    /** @nocollapse */
	    MenuClose.ctorParameters = [
	        { type: MenuController, },
	    ];
	    /** @nocollapse */
	    MenuClose.propDecorators = {
	        'menuClose': [{ type: Input },],
	        'close': [{ type: HostListener, args: ['click',] },],
	    };
	    return MenuClose;
	}());

	var Badge = (function () {
	    function Badge(config, _elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        var element = _elementRef.nativeElement;
	        this._readAttrs(element);
	    }
	    /**
	     * @private
	     */
	    Badge.prototype._readAttrs = function (element) {
	        var elementAttrs = element.attributes;
	        var attrName;
	        for (var i = 0, l = elementAttrs.length; i < l; i++) {
	            if (elementAttrs[i].value !== '')
	                continue;
	            attrName = elementAttrs[i].name;
	            // Ignore attributes item-left, item-right
	            if (attrName.indexOf('item') === -1) {
	                this._setClass(attrName);
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Badge.prototype._setClass = function (color) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, 'badge-' + color, true);
	    };
	    /** @nocollapse */
	    Badge.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-badge'
	                },] },
	    ];
	    /** @nocollapse */
	    Badge.ctorParameters = [
	        { type: Config, },
	        { type: ElementRef, },
	        { type: Renderer, },
	    ];
	    return Badge;
	}());

	var Button = (function () {
	    function Button(config, _elementRef, _renderer, ionItem) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._role = 'button'; // bar-button/item-button
	        this._size = null; // large/small/default
	        this._style = 'default'; // outline/clear/solid
	        this._shape = null; // round/fab
	        this._display = null; // block/full
	        this._colors = []; // primary/secondary
	        this._icon = null; // left/right/only
	        this._disabled = false; // disabled
	        this.isItem = (ionItem === '');
	        var element = _elementRef.nativeElement;
	        if (config.get('hoverCSS') === false) {
	            _renderer.setElementClass(_elementRef.nativeElement, 'disable-hover', true);
	        }
	        if (element.hasAttribute('ion-item')) {
	            // no need to put on these classes for an ion-item
	            this._role = null;
	            return;
	        }
	        if (element.hasAttribute('disabled')) {
	            this._disabled = true;
	        }
	        this._readAttrs(element);
	    }
	    Object.defineProperty(Button.prototype, "large", {
	        set: function (val) {
	            this._attr('_size', 'large', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "small", {
	        set: function (val) {
	            this._attr('_size', 'small', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "default", {
	        set: function (val) {
	            this._attr('_size', 'default', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "outline", {
	        set: function (val) {
	            this._attr('_style', 'outline', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "clear", {
	        set: function (val) {
	            this._attr('_style', 'clear', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "solid", {
	        set: function (val) {
	            this._attr('_style', 'solid', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "round", {
	        set: function (val) {
	            this._attr('_shape', 'round', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "block", {
	        set: function (val) {
	            this._attr('_display', 'block', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Button.prototype, "full", {
	        set: function (val) {
	            this._attr('_display', 'full', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Button.prototype._attr = function (type, attrName, attrValue) {
	        this._setClass(this[type], false);
	        if (isTrueProperty(attrValue)) {
	            this[type] = attrName;
	            this._setClass(attrName, true);
	        }
	        else {
	            // Special handling for '_style' which defaults to 'default'.
	            this[type] = (type === '_style' ? 'default' : null);
	        }
	        if (type === '_style') {
	            this._setColor(attrName, isTrueProperty(attrValue));
	        }
	    };
	    Object.defineProperty(Button.prototype, "color", {
	        set: function (val) {
	            // Clear the colors for all styles including the default one.
	            this._setColor(BUTTON_STYLE_ATTRS.concat(['default']), false);
	            // Support array input which is also supported via multiple attributes (e.g. primary, secondary, etc).
	            this._colors = (val instanceof Array ? val : [val]);
	            // Set the colors for the currently effective style.
	            this._setColor(this._style, true);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Button.prototype.ngOnInit = function () {
	        // If the button has a role applied to it
	        if (this.category) {
	            this.setRole(this.category);
	        }
	    };
	    /**
	     * @private
	     */
	    Button.prototype.ngAfterContentInit = function () {
	        this._init = true;
	        this._readIcon(this._elementRef.nativeElement);
	        this._assignCss(true);
	    };
	    /**
	     * @private
	     */
	    Button.prototype.ngAfterContentChecked = function () {
	        this._readIcon(this._elementRef.nativeElement);
	        this._assignCss(true);
	    };
	    /**
	     * @private
	     */
	    Button.prototype.addClass = function (className) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, className, true);
	    };
	    /**
	     * @private
	     */
	    Button.prototype.setRole = function (val) {
	        this._role = val;
	    };
	    /**
	     * @private
	     */
	    Button.prototype._readIcon = function (element) {
	        // figure out if and where the icon lives in the button
	        var childNodes = element.childNodes;
	        if (childNodes.length > 0) {
	            childNodes = childNodes[0].childNodes;
	        }
	        var childNode;
	        var nodes = [];
	        for (var i = 0, l = childNodes.length; i < l; i++) {
	            childNode = childNodes[i];
	            if (childNode.nodeType === 3) {
	                // text node
	                if (childNode.textContent.trim() !== '') {
	                    nodes.push(TEXT);
	                }
	            }
	            else if (childNode.nodeType === 1) {
	                if (childNode.nodeName === 'ION-ICON') {
	                    // icon element node
	                    nodes.push(ICON);
	                }
	                else {
	                    // element other than an <ion-icon>
	                    nodes.push(TEXT);
	                }
	            }
	        }
	        // Remove any classes that are set already
	        this._setClass(this._icon, false);
	        if (nodes.length > 1) {
	            if (nodes[0] === ICON && nodes[1] === TEXT) {
	                this._icon = 'icon-left';
	            }
	            else if (nodes[0] === TEXT && nodes[1] === ICON) {
	                this._icon = 'icon-right';
	            }
	        }
	        else if (nodes.length === 1 && nodes[0] === ICON) {
	            this._icon = 'icon-only';
	        }
	    };
	    /**
	     * @private
	     */
	    Button.prototype._readAttrs = function (element) {
	        var elementAttrs = element.attributes;
	        var attrName;
	        for (var i = 0, l = elementAttrs.length; i < l; i++) {
	            if (elementAttrs[i].value !== '')
	                continue;
	            attrName = elementAttrs[i].name;
	            if (BUTTON_STYLE_ATTRS.indexOf(attrName) > -1) {
	                this._style = attrName;
	            }
	            else if (BUTTON_DISPLAY_ATTRS.indexOf(attrName) > -1) {
	                this._display = attrName;
	            }
	            else if (BUTTON_SHAPE_ATTRS.indexOf(attrName) > -1) {
	                this._shape = attrName;
	            }
	            else if (BUTTON_SIZE_ATTRS.indexOf(attrName) > -1) {
	                this._size = attrName;
	            }
	            else if (!(IGNORE_ATTRS.test(attrName))) {
	                this._colors.push(attrName);
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Button.prototype._assignCss = function (assignCssClass) {
	        var role = this._role;
	        if (role) {
	            this._renderer.setElementClass(this._elementRef.nativeElement, role, assignCssClass); // button
	            this._setClass(this._style, assignCssClass); // button-clear
	            this._setClass(this._shape, assignCssClass); // button-round
	            this._setClass(this._display, assignCssClass); // button-full
	            this._setClass(this._size, assignCssClass); // button-small
	            this._setClass(this._icon, assignCssClass); // button-icon-left
	            this._setColor(this._style, assignCssClass); // button-secondary, button-clear-secondary
	        }
	    };
	    /**
	     * @private
	     */
	    Button.prototype._setClass = function (type, assignCssClass) {
	        if (type && this._init) {
	            this._renderer.setElementClass(this._elementRef.nativeElement, this._role + '-' + type.toLowerCase(), assignCssClass);
	        }
	    };
	    /**
	     * @private
	     */
	    Button.prototype._setColor = function (type, assignCssClass) {
	        var _this = this;
	        if (type && this._init) {
	            // Support array to allow removal of many styles at once.
	            var styles = (type instanceof Array ? type : [type]);
	            styles.forEach(function (styleName) {
	                // If the role is not a bar-button, don't apply the solid style
	                styleName = (_this._role !== 'bar-button' && styleName === 'solid' ? 'default' : styleName);
	                var colorStyle = (styleName !== null && styleName !== 'default' ? styleName.toLowerCase() + '-' : '');
	                _this._colors.forEach(function (colorName) {
	                    _this._setClass(colorStyle + colorName, assignCssClass); // button-secondary, button-clear-secondary
	                });
	            });
	        }
	    };
	    /**
	     * @private
	     */
	    Button.setRoles = function (contentButtonChildren, role) {
	        var buttons = contentButtonChildren.toArray();
	        buttons.forEach(function (button) {
	            button.setRole(role);
	        });
	    };
	    /** @nocollapse */
	    Button.decorators = [
	        { type: Component, args: [{
	                    selector: 'button:not([ion-item]),[button]',
	                    // NOTE: template must not contain spaces between elements
	                    template: '<span class="button-inner"><ng-content></ng-content></span><ion-button-effect></ion-button-effect>',
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Button.ctorParameters = [
	        { type: Config, },
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: undefined, decorators: [{ type: Attribute, args: ['ion-item',] },] },
	    ];
	    /** @nocollapse */
	    Button.propDecorators = {
	        'category': [{ type: Input },],
	        'large': [{ type: Input },],
	        'small': [{ type: Input },],
	        'default': [{ type: Input },],
	        'outline': [{ type: Input },],
	        'clear': [{ type: Input },],
	        'solid': [{ type: Input },],
	        'round': [{ type: Input },],
	        'block': [{ type: Input },],
	        'full': [{ type: Input },],
	        'color': [{ type: Input },],
	    };
	    return Button;
	}());
	var BUTTON_SIZE_ATTRS = ['large', 'small', 'default'];
	var BUTTON_STYLE_ATTRS = ['clear', 'outline', 'solid'];
	var BUTTON_SHAPE_ATTRS = ['round', 'fab'];
	var BUTTON_DISPLAY_ATTRS = ['block', 'full'];
	var IGNORE_ATTRS = /_ng|button|left|right/;
	var TEXT = 1;
	var ICON = 2;

	var ScrollView = (function () {
	    function ScrollView(ele) {
	        this._js = false;
	        this._top = 0;
	        this._el = ele;
	    }
	    ScrollView.prototype.getTop = function () {
	        if (this._js) {
	            return this._top;
	        }
	        return this._top = this._el.scrollTop;
	    };
	    ScrollView.prototype.setTop = function (top) {
	        this._top = top;
	        if (this._js) {
	            this._el.style[CSS.transform] = "translate3d(0px," + top * -1 + "px,0px)";
	        }
	        else {
	            this._el.scrollTop = top;
	        }
	    };
	    ScrollView.prototype.scrollTo = function (x, y, duration) {
	        // scroll animation loop w/ easing
	        // credit https://gist.github.com/dezinezync/5487119
	        var self = this;
	        if (!self._el) {
	            // invalid element
	            return Promise.resolve();
	        }
	        x = x || 0;
	        y = y || 0;
	        var fromY = self._el.scrollTop;
	        var fromX = self._el.scrollLeft;
	        var xDistance = Math.abs(x - fromX);
	        var yDistance = Math.abs(y - fromY);
	        var maxAttempts = (duration / 16) + 100;
	        return new Promise(function (resolve) {
	            var startTime;
	            var attempts = 0;
	            // scroll loop
	            function step() {
	                attempts++;
	                if (!self._el || !self.isPlaying || attempts > maxAttempts) {
	                    self.isPlaying = false;
	                    resolve();
	                    return;
	                }
	                var time = Math.min(1, ((Date.now() - startTime) / duration));
	                // where .5 would be 50% of time on a linear scale easedT gives a
	                // fraction based on the easing method
	                var easedT = (--time) * time * time + 1;
	                if (fromY !== y) {
	                    self.setTop((easedT * (y - fromY)) + fromY);
	                }
	                if (fromX !== x) {
	                    self._el.scrollLeft = Math.floor((easedT * (x - fromX)) + fromX);
	                }
	                if (easedT < 1) {
	                    nativeRaf(step);
	                }
	                else {
	                    // done
	                    resolve();
	                }
	            }
	            // start scroll loop
	            self.isPlaying = true;
	            // chill out for a frame first
	            nativeRaf(function () {
	                startTime = Date.now();
	                nativeRaf(step);
	            });
	        });
	    };
	    ScrollView.prototype.scrollToTop = function (duration) {
	        return this.scrollTo(0, 0, duration);
	    };
	    ScrollView.prototype.scrollToBottom = function (duration) {
	        var y = 0;
	        if (this._el) {
	            y = this._el.scrollHeight - this._el.clientHeight;
	        }
	        return this.scrollTo(0, y, duration);
	    };
	    ScrollView.prototype.stop = function () {
	        this.isPlaying = false;
	    };
	    /**
	     * @private
	     * JS Scrolling has been provided only as a temporary solution
	     * until iOS apps can take advantage of scroll events at all times.
	     * The goal is to eventually remove JS scrolling entirely. This
	     * method may be removed in the future.
	     */
	    ScrollView.prototype.jsScroll = function (onScrollCallback) {
	        var _this = this;
	        this._js = true;
	        this._cb = onScrollCallback;
	        this._pos = [];
	        if (this._el) {
	            this._el.addEventListener('touchstart', this._start.bind(this));
	            this._el.addEventListener('touchmove', this._move.bind(this));
	            this._el.addEventListener('touchend', this._end.bind(this));
	            this._el.parentElement.classList.add('js-scroll');
	        }
	        return function () {
	            if (_this._el) {
	                _this._el.removeEventListener('touchstart', _this._start.bind(_this));
	                _this._el.removeEventListener('touchmove', _this._move.bind(_this));
	                _this._el.removeEventListener('touchend', _this._end.bind(_this));
	                _this._el.parentElement.classList.remove('js-scroll');
	            }
	        };
	    };
	    /**
	     * @private
	     * Used for JS scrolling. May be removed in the future.
	     */
	    ScrollView.prototype._start = function (ev) {
	        this._velocity = 0;
	        this._pos.length = 0;
	        this._max = null;
	        this._pos.push(pointerCoord(ev).y, Date.now());
	    };
	    /**
	     * @private
	     * Used for JS scrolling. May be removed in the future.
	     */
	    ScrollView.prototype._move = function (ev) {
	        if (this._pos.length) {
	            var y = pointerCoord(ev).y;
	            // ******** DOM READ ****************
	            this._setMax();
	            this._top -= (y - this._pos[this._pos.length - 2]);
	            this._top = Math.min(Math.max(this._top, 0), this._max);
	            this._pos.push(y, Date.now());
	            // ******** DOM READ THEN DOM WRITE ****************
	            this._cb(this._top);
	            // ******** DOM WRITE ****************
	            this.setTop(this._top);
	        }
	    };
	    /**
	     * @private
	     * Used for JS scrolling. May be removed in the future.
	     */
	    ScrollView.prototype._setMax = function () {
	        if (!this._max) {
	            // ******** DOM READ ****************
	            this._max = (this._el.offsetHeight - this._el.parentElement.offsetHeight + this._el.parentElement.offsetTop);
	        }
	    };
	    /**
	     * @private
	     * Used for JS scrolling. May be removed in the future.
	     */
	    ScrollView.prototype._end = function (ev) {
	        // figure out what the scroll position was about 100ms ago
	        var positions = this._pos;
	        this._velocity = 0;
	        cancelRaf(this._rafId);
	        if (!positions.length)
	            return;
	        var y = pointerCoord(ev).y;
	        positions.push(y, Date.now());
	        var endPos = (positions.length - 1);
	        var startPos = endPos;
	        var timeRange = (Date.now() - 100);
	        // move pointer to position measured 100ms ago
	        for (var i = endPos; i > 0 && positions[i] > timeRange; i -= 2) {
	            startPos = i;
	        }
	        if (startPos !== endPos) {
	            // compute relative movement between these two points
	            var timeOffset = (positions[endPos] - positions[startPos]);
	            var movedTop = (positions[startPos - 1] - positions[endPos - 1]);
	            // based on XXms compute the movement to apply for each render step
	            this._velocity = ((movedTop / timeOffset) * FRAME_MS);
	            // verify that we have enough velocity to start deceleration
	            if (Math.abs(this._velocity) > MIN_VELOCITY_START_DECELERATION) {
	                // ******** DOM READ ****************
	                this._setMax();
	                this._rafId = nativeRaf(this._decelerate.bind(this));
	            }
	        }
	        positions.length = 0;
	    };
	    /**
	     * @private
	     * Used for JS scrolling. May be removed in the future.
	     */
	    ScrollView.prototype._decelerate = function () {
	        var self = this;
	        if (self._velocity) {
	            self._velocity *= DECELERATION_FRICTION;
	            // update top with updated velocity
	            // clamp top within scroll limits
	            self._top = Math.min(Math.max(self._top + self._velocity, 0), self._max);
	            // ******** DOM READ THEN DOM WRITE ****************
	            self._cb(self._top);
	            // ******** DOM WRITE ****************
	            self.setTop(self._top);
	            if (self._top > 0 && self._top < self._max && Math.abs(self._velocity) > MIN_VELOCITY_CONTINUE_DECELERATION) {
	                self._rafId = nativeRaf(self._decelerate.bind(self));
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    ScrollView.prototype.destroy = function () {
	        this._velocity = 0;
	        this.stop();
	        this._el = null;
	    };
	    return ScrollView;
	}());
	var MIN_VELOCITY_START_DECELERATION = 4;
	var MIN_VELOCITY_CONTINUE_DECELERATION = 0.12;
	var DECELERATION_FRICTION = 0.97;
	var FRAME_MS = (1000 / 60);

	var __extends$17 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TabButton = (function (_super) {
	    __extends$17(TabButton, _super);
	    function TabButton(config, elementRef) {
	        _super.call(this, elementRef);
	        this.ionSelect = new EventEmitter();
	        this.disHover = (config.get('hoverCSS') === false);
	        this.layout = config.get('tabbarLayout');
	    }
	    TabButton.prototype.ngOnInit = function () {
	        this.tab.btn = this;
	        this.layout = this.tab.parent.tabbarLayout || this.layout;
	        this.hasTitle = !!this.tab.tabTitle;
	        this.hasIcon = !!this.tab.tabIcon && this.layout !== 'icon-hide';
	        this.hasTitleOnly = (this.hasTitle && !this.hasIcon);
	        this.hasIconOnly = (this.hasIcon && !this.hasTitle);
	        this.hasBadge = !!this.tab.tabBadge;
	    };
	    TabButton.prototype.onClick = function (ev) {
	        this.ionSelect.emit(this.tab);
	        ev.preventDefault();
	    };
	    /** @nocollapse */
	    TabButton.decorators = [
	        { type: Directive, args: [{
	                    selector: '.tab-button',
	                    host: {
	                        '[attr.id]': 'tab._btnId',
	                        '[attr.aria-controls]': 'tab._panelId',
	                        '[attr.aria-selected]': 'tab.isSelected',
	                        '[class.has-title]': 'hasTitle',
	                        '[class.has-icon]': 'hasIcon',
	                        '[class.has-title-only]': 'hasTitleOnly',
	                        '[class.icon-only]': 'hasIconOnly',
	                        '[class.has-badge]': 'hasBadge',
	                        '[class.disable-hover]': 'disHover'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    TabButton.ctorParameters = [
	        { type: Config, },
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    TabButton.propDecorators = {
	        'tab': [{ type: Input },],
	        'ionSelect': [{ type: Output },],
	        'onClick': [{ type: HostListener, args: ['click', ['$event'],] },],
	    };
	    return TabButton;
	}(Ion));

	var TabHighlight = (function () {
	    function TabHighlight(_elementRef) {
	        this._elementRef = _elementRef;
	    }
	    TabHighlight.prototype.select = function (tab) {
	        var _this = this;
	        rafFrames(3, function () {
	            var d = tab.btn.getDimensions();
	            var ele = _this._elementRef.nativeElement;
	            ele.style.transform = 'translate3d(' + d.left + 'px,0,0) scaleX(' + d.width + ')';
	            if (!_this._init) {
	                _this._init = true;
	                rafFrames(6, function () {
	                    ele.classList.add('animate');
	                });
	            }
	        });
	    };
	    /** @nocollapse */
	    TabHighlight.decorators = [
	        { type: Directive, args: [{
	                    selector: 'tab-highlight'
	                },] },
	    ];
	    /** @nocollapse */
	    TabHighlight.ctorParameters = [
	        { type: ElementRef, },
	    ];
	    return TabHighlight;
	}());

	var __extends$16 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Tabs = (function (_super) {
	    __extends$16(Tabs, _super);
	    function Tabs(parent, viewCtrl, _app, _config, _elementRef, _platform, _renderer) {
	        var _this = this;
	        _super.call(this, _elementRef);
	        this._app = _app;
	        this._config = _config;
	        this._elementRef = _elementRef;
	        this._platform = _platform;
	        this._renderer = _renderer;
	        this._ids = -1;
	        this._tabs = [];
	        this._onReady = null;
	        /**
	         * @private
	         */
	        this.selectHistory = [];
	        this.ionChange = new EventEmitter();
	        this.parent = parent;
	        this.id = ++tabIds;
	        this.subPages = _config.getBoolean('tabSubPages');
	        this._useHighlight = _config.getBoolean('tabbarHighlight');
	        this._sbPadding = _config.getBoolean('statusbarPadding');
	        if (parent) {
	            // this Tabs has a parent Nav
	            parent.registerChildNav(this);
	        }
	        else if (this._app) {
	            // this is the root navcontroller for the entire app
	            this._app.setRootNav(this);
	        }
	        // Tabs may also be an actual ViewController which was navigated to
	        // if Tabs is static and not navigated to within a NavController
	        // then skip this and don't treat it as it's own ViewController
	        if (viewCtrl) {
	            viewCtrl.setContent(this);
	            viewCtrl.setContentRef(_elementRef);
	            viewCtrl.loaded = function (done) {
	                _this._onReady = done;
	            };
	        }
	    }
	    /**
	     * @private
	     */
	    Tabs.prototype.ngAfterViewInit = function () {
	        var _this = this;
	        this._setConfig('tabbarPlacement', 'bottom');
	        this._setConfig('tabbarLayout', 'icon-top');
	        if (this._useHighlight) {
	            this._platform.onResize(function () {
	                _this._highlight.select(_this.getSelected());
	            });
	        }
	        var preloadTabs = (isBlank$5(this.preloadTabs) ? this._config.getBoolean('preloadTabs') : isTrueProperty(this.preloadTabs));
	        // get the selected index
	        var selectedIndex = this.selectedIndex ? parseInt(this.selectedIndex, 10) : 0;
	        // ensure the selectedIndex isn't a hidden or disabled tab
	        // also find the first available index incase we need it later
	        var availableIndex = -1;
	        this._tabs.forEach(function (tab, index) {
	            if (tab.enabled && tab.show && availableIndex < 0) {
	                // we know this tab index is safe to show
	                availableIndex = index;
	            }
	            if (index === selectedIndex && (!tab.enabled || !tab.show)) {
	                // the selectedIndex is not safe to show
	                selectedIndex = -1;
	            }
	        });
	        if (selectedIndex < 0) {
	            // the selected index wasn't safe to show
	            // instead use an available index found to be safe to show
	            selectedIndex = availableIndex;
	        }
	        this._tabs.forEach(function (tab, index) {
	            if (index === selectedIndex) {
	                _this.select(tab);
	            }
	            else if (preloadTabs) {
	                tab.preload(1000 * index);
	            }
	        });
	    };
	    /**
	     * @private
	     */
	    Tabs.prototype._setConfig = function (attrKey, fallback) {
	        var val = this[attrKey];
	        if (isBlank$5(val)) {
	            val = this._config.get(attrKey, fallback);
	        }
	        this._renderer.setElementAttribute(this._elementRef.nativeElement, attrKey, val);
	    };
	    /**
	     * @private
	     */
	    Tabs.prototype.add = function (tab) {
	        tab.id = this.id + '-' + (++this._ids);
	        this._tabs.push(tab);
	    };
	    /**
	     * @param {number|Tab} tabOrIndex Index, or the Tab instance, of the tab to select.
	     */
	    Tabs.prototype.select = function (tabOrIndex) {
	        var _this = this;
	        var selectedTab = (typeof tabOrIndex === 'number' ? this.getByIndex(tabOrIndex) : tabOrIndex);
	        if (isBlank$5(selectedTab)) {
	            return;
	        }
	        var deselectedTab = this.getSelected();
	        if (selectedTab === deselectedTab) {
	            // no change
	            return this._touchActive(selectedTab);
	        }
	        console.debug('Tabs, select', selectedTab.id);
	        var opts = {
	            animate: false
	        };
	        var deselectedPage;
	        if (deselectedTab) {
	            deselectedPage = deselectedTab.getActive();
	            deselectedPage && deselectedPage.fireWillLeave();
	        }
	        var selectedPage = selectedTab.getActive();
	        selectedPage && selectedPage.fireWillEnter();
	        selectedTab.load(opts, function (initialLoad) {
	            selectedTab.ionSelect.emit(selectedTab);
	            _this.ionChange.emit(selectedTab);
	            if (selectedTab.root) {
	                // only show the selectedTab if it has a root
	                // it's possible the tab is only for opening modal's or signing out
	                // and doesn't actually have content. In the case there's no content
	                // for a tab then do nothing and leave the current view as is
	                _this._tabs.forEach(function (tab) {
	                    tab.setSelected(tab === selectedTab);
	                });
	                if (_this._useHighlight) {
	                    _this._highlight.select(selectedTab);
	                }
	            }
	            selectedPage && selectedPage.fireDidEnter();
	            deselectedPage && deselectedPage.fireDidLeave();
	            if (_this._onReady) {
	                _this._onReady();
	                _this._onReady = null;
	            }
	            // track the order of which tabs have been selected, by their index
	            // do not track if the tab index is the same as the previous
	            if (_this.selectHistory[_this.selectHistory.length - 1] !== selectedTab.id) {
	                _this.selectHistory.push(selectedTab.id);
	            }
	            // if this is not the Tab's initial load then we need
	            // to refresh the tabbar and content dimensions to be sure
	            // they're lined up correctly
	            if (!initialLoad && selectedPage) {
	                var content = selectedPage.getContent();
	                if (content && content instanceof Content) {
	                    nativeRaf(function () {
	                        content.readDimensions();
	                        content.writeDimensions();
	                    });
	                }
	            }
	        });
	    };
	    /**
	     * Get the previously selected Tab which is currently not disabled or hidden.
	     * @param {boolean} trimHistory If the selection history should be trimmed up to the previous tab selection or not.
	     * @returns {Tab}
	     */
	    Tabs.prototype.previousTab = function (trimHistory) {
	        var _this = this;
	        if (trimHistory === void 0) { trimHistory = true; }
	        // walk backwards through the tab selection history
	        // and find the first previous tab that is enabled and shown
	        console.debug('run previousTab', this.selectHistory);
	        for (var i = this.selectHistory.length - 2; i >= 0; i--) {
	            var tab = this._tabs.find(function (t) { return t.id === _this.selectHistory[i]; });
	            if (tab && tab.enabled && tab.show) {
	                if (trimHistory) {
	                    this.selectHistory.splice(i + 1);
	                }
	                return tab;
	            }
	        }
	        return null;
	    };
	    /**
	     * @param {number} index Index of the tab you want to get
	     * @returns {Tab} Returns the tab who's index matches the one passed
	     */
	    Tabs.prototype.getByIndex = function (index) {
	        if (index < this._tabs.length && index > -1) {
	            return this._tabs[index];
	        }
	        return null;
	    };
	    /**
	     * @return {Tab} Returns the currently selected tab
	     */
	    Tabs.prototype.getSelected = function () {
	        for (var i = 0; i < this._tabs.length; i++) {
	            if (this._tabs[i].isSelected) {
	                return this._tabs[i];
	            }
	        }
	        return null;
	    };
	    /**
	     * @private
	     */
	    Tabs.prototype.getActiveChildNav = function () {
	        return this.getSelected();
	    };
	    /**
	     * @private
	     */
	    Tabs.prototype.getIndex = function (tab) {
	        return this._tabs.indexOf(tab);
	    };
	    /**
	     * @private
	     * "Touch" the active tab, going back to the root view of the tab
	     * or optionally letting the tab handle the event
	     */
	    Tabs.prototype._touchActive = function (tab) {
	        var active = tab.getActive();
	        if (!active) {
	            return Promise.resolve();
	        }
	        var instance = active.instance;
	        // If they have a custom tab selected handler, call it
	        if (instance.ionSelected) {
	            return instance.ionSelected();
	        }
	        // If we're a few pages deep, pop to root
	        if (tab.length() > 1) {
	            // Pop to the root view
	            return tab.popToRoot();
	        }
	        // Otherwise, if the page we're on is not our real root, reset it to our
	        // default root type
	        if (tab.root !== active.componentType) {
	            return tab.setRoot(tab.root);
	        }
	        // And failing all of that, we do something safe and secure
	        return Promise.resolve();
	    };
	    Object.defineProperty(Tabs.prototype, "rootNav", {
	        /**
	         * @private
	         * Returns the root NavController. Returns `null` if Tabs is not
	         * within a NavController.
	         * @returns {NavController}
	         */
	        get: function () {
	            var nav = this.parent;
	            while (nav && nav.parent) {
	                nav = nav.parent;
	            }
	            return nav;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * DOM WRITE
	     */
	    Tabs.prototype.setTabbarPosition = function (top, bottom) {
	        if (this._top !== top || this._bottom !== bottom) {
	            var tabbarEle = this._tabbar.nativeElement;
	            tabbarEle.style.top = (top > -1 ? top + 'px' : '');
	            tabbarEle.style.bottom = (bottom > -1 ? bottom + 'px' : '');
	            tabbarEle.classList.add('show-tabbar');
	            this._top = top;
	            this._bottom = bottom;
	        }
	    };
	    /** @nocollapse */
	    Tabs.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-tabs',
	                    template: "\n    <ion-tabbar role=\"tablist\" #tabbar>\n      <a *ngFor=\"let t of _tabs\" [tab]=\"t\" class=\"tab-button\" [class.tab-disabled]=\"!t.enabled\" [class.tab-hidden]=\"!t.show\" role=\"tab\" href=\"#\" (ionSelect)=\"select($event)\">\n        <ion-icon *ngIf=\"t.tabIcon\" [name]=\"t.tabIcon\" [isActive]=\"t.isSelected\" class=\"tab-button-icon\"></ion-icon>\n        <span *ngIf=\"t.tabTitle\" class=\"tab-button-text\">{{t.tabTitle}}</span>\n        <ion-badge *ngIf=\"t.tabBadge\" class=\"tab-badge\" [ngClass]=\"'badge-' + t.tabBadgeStyle\">{{t.tabBadge}}</ion-badge>\n        <ion-button-effect></ion-button-effect>\n      </a>\n      <tab-highlight></tab-highlight>\n    </ion-tabbar>\n    <ng-content></ng-content>\n    <div #portal tab-portal></div>\n  ",
	                    directives: [Badge, Icon, NgClass, NgFor, NgIf, TabButton, TabHighlight],
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Tabs.ctorParameters = [
	        { type: NavController, decorators: [{ type: Optional },] },
	        { type: ViewController, decorators: [{ type: Optional },] },
	        { type: App, },
	        { type: Config, },
	        { type: ElementRef, },
	        { type: Platform, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    Tabs.propDecorators = {
	        'selectedIndex': [{ type: Input },],
	        'preloadTabs': [{ type: Input },],
	        'tabbarLayout': [{ type: Input },],
	        'tabbarPlacement': [{ type: Input },],
	        'ionChange': [{ type: Output },],
	        '_highlight': [{ type: ViewChild, args: [TabHighlight,] },],
	        '_tabbar': [{ type: ViewChild, args: ['tabbar',] },],
	        'portal': [{ type: ViewChild, args: ['portal', { read: ViewContainerRef },] },],
	    };
	    return Tabs;
	}(Ion));
	var tabIds = -1;

	var __extends$15 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Content = (function (_super) {
	    __extends$15(Content, _super);
	    function Content(_elementRef, config, _app, _keyboard, _zone, viewCtrl, _tabs) {
	        _super.call(this, _elementRef);
	        this._elementRef = _elementRef;
	        this._app = _app;
	        this._keyboard = _keyboard;
	        this._zone = _zone;
	        this._tabs = _tabs;
	        this._inputPolling = false;
	        this._sbPadding = config.getBoolean('statusbarPadding', false);
	        if (viewCtrl) {
	            viewCtrl.setContent(this);
	            viewCtrl.setContentRef(_elementRef);
	        }
	    }
	    /**
	     * @private
	     */
	    Content.prototype.ngOnInit = function () {
	        var _this = this;
	        this._scrollEle = this._elementRef.nativeElement.children[0];
	        this._zone.runOutsideAngular(function () {
	            _this._scroll = new ScrollView(_this._scrollEle);
	            _this._scLsn = _this.addScrollListener(_this._app.setScrolling);
	        });
	    };
	    /**
	     * @private
	     */
	    Content.prototype.ngOnDestroy = function () {
	        this._scLsn && this._scLsn();
	        this._scroll && this._scroll.destroy();
	        this._scrollEle = this._footerEle = this._scLsn = this._scroll = null;
	    };
	    /**
	     * @private
	     */
	    Content.prototype.addScrollListener = function (handler) {
	        return this._addListener('scroll', handler);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.addTouchStartListener = function (handler) {
	        return this._addListener('touchstart', handler);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.addTouchMoveListener = function (handler) {
	        return this._addListener('touchmove', handler);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.addTouchEndListener = function (handler) {
	        return this._addListener('touchend', handler);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.addMouseDownListener = function (handler) {
	        return this._addListener('mousedown', handler);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.addMouseUpListener = function (handler) {
	        return this._addListener('mouseup', handler);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.addMouseMoveListener = function (handler) {
	        return this._addListener('mousemove', handler);
	    };
	    Content.prototype._addListener = function (type, handler) {
	        var _this = this;
	        if (!this._scrollEle) {
	            return;
	        }
	        // ensure we're not creating duplicates
	        this._scrollEle.removeEventListener(type, handler);
	        this._scrollEle.addEventListener(type, handler);
	        return function () {
	            if (_this._scrollEle) {
	                _this._scrollEle.removeEventListener(type, handler);
	            }
	        };
	    };
	    /**
	     * @private
	     */
	    Content.prototype.getScrollElement = function () {
	        return this._scrollEle;
	    };
	    /**
	     * @private
	     * Call a method when scrolling has stopped
	     * @param {Function} callback The method you want perform when scrolling has ended
	     */
	    Content.prototype.onScrollEnd = function (callback) {
	        var lastScrollTop = null;
	        var framesUnchanged = 0;
	        var _scrollEle = this._scrollEle;
	        function next() {
	            var currentScrollTop = _scrollEle.scrollTop;
	            if (lastScrollTop !== null) {
	                if (Math.round(lastScrollTop) === Math.round(currentScrollTop)) {
	                    framesUnchanged++;
	                }
	                else {
	                    framesUnchanged = 0;
	                }
	                if (framesUnchanged > 9) {
	                    return callback();
	                }
	            }
	            lastScrollTop = currentScrollTop;
	            nativeRaf(function () {
	                nativeRaf(next);
	            });
	        }
	        nativeTimeout(next, 100);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.onScrollElementTransitionEnd = function (callback) {
	        transitionEnd(this._scrollEle, callback);
	    };
	    /**
	     * Scroll to the specified position.
	     *
	     * ```ts
	     * import {Component, ViewChild} from '@angular/core';
	     * import {Content} from 'ionic-angular';
	     *
	     * @Component({
	     *   template: `<ion-content>
	     *                <button (click)="scrollTo()">Down 500px</button>
	     *              </ion-content>`
	     * )}
	     * export class MyPage{
	     *   @ViewChild(Content) content: Content;
	     *
	     *   scrollTo() {
	     *     // set the scrollLeft to 0px, and scrollTop to 500px
	     *     // the scroll duration should take 200ms
	     *     this.content.scrollTo(0, 500, 200);
	     *   }
	     * }
	     * ```
	     * @param {number} x  The x-value to scroll to.
	     * @param {number} y  The y-value to scroll to.
	     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
	     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
	     */
	    Content.prototype.scrollTo = function (x, y, duration) {
	        if (duration === void 0) { duration = 300; }
	        return this._scroll.scrollTo(x, y, duration);
	    };
	    /**
	     * Scroll to the top of the content component.
	     *
	     * ```ts
	     * import {Component, ViewChild} from '@angular/core';
	     * import {Content} from 'ionic-angular';
	     *
	     * @Component({
	     *   template: `<ion-content>
	     *                <button (click)="scrollToTop()">Scroll to top</button>
	     *              </ion-content>`
	     * )}
	     * export class MyPage{
	     *   @ViewChild(Content) content: Content;
	     *
	     *   scrollToTop() {
	     *     this.content.scrollToTop();
	     *   }
	     * }
	     * ```
	     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
	     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
	     */
	    Content.prototype.scrollToTop = function (duration) {
	        if (duration === void 0) { duration = 300; }
	        return this._scroll.scrollToTop(duration);
	    };
	    /**
	     * Get the `scrollTop` property of the content's scrollable element.
	     * @returns {number}
	     */
	    Content.prototype.getScrollTop = function () {
	        return this._scroll.getTop();
	    };
	    /**
	     * Set the `scrollTop` property of the content's scrollable element.
	     * @param {number} top
	     */
	    Content.prototype.setScrollTop = function (top) {
	        this._scroll.setTop(top);
	    };
	    /**
	     * Scroll to the bottom of the content component.
	     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.
	     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.
	     */
	    Content.prototype.scrollToBottom = function (duration) {
	        if (duration === void 0) { duration = 300; }
	        return this._scroll.scrollToBottom(duration);
	    };
	    /**
	     * @private
	     */
	    Content.prototype.jsScroll = function (onScrollCallback) {
	        return this._scroll.jsScroll(onScrollCallback);
	    };
	    /**
	     * @private
	     * DOM WRITE
	     */
	    Content.prototype.addCssClass = function (className) {
	        this.getNativeElement().classList.add(className);
	    };
	    Object.defineProperty(Content.prototype, "fullscreen", {
	        get: function () {
	            return !!this._fullscreen;
	        },
	        set: function (val) {
	            this._fullscreen = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * DOM WRITE
	     */
	    Content.prototype.removeCssClass = function (className) {
	        this.getNativeElement().classList.remove(className);
	    };
	    /**
	     * @private
	     * DOM WRITE
	     */
	    Content.prototype.setScrollElementStyle = function (prop, val) {
	        this._scrollEle.style[prop] = val;
	    };
	    /**
	     * Returns the content and scroll elements' dimensions.
	     * @returns {object} dimensions  The content and scroll elements' dimensions
	     * {number} dimensions.contentHeight  content offsetHeight
	     * {number} dimensions.contentTop  content offsetTop
	     * {number} dimensions.contentBottom  content offsetTop+offsetHeight
	     * {number} dimensions.contentWidth  content offsetWidth
	     * {number} dimensions.contentLeft  content offsetLeft
	     * {number} dimensions.contentRight  content offsetLeft + offsetWidth
	     * {number} dimensions.scrollHeight  scroll scrollHeight
	     * {number} dimensions.scrollTop  scroll scrollTop
	     * {number} dimensions.scrollBottom  scroll scrollTop + scrollHeight
	     * {number} dimensions.scrollWidth  scroll scrollWidth
	     * {number} dimensions.scrollLeft  scroll scrollLeft
	     * {number} dimensions.scrollRight  scroll scrollLeft + scrollWidth
	     */
	    Content.prototype.getContentDimensions = function () {
	        var _scrollEle = this._scrollEle;
	        var parentElement = _scrollEle.parentElement;
	        return {
	            contentHeight: parentElement.offsetHeight,
	            contentTop: parentElement.offsetTop,
	            contentBottom: parentElement.offsetTop + parentElement.offsetHeight,
	            contentWidth: parentElement.offsetWidth,
	            contentLeft: parentElement.offsetLeft,
	            contentRight: parentElement.offsetLeft + parentElement.offsetWidth,
	            scrollHeight: _scrollEle.scrollHeight,
	            scrollTop: _scrollEle.scrollTop,
	            scrollBottom: _scrollEle.scrollTop + _scrollEle.scrollHeight,
	            scrollWidth: _scrollEle.scrollWidth,
	            scrollLeft: _scrollEle.scrollLeft,
	            scrollRight: _scrollEle.scrollLeft + _scrollEle.scrollWidth,
	        };
	    };
	    /**
	     * @private
	     * DOM WRITE
	     * Adds padding to the bottom of the scroll element when the keyboard is open
	     * so content below the keyboard can be scrolled into view.
	     */
	    Content.prototype.addScrollPadding = function (newPadding) {
	        if (newPadding > this._scrollPadding) {
	            console.debug('content addScrollPadding', newPadding);
	            this._scrollPadding = newPadding;
	            this._scrollEle.style.paddingBottom = newPadding + 'px';
	        }
	    };
	    /**
	     * @private
	     * DOM WRITE
	     */
	    Content.prototype.clearScrollPaddingFocusOut = function () {
	        var _this = this;
	        if (!this._inputPolling) {
	            this._inputPolling = true;
	            this._keyboard.onClose(function () {
	                _this._scrollPadding = 0;
	                _this._scrollEle.style.paddingBottom = (_this._paddingBottom > 0 ? _this._paddingBottom + 'px' : '');
	                _this._inputPolling = false;
	                _this.addScrollPadding(0);
	            }, 200, Infinity);
	        }
	    };
	    /**
	     * Tell the content to recalculate its dimensions. This should be called
	     * after dynamically adding headers, footers, or tabs.
	     *
	     * ```ts
	     * @Component({
	     *   template: `
	     *     <ion-header>
	     *       <ion-navbar>
	     *         <ion-title>Main Navbar</ion-title>
	     *       </ion-navbar>
	     *       <ion-toolbar *ngIf="showToolbar">
	     *         <ion-title>Dynamic Toolbar</ion-title>
	     *       </ion-toolbar>
	     *     </ion-header>
	     *     <ion-content>
	     *       <button (click)="toggleToolbar()">Toggle Toolbar</button>
	     *     </ion-content>
	     * `})
	     *
	     * class E2EPage {
	     *   @ViewChild(Content) content: Content;
	     *   showToolbar: boolean = false;
	     *
	     *   toggleToolbar() {
	     *     this.showToolbar = !this.showToolbar;
	     *     this.content.resize();
	     *   }
	     * }
	     * ```
	     *
	     */
	    Content.prototype.resize = function () {
	        var _this = this;
	        nativeRaf(function () {
	            _this.readDimensions();
	            _this.writeDimensions();
	        });
	    };
	    /**
	     * @private
	     * DOM READ
	     */
	    Content.prototype.readDimensions = function () {
	        this._paddingTop = 0;
	        this._paddingRight = 0;
	        this._paddingBottom = 0;
	        this._paddingLeft = 0;
	        this._headerHeight = 0;
	        this._footerHeight = 0;
	        this._tabbarPlacement = null;
	        var ele = this._elementRef.nativeElement;
	        if (!ele)
	            return;
	        var parentEle = ele.parentElement;
	        var computedStyle;
	        for (var i = 0; i < parentEle.children.length; i++) {
	            ele = parentEle.children[i];
	            if (ele.tagName === 'ION-CONTENT') {
	                if (this._fullscreen) {
	                    computedStyle = getComputedStyle(ele);
	                    this._paddingTop = parsePxUnit(computedStyle.paddingTop);
	                    this._paddingBottom = parsePxUnit(computedStyle.paddingBottom);
	                    this._paddingRight = parsePxUnit(computedStyle.paddingRight);
	                    this._paddingLeft = parsePxUnit(computedStyle.paddingLeft);
	                }
	            }
	            else if (ele.tagName === 'ION-HEADER') {
	                this._headerHeight = ele.clientHeight;
	            }
	            else if (ele.tagName === 'ION-FOOTER') {
	                this._footerHeight = ele.clientHeight;
	                this._footerEle = ele;
	            }
	        }
	        ele = parentEle;
	        var tabbarEle;
	        while (ele && ele.tagName !== 'ION-MODAL' && !ele.classList.contains('tab-subpage')) {
	            if (ele.tagName === 'ION-TABS') {
	                tabbarEle = ele.firstElementChild;
	                this._tabbarHeight = tabbarEle.clientHeight;
	                if (this._tabbarPlacement === null) {
	                    // this is the first tabbar found, remember it's position
	                    this._tabbarPlacement = ele.getAttribute('tabbarplacement');
	                }
	            }
	            ele = ele.parentElement;
	        }
	    };
	    /**
	     * @private
	     * DOM WRITE
	     */
	    Content.prototype.writeDimensions = function () {
	        var newVal;
	        var scrollEle = this._scrollEle;
	        if (!scrollEle)
	            return;
	        // only write when it has changed
	        if (this._fullscreen) {
	            // adjust the content with padding, allowing content to scroll under headers/footers
	            // however, on iOS you cannot control the margins of the scrollbar (last tested iOS9.2)
	            // only add inline padding styles if the computed padding value, which would
	            // have come from the app's css, is different than the new padding value
	            newVal = this._headerHeight + this._paddingTop;
	            if (this._tabbarPlacement === 'top') {
	                newVal += this._tabbarHeight;
	            }
	            if (newVal !== this.contentTop) {
	                scrollEle.style.paddingTop = (newVal > 0 ? newVal + 'px' : '');
	                this.contentTop = newVal;
	            }
	            newVal = this._footerHeight + this._paddingBottom;
	            if (this._tabbarPlacement === 'bottom') {
	                newVal += this._tabbarHeight;
	                if (newVal > 0 && this._footerEle) {
	                    this._footerEle.style.bottom = (newVal - this._footerHeight - this._paddingBottom) + 'px';
	                }
	            }
	            if (newVal !== this.contentBottom) {
	                scrollEle.style.paddingBottom = (newVal > 0 ? newVal + 'px' : '');
	                this.contentBottom = newVal;
	            }
	        }
	        else {
	            // adjust the content with margins
	            newVal = this._headerHeight;
	            if (this._tabbarPlacement === 'top') {
	                newVal += this._tabbarHeight;
	            }
	            if (newVal !== this.contentTop) {
	                scrollEle.style.marginTop = (newVal > 0 ? newVal + 'px' : '');
	                this.contentTop = newVal;
	            }
	            newVal = this._footerHeight;
	            if (this._tabbarPlacement === 'bottom') {
	                newVal += this._tabbarHeight;
	            }
	            if (newVal !== this.contentBottom) {
	                scrollEle.style.marginBottom = (newVal > 0 ? newVal + 'px' : '');
	                this.contentBottom = newVal;
	                if (newVal > 0 && this._footerEle) {
	                    this._footerEle.style.bottom = (newVal - this._footerHeight) + 'px';
	                }
	            }
	        }
	        if (this._tabbarPlacement !== null && this._tabs) {
	            // set the position of the tabbar
	            if (this._tabbarPlacement === 'top') {
	                this._tabs.setTabbarPosition(this._headerHeight, -1);
	            }
	            else {
	                this._tabs.setTabbarPosition(-1, 0);
	            }
	        }
	    };
	    /** @nocollapse */
	    Content.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-content',
	                    template: '<scroll-content>' +
	                        '<ng-content></ng-content>' +
	                        '</scroll-content>' +
	                        '<ng-content select="ion-fixed"></ng-content>' +
	                        '<ng-content select="ion-refresher"></ng-content>',
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                    host: {
	                        '[class.statusbar-padding]': '_sbPadding'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    Content.ctorParameters = [
	        { type: ElementRef, },
	        { type: Config, },
	        { type: App, },
	        { type: Keyboard, },
	        { type: NgZone, },
	        { type: ViewController, decorators: [{ type: Optional },] },
	        { type: Tabs, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    Content.propDecorators = {
	        'fullscreen': [{ type: Input },],
	    };
	    return Content;
	}(Ion));
	function parsePxUnit(val) {
	    return (val.indexOf('px') > 0) ? parseInt(val, 10) : 0;
	}

	var Img = (function () {
	    function Img(_elementRef, _platform, _zone) {
	        this._elementRef = _elementRef;
	        this._platform = _platform;
	        this._zone = _zone;
	        this._src = '';
	        this._normalizeSrc = '';
	        this._imgs = [];
	        this._enabled = true;
	    }
	    Object.defineProperty(Img.prototype, "src", {
	        set: function (val) {
	            var tmpImg = new Image();
	            tmpImg.src = isPresent$5(val) ? val : '';
	            this._src = isPresent$5(val) ? val : '';
	            this._normalizeSrc = tmpImg.src;
	            if (this._init) {
	                this._update();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Img.prototype.ngOnInit = function () {
	        this._init = true;
	        this._update();
	    };
	    Img.prototype._update = function () {
	        var _this = this;
	        if (this._enabled && this._src !== '') {
	            // actively update the image
	            for (var i = this._imgs.length - 1; i >= 0; i--) {
	                if (this._imgs[i].src === this._normalizeSrc) {
	                    // this is the active image
	                    if (this._imgs[i].complete) {
	                        this._loaded(true);
	                    }
	                }
	                else {
	                    // no longer the active image
	                    if (this._imgs[i].parentElement) {
	                        this._imgs[i].parentElement.removeChild(this._imgs[i]);
	                    }
	                    this._imgs.splice(i, 1);
	                }
	            }
	            if (!this._imgs.length) {
	                this._zone.runOutsideAngular(function () {
	                    var img = new Image();
	                    img.style.width = _this._width;
	                    img.style.height = _this._height;
	                    if (isPresent$5(_this.alt)) {
	                        img.alt = _this.alt;
	                    }
	                    if (isPresent$5(_this.title)) {
	                        img.title = _this.title;
	                    }
	                    img.addEventListener('load', function () {
	                        if (img.src === _this._normalizeSrc) {
	                            _this._elementRef.nativeElement.appendChild(img);
	                            nativeRaf(function () {
	                                _this._update();
	                            });
	                        }
	                    });
	                    img.src = _this._src;
	                    _this._imgs.push(img);
	                    _this._loaded(false);
	                });
	            }
	        }
	        else {
	            // do not actively update the image
	            if (!this._imgs.some(function (img) { return img.src === _this._normalizeSrc; })) {
	                this._loaded(false);
	            }
	        }
	    };
	    Img.prototype._loaded = function (isLoaded) {
	        this._elementRef.nativeElement.classList[isLoaded ? 'add' : 'remove']('img-loaded');
	    };
	    Img.prototype.enable = function (shouldEnable) {
	        this._enabled = shouldEnable;
	        this._update();
	    };
	    Object.defineProperty(Img.prototype, "width", {
	        set: function (val) {
	            this._w = getUnitValue(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Img.prototype, "height", {
	        set: function (val) {
	            this._h = getUnitValue(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Img.prototype, "_width", {
	        get: function () {
	            return isPresent$5(this._w) ? this._w : '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Img.prototype, "_height", {
	        get: function () {
	            return isPresent$5(this._h) ? this._h : '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    Img.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-img',
	                    template: '<div class="img-placeholder" [style.height]="_h" [style.width]="_w"></div>',
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Img.ctorParameters = [
	        { type: ElementRef, },
	        { type: Platform, },
	        { type: NgZone, },
	    ];
	    /** @nocollapse */
	    Img.propDecorators = {
	        'src': [{ type: Input },],
	        'width': [{ type: Input },],
	        'height': [{ type: Input },],
	        'alt': [{ type: Input },],
	        'title': [{ type: Input },],
	        '_width': [{ type: HostBinding, args: ['style.width',] },],
	        '_height': [{ type: HostBinding, args: ['style.height',] },],
	    };
	    return Img;
	}());
	function getUnitValue(val) {
	    if (isPresent$5(val)) {
	        if (typeof val === 'string') {
	            if (val.indexOf('%') > -1 || val.indexOf('px') > -1) {
	                return val;
	            }
	            if (val.length) {
	                return val + 'px';
	            }
	        }
	        else if (typeof val === 'number') {
	            return val + 'px';
	        }
	    }
	    return '';
	}

	var __extends$18 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Scroll = (function (_super) {
	    __extends$18(Scroll, _super);
	    function Scroll(elementRef) {
	        _super.call(this, elementRef);
	        /**
	         * @private
	         */
	        this.maxScale = 3;
	        /**
	         * @private
	         */
	        this.zoomDuration = 250;
	    }
	    /**
	     * @private
	     */
	    Scroll.prototype.ngOnInit = function () {
	        this.scrollElement = this.getNativeElement().children[0];
	    };
	    /**
	     * @private
	     * Add a scroll event handler to the scroll element if it exists.
	     * @param {Function} handler  The scroll handler to add to the scroll element.
	     * @returns {?Function} a function to remove the specified handler, otherwise
	     * undefined if the scroll element doesn't exist.
	     */
	    Scroll.prototype.addScrollEventListener = function (handler) {
	        var _this = this;
	        if (!this.scrollElement) {
	            return;
	        }
	        this.scrollElement.addEventListener('scroll', handler);
	        return function () {
	            _this.scrollElement.removeEventListener('scroll', handler);
	        };
	    };
	    /** @nocollapse */
	    Scroll.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-scroll',
	                    inputs: [
	                        'scrollX', 'scrollY', 'zoom', 'maxZoom'
	                    ],
	                    host: {
	                        '[class.scroll-x]': 'scrollX',
	                        '[class.scroll-y]': 'scrollY'
	                    },
	                    template: '<scroll-content>' +
	                        '<div class="scroll-zoom-wrapper">' +
	                        '<ng-content></ng-content>' +
	                        '</div>' +
	                        '</scroll-content>',
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Scroll.ctorParameters = [
	        { type: ElementRef, },
	    ];
	    return Scroll;
	}(Ion));

	var InfiniteScroll = (function () {
	    function InfiniteScroll(_content, _zone, _elementRef) {
	        this._content = _content;
	        this._zone = _zone;
	        this._elementRef = _elementRef;
	        this._lastCheck = 0;
	        this._highestY = 0;
	        this._thr = '15%';
	        this._thrPx = 0;
	        this._thrPc = 0.15;
	        this._init = false;
	        this.state = STATE_ENABLED;
	        this.ionInfinite = new EventEmitter();
	        _content.addCssClass('has-infinite-scroll');
	    }
	    Object.defineProperty(InfiniteScroll.prototype, "threshold", {
	        get: function () {
	            return this._thr;
	        },
	        set: function (val) {
	            this._thr = val;
	            if (val.indexOf('%') > -1) {
	                this._thrPx = 0;
	                this._thrPc = (parseFloat(val) / 100);
	            }
	            else {
	                this._thrPx = parseFloat(val);
	                this._thrPc = 0;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    InfiniteScroll.prototype._onScroll = function () {
	        var _this = this;
	        if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
	            return 1;
	        }
	        var now = Date.now();
	        if (this._lastCheck + 32 > now) {
	            // no need to check less than every XXms
	            return 2;
	        }
	        this._lastCheck = now;
	        var infiniteHeight = this._elementRef.nativeElement.scrollHeight;
	        if (!infiniteHeight) {
	            // if there is no height of this element then do nothing
	            return 3;
	        }
	        var d = this._content.getContentDimensions();
	        var reloadY = d.contentHeight;
	        if (this._thrPc) {
	            reloadY += (reloadY * this._thrPc);
	        }
	        else {
	            reloadY += this._thrPx;
	        }
	        var distanceFromInfinite = ((d.scrollHeight - infiniteHeight) - d.scrollTop) - reloadY;
	        if (distanceFromInfinite < 0) {
	            this._zone.run(function () {
	                if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
	                    _this.state = STATE_LOADING;
	                    _this.ionInfinite.emit(_this);
	                }
	            });
	            return 5;
	        }
	        return 6;
	    };
	    /**
	     * Call `complete()` within the `infinite` output event handler when
	     * your async operation has completed. For example, the `loading`
	     * state is while the app is performing an asynchronous operation,
	     * such as receiving more data from an AJAX request to add more items
	     * to a data list. Once the data has been received and UI updated, you
	     * then call this method to signify that the loading has completed.
	     * This method will change the infinite scroll's state from `loading`
	     * to `enabled`.
	     */
	    InfiniteScroll.prototype.complete = function () {
	        this.state = STATE_ENABLED;
	    };
	    /**
	     * Call `enable(false)` to disable the infinite scroll from actively
	     * trying to receive new data while scrolling. This method is useful
	     * when it is known that there is no more data that can be added, and
	     * the infinite scroll is no longer needed.
	     * @param {boolean} shouldEnable  If the infinite scroll should be
	     * enabled or not. Setting to `false` will remove scroll event listeners
	     * and hide the display.
	     */
	    InfiniteScroll.prototype.enable = function (shouldEnable) {
	        this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
	        this._setListeners(shouldEnable);
	    };
	    InfiniteScroll.prototype._setListeners = function (shouldListen) {
	        var _this = this;
	        if (this._init) {
	            if (shouldListen) {
	                if (!this._scLsn) {
	                    this._zone.runOutsideAngular(function () {
	                        _this._scLsn = _this._content.addScrollListener(_this._onScroll.bind(_this));
	                    });
	                }
	            }
	            else {
	                this._scLsn && this._scLsn();
	                this._scLsn = null;
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    InfiniteScroll.prototype.ngAfterContentInit = function () {
	        this._init = true;
	        this._setListeners(this.state !== STATE_DISABLED);
	    };
	    /**
	     * @private
	     */
	    InfiniteScroll.prototype.ngOnDestroy = function () {
	        this._setListeners(false);
	    };
	    /** @nocollapse */
	    InfiniteScroll.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-infinite-scroll'
	                },] },
	    ];
	    /** @nocollapse */
	    InfiniteScroll.ctorParameters = [
	        { type: Content, decorators: [{ type: Host },] },
	        { type: NgZone, },
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    InfiniteScroll.propDecorators = {
	        'threshold': [{ type: Input },],
	        'ionInfinite': [{ type: Output },],
	    };
	    return InfiniteScroll;
	}());
	var STATE_ENABLED = 'enabled';
	var STATE_DISABLED = 'disabled';
	var STATE_LOADING = 'loading';

	var Spinner = (function () {
	    function Spinner(_config) {
	        this._config = _config;
	        this._dur = null;
	        this.paused = false;
	    }
	    Object.defineProperty(Spinner.prototype, "name", {
	        get: function () {
	            return this._name;
	        },
	        set: function (val) {
	            this._name = val;
	            this.load();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Spinner.prototype, "duration", {
	        get: function () {
	            return this._dur;
	        },
	        set: function (val) {
	            this._dur = val;
	            this.load();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Spinner.prototype.ngOnInit = function () {
	        this._init = true;
	        this.load();
	    };
	    /**
	     * @private
	     */
	    Spinner.prototype.load = function () {
	        if (this._init) {
	            this._l = [];
	            this._c = [];
	            var name = this._name || this._config.get('spinner', 'ios');
	            var spinner = SPINNERS[name];
	            if (spinner) {
	                this._applied = 'spinner-' + name;
	                if (spinner.lines) {
	                    for (var i = 0, l = spinner.lines; i < l; i++) {
	                        this._l.push(this._loadEle(spinner, i, l));
	                    }
	                }
	                else if (spinner.circles) {
	                    for (var i = 0, l = spinner.circles; i < l; i++) {
	                        this._c.push(this._loadEle(spinner, i, l));
	                    }
	                }
	            }
	        }
	    };
	    Spinner.prototype._loadEle = function (spinner, index, total) {
	        var duration = this._dur || spinner.dur;
	        var data = spinner.fn(duration, index, total);
	        data.style.animationDuration = duration + 'ms';
	        return data;
	    };
	    /** @nocollapse */
	    Spinner.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-spinner',
	                    template: "\n    <svg viewBox=\"0 0 64 64\" *ngFor=\"let i of _c\" [ngStyle]=\"i.style\">\n     <circle [attr.r]=\"i.r\" transform=\"translate(32,32)\"></circle>\n    </svg>\n    <svg viewBox=\"0 0 64 64\" *ngFor=\"let i of _l\" [ngStyle]=\"i.style\">\n     <line [attr.y1]=\"i.y1\" [attr.y2]=\"i.y2\" transform=\"translate(32,32)\"></line>\n    </svg>\n  ",
	                    directives: [NgFor, NgStyle],
	                    host: {
	                        '[class]': '_applied',
	                        '[class.spinner-paused]': 'paused'
	                    },
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Spinner.ctorParameters = [
	        { type: Config, },
	    ];
	    /** @nocollapse */
	    Spinner.propDecorators = {
	        'name': [{ type: Input },],
	        'duration': [{ type: Input },],
	        'paused': [{ type: Input },],
	    };
	    return Spinner;
	}());
	var SPINNERS = {
	    ios: {
	        dur: 1000,
	        lines: 12,
	        fn: function (dur, index, total) {
	            return {
	                y1: 17,
	                y2: 29,
	                style: {
	                    transform: 'rotate(' + (30 * index + (index < 6 ? 180 : -180)) + 'deg)',
	                    animationDelay: -(dur - ((dur / total) * index)) + 'ms'
	                }
	            };
	        }
	    },
	    'ios-small': {
	        dur: 1000,
	        lines: 12,
	        fn: function (dur, index, total) {
	            return {
	                y1: 12,
	                y2: 20,
	                style: {
	                    transform: 'rotate(' + (30 * index + (index < 6 ? 180 : -180)) + 'deg)',
	                    animationDelay: -(dur - ((dur / total) * index)) + 'ms'
	                }
	            };
	        }
	    },
	    bubbles: {
	        dur: 1000,
	        circles: 9,
	        fn: function (dur, index, total) {
	            return {
	                r: 5,
	                style: {
	                    top: 9 * Math.sin(2 * Math.PI * index / total),
	                    left: 9 * Math.cos(2 * Math.PI * index / total),
	                    animationDelay: -(dur - ((dur / total) * index)) + 'ms'
	                }
	            };
	        }
	    },
	    circles: {
	        dur: 1000,
	        circles: 8,
	        fn: function (dur, index, total) {
	            return {
	                r: 5,
	                style: {
	                    top: 9 * Math.sin(2 * Math.PI * index / total),
	                    left: 9 * Math.cos(2 * Math.PI * index / total),
	                    animationDelay: -(dur - ((dur / total) * index)) + 'ms'
	                }
	            };
	        }
	    },
	    crescent: {
	        dur: 750,
	        circles: 1,
	        fn: function (dur) {
	            return {
	                r: 26,
	                style: {}
	            };
	        }
	    },
	    dots: {
	        dur: 750,
	        circles: 3,
	        fn: function (dur, index, total) {
	            return {
	                r: 6,
	                style: {
	                    left: (9 - (9 * index)),
	                    animationDelay: -(110 * index) + 'ms'
	                }
	            };
	        }
	    }
	};

	var InfiniteScrollContent = (function () {
	    function InfiniteScrollContent(inf, _config) {
	        this.inf = inf;
	        this._config = _config;
	    }
	    /**
	     * @private
	     */
	    InfiniteScrollContent.prototype.ngOnInit = function () {
	        if (!this.loadingSpinner) {
	            this.loadingSpinner = this._config.get('infiniteLoadingSpinner', this._config.get('spinner', 'ios'));
	        }
	    };
	    /** @nocollapse */
	    InfiniteScrollContent.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-infinite-scroll-content',
	                    template: '<div class="infinite-loading">' +
	                        '<div class="infinite-loading-spinner" *ngIf="loadingSpinner">' +
	                        '<ion-spinner [name]="loadingSpinner"></ion-spinner>' +
	                        '</div>' +
	                        '<div class="infinite-loading-text" [innerHTML]="loadingText" *ngIf="loadingText"></div>' +
	                        '</div>',
	                    directives: [NgIf, Spinner],
	                    host: {
	                        '[attr.state]': 'inf.state'
	                    },
	                    encapsulation: ViewEncapsulation.None
	                },] },
	    ];
	    /** @nocollapse */
	    InfiniteScrollContent.ctorParameters = [
	        { type: InfiniteScroll, },
	        { type: Config, },
	    ];
	    /** @nocollapse */
	    InfiniteScrollContent.propDecorators = {
	        'loadingSpinner': [{ type: Input },],
	        'loadingText': [{ type: Input },],
	    };
	    return InfiniteScrollContent;
	}());

	/**
	 * @private
	 */
	var PointerEvents = (function () {
	    function PointerEvents(ele, pointerDown, pointerMove, pointerUp, zone, option) {
	        var _this = this;
	        this.ele = ele;
	        this.pointerDown = pointerDown;
	        this.pointerMove = pointerMove;
	        this.pointerUp = pointerUp;
	        this.zone = zone;
	        this.option = option;
	        this.rmTouchStart = null;
	        this.rmTouchMove = null;
	        this.rmTouchEnd = null;
	        this.rmMouseStart = null;
	        this.rmMouseMove = null;
	        this.rmMouseUp = null;
	        this.lastTouchEvent = 0;
	        this.mouseWait = 2 * 1000;
	        this.rmTouchStart = listenEvent(ele, 'touchstart', zone, option, function (ev) { return _this.handleTouchStart(ev); });
	        this.rmMouseStart = listenEvent(ele, 'mousedown', zone, option, function (ev) { return _this.handleMouseDown(ev); });
	    }
	    PointerEvents.prototype.handleTouchStart = function (ev) {
	        var _this = this;
	        this.lastTouchEvent = Date.now() + this.mouseWait;
	        if (!this.pointerDown(ev)) {
	            return;
	        }
	        if (!this.rmTouchMove) {
	            this.rmTouchMove = listenEvent(this.ele, 'touchmove', this.zone, this.option, this.pointerMove);
	        }
	        if (!this.rmTouchEnd) {
	            this.rmTouchEnd = listenEvent(this.ele, 'touchend', this.zone, this.option, function (ev) { return _this.handleTouchEnd(ev); });
	        }
	    };
	    PointerEvents.prototype.handleMouseDown = function (ev) {
	        var _this = this;
	        if (this.lastTouchEvent > Date.now()) {
	            console.debug('mousedown event dropped because of previous touch');
	            return;
	        }
	        if (!this.pointerDown(ev)) {
	            return;
	        }
	        if (!this.rmMouseMove) {
	            this.rmMouseMove = listenEvent(window, 'mousemove', this.zone, this.option, this.pointerMove);
	        }
	        if (!this.rmMouseUp) {
	            this.rmMouseUp = listenEvent(window, 'mouseup', this.zone, this.option, function (ev) { return _this.handleMouseUp(ev); });
	        }
	    };
	    PointerEvents.prototype.handleTouchEnd = function (ev) {
	        this.rmTouchMove && this.rmTouchMove();
	        this.rmTouchMove = null;
	        this.rmTouchEnd && this.rmTouchEnd();
	        this.rmTouchEnd = null;
	        this.pointerUp(ev);
	    };
	    PointerEvents.prototype.handleMouseUp = function (ev) {
	        this.rmMouseMove && this.rmMouseMove();
	        this.rmMouseMove = null;
	        this.rmMouseUp && this.rmMouseUp();
	        this.rmMouseUp = null;
	        this.pointerUp(ev);
	    };
	    PointerEvents.prototype.stop = function () {
	        this.rmTouchMove && this.rmTouchMove();
	        this.rmTouchEnd && this.rmTouchEnd();
	        this.rmTouchMove = null;
	        this.rmTouchEnd = null;
	        this.rmMouseMove && this.rmMouseMove();
	        this.rmMouseUp && this.rmMouseUp();
	        this.rmMouseMove = null;
	        this.rmMouseUp = null;
	    };
	    PointerEvents.prototype.destroy = function () {
	        this.rmTouchStart && this.rmTouchStart();
	        this.rmTouchStart = null;
	        this.rmMouseStart && this.rmMouseStart();
	        this.rmMouseStart = null;
	        this.stop();
	        this.pointerDown = null;
	        this.pointerMove = null;
	        this.pointerUp = null;
	        this.ele = null;
	    };
	    return PointerEvents;
	}());
	/**
	 * @private
	 */
	var UIEventManager = (function () {
	    function UIEventManager(zoneWrapped) {
	        if (zoneWrapped === void 0) { zoneWrapped = true; }
	        this.zoneWrapped = zoneWrapped;
	        this.events = [];
	    }
	    UIEventManager.prototype.listenRef = function (ref, eventName, callback, option) {
	        return this.listen(ref.nativeElement, eventName, callback, option);
	    };
	    UIEventManager.prototype.pointerEventsRef = function (ref, pointerStart, pointerMove, pointerEnd, option) {
	        return this.pointerEvents(ref.nativeElement, pointerStart, pointerMove, pointerEnd, option);
	    };
	    UIEventManager.prototype.pointerEvents = function (element, pointerDown, pointerMove, pointerUp, option) {
	        if (option === void 0) { option = false; }
	        if (!element) {
	            return;
	        }
	        var submanager = new PointerEvents(element, pointerDown, pointerMove, pointerUp, this.zoneWrapped, option);
	        var removeFunc = function () { return submanager.destroy(); };
	        this.events.push(removeFunc);
	        return submanager;
	    };
	    UIEventManager.prototype.listen = function (element, eventName, callback, option) {
	        if (option === void 0) { option = false; }
	        if (!element) {
	            return;
	        }
	        var removeFunc = listenEvent(element, eventName, this.zoneWrapped, option, callback);
	        this.events.push(removeFunc);
	        return removeFunc;
	    };
	    UIEventManager.prototype.unlistenAll = function () {
	        for (var _i = 0, _a = this.events; _i < _a.length; _i++) {
	            var event_1 = _a[_i];
	            event_1();
	        }
	        this.events.length = 0;
	    };
	    return UIEventManager;
	}());
	function listenEvent(ele, eventName, zoneWrapped, option, callback) {
	    var rawEvent = ('__zone_symbol__addEventListener' in ele && !zoneWrapped);
	    if (rawEvent) {
	        ele.__zone_symbol__addEventListener(eventName, callback, option);
	        return function () { return ele.__zone_symbol__removeEventListener(eventName, callback); };
	    }
	    else {
	        ele.addEventListener(eventName, callback, option);
	        return function () { return ele.removeEventListener(eventName, callback); };
	    }
	}

	var Refresher = (function () {
	    function Refresher(_content, _zone) {
	        this._content = _content;
	        this._zone = _zone;
	        this._appliedStyles = false;
	        this._lastCheck = 0;
	        this._isEnabled = true;
	        this._events = new UIEventManager(false);
	        this._top = '';
	        /**
	         * The current state which the refresher is in. The refresher's states include:
	         *
	         * - `inactive` - The refresher is not being pulled down or refreshing and is currently hidden.
	         * - `pulling` - The user is actively pulling down the refresher, but has not reached the point yet that if the user lets go, it'll refresh.
	         * - `cancelling` - The user pulled down the refresher and let go, but did not pull down far enough to kick off the `refreshing` state. After letting go, the refresher is in the `cancelling` state while it is closing, and will go back to the `inactive` state once closed.
	         * - `ready` - The user has pulled down the refresher far enough that if they let go, it'll begin the `refreshing` state.
	         * - `refreshing` - The refresher is actively waiting on the async operation to end. Once the refresh handler calls `complete()` it will begin the `completing` state.
	         * - `completing` - The `refreshing` state has finished and the refresher is in the process of closing itself. Once closed, the refresher will go back to the `inactive` state.
	         */
	        this.state = STATE_INACTIVE$1;
	        /**
	         * The Y coordinate of where the user started to the pull down the content.
	         */
	        this.startY = null;
	        /**
	         * The current touch or mouse event's Y coordinate.
	         */
	        this.currentY = null;
	        /**
	         * The distance between the start of the pull and the current touch or
	         * mouse event's Y coordinate.
	         */
	        this.deltaY = null;
	        /**
	         * A number representing how far down the user has pulled.
	         * The number `0` represents the user hasn't pulled down at all. The
	         * number `1`, and anything greater than `1`, represents that the user
	         * has pulled far enough down that when they let go then the refresh will
	         * happen. If they let go and the number is less than `1`, then the
	         * refresh will not happen, and the content will return to it's original
	         * position.
	         */
	        this.progress = 0;
	        this.pullMin = 60;
	        this.pullMax = this.pullMin + 60;
	        this.closeDuration = 280;
	        this.snapbackDuration = 280;
	        this.ionRefresh = new EventEmitter();
	        this.ionPull = new EventEmitter();
	        this.ionStart = new EventEmitter();
	        _content.addCssClass('has-refresher');
	    }
	    Object.defineProperty(Refresher.prototype, "enabled", {
	        get: function () {
	            return this._isEnabled;
	        },
	        set: function (val) {
	            this._isEnabled = isTrueProperty(val);
	            this._setListeners(this._isEnabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Refresher.prototype._onStart = function (ev) {
	        // if multitouch then get out immediately
	        if (ev.touches && ev.touches.length > 1) {
	            return false;
	        }
	        if (this.state !== STATE_INACTIVE$1) {
	            return false;
	        }
	        var scrollHostScrollTop = this._content.getContentDimensions().scrollTop;
	        // if the scrollTop is greater than zero then it's
	        // not possible to pull the content down yet
	        if (scrollHostScrollTop > 0) {
	            return false;
	        }
	        var coord = pointerCoord(ev);
	        console.debug('Pull-to-refresh, onStart', ev.type, 'y:', coord.y);
	        if (this._content.contentTop > 0) {
	            var newTop = this._content.contentTop + 'px';
	            if (this._top !== newTop) {
	                this._top = newTop;
	            }
	        }
	        this.startY = this.currentY = coord.y;
	        this.progress = 0;
	        this.state = STATE_PULLING;
	        return true;
	    };
	    Refresher.prototype._onMove = function (ev) {
	        // this method can get called like a bazillion times per second,
	        // so it's built to be as efficient as possible, and does its
	        // best to do any DOM read/writes only when absolutely necessary
	        var _this = this;
	        // if multitouch then get out immediately
	        if (ev.touches && ev.touches.length > 1) {
	            return 1;
	        }
	        // do nothing if it's actively refreshing
	        // or it's in the process of closing
	        // or this was never a startY
	        if (this.startY === null || this.state === STATE_REFRESHING || this.state === STATE_CANCELLING || this.state === STATE_COMPLETING) {
	            return 2;
	        }
	        // if we just updated stuff less than 16ms ago
	        // then don't check again, just chillout plz
	        var now = Date.now();
	        if (this._lastCheck + 16 > now) {
	            return 3;
	        }
	        // remember the last time we checked all this
	        this._lastCheck = now;
	        // get the current pointer coordinates
	        var coord = pointerCoord(ev);
	        this.currentY = coord.y;
	        // it's now possible they could be pulling down the content
	        // how far have they pulled so far?
	        this.deltaY = (coord.y - this.startY);
	        // don't bother if they're scrolling up
	        // and have not already started dragging
	        if (this.deltaY <= 0) {
	            // the current Y is higher than the starting Y
	            // so they scrolled up enough to be ignored
	            this.progress = 0;
	            if (this.state !== STATE_INACTIVE$1) {
	                this._zone.run(function () {
	                    _this.state = STATE_INACTIVE$1;
	                });
	            }
	            if (this._appliedStyles) {
	                // reset the styles only if they were applied
	                this._setCss(0, '', false, '');
	                return 5;
	            }
	            return 6;
	        }
	        if (this.state === STATE_INACTIVE$1) {
	            // this refresh is not already actively pulling down
	            // get the content's scrollTop
	            var scrollHostScrollTop = this._content.getContentDimensions().scrollTop;
	            // if the scrollTop is greater than zero then it's
	            // not possible to pull the content down yet
	            if (scrollHostScrollTop > 0) {
	                this.progress = 0;
	                this.startY = null;
	                return 7;
	            }
	            // content scrolled all the way to the top, and dragging down
	            this.state = STATE_PULLING;
	        }
	        // prevent native scroll events
	        ev.preventDefault();
	        // the refresher is actively pulling at this point
	        // move the scroll element within the content element
	        this._setCss(this.deltaY, '0ms', true, '');
	        if (!this.deltaY) {
	            // don't continue if there's no delta yet
	            this.progress = 0;
	            return 8;
	        }
	        // so far so good, let's run this all back within zone now
	        this._zone.run(function () {
	            _this._onMoveInZone();
	        });
	    };
	    Refresher.prototype._onMoveInZone = function () {
	        // set pull progress
	        this.progress = (this.deltaY / this.pullMin);
	        // emit "start" if it hasn't started yet
	        if (!this._didStart) {
	            this._didStart = true;
	            this.ionStart.emit(this);
	        }
	        // emit "pulling" on every move
	        this.ionPull.emit(this);
	        // do nothing if the delta is less than the pull threshold
	        if (this.deltaY < this.pullMin) {
	            // ensure it stays in the pulling state, cuz its not ready yet
	            this.state = STATE_PULLING;
	            return 2;
	        }
	        if (this.deltaY > this.pullMax) {
	            // they pulled farther than the max, so kick off the refresh
	            this._beginRefresh();
	            return 3;
	        }
	        // pulled farther than the pull min!!
	        // it is now in the `ready` state!!
	        // if they let go then it'll refresh, kerpow!!
	        this.state = STATE_READY;
	        return 4;
	    };
	    Refresher.prototype._onEnd = function (ev) {
	        // only run in a zone when absolutely necessary
	        var _this = this;
	        if (this.state === STATE_READY) {
	            this._zone.run(function () {
	                // they pulled down far enough, so it's ready to refresh
	                _this._beginRefresh();
	            });
	        }
	        else if (this.state === STATE_PULLING) {
	            this._zone.run(function () {
	                // they were pulling down, but didn't pull down far enough
	                // set the content back to it's original location
	                // and close the refresher
	                // set that the refresh is actively cancelling
	                _this.cancel();
	            });
	        }
	        // reset on any touchend/mouseup
	        this.startY = null;
	    };
	    Refresher.prototype._beginRefresh = function () {
	        // assumes we're already back in a zone
	        // they pulled down far enough, so it's ready to refresh
	        this.state = STATE_REFRESHING;
	        // place the content in a hangout position while it thinks
	        this._setCss(this.pullMin, (this.snapbackDuration + 'ms'), true, '');
	        // emit "refresh" because it was pulled down far enough
	        // and they let go to begin refreshing
	        this.ionRefresh.emit(this);
	    };
	    /**
	     * Call `complete()` when your async operation has completed.
	     * For example, the `refreshing` state is while the app is performing
	     * an asynchronous operation, such as receiving more data from an
	     * AJAX request. Once the data has been received, you then call this
	     * method to signify that the refreshing has completed and to close
	     * the refresher. This method also changes the refresher's state from
	     * `refreshing` to `completing`.
	     */
	    Refresher.prototype.complete = function () {
	        this._close(STATE_COMPLETING, '120ms');
	    };
	    /**
	     * Changes the refresher's state from `refreshing` to `cancelling`.
	     */
	    Refresher.prototype.cancel = function () {
	        this._close(STATE_CANCELLING, '');
	    };
	    Refresher.prototype._close = function (state, delay) {
	        var timer;
	        function close(ev) {
	            // closing is done, return to inactive state
	            if (ev) {
	                clearTimeout(timer);
	            }
	            this.state = STATE_INACTIVE$1;
	            this.progress = 0;
	            this._didStart = this.startY = this.currentY = this.deltaY = null;
	            this._setCss(0, '0ms', false, '');
	        }
	        // create fallback timer incase something goes wrong with transitionEnd event
	        timer = setTimeout(close.bind(this), 600);
	        // create transition end event on the content's scroll element
	        this._content.onScrollElementTransitionEnd(close.bind(this));
	        // reset set the styles on the scroll element
	        // set that the refresh is actively cancelling/completing
	        this.state = state;
	        this._setCss(0, '', true, delay);
	        if (this._pointerEvents) {
	            this._pointerEvents.stop();
	        }
	    };
	    Refresher.prototype._setCss = function (y, duration, overflowVisible, delay) {
	        this._appliedStyles = (y > 0);
	        var content = this._content;
	        content.setScrollElementStyle(CSS.transform, ((y > 0) ? 'translateY(' + y + 'px) translateZ(0px)' : 'translateZ(0px)'));
	        content.setScrollElementStyle(CSS.transitionDuration, duration);
	        content.setScrollElementStyle(CSS.transitionDelay, delay);
	        content.setScrollElementStyle('overflow', (overflowVisible ? 'hidden' : ''));
	    };
	    Refresher.prototype._setListeners = function (shouldListen) {
	        this._events.unlistenAll();
	        this._pointerEvents = null;
	        if (shouldListen) {
	            this._pointerEvents = this._events.pointerEvents(this._content.getScrollElement(), this._onStart.bind(this), this._onMove.bind(this), this._onEnd.bind(this));
	        }
	    };
	    /**
	     * @private
	     */
	    Refresher.prototype.ngOnInit = function () {
	        // bind event listeners
	        // save the unregister listener functions to use onDestroy
	        this._setListeners(this._isEnabled);
	    };
	    /**
	     * @private
	     */
	    Refresher.prototype.ngOnDestroy = function () {
	        this._setListeners(false);
	    };
	    /** @nocollapse */
	    Refresher.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-refresher',
	                    host: {
	                        '[class.refresher-active]': 'state !== "inactive"',
	                        '[style.top]': '_top'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    Refresher.ctorParameters = [
	        { type: Content, decorators: [{ type: Host },] },
	        { type: NgZone, },
	    ];
	    /** @nocollapse */
	    Refresher.propDecorators = {
	        'pullMin': [{ type: Input },],
	        'pullMax': [{ type: Input },],
	        'closeDuration': [{ type: Input },],
	        'snapbackDuration': [{ type: Input },],
	        'enabled': [{ type: Input },],
	        'ionRefresh': [{ type: Output },],
	        'ionPull': [{ type: Output },],
	        'ionStart': [{ type: Output },],
	    };
	    return Refresher;
	}());
	var STATE_INACTIVE$1 = 'inactive';
	var STATE_PULLING = 'pulling';
	var STATE_READY = 'ready';
	var STATE_REFRESHING = 'refreshing';
	var STATE_CANCELLING = 'cancelling';
	var STATE_COMPLETING = 'completing';

	var RefresherContent = (function () {
	    function RefresherContent(r, _config) {
	        this.r = r;
	        this._config = _config;
	    }
	    /**
	     * @private
	     */
	    RefresherContent.prototype.ngOnInit = function () {
	        if (!this.pullingIcon) {
	            this.pullingIcon = this._config.get('ionPullIcon', 'arrow-down');
	        }
	        if (!this.refreshingSpinner) {
	            this.refreshingSpinner = this._config.get('ionRefreshingSpinner', this._config.get('spinner', 'ios'));
	        }
	    };
	    /** @nocollapse */
	    RefresherContent.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-refresher-content',
	                    template: "\n    <div class=\"refresher-pulling\">\n      <div class=\"refresher-pulling-icon\" *ngIf=\"pullingIcon\">\n        <ion-icon [name]=\"pullingIcon\"></ion-icon>\n      </div>\n      <div class=\"refresher-pulling-text\" [innerHTML]=\"pullingText\" *ngIf=\"pullingText\"></div>\n    </div>\n    <div class=\"refresher-refreshing\">\n      <div class=\"refresher-refreshing-icon\">\n        <ion-spinner [name]=\"refreshingSpinner\"></ion-spinner>\n      </div>\n      <div class=\"refresher-refreshing-text\" [innerHTML]=\"refreshingText\" *ngIf=\"refreshingText\"></div>\n    </div>\n  ",
	                    directives: [Icon, NgIf, Spinner],
	                    host: {
	                        '[attr.state]': 'r.state'
	                    },
	                    encapsulation: ViewEncapsulation.None
	                },] },
	    ];
	    /** @nocollapse */
	    RefresherContent.ctorParameters = [
	        { type: Refresher, },
	        { type: Config, },
	    ];
	    /** @nocollapse */
	    RefresherContent.propDecorators = {
	        'pullingIcon': [{ type: Input },],
	        'pullingText': [{ type: Input },],
	        'refreshingSpinner': [{ type: Input },],
	        'refreshingText': [{ type: Input },],
	    };
	    return RefresherContent;
	}());

	var $;
	  /*===========================
	  Swiper
	  ===========================*/

	function Swiper(container, params) {


	      if (!(this instanceof Swiper)) return new Swiper(container, params);

	      var defaults = {
	          direction: 'horizontal',
	          touchEventsTarget: 'container',
	          initialSlide: 0,
	          speed: 300,
	          // autoplay
	          autoplay: false,
	          autoplayDisableOnInteraction: true,
	          // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
	          iOSEdgeSwipeDetection: false,
	          iOSEdgeSwipeThreshold: 20,
	          // Free mode
	          freeMode: false,
	          freeModeMomentum: true,
	          freeModeMomentumRatio: 1,
	          freeModeMomentumBounce: true,
	          freeModeMomentumBounceRatio: 1,
	          freeModeSticky: false,
	          // Set wrapper width
	          setWrapperSize: false,
	          // Virtual Translate
	          virtualTranslate: false,
	          // Effects
	          effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow'
	          coverflow: {
	              rotate: 50,
	              stretch: 0,
	              depth: 100,
	              modifier: 1,
	              slideShadows : true
	          },
	          cube: {
	              slideShadows: true,
	              shadow: true,
	              shadowOffset: 20,
	              shadowScale: 0.94
	          },
	          fade: {
	              crossFade: false
	          },
	          // Parallax
	          parallax: false,
	          // Scrollbar
	          scrollbar: null,
	          scrollbarHide: true,
	          // Keyboard Mousewheel
	          keyboardControl: false,
	          mousewheelControl: false,
	          mousewheelReleaseOnEdges: false,
	          mousewheelInvert: false,
	          mousewheelForceToAxis: false,
	          mousewheelSensitivity: 1,
	          // Hash Navigation
	          hashnav: false,
	          // Slides grid
	          spaceBetween: 0,
	          slidesPerView: 1,
	          slidesPerColumn: 1,
	          slidesPerColumnFill: 'column',
	          slidesPerGroup: 1,
	          centeredSlides: false,
	          slidesOffsetBefore: 0, // in px
	          slidesOffsetAfter: 0, // in px
	          // Round length
	          roundLengths: false,
	          // Touches
	          touchRatio: 1,
	          touchAngle: 45,
	          simulateTouch: true,
	          shortSwipes: true,
	          longSwipes: true,
	          longSwipesRatio: 0.5,
	          longSwipesMs: 300,
	          followFinger: true,
	          onlyExternal: false,
	          threshold: 0,
	          touchMoveStopPropagation: true,
	          // Pagination
	          pagination: null,
	          paginationElement: 'span',
	          paginationClickable: false,
	          paginationHide: false,
	          paginationBulletRender: null,
	          // Resistance
	          resistance: true,
	          resistanceRatio: 0.85,
	          // Next/prev buttons
	          nextButton: null,
	          prevButton: null,
	          // Progress
	          watchSlidesProgress: false,
	          watchSlidesVisibility: false,
	          // Cursor
	          grabCursor: false,
	          // Clicks
	          preventClicks: true,
	          preventClicksPropagation: true,
	          slideToClickedSlide: false,
	          // Lazy Loading
	          lazyLoading: false,
	          lazyLoadingInPrevNext: false,
	          lazyLoadingOnTransitionStart: false,
	          // Images
	          preloadImages: true,
	          updateOnImagesReady: true,
	          // loop
	          loop: false,
	          loopAdditionalSlides: 0,
	          loopedSlides: null,
	          // Control
	          control: undefined,
	          controlInverse: false,
	          controlBy: 'slide', //or 'container'
	          // Swiping/no swiping
	          allowSwipeToPrev: true,
	          allowSwipeToNext: true,
	          swipeHandler: null, //'.swipe-handler',
	          noSwiping: true,
	          noSwipingClass: 'swiper-no-swiping',
	          // NS
	          slideClass: 'swiper-slide',
	          slideActiveClass: 'swiper-slide-active',
	          slideVisibleClass: 'swiper-slide-visible',
	          slideDuplicateClass: 'swiper-slide-duplicate',
	          slideNextClass: 'swiper-slide-next',
	          slidePrevClass: 'swiper-slide-prev',
	          wrapperClass: 'swiper-wrapper',
	          bulletClass: 'swiper-pagination-bullet',
	          bulletActiveClass: 'swiper-pagination-bullet-active',
	          buttonDisabledClass: 'swiper-button-disabled',
	          paginationHiddenClass: 'swiper-pagination-hidden',
	          // Observer
	          observer: false,
	          observeParents: false,
	          // Accessibility
	          a11y: false,
	          prevSlideMessage: 'Previous slide',
	          nextSlideMessage: 'Next slide',
	          firstSlideMessage: 'This is the first slide',
	          lastSlideMessage: 'This is the last slide',
	          paginationBulletMessage: 'Go to slide {{index}}',
	          // Callbacks
	          runCallbacksOnInit: true
	          /*
	          Callbacks:
	          onInit: function (swiper)
	          onDestroy: function (swiper)
	          onClick: function (swiper, e)
	          onTap: function (swiper, e)
	          onDoubleTap: function (swiper, e)
	          onSliderMove: function (swiper, e)
	          onSlideChangeStart: function (swiper)
	          onSlideChangeEnd: function (swiper)
	          onTransitionStart: function (swiper)
	          onTransitionEnd: function (swiper)
	          onImagesReady: function (swiper)
	          onProgress: function (swiper, progress)
	          onTouchStart: function (swiper, e)
	          onTouchMove: function (swiper, e)
	          onTouchMoveOpposite: function (swiper, e)
	          onTouchEnd: function (swiper, e)
	          onReachBeginning: function (swiper)
	          onReachEnd: function (swiper)
	          onSetTransition: function (swiper, duration)
	          onSetTranslate: function (swiper, translate)
	          onAutoplayStart: function (swiper)
	          onAutoplayStop: function (swiper),
	          onLazyImageLoad: function (swiper, slide, image)
	          onLazyImageReady: function (swiper, slide, image)
	          */

	      };
	      var initialVirtualTranslate = params && params.virtualTranslate;

	      params = params || {};
	      for (var def in defaults) {
	          if (typeof params[def] === 'undefined') {
	              params[def] = defaults[def];
	          }
	          else if (typeof params[def] === 'object') {
	              for (var deepDef in defaults[def]) {
	                  if (typeof params[def][deepDef] === 'undefined') {
	                      params[def][deepDef] = defaults[def][deepDef];
	                  }
	              }
	          }
	      }

	      // Swiper
	      var s = this;

	      // Version
	      s.version = '3.1.0';

	      // Params
	      s.params = params;

	      // Classname
	      s.classNames = [];
	      /*=========================
	        Dom Library and plugins
	        ===========================*/
	      if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){
	          $ = Dom7;
	      }
	      if (typeof $ === 'undefined') {
	          if (typeof Dom7 === 'undefined') {
	              $ = window.Dom7 || window.Zepto || window.jQuery;
	          }
	          else {
	              $ = Dom7;
	          }
	          if (!$) return;
	      }
	      // Export it to Swiper instance
	      s.$ = $;

	      /*=========================
	        Preparation - Define Container, Wrapper and Pagination
	        ===========================*/
	      s.container = $(container);
	      if (s.container.length === 0) return;
	      if (s.container.length > 1) {
	          s.container.each(function () {
	              new Swiper(this, params);
	          });
	          return;
	      }

	      // Save instance in container HTML Element and in data
	      s.container[0].swiper = s;
	      s.container.data('swiper', s);

	      s.classNames.push('swiper-container-' + s.params.direction);

	      if (s.params.freeMode) {
	          s.classNames.push('swiper-container-free-mode');
	      }
	      if (!s.support.flexbox) {
	          s.classNames.push('swiper-container-no-flexbox');
	          s.params.slidesPerColumn = 1;
	      }
	      // Enable slides progress when required
	      if (s.params.parallax || s.params.watchSlidesVisibility) {
	          s.params.watchSlidesProgress = true;
	      }
	      // Coverflow / 3D
	      if (['cube', 'coverflow'].indexOf(s.params.effect) >= 0) {
	          if (s.support.transforms3d) {
	              s.params.watchSlidesProgress = true;
	              s.classNames.push('swiper-container-3d');
	          }
	          else {
	              s.params.effect = 'slide';
	          }
	      }
	      if (s.params.effect !== 'slide') {
	          s.classNames.push('swiper-container-' + s.params.effect);
	      }
	      if (s.params.effect === 'cube') {
	          s.params.resistanceRatio = 0;
	          s.params.slidesPerView = 1;
	          s.params.slidesPerColumn = 1;
	          s.params.slidesPerGroup = 1;
	          s.params.centeredSlides = false;
	          s.params.spaceBetween = 0;
	          s.params.virtualTranslate = true;
	          s.params.setWrapperSize = false;
	      }
	      if (s.params.effect === 'fade') {
	          s.params.slidesPerView = 1;
	          s.params.slidesPerColumn = 1;
	          s.params.slidesPerGroup = 1;
	          s.params.watchSlidesProgress = true;
	          s.params.spaceBetween = 0;
	          if (typeof initialVirtualTranslate === 'undefined') {
	              s.params.virtualTranslate = true;
	          }
	      }

	      // Grab Cursor
	      if (s.params.grabCursor && s.support.touch) {
	          s.params.grabCursor = false;
	      }

	      // Wrapper
	      s.wrapper = s.container.children('.' + s.params.wrapperClass);

	      // Pagination
	      if (s.params.pagination) {
	          s.paginationContainer = $(s.params.pagination);
	          if (s.params.paginationClickable) {
	              s.paginationContainer.addClass('swiper-pagination-clickable');
	          }
	      }

	      // Is Horizontal
	      function isH() {
	          return s.params.direction === 'horizontal';
	      }

	      // RTL
	      s.rtl = isH() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
	      if (s.rtl) {
	          s.classNames.push('swiper-container-rtl');
	      }

	      // Wrong RTL support
	      if (s.rtl) {
	          s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
	      }

	      // Columns
	      if (s.params.slidesPerColumn > 1) {
	          s.classNames.push('swiper-container-multirow');
	      }

	      // Check for Android
	      if (s.device.android) {
	          s.classNames.push('swiper-container-android');
	      }

	      // Add classes
	      s.container.addClass(s.classNames.join(' '));

	      // Translate
	      s.translate = 0;

	      // Progress
	      s.progress = 0;

	      // Velocity
	      s.velocity = 0;

	      /*=========================
	        Locks, unlocks
	        ===========================*/
	      s.lockSwipeToNext = function () {
	          s.params.allowSwipeToNext = false;
	      };
	      s.lockSwipeToPrev = function () {
	          s.params.allowSwipeToPrev = false;
	      };
	      s.lockSwipes = function () {
	          s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
	      };
	      s.unlockSwipeToNext = function () {
	          s.params.allowSwipeToNext = true;
	      };
	      s.unlockSwipeToPrev = function () {
	          s.params.allowSwipeToPrev = true;
	      };
	      s.unlockSwipes = function () {
	          s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
	      };

	      /*=========================
	        Round helper
	        ===========================*/
	      function round(a) {
	          return Math.floor(a);
	      }
	      /*=========================
	        Set grab cursor
	        ===========================*/
	      if (s.params.grabCursor) {
	          s.container[0].style.cursor = 'move';
	          s.container[0].style.cursor = '-webkit-grab';
	          s.container[0].style.cursor = '-moz-grab';
	          s.container[0].style.cursor = 'grab';
	      }
	      /*=========================
	        Update on Images Ready
	        ===========================*/
	      s.imagesToLoad = [];
	      s.imagesLoaded = 0;

	      s.loadImage = function (imgElement, src, checkForComplete, callback) {
	          var image;
	          function onReady () {
	              if (callback) callback();
	          }
	          if (!imgElement.complete || !checkForComplete) {
	              if (src) {
	                  image = new window.Image();
	                  image.onload = onReady;
	                  image.onerror = onReady;
	                  image.src = src;
	              } else {
	                  onReady();
	              }

	          } else {//image already loaded...
	              onReady();
	          }
	      };
	      s.preloadImages = function () {
	          s.imagesToLoad = s.container.find('img');
	          function _onReady() {
	              if (typeof s === 'undefined' || s === null) return;
	              if (s.imagesLoaded !== undefined) s.imagesLoaded++;
	              if (s.imagesLoaded === s.imagesToLoad.length) {
	                  if (s.params.updateOnImagesReady) s.update();
	                  s.emit('onImagesReady', s);
	              }
	          }
	          for (var i = 0; i < s.imagesToLoad.length; i++) {
	              s.loadImage(s.imagesToLoad[i], (s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src')), true, _onReady);
	          }
	      };

	      /*=========================
	        Autoplay
	        ===========================*/
	      s.autoplayTimeoutId = undefined;
	      s.autoplaying = false;
	      s.autoplayPaused = false;
	      function autoplay() {
	          s.autoplayTimeoutId = setTimeout(function () {
	              if (s.params.loop) {
	                  s.fixLoop();
	                  s._slideNext();
	              }
	              else {
	                  if (!s.isEnd) {
	                      s._slideNext();
	                  }
	                  else {
	                      if (!params.autoplayStopOnLast) {
	                          s._slideTo(0);
	                      }
	                      else {
	                          s.stopAutoplay();
	                      }
	                  }
	              }
	          }, s.params.autoplay);
	      }
	      s.startAutoplay = function () {
	          if (typeof s.autoplayTimeoutId !== 'undefined') return false;
	          if (!s.params.autoplay) return false;
	          if (s.autoplaying) return false;
	          s.autoplaying = true;
	          s.emit('onAutoplayStart', s);
	          autoplay();
	      };
	      s.stopAutoplay = function (internal) {
	          if (!s.autoplayTimeoutId) return;
	          if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
	          s.autoplaying = false;
	          s.autoplayTimeoutId = undefined;
	          s.emit('onAutoplayStop', s);
	      };
	      s.pauseAutoplay = function (speed) {
	          if (s.autoplayPaused) return;
	          if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
	          s.autoplayPaused = true;
	          if (speed === 0) {
	              s.autoplayPaused = false;
	              autoplay();
	          }
	          else {
	              s.wrapper.transitionEnd(function () {
	                  if (!s) return;
	                  s.autoplayPaused = false;
	                  if (!s.autoplaying) {
	                      s.stopAutoplay();
	                  }
	                  else {
	                      autoplay();
	                  }
	              });
	          }
	      };
	      /*=========================
	        Min/Max Translate
	        ===========================*/
	      s.minTranslate = function () {
	          return (-s.snapGrid[0]);
	      };
	      s.maxTranslate = function () {
	          return (-s.snapGrid[s.snapGrid.length - 1]);
	      };
	      /*=========================
	        Slider/slides sizes
	        ===========================*/
	      s.updateContainerSize = function () {
	          var width, height;
	          if (typeof s.params.width !== 'undefined') {
	              width = s.params.width;
	          }
	          else {
	              width = s.container[0].clientWidth;
	          }
	          if (typeof s.params.height !== 'undefined') {
	              height = s.params.height;
	          }
	          else {
	              height = s.container[0].clientHeight;
	          }
	          if (width === 0 && isH() || height === 0 && !isH()) {
	              return;
	          }

	          //Subtract paddings
	          width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
	          height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);

	          // Store values
	          s.width = width;
	          s.height = height;
	          s.size = isH() ? s.width : s.height;
	      };

	      s.updateSlidesSize = function () {
	          s.slides = s.wrapper.children('.' + s.params.slideClass);
	          s.snapGrid = [];
	          s.slidesGrid = [];
	          s.slidesSizesGrid = [];

	          var spaceBetween = s.params.spaceBetween,
	              slidePosition = -s.params.slidesOffsetBefore,
	              i,
	              prevSlideSize = 0,
	              index = 0;
	          if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
	              spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
	          }

	          s.virtualSize = -spaceBetween;
	          // reset margins
	          if (s.rtl) s.slides.css({marginLeft: '', marginTop: ''});
	          else s.slides.css({marginRight: '', marginBottom: ''});

	          var slidesNumberEvenToRows;
	          if (s.params.slidesPerColumn > 1) {
	              if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
	                  slidesNumberEvenToRows = s.slides.length;
	              }
	              else {
	                  slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
	              }
	          }

	          // Calc slides
	          var slideSize;
	          var slidesPerColumn = s.params.slidesPerColumn;
	          var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
	          var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
	          for (i = 0; i < s.slides.length; i++) {
	              slideSize = 0;
	              var slide = s.slides.eq(i);
	              if (s.params.slidesPerColumn > 1) {
	                  // Set slides order
	                  var newSlideOrderIndex;
	                  var column, row;
	                  if (s.params.slidesPerColumnFill === 'column') {
	                      column = Math.floor(i / slidesPerColumn);
	                      row = i - column * slidesPerColumn;
	                      if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn-1)) {
	                          if (++row >= slidesPerColumn) {
	                              row = 0;
	                              column++;
	                          }
	                      }
	                      newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
	                      slide
	                          .css({
	                              '-webkit-box-ordinal-group': newSlideOrderIndex,
	                              '-moz-box-ordinal-group': newSlideOrderIndex,
	                              '-ms-flex-order': newSlideOrderIndex,
	                              '-webkit-order': newSlideOrderIndex,
	                              'order': newSlideOrderIndex
	                          });
	                  }
	                  else {
	                      row = Math.floor(i / slidesPerRow);
	                      column = i - row * slidesPerRow;
	                  }
	                  slide
	                      .css({
	                          'margin-top': (row !== 0 && s.params.spaceBetween) && (s.params.spaceBetween + 'px')
	                      })
	                      .attr('data-swiper-column', column)
	                      .attr('data-swiper-row', row);

	              }
	              if (slide.css('display') === 'none') continue;
	              if (s.params.slidesPerView === 'auto') {
	                  slideSize = isH() ? slide.outerWidth(true) : slide.outerHeight(true);
	                  if (s.params.roundLengths) slideSize = round(slideSize);
	              }
	              else {
	                  slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
	                  if (s.params.roundLengths) slideSize = round(slideSize);

	                  if (isH()) {
	                      s.slides[i].style.width = slideSize + 'px';
	                  }
	                  else {
	                      s.slides[i].style.height = slideSize + 'px';
	                  }
	              }
	              s.slides[i].swiperSlideSize = slideSize;
	              s.slidesSizesGrid.push(slideSize);


	              if (s.params.centeredSlides) {
	                  slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
	                  if (i === 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
	                  if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
	                  if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
	                  s.slidesGrid.push(slidePosition);
	              }
	              else {
	                  if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
	                  s.slidesGrid.push(slidePosition);
	                  slidePosition = slidePosition + slideSize + spaceBetween;
	              }

	              s.virtualSize += slideSize + spaceBetween;

	              prevSlideSize = slideSize;

	              index ++;
	          }
	          s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;

	          var newSlidesGrid;

	          if (
	              s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
	              s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
	          }
	          if (!s.support.flexbox || s.params.setWrapperSize) {
	              if (isH()) s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
	              else s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
	          }

	          if (s.params.slidesPerColumn > 1) {
	              s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
	              s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
	              s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
	              if (s.params.centeredSlides) {
	                  newSlidesGrid = [];
	                  for (i = 0; i < s.snapGrid.length; i++) {
	                      if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0]) newSlidesGrid.push(s.snapGrid[i]);
	                  }
	                  s.snapGrid = newSlidesGrid;
	              }
	          }

	          // Remove last grid elements depending on width
	          if (!s.params.centeredSlides) {
	              newSlidesGrid = [];
	              for (i = 0; i < s.snapGrid.length; i++) {
	                  if (s.snapGrid[i] <= s.virtualSize - s.size) {
	                      newSlidesGrid.push(s.snapGrid[i]);
	                  }
	              }
	              s.snapGrid = newSlidesGrid;
	              if (Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1])) {
	                  s.snapGrid.push(s.virtualSize - s.size);
	              }
	          }
	          if (s.snapGrid.length === 0) s.snapGrid = [0];

	          if (s.params.spaceBetween !== 0) {
	              if (isH()) {
	                  if (s.rtl) s.slides.css({marginLeft: spaceBetween + 'px'});
	                  else s.slides.css({marginRight: spaceBetween + 'px'});
	              }
	              else s.slides.css({marginBottom: spaceBetween + 'px'});
	          }
	          if (s.params.watchSlidesProgress) {
	              s.updateSlidesOffset();
	          }
	      };
	      s.updateSlidesOffset = function () {
	          for (var i = 0; i < s.slides.length; i++) {
	              s.slides[i].swiperSlideOffset = isH() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
	          }
	      };

	      /*=========================
	        Slider/slides progress
	        ===========================*/
	      s.updateSlidesProgress = function (translate) {
	          if (typeof translate === 'undefined') {
	              translate = s.translate || 0;
	          }
	          if (s.slides.length === 0) return;
	          if (typeof s.slides[0].swiperSlideOffset === 'undefined') s.updateSlidesOffset();

	          var offsetCenter = -translate;
	          if (s.rtl) offsetCenter = translate;

	          // Visible Slides
	          var containerBox = s.container[0].getBoundingClientRect();
	          var sideBefore = isH() ? 'left' : 'top';
	          var sideAfter = isH() ? 'right' : 'bottom';
	          s.slides.removeClass(s.params.slideVisibleClass);
	          for (var i = 0; i < s.slides.length; i++) {
	              var slide = s.slides[i];
	              var slideProgress = (offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
	              if (s.params.watchSlidesVisibility) {
	                  var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
	                  var slideAfter = slideBefore + s.slidesSizesGrid[i];
	                  var isVisible =
	                      (slideBefore >= 0 && slideBefore < s.size) ||
	                      (slideAfter > 0 && slideAfter <= s.size) ||
	                      (slideBefore <= 0 && slideAfter >= s.size);
	                  if (isVisible) {
	                      s.slides.eq(i).addClass(s.params.slideVisibleClass);
	                  }
	              }
	              slide.progress = s.rtl ? -slideProgress : slideProgress;
	          }
	      };
	      s.updateProgress = function (translate) {
	          if (typeof translate === 'undefined') {
	              translate = s.translate || 0;
	          }
	          var translatesDiff = s.maxTranslate() - s.minTranslate();
	          if (translatesDiff === 0) {
	              s.progress = 0;
	              s.isBeginning = s.isEnd = true;
	          }
	          else {
	              s.progress = (translate - s.minTranslate()) / (translatesDiff);
	              s.isBeginning = s.progress <= 0;
	              s.isEnd = s.progress >= 1;
	          }
	          if (s.isBeginning) s.emit('onReachBeginning', s);
	          if (s.isEnd) s.emit('onReachEnd', s);

	          if (s.params.watchSlidesProgress) s.updateSlidesProgress(translate);
	          s.emit('onProgress', s, s.progress);
	      };
	      s.updateActiveIndex = function () {
	          var translate = s.rtl ? s.translate : -s.translate;
	          var newActiveIndex, i, snapIndex;
	          for (i = 0; i < s.slidesGrid.length; i ++) {
	              if (typeof s.slidesGrid[i + 1] !== 'undefined') {
	                  if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
	                      newActiveIndex = i;
	                  }
	                  else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
	                      newActiveIndex = i + 1;
	                  }
	              }
	              else {
	                  if (translate >= s.slidesGrid[i]) {
	                      newActiveIndex = i;
	                  }
	              }
	          }
	          // Normalize slideIndex
	          if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined') newActiveIndex = 0;
	          // for (i = 0; i < s.slidesGrid.length; i++) {
	              // if (- translate >= s.slidesGrid[i]) {
	                  // newActiveIndex = i;
	              // }
	          // }
	          snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
	          if (snapIndex >= s.snapGrid.length) snapIndex = s.snapGrid.length - 1;

	          if (newActiveIndex === s.activeIndex) {
	              return;
	          }
	          s.snapIndex = snapIndex;
	          s.previousIndex = s.activeIndex;
	          s.activeIndex = newActiveIndex;
	          s.updateClasses();
	      };

	      /*=========================
	        Classes
	        ===========================*/
	      s.updateClasses = function () {
	          s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);
	          var activeSlide = s.slides.eq(s.activeIndex);
	          // Active classes
	          activeSlide.addClass(s.params.slideActiveClass);
	          activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
	          activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);

	          // Pagination
	          if (s.bullets && s.bullets.length > 0) {
	              s.bullets.removeClass(s.params.bulletActiveClass);
	              var bulletIndex;
	              if (s.params.loop) {
	                  bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides)/s.params.slidesPerGroup;
	                  if (bulletIndex > s.slides.length - 1 - s.loopedSlides * 2) {
	                      bulletIndex = bulletIndex - (s.slides.length - s.loopedSlides * 2);
	                  }
	                  if (bulletIndex > s.bullets.length - 1) bulletIndex = bulletIndex - s.bullets.length;
	              }
	              else {
	                  if (typeof s.snapIndex !== 'undefined') {
	                      bulletIndex = s.snapIndex;
	                  }
	                  else {
	                      bulletIndex = s.activeIndex || 0;
	                  }
	              }
	              if (s.paginationContainer.length > 1) {
	                  s.bullets.each(function () {
	                      if ($(this).index() === bulletIndex) $(this).addClass(s.params.bulletActiveClass);
	                  });
	              }
	              else {
	                  s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);
	              }
	          }

	          // Next/active buttons
	          if (!s.params.loop) {
	              if (s.params.prevButton) {
	                  if (s.isBeginning) {
	                      $(s.params.prevButton).addClass(s.params.buttonDisabledClass);
	                      if (s.params.a11y && s.a11y) s.a11y.disable($(s.params.prevButton));
	                  }
	                  else {
	                      $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
	                      if (s.params.a11y && s.a11y) s.a11y.enable($(s.params.prevButton));
	                  }
	              }
	              if (s.params.nextButton) {
	                  if (s.isEnd) {
	                      $(s.params.nextButton).addClass(s.params.buttonDisabledClass);
	                      if (s.params.a11y && s.a11y) s.a11y.disable($(s.params.nextButton));
	                  }
	                  else {
	                      $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
	                      if (s.params.a11y && s.a11y) s.a11y.enable($(s.params.nextButton));
	                  }
	              }
	          }
	      };

	      /*=========================
	        Pagination
	        ===========================*/
	      s.updatePagination = function () {
	          if (!s.params.pagination) return;
	          if (s.paginationContainer && s.paginationContainer.length > 0) {
	              var bulletsHTML = '';
	              var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
	              for (var i = 0; i < numberOfBullets; i++) {
	                  if (s.params.paginationBulletRender) {
	                      bulletsHTML += s.params.paginationBulletRender(i, s.params.bulletClass);
	                  }
	                  else {
	                      bulletsHTML += '<' + s.params.paginationElement+' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
	                  }
	              }
	              s.paginationContainer.html(bulletsHTML);
	              s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
	              if (s.params.paginationClickable && s.params.a11y && s.a11y) {
	                  s.a11y.initPagination();
	              }
	          }
	      };
	      /*=========================
	        Common update method
	        ===========================*/
	      s.update = function (updateTranslate) {
	          s.updateContainerSize();
	          s.updateSlidesSize();
	          s.updateProgress();
	          s.updatePagination();
	          s.updateClasses();
	          if (s.params.scrollbar && s.scrollbar) {
	              s.scrollbar.set();
	          }
	          function forceSetTranslate() {
	              newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
	              s.setWrapperTranslate(newTranslate);
	              s.updateActiveIndex();
	              s.updateClasses();
	          }
	          if (updateTranslate) {
	              var translated, newTranslate;
	              if (s.controller && s.controller.spline) {
	                  s.controller.spline = undefined;
	              }
	              if (s.params.freeMode) {
	                  forceSetTranslate();
	              }
	              else {
	                  if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
	                      translated = s.slideTo(s.slides.length - 1, 0, false, true);
	                  }
	                  else {
	                      translated = s.slideTo(s.activeIndex, 0, false, true);
	                  }
	                  if (!translated) {
	                      forceSetTranslate();
	                  }
	              }

	          }
	      };

	      /*=========================
	        Resize Handler
	        ===========================*/
	      s.onResize = function (forceUpdatePagination) {
	          // Disable locks on resize
	          var allowSwipeToPrev = s.params.allowSwipeToPrev;
	          var allowSwipeToNext = s.params.allowSwipeToNext;
	          s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;

	          s.updateContainerSize();
	          s.updateSlidesSize();
	          if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination) s.updatePagination();
	          if (s.params.scrollbar && s.scrollbar) {
	              s.scrollbar.set();
	          }
	          if (s.controller && s.controller.spline) {
	              s.controller.spline = undefined;
	          }
	          if (s.params.freeMode) {
	              var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
	              s.setWrapperTranslate(newTranslate);
	              s.updateActiveIndex();
	              s.updateClasses();
	          }
	          else {
	              s.updateClasses();
	              if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
	                  s.slideTo(s.slides.length - 1, 0, false, true);
	              }
	              else {
	                  s.slideTo(s.activeIndex, 0, false, true);
	              }
	          }
	          // Return locks after resize
	          s.params.allowSwipeToPrev = allowSwipeToPrev;
	          s.params.allowSwipeToNext = allowSwipeToNext;
	      };

	      /*=========================
	        Events
	        ===========================*/

	      //Define Touch Events
	      var desktopEvents = ['mousedown', 'mousemove', 'mouseup'];
	      if (window.navigator.pointerEnabled) desktopEvents = ['pointerdown', 'pointermove', 'pointerup'];
	      else if (window.navigator.msPointerEnabled) desktopEvents = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
	      s.touchEvents = {
	          start : s.support.touch || !s.params.simulateTouch  ? 'touchstart' : desktopEvents[0],
	          move : s.support.touch || !s.params.simulateTouch ? 'touchmove' : desktopEvents[1],
	          end : s.support.touch || !s.params.simulateTouch ? 'touchend' : desktopEvents[2]
	      };


	      // WP8 Touch Events Fix
	      if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
	          (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
	      }

	      // Attach/detach events
	      s.initEvents = function (detach) {
	          console.debug('swiper initEvents', detach ? 'detach' : 'attach');
	          var actionDom = detach ? 'off' : 'on';
	          var action = detach ? 'removeEventListener' : 'addEventListener';
	          var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
	          var target = s.support.touch ? touchEventsTarget : document;

	          var moveCapture = s.params.nested ? true : false;

	          //Touch Events
	          if (s.browser.ie) {
	              touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
	              target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
	              target[action](s.touchEvents.end, s.onTouchEnd, false);
	          }
	          else {
	              if (s.support.touch) {
	                  touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
	                  touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
	                  touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, false);
	              }
	              if (params.simulateTouch && !s.device.ios && !s.device.android) {
	                  touchEventsTarget[action]('mousedown', s.onTouchStart, false);
	                  document[action]('mousemove', s.onTouchMove, moveCapture);
	                  document[action]('mouseup', s.onTouchEnd, false);
	              }
	          }
	          window[action]('resize', s.onResize);

	          // Next, Prev, Index
	          if (s.params.nextButton) {
	              $(s.params.nextButton)[actionDom]('click', s.onClickNext);
	              if (s.params.a11y && s.a11y) $(s.params.nextButton)[actionDom]('keydown', s.a11y.onEnterKey);
	          }
	          if (s.params.prevButton) {
	              $(s.params.prevButton)[actionDom]('click', s.onClickPrev);
	              if (s.params.a11y && s.a11y) $(s.params.prevButton)[actionDom]('keydown', s.a11y.onEnterKey);
	          }
	          if (s.params.pagination && s.params.paginationClickable) {
	              $(s.paginationContainer)[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
	              if (s.params.a11y && s.a11y) $(s.paginationContainer)[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
	          }

	          // Prevent Links Clicks
	          if (s.params.preventClicks || s.params.preventClicksPropagation) touchEventsTarget[action]('click', s.preventClicks, true);
	      };
	      s.attachEvents = function (detach) {
	          s.initEvents();
	      };
	      s.detachEvents = function () {
	          s.initEvents(true);
	      };

	      /*=========================
	        Handle Clicks
	        ===========================*/
	      // Prevent Clicks
	      s.allowClick = true;
	      s.preventClicks = function (e) {
	          if (!s.allowClick) {
	              if (s.params.preventClicks) e.preventDefault();
	              if (s.params.preventClicksPropagation && s.animating) {
	                  e.stopPropagation();
	                  e.stopImmediatePropagation();
	              }
	          }
	      };
	      // Clicks
	      s.onClickNext = function (e) {
	          e.preventDefault();
	          if (s.isEnd && !s.params.loop) return;
	          s.slideNext();
	      };
	      s.onClickPrev = function (e) {
	          e.preventDefault();
	          if (s.isBeginning && !s.params.loop) return;
	          s.slidePrev();
	      };
	      s.onClickIndex = function (e) {
	          e.preventDefault();
	          var index = $(this).index() * s.params.slidesPerGroup;
	          if (s.params.loop) index = index + s.loopedSlides;
	          s.slideTo(index);
	      };

	      /*=========================
	        Handle Touches
	        ===========================*/
	      function findElementInEvent(e, selector) {
	          var el = $(e.target);
	          if (!el.is(selector)) {
	              if (typeof selector === 'string') {
	                  el = el.parents(selector);
	              }
	              else if (selector.nodeType) {
	                  var found;
	                  el.parents().each(function (index, _el) {
	                      if (_el === selector) found = selector;
	                  });
	                  if (!found) return undefined;
	                  else return selector;
	              }
	          }
	          if (el.length === 0) {
	              return undefined;
	          }
	          return el[0];
	      }
	      s.updateClickedSlide = function (e) {
	          var slide = findElementInEvent(e, '.' + s.params.slideClass);
	          var slideFound = false;
	          if (slide) {
	              for (var i = 0; i < s.slides.length; i++) {
	                  if (s.slides[i] === slide) slideFound = true;
	              }
	          }

	          if (slide && slideFound) {
	              s.clickedSlide = slide;
	              s.clickedIndex = $(slide).index();
	          }
	          else {
	              s.clickedSlide = undefined;
	              s.clickedIndex = undefined;
	              return;
	          }
	          if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
	              var slideToIndex = s.clickedIndex,
	                  realIndex;
	              if (s.params.loop) {
	                  realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');
	                  if (slideToIndex > s.slides.length - s.params.slidesPerView) {
	                      s.fixLoop();
	                      slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]').eq(0).index();
	                      setTimeout(function () {
	                          s.slideTo(slideToIndex);
	                      }, 0);
	                  }
	                  else if (slideToIndex < s.params.slidesPerView - 1) {
	                      s.fixLoop();
	                      var duplicatedSlides = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]');
	                      slideToIndex = duplicatedSlides.eq(duplicatedSlides.length - 1).index();
	                      setTimeout(function () {
	                          s.slideTo(slideToIndex);
	                      }, 0);
	                  }
	                  else {
	                      s.slideTo(slideToIndex);
	                  }
	              }
	              else {
	                  s.slideTo(slideToIndex);
	              }
	          }
	      };

	      var isTouched,
	          isMoved,
	          touchStartTime,
	          isScrolling,
	          currentTranslate,
	          startTranslate,
	          allowThresholdMove,
	          // Form elements to match
	          formElements = 'input, select, textarea, button',
	          // Last click time
	          lastClickTime = Date.now(), clickTimeout,
	          //Velocities
	          velocities = [],
	          allowMomentumBounce;

	      // Animating Flag
	      s.animating = false;

	      // Touches information
	      s.touches = {
	          startX: 0,
	          startY: 0,
	          currentX: 0,
	          currentY: 0,
	          diff: 0
	      };

	      // Touch handlers
	      var isTouchEvent, startMoving;
	      s.onTouchStart = function (e) {
	          if (e.originalEvent) e = e.originalEvent;
	          isTouchEvent = e.type === 'touchstart';
	          if (!isTouchEvent && 'which' in e && e.which === 3) return;
	          if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
	              s.allowClick = true;
	              return;
	          }
	          if (s.params.swipeHandler) {
	              if (!findElementInEvent(e, s.params.swipeHandler)) return;
	          }

	          var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
	          var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;

	          // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
	          if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
	              return;
	          }

	          isTouched = true;
	          isMoved = false;
	          isScrolling = undefined;
	          startMoving = undefined;
	          s.touches.startX = startX;
	          s.touches.startY = startY;
	          touchStartTime = Date.now();
	          s.allowClick = true;
	          s.updateContainerSize();
	          s.swipeDirection = undefined;
	          if (s.params.threshold > 0) allowThresholdMove = false;
	          if (e.type !== 'touchstart') {
	              var preventDefault = true;
	              if ($(e.target).is(formElements)) preventDefault = false;
	              if (document.activeElement && $(document.activeElement).is(formElements)) {
	                  document.activeElement.blur();
	              }
	              if (preventDefault) {
	                  e.preventDefault();
	              }
	          }
	          s.emit('onTouchStart', s, e);
	      };

	      s.onTouchMove = function (e) {
	          if (e.originalEvent) e = e.originalEvent;
	          if (isTouchEvent && e.type === 'mousemove') return;
	          if (e.preventedByNestedSwiper) return;
	          if (s.params.onlyExternal) {
	              // isMoved = true;
	              s.allowClick = false;
	              if (isTouched) {
	                  s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	                  s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
	                  touchStartTime = Date.now();
	              }
	              return;
	          }
	          if (isTouchEvent && document.activeElement) {
	              if (e.target === document.activeElement && $(e.target).is(formElements)) {
	                  isMoved = true;
	                  s.allowClick = false;
	                  return;
	              }
	          }

	          s.emit('onTouchMove', s, e);

	          if (e.targetTouches && e.targetTouches.length > 1) return;

	          s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
	          s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

	          if (typeof isScrolling === 'undefined') {
	              var touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
	              isScrolling = isH() ? touchAngle > s.params.touchAngle : (90 - touchAngle > s.params.touchAngle);
	          }
	          if (isScrolling) {
	              s.emit('onTouchMoveOpposite', s, e);
	          }
	          if (typeof startMoving === 'undefined' && s.browser.ieTouch) {
	              if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
	                  startMoving = true;
	              }
	          }
	          if (!isTouched) return;
	          if (isScrolling)  {
	              isTouched = false;
	              return;
	          }
	          if (!startMoving && s.browser.ieTouch) {
	              return;
	          }
	          s.allowClick = false;
	          s.emit('onSliderMove', s, e);
	          e.preventDefault();
	          if (s.params.touchMoveStopPropagation && !s.params.nested) {
	              e.stopPropagation();
	          }

	          if (!isMoved) {
	              if (params.loop) {
	                  s.fixLoop();
	              }
	              startTranslate = s.getWrapperTranslate();
	              s.setWrapperTransition(0);
	              if (s.animating) {
	                  s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
	              }
	              if (s.params.autoplay && s.autoplaying) {
	                  if (s.params.autoplayDisableOnInteraction) {
	                      s.stopAutoplay();
	                  }
	                  else {
	                      s.pauseAutoplay();
	                  }
	              }
	              allowMomentumBounce = false;
	              //Grab Cursor
	              if (s.params.grabCursor) {
	                  s.container[0].style.cursor = 'move';
	                  s.container[0].style.cursor = '-webkit-grabbing';
	                  s.container[0].style.cursor = '-moz-grabbin';
	                  s.container[0].style.cursor = 'grabbing';
	              }
	          }
	          isMoved = true;

	          var diff = s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;

	          diff = diff * s.params.touchRatio;
	          if (s.rtl) diff = -diff;

	          s.swipeDirection = diff > 0 ? 'prev' : 'next';
	          currentTranslate = diff + startTranslate;

	          var disableParentSwiper = true;
	          if ((diff > 0 && currentTranslate > s.minTranslate())) {
	              disableParentSwiper = false;
	              if (s.params.resistance) currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
	          }
	          else if (diff < 0 && currentTranslate < s.maxTranslate()) {
	              disableParentSwiper = false;
	              if (s.params.resistance) currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
	          }

	          if (disableParentSwiper) {
	              e.preventedByNestedSwiper = true;
	          }

	          // Directions locks
	          if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
	              currentTranslate = startTranslate;
	          }
	          if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
	              currentTranslate = startTranslate;
	          }

	          if (!s.params.followFinger) return;

	          // Threshold
	          if (s.params.threshold > 0) {
	              if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
	                  if (!allowThresholdMove) {
	                      allowThresholdMove = true;
	                      s.touches.startX = s.touches.currentX;
	                      s.touches.startY = s.touches.currentY;
	                      currentTranslate = startTranslate;
	                      s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
	                      return;
	                  }
	              }
	              else {
	                  currentTranslate = startTranslate;
	                  return;
	              }
	          }
	          // Update active index in free mode
	          if (s.params.freeMode || s.params.watchSlidesProgress) {
	              s.updateActiveIndex();
	          }
	          if (s.params.freeMode) {
	              //Velocity
	              if (velocities.length === 0) {
	                  velocities.push({
	                      position: s.touches[isH() ? 'startX' : 'startY'],
	                      time: touchStartTime
	                  });
	              }
	              velocities.push({
	                  position: s.touches[isH() ? 'currentX' : 'currentY'],
	                  time: (new window.Date()).getTime()
	              });
	          }
	          // Update progress
	          s.updateProgress(currentTranslate);
	          // Update translate
	          s.setWrapperTranslate(currentTranslate);
	      };
	      s.onTouchEnd = function (e) {
	          if (e.originalEvent) e = e.originalEvent;
	          s.emit('onTouchEnd', s, e);
	          if (!isTouched) return;
	          //Return Grab Cursor
	          if (s.params.grabCursor && isMoved && isTouched) {
	              s.container[0].style.cursor = 'move';
	              s.container[0].style.cursor = '-webkit-grab';
	              s.container[0].style.cursor = '-moz-grab';
	              s.container[0].style.cursor = 'grab';
	          }

	          // Time diff
	          var touchEndTime = Date.now();
	          var timeDiff = touchEndTime - touchStartTime;

	          // Tap, doubleTap, Click
	          if (s.allowClick) {
	              s.updateClickedSlide(e);
	              s.emit('onTap', s, e);
	              if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
	                  if (clickTimeout) clearTimeout(clickTimeout);
	                  clickTimeout = setTimeout(function () {
	                      if (!s) return;
	                      if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
	                          s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
	                      }
	                      s.emit('onClick', s, e);
	                  }, 300);

	              }
	              if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
	                  if (clickTimeout) clearTimeout(clickTimeout);
	                  s.emit('onDoubleTap', s, e);
	              }
	          }

	          lastClickTime = Date.now();
	          setTimeout(function () {
	              if (s) s.allowClick = true;
	          }, 0);

	          if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
	              isTouched = isMoved = false;
	              return;
	          }
	          isTouched = isMoved = false;

	          var currentPos;
	          if (s.params.followFinger) {
	              currentPos = s.rtl ? s.translate : -s.translate;
	          }
	          else {
	              currentPos = -currentTranslate;
	          }
	          if (s.params.freeMode) {
	              if (currentPos < -s.minTranslate()) {
	                  s.slideTo(s.activeIndex);
	                  return;
	              }
	              else if (currentPos > -s.maxTranslate()) {
	                  if (s.slides.length < s.snapGrid.length) {
	                      s.slideTo(s.snapGrid.length - 1);
	                  }
	                  else {
	                      s.slideTo(s.slides.length - 1);
	                  }
	                  return;
	              }

	              if (s.params.freeModeMomentum) {
	                  if (velocities.length > 1) {
	                      var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop();

	                      var distance = lastMoveEvent.position - velocityEvent.position;
	                      var time = lastMoveEvent.time - velocityEvent.time;
	                      s.velocity = distance / time;
	                      s.velocity = s.velocity / 2;
	                      if (Math.abs(s.velocity) < 0.02) {
	                          s.velocity = 0;
	                      }
	                      // this implies that the user stopped moving a finger then released.
	                      // There would be no events with distance zero, so the last event is stale.
	                      if (time > 150 || (new window.Date().getTime() - lastMoveEvent.time) > 300) {
	                          s.velocity = 0;
	                      }
	                  } else {
	                      s.velocity = 0;
	                  }

	                  velocities.length = 0;
	                  var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
	                  var momentumDistance = s.velocity * momentumDuration;

	                  var newPosition = s.translate + momentumDistance;
	                  if (s.rtl) newPosition = - newPosition;
	                  var doBounce = false;
	                  var afterBouncePosition;
	                  var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
	                  if (newPosition < s.maxTranslate()) {
	                      if (s.params.freeModeMomentumBounce) {
	                          if (newPosition + s.maxTranslate() < -bounceAmount) {
	                              newPosition = s.maxTranslate() - bounceAmount;
	                          }
	                          afterBouncePosition = s.maxTranslate();
	                          doBounce = true;
	                          allowMomentumBounce = true;
	                      }
	                      else {
	                          newPosition = s.maxTranslate();
	                      }
	                  }
	                  else if (newPosition > s.minTranslate()) {
	                      if (s.params.freeModeMomentumBounce) {
	                          if (newPosition - s.minTranslate() > bounceAmount) {
	                              newPosition = s.minTranslate() + bounceAmount;
	                          }
	                          afterBouncePosition = s.minTranslate();
	                          doBounce = true;
	                          allowMomentumBounce = true;
	                      }
	                      else {
	                          newPosition = s.minTranslate();
	                      }
	                  }
	                  else if (s.params.freeModeSticky) {
	                      var j = 0,
	                          nextSlide;
	                      for (j = 0; j < s.snapGrid.length; j += 1) {
	                          if (s.snapGrid[j] > -newPosition) {
	                              nextSlide = j;
	                              break;
	                          }

	                      }
	                      if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
	                          newPosition = s.snapGrid[nextSlide];
	                      } else {
	                          newPosition = s.snapGrid[nextSlide - 1];
	                      }
	                      if (!s.rtl) newPosition = - newPosition;
	                  }
	                  //Fix duration
	                  if (s.velocity !== 0) {
	                      if (s.rtl) {
	                          momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
	                      }
	                      else {
	                          momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
	                      }
	                  }
	                  else if (s.params.freeModeSticky) {
	                      s.slideReset();
	                      return;
	                  }

	                  if (s.params.freeModeMomentumBounce && doBounce) {
	                      s.updateProgress(afterBouncePosition);
	                      s.setWrapperTransition(momentumDuration);
	                      s.setWrapperTranslate(newPosition);
	                      s.onTransitionStart();
	                      s.animating = true;
	                      s.wrapper.transitionEnd(function () {
	                          if (!s || !allowMomentumBounce) return;
	                          s.emit('onMomentumBounce', s);

	                          s.setWrapperTransition(s.params.speed);
	                          s.setWrapperTranslate(afterBouncePosition);
	                          s.wrapper.transitionEnd(function () {
	                              if (!s) return;
	                              s.onTransitionEnd();
	                          });
	                      });
	                  } else if (s.velocity) {
	                      s.updateProgress(newPosition);
	                      s.setWrapperTransition(momentumDuration);
	                      s.setWrapperTranslate(newPosition);
	                      s.onTransitionStart();
	                      if (!s.animating) {
	                          s.animating = true;
	                          s.wrapper.transitionEnd(function () {
	                              if (!s) return;
	                              s.onTransitionEnd();
	                          });
	                      }

	                  } else {
	                      s.updateProgress(newPosition);
	                  }

	                  s.updateActiveIndex();
	              }
	              if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
	                  s.updateProgress();
	                  s.updateActiveIndex();
	              }
	              return;
	          }

	          // Find current slide
	          var i, stopIndex = 0, groupSize = s.slidesSizesGrid[0];
	          for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
	              if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
	                  if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
	                      stopIndex = i;
	                      groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
	                  }
	              }
	              else {
	                  if (currentPos >= s.slidesGrid[i]) {
	                      stopIndex = i;
	                      groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
	                  }
	              }
	          }

	          // Find current slide size
	          var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;

	          if (timeDiff > s.params.longSwipesMs) {
	              // Long touches
	              if (!s.params.longSwipes) {
	                  s.slideTo(s.activeIndex);
	                  return;
	              }
	              if (s.swipeDirection === 'next') {
	                  if (ratio >= s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);
	                  else s.slideTo(stopIndex);

	              }
	              if (s.swipeDirection === 'prev') {
	                  if (ratio > (1 - s.params.longSwipesRatio)) s.slideTo(stopIndex + s.params.slidesPerGroup);
	                  else s.slideTo(stopIndex);
	              }
	          }
	          else {
	              // Short swipes
	              if (!s.params.shortSwipes) {
	                  s.slideTo(s.activeIndex);
	                  return;
	              }
	              if (s.swipeDirection === 'next') {
	                  s.slideTo(stopIndex + s.params.slidesPerGroup);

	              }
	              if (s.swipeDirection === 'prev') {
	                  s.slideTo(stopIndex);
	              }
	          }
	      };
	      /*=========================
	        Transitions
	        ===========================*/
	      s._slideTo = function (slideIndex, speed) {
	          return s.slideTo(slideIndex, speed, true, true);
	      };
	      s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
	          if (typeof runCallbacks === 'undefined') runCallbacks = true;
	          if (typeof slideIndex === 'undefined') slideIndex = 0;
	          if (slideIndex < 0) slideIndex = 0;
	          s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
	          if (s.snapIndex >= s.snapGrid.length) s.snapIndex = s.snapGrid.length - 1;

	          var translate = - s.snapGrid[s.snapIndex];

	          // Stop autoplay
	          if (s.params.autoplay && s.autoplaying) {
	              if (internal || !s.params.autoplayDisableOnInteraction) {
	                  s.pauseAutoplay(speed);
	              }
	              else {
	                  s.stopAutoplay();
	              }
	          }
	          // Update progress
	          s.updateProgress(translate);

	          // Normalize slideIndex
	          for (var i = 0; i < s.slidesGrid.length; i++) {
	              if (- Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
	                  slideIndex = i;
	              }
	          }

	          // Directions locks
	          if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
	              return false;
	          }
	          if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
	              if ((s.activeIndex || 0) !== slideIndex ) return false;
	          }

	          // Update Index
	          if (typeof speed === 'undefined') speed = s.params.speed;
	          s.previousIndex = s.activeIndex || 0;
	          s.activeIndex = slideIndex;

	          if (translate === s.translate) {
	              s.updateClasses();
	              return false;
	          }
	          s.updateClasses();
	          s.onTransitionStart(runCallbacks);
	          var translateX = isH() ? translate : 0, translateY = isH() ? 0 : translate;
	          if (speed === 0) {
	              s.setWrapperTransition(0);
	              s.setWrapperTranslate(translate);
	              s.onTransitionEnd(runCallbacks);
	          }
	          else {
	              s.setWrapperTransition(speed);
	              s.setWrapperTranslate(translate);
	              if (!s.animating) {
	                  s.animating = true;
	                  s.wrapper.transitionEnd(function () {
	                      if (!s) return;
	                      s.onTransitionEnd(runCallbacks);
	                  });
	              }

	          }

	          return true;
	      };

	      s.onTransitionStart = function (runCallbacks) {
	          if (typeof runCallbacks === 'undefined') runCallbacks = true;
	          if (s.lazy) s.lazy.onTransitionStart();
	          if (runCallbacks) {
	              s.emit('onTransitionStart', s);
	              if (s.activeIndex !== s.previousIndex) {
	                  s.emit('onSlideChangeStart', s);
	              }
	          }
	      };
	      s.onTransitionEnd = function (runCallbacks) {
	          s.animating = false;
	          s.setWrapperTransition(0);
	          if (typeof runCallbacks === 'undefined') runCallbacks = true;
	          if (s.lazy) s.lazy.onTransitionEnd();
	          if (runCallbacks) {
	              s.emit('onTransitionEnd', s);
	              if (s.activeIndex !== s.previousIndex) {
	                  s.emit('onSlideChangeEnd', s);
	              }
	          }
	          if (s.params.hashnav && s.hashnav) {
	              s.hashnav.setHash();
	          }

	      };
	      s.slideNext = function (runCallbacks, speed, internal) {
	          if (s.params.loop) {
	              if (s.animating) return false;
	              s.fixLoop();
	              var clientLeft = s.container[0].clientLeft;
	              return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
	          }
	          else return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
	      };
	      s._slideNext = function (speed) {
	          return s.slideNext(true, speed, true);
	      };
	      s.slidePrev = function (runCallbacks, speed, internal) {
	          if (s.params.loop) {
	              if (s.animating) return false;
	              s.fixLoop();
	              var clientLeft = s.container[0].clientLeft;
	              return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
	          }
	          else return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
	      };
	      s._slidePrev = function (speed) {
	          return s.slidePrev(true, speed, true);
	      };
	      s.slideReset = function (runCallbacks, speed, internal) {
	          return s.slideTo(s.activeIndex, speed, runCallbacks);
	      };

	      /*=========================
	        Translate/transition helpers
	        ===========================*/
	      s.setWrapperTransition = function (duration, byController) {
	          s.wrapper.transition(duration);
	          if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
	              s.effects[s.params.effect].setTransition(duration);
	          }
	          if (s.params.parallax && s.parallax) {
	              s.parallax.setTransition(duration);
	          }
	          if (s.params.scrollbar && s.scrollbar) {
	              s.scrollbar.setTransition(duration);
	          }
	          if (s.params.control && s.controller) {
	              s.controller.setTransition(duration, byController);
	          }
	          s.emit('onSetTransition', s, duration);
	      };
	      s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
	          var x = 0, y = 0, z = 0;
	          if (isH()) {
	              x = s.rtl ? -translate : translate;
	          }
	          else {
	              y = translate;
	          }
	          if (!s.params.virtualTranslate) {
	              if (s.support.transforms3d) s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
	              else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
	          }

	          s.translate = isH() ? x : y;

	          if (updateActiveIndex) s.updateActiveIndex();
	          if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
	              s.effects[s.params.effect].setTranslate(s.translate);
	          }
	          if (s.params.parallax && s.parallax) {
	              s.parallax.setTranslate(s.translate);
	          }
	          if (s.params.scrollbar && s.scrollbar) {
	              s.scrollbar.setTranslate(s.translate);
	          }
	          if (s.params.control && s.controller) {
	              s.controller.setTranslate(s.translate, byController);
	          }
	          s.emit('onSetTranslate', s, s.translate);
	      };

	      s.getTranslate = function (el, axis) {
	          var matrix, curTransform, curStyle, transformMatrix;

	          // automatic axis detection
	          if (typeof axis === 'undefined') {
	              axis = 'x';
	          }

	          if (s.params.virtualTranslate) {
	              return s.rtl ? -s.translate : s.translate;
	          }

	          curStyle = window.getComputedStyle(el, null);
	          if (window.WebKitCSSMatrix) {
	              // Some old versions of Webkit choke when 'none' is passed; pass
	              // empty string instead in this case
	              transformMatrix = new window.WebKitCSSMatrix(curStyle.webkitTransform === 'none' ? '' : curStyle.webkitTransform);
	          }
	          else {
	              transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform  || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
	              matrix = transformMatrix.toString().split(',');
	          }

	          if (axis === 'x') {
	              //Latest Chrome and webkits Fix
	              if (window.WebKitCSSMatrix)
	                  curTransform = transformMatrix.m41;
	              //Crazy IE10 Matrix
	              else if (matrix.length === 16)
	                  curTransform = parseFloat(matrix[12]);
	              //Normal Browsers
	              else
	                  curTransform = parseFloat(matrix[4]);
	          }
	          if (axis === 'y') {
	              //Latest Chrome and webkits Fix
	              if (window.WebKitCSSMatrix)
	                  curTransform = transformMatrix.m42;
	              //Crazy IE10 Matrix
	              else if (matrix.length === 16)
	                  curTransform = parseFloat(matrix[13]);
	              //Normal Browsers
	              else
	                  curTransform = parseFloat(matrix[5]);
	          }
	          if (s.rtl && curTransform) curTransform = -curTransform;
	          return curTransform || 0;
	      };
	      s.getWrapperTranslate = function (axis) {
	          if (typeof axis === 'undefined') {
	              axis = isH() ? 'x' : 'y';
	          }
	          return s.getTranslate(s.wrapper[0], axis);
	      };

	      /*=========================
	        Observer
	        ===========================*/
	      s.observers = [];
	      function initObserver(target, options) {
	          options = options || {};
	          // create an observer instance
	          var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
	          var observer = new ObserverFunc(function (mutations) {
	              mutations.forEach(function (mutation) {
	                  s.onResize(true);
	                  s.emit('onObserverUpdate', s, mutation);
	              });
	          });

	          observer.observe(target, {
	              attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
	              childList: typeof options.childList === 'undefined' ? true : options.childList,
	              characterData: typeof options.characterData === 'undefined' ? true : options.characterData
	          });

	          s.observers.push(observer);
	      }
	      s.initObservers = function () {
	          if (s.params.observeParents) {
	              var containerParents = s.container.parents();
	              for (var i = 0; i < containerParents.length; i++) {
	                  initObserver(containerParents[i]);
	              }
	          }

	          // Observe container
	          initObserver(s.container[0], {childList: false});

	          // Observe wrapper
	          initObserver(s.wrapper[0], {attributes: false});
	      };
	      s.disconnectObservers = function () {
	          for (var i = 0; i < s.observers.length; i++) {
	              s.observers[i].disconnect();
	          }
	          s.observers = [];
	      };
	      /*=========================
	        Loop
	        ===========================*/
	      // Create looped slides
	      s.createLoop = function () {
	          // Remove duplicated slides
	          s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();

	          var slides = s.wrapper.children('.' + s.params.slideClass);

	          if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides) s.params.loopedSlides = slides.length;

	          s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
	          s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
	          if (s.loopedSlides > slides.length) {
	              s.loopedSlides = slides.length;
	          }

	          var prependSlides = [], appendSlides = [], i;
	          slides.each(function (index, el) {
	              var slide = $(this);
	              if (index < s.loopedSlides) appendSlides.push(el);
	              if (index < slides.length && index >= slides.length - s.loopedSlides) prependSlides.push(el);
	              slide.attr('data-swiper-slide-index', index);
	          });
	          for (i = 0; i < appendSlides.length; i++) {
	              s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
	          }
	          for (i = prependSlides.length - 1; i >= 0; i--) {
	              s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
	          }
	      };
	      s.destroyLoop = function () {
	          s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
	          s.slides.removeAttr('data-swiper-slide-index');
	      };
	      s.fixLoop = function () {
	          var newIndex;
	          //Fix For Negative Oversliding
	          if (s.activeIndex < s.loopedSlides) {
	              newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
	              newIndex = newIndex + s.loopedSlides;
	              s.slideTo(newIndex, 0, false, true);
	          }
	          //Fix For Positive Oversliding
	          else if ((s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2) || (s.activeIndex > s.slides.length - s.params.slidesPerView * 2)) {
	              newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
	              newIndex = newIndex + s.loopedSlides;
	              s.slideTo(newIndex, 0, false, true);
	          }
	      };
	      /*=========================
	        Append/Prepend/Remove Slides
	        ===========================*/
	      s.appendSlide = function (slides) {
	          if (s.params.loop) {
	              s.destroyLoop();
	          }
	          if (typeof slides === 'object' && slides.length) {
	              for (var i = 0; i < slides.length; i++) {
	                  if (slides[i]) s.wrapper.append(slides[i]);
	              }
	          }
	          else {
	              s.wrapper.append(slides);
	          }
	          if (s.params.loop) {
	              s.createLoop();
	          }
	          if (!(s.params.observer && s.support.observer)) {
	              s.update(true);
	          }
	      };
	      s.prependSlide = function (slides) {
	          if (s.params.loop) {
	              s.destroyLoop();
	          }
	          var newActiveIndex = s.activeIndex + 1;
	          if (typeof slides === 'object' && slides.length) {
	              for (var i = 0; i < slides.length; i++) {
	                  if (slides[i]) s.wrapper.prepend(slides[i]);
	              }
	              newActiveIndex = s.activeIndex + slides.length;
	          }
	          else {
	              s.wrapper.prepend(slides);
	          }
	          if (s.params.loop) {
	              s.createLoop();
	          }
	          if (!(s.params.observer && s.support.observer)) {
	              s.update(true);
	          }
	          s.slideTo(newActiveIndex, 0, false);
	      };
	      s.removeSlide = function (slidesIndexes) {
	          if (s.params.loop) {
	              s.destroyLoop();
	              s.slides = s.wrapper.children('.' + s.params.slideClass);
	          }
	          var newActiveIndex = s.activeIndex,
	              indexToRemove;
	          if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
	              for (var i = 0; i < slidesIndexes.length; i++) {
	                  indexToRemove = slidesIndexes[i];
	                  if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
	                  if (indexToRemove < newActiveIndex) newActiveIndex--;
	              }
	              newActiveIndex = Math.max(newActiveIndex, 0);
	          }
	          else {
	              indexToRemove = slidesIndexes;
	              if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
	              if (indexToRemove < newActiveIndex) newActiveIndex--;
	              newActiveIndex = Math.max(newActiveIndex, 0);
	          }

	          if (s.params.loop) {
	              s.createLoop();
	          }

	          if (!(s.params.observer && s.support.observer)) {
	              s.update(true);
	          }
	          if (s.params.loop) {
	              s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
	          }
	          else {
	              s.slideTo(newActiveIndex, 0, false);
	          }

	      };
	      s.removeAllSlides = function () {
	          var slidesIndexes = [];
	          for (var i = 0; i < s.slides.length; i++) {
	              slidesIndexes.push(i);
	          }
	          s.removeSlide(slidesIndexes);
	      };


	      /*=========================
	        Effects
	        ===========================*/
	      s.effects = {
	          fade: {
	              setTranslate: function () {
	                  for (var i = 0; i < s.slides.length; i++) {
	                      var slide = s.slides.eq(i);
	                      var offset = slide[0].swiperSlideOffset;
	                      var tx = -offset;
	                      if (!s.params.virtualTranslate) tx = tx - s.translate;
	                      var ty = 0;
	                      if (!isH()) {
	                          ty = tx;
	                          tx = 0;
	                      }
	                      var slideOpacity = s.params.fade.crossFade ?
	                              Math.max(1 - Math.abs(slide[0].progress), 0) :
	                              1 + Math.min(Math.max(slide[0].progress, -1), 0);
	                      slide
	                          .css({
	                              opacity: slideOpacity
	                          })
	                          .transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');

	                  }

	              },
	              setTransition: function (duration) {
	                  s.slides.transition(duration);
	                  if (s.params.virtualTranslate && duration !== 0) {
	                      var eventTriggered = false;
	                      s.slides.transitionEnd(function () {
	                          if (eventTriggered) return;
	                          if (!s) return;
	                          eventTriggered = true;
	                          s.animating = false;
	                          var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
	                          for (var i = 0; i < triggerEvents.length; i++) {
	                              s.wrapper.trigger(triggerEvents[i]);
	                          }
	                      });
	                  }
	              }
	          },
	          cube: {
	              setTranslate: function () {
	                  var wrapperRotate = 0, cubeShadow;
	                  if (s.params.cube.shadow) {
	                      if (isH()) {
	                          cubeShadow = s.wrapper.find('.swiper-cube-shadow');
	                          if (cubeShadow.length === 0) {
	                              cubeShadow = $('<div class="swiper-cube-shadow"></div>');
	                              s.wrapper.append(cubeShadow);
	                          }
	                          cubeShadow.css({height: s.width + 'px'});
	                      }
	                      else {
	                          cubeShadow = s.container.find('.swiper-cube-shadow');
	                          if (cubeShadow.length === 0) {
	                              cubeShadow = $('<div class="swiper-cube-shadow"></div>');
	                              s.container.append(cubeShadow);
	                          }
	                      }
	                  }
	                  for (var i = 0; i < s.slides.length; i++) {
	                      var slide = s.slides.eq(i);
	                      var slideAngle = i * 90;
	                      var round = Math.floor(slideAngle / 360);
	                      if (s.rtl) {
	                          slideAngle = -slideAngle;
	                          round = Math.floor(-slideAngle / 360);
	                      }
	                      var progress = Math.max(Math.min(slide[0].progress, 1), -1);
	                      var tx = 0, ty = 0, tz = 0;
	                      if (i % 4 === 0) {
	                          tx = - round * 4 * s.size;
	                          tz = 0;
	                      }
	                      else if ((i - 1) % 4 === 0) {
	                          tx = 0;
	                          tz = - round * 4 * s.size;
	                      }
	                      else if ((i - 2) % 4 === 0) {
	                          tx = s.size + round * 4 * s.size;
	                          tz = s.size;
	                      }
	                      else if ((i - 3) % 4 === 0) {
	                          tx = - s.size;
	                          tz = 3 * s.size + s.size * 4 * round;
	                      }
	                      if (s.rtl) {
	                          tx = -tx;
	                      }

	                      if (!isH()) {
	                          ty = tx;
	                          tx = 0;
	                      }

	                      var transform = 'rotateX(' + (isH() ? 0 : -slideAngle) + 'deg) rotateY(' + (isH() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
	                      if (progress <= 1 && progress > -1) {
	                          wrapperRotate = i * 90 + progress * 90;
	                          if (s.rtl) wrapperRotate = -i * 90 - progress * 90;
	                      }
	                      slide.transform(transform);
	                      if (s.params.cube.slideShadows) {
	                          //Set shadows
	                          var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
	                          var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
	                          if (shadowBefore.length === 0) {
	                              shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
	                              slide.append(shadowBefore);
	                          }
	                          if (shadowAfter.length === 0) {
	                              shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
	                              slide.append(shadowAfter);
	                          }
	                          var shadowOpacity = slide[0].progress;
	                          if (shadowBefore.length) shadowBefore[0].style.opacity = -slide[0].progress;
	                          if (shadowAfter.length) shadowAfter[0].style.opacity = slide[0].progress;
	                      }
	                  }
	                  s.wrapper.css({
	                      '-webkit-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
	                      '-moz-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
	                      '-ms-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
	                      'transform-origin': '50% 50% -' + (s.size / 2) + 'px'
	                  });

	                  if (s.params.cube.shadow) {
	                      if (isH()) {
	                          cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + (-s.width / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.params.cube.shadowScale) + ')');
	                      }
	                      else {
	                          var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
	                          var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
	                          var scale1 = s.params.cube.shadowScale,
	                              scale2 = s.params.cube.shadowScale / multiplier,
	                              offset = s.params.cube.shadowOffset;
	                          cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + (-s.height / 2 / scale2) + 'px) rotateX(-90deg)');
	                      }
	                  }
	                  var zFactor = (s.isSafari || s.isUiWebView) ? (-s.size / 2) : 0;
	                  s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isH() ? 0 : wrapperRotate) + 'deg) rotateY(' + (isH() ? -wrapperRotate : 0) + 'deg)');
	              },
	              setTransition: function (duration) {
	                  s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	                  if (s.params.cube.shadow && !isH()) {
	                      s.container.find('.swiper-cube-shadow').transition(duration);
	                  }
	              }
	          },
	          coverflow: {
	              setTranslate: function () {
	                  var transform = s.translate;
	                  var center = isH() ? -transform + s.width / 2 : -transform + s.height / 2;
	                  var rotate = isH() ? s.params.coverflow.rotate: -s.params.coverflow.rotate;
	                  var translate = s.params.coverflow.depth;
	                  //Each slide offset from center
	                  for (var i = 0, length = s.slides.length; i < length; i++) {
	                      var slide = s.slides.eq(i);
	                      var slideSize = s.slidesSizesGrid[i];
	                      var slideOffset = slide[0].swiperSlideOffset;
	                      var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;

	                      var rotateY = isH() ? rotate * offsetMultiplier : 0;
	                      var rotateX = isH() ? 0 : rotate * offsetMultiplier;
	                      // var rotateZ = 0
	                      var translateZ = -translate * Math.abs(offsetMultiplier);

	                      var translateY = isH() ? 0 : s.params.coverflow.stretch * (offsetMultiplier);
	                      var translateX = isH() ? s.params.coverflow.stretch * (offsetMultiplier) : 0;

	                      //Fix for ultra small values
	                      if (Math.abs(translateX) < 0.001) translateX = 0;
	                      if (Math.abs(translateY) < 0.001) translateY = 0;
	                      if (Math.abs(translateZ) < 0.001) translateZ = 0;
	                      if (Math.abs(rotateY) < 0.001) rotateY = 0;
	                      if (Math.abs(rotateX) < 0.001) rotateX = 0;

	                      var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';

	                      slide.transform(slideTransform);
	                      slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
	                      if (s.params.coverflow.slideShadows) {
	                          //Set shadows
	                          var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
	                          var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
	                          if (shadowBefore.length === 0) {
	                              shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
	                              slide.append(shadowBefore);
	                          }
	                          if (shadowAfter.length === 0) {
	                              shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
	                              slide.append(shadowAfter);
	                          }
	                          if (shadowBefore.length) shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
	                          if (shadowAfter.length) shadowAfter[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
	                      }
	                  }

	                  //Set correct perspective for IE10
	                  if (s.browser.ie) {
	                      var ws = s.wrapper[0].style;
	                      ws.perspectiveOrigin = center + 'px 50%';
	                  }
	              },
	              setTransition: function (duration) {
	                  s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
	              }
	          }
	      };

	      /*=========================
	        Images Lazy Loading
	        ===========================*/
	      s.lazy = {
	          initialImageLoaded: false,
	          loadImageInSlide: function (index, loadInDuplicate) {
	              if (typeof index === 'undefined') return;
	              if (typeof loadInDuplicate === 'undefined') loadInDuplicate = true;
	              if (s.slides.length === 0) return;

	              var slide = s.slides.eq(index);
	              var img = slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');
	              if (slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')) {
	                  img.add(slide[0]);
	              }
	              if (img.length === 0) return;

	              img.each(function () {
	                  var _img = $(this);
	                  _img.addClass('swiper-lazy-loading');
	                  var background = _img.attr('data-background');
	                  var src = _img.attr('data-src');
	                  s.loadImage(_img[0], (src || background), false, function () {
	                      if (background) {
	                          _img.css('background-image', 'url(' + background + ')');
	                          _img.removeAttr('data-background');
	                      }
	                      else {
	                          _img.attr('src', src);
	                          _img.removeAttr('data-src');
	                      }

	                      _img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');
	                      slide.find('.swiper-lazy-preloader, .preloader').remove();
	                      if (s.params.loop && loadInDuplicate) {
	                          var slideOriginalIndex = slide.attr('data-swiper-slide-index');
	                          if (slide.hasClass(s.params.slideDuplicateClass)) {
	                              var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
	                              s.lazy.loadImageInSlide(originalSlide.index(), false);
	                          }
	                          else {
	                              var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
	                              s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
	                          }
	                      }
	                      s.emit('onLazyImageReady', s, slide[0], _img[0]);
	                  });

	                  s.emit('onLazyImageLoad', s, slide[0], _img[0]);
	              });

	          },
	          load: function () {
	              var i;
	              if (s.params.watchSlidesVisibility) {
	                  s.wrapper.children('.' + s.params.slideVisibleClass).each(function () {
	                      s.lazy.loadImageInSlide($(this).index());
	                  });
	              }
	              else {
	                  if (s.params.slidesPerView > 1) {
	                      for (i = s.activeIndex; i < s.activeIndex + s.params.slidesPerView ; i++) {
	                          if (s.slides[i]) s.lazy.loadImageInSlide(i);
	                      }
	                  }
	                  else {
	                      s.lazy.loadImageInSlide(s.activeIndex);
	                  }
	              }
	              if (s.params.lazyLoadingInPrevNext) {
	                  if (s.params.slidesPerView > 1) {
	                      // Next Slides
	                      for (i = s.activeIndex + s.params.slidesPerView; i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView; i++) {
	                          if (s.slides[i]) s.lazy.loadImageInSlide(i);
	                      }
	                      // Prev Slides
	                      for (i = s.activeIndex - s.params.slidesPerView; i < s.activeIndex ; i++) {
	                          if (s.slides[i]) s.lazy.loadImageInSlide(i);
	                      }
	                  }
	                  else {
	                      var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
	                      if (nextSlide.length > 0) s.lazy.loadImageInSlide(nextSlide.index());

	                      var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
	                      if (prevSlide.length > 0) s.lazy.loadImageInSlide(prevSlide.index());
	                  }
	              }
	          },
	          onTransitionStart: function () {
	              if (s.params.lazyLoading) {
	                  if (s.params.lazyLoadingOnTransitionStart || (!s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded)) {
	                      s.lazy.load();
	                  }
	              }
	          },
	          onTransitionEnd: function () {
	              if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
	                  s.lazy.load();
	              }
	          }
	      };


	      /*=========================
	        Scrollbar
	        ===========================*/
	      s.scrollbar = {
	          set: function () {
	              if (!s.params.scrollbar) return;
	              var sb = s.scrollbar;
	              sb.track = $(s.params.scrollbar);
	              sb.drag = sb.track.find('.swiper-scrollbar-drag');
	              if (sb.drag.length === 0) {
	                  sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
	                  sb.track.append(sb.drag);
	              }
	              sb.drag[0].style.width = '';
	              sb.drag[0].style.height = '';
	              sb.trackSize = isH() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;

	              sb.divider = s.size / s.virtualSize;
	              sb.moveDivider = sb.divider * (sb.trackSize / s.size);
	              sb.dragSize = sb.trackSize * sb.divider;

	              if (isH()) {
	                  sb.drag[0].style.width = sb.dragSize + 'px';
	              }
	              else {
	                  sb.drag[0].style.height = sb.dragSize + 'px';
	              }

	              if (sb.divider >= 1) {
	                  sb.track[0].style.display = 'none';
	              }
	              else {
	                  sb.track[0].style.display = '';
	              }
	              if (s.params.scrollbarHide) {
	                  sb.track[0].style.opacity = 0;
	              }
	          },
	          setTranslate: function () {
	              if (!s.params.scrollbar) return;
	              var diff;
	              var sb = s.scrollbar;
	              var translate = s.translate || 0;
	              var newPos;

	              var newSize = sb.dragSize;
	              newPos = (sb.trackSize - sb.dragSize) * s.progress;
	              if (s.rtl && isH()) {
	                  newPos = -newPos;
	                  if (newPos > 0) {
	                      newSize = sb.dragSize - newPos;
	                      newPos = 0;
	                  }
	                  else if (-newPos + sb.dragSize > sb.trackSize) {
	                      newSize = sb.trackSize + newPos;
	                  }
	              }
	              else {
	                  if (newPos < 0) {
	                      newSize = sb.dragSize + newPos;
	                      newPos = 0;
	                  }
	                  else if (newPos + sb.dragSize > sb.trackSize) {
	                      newSize = sb.trackSize - newPos;
	                  }
	              }
	              if (isH()) {
	                  if (s.support.transforms3d) {
	                      sb.drag.transform('translate3d(' + (newPos) + 'px, 0, 0)');
	                  }
	                  else {
	                      sb.drag.transform('translateX(' + (newPos) + 'px)');
	                  }
	                  sb.drag[0].style.width = newSize + 'px';
	              }
	              else {
	                  if (s.support.transforms3d) {
	                      sb.drag.transform('translate3d(0px, ' + (newPos) + 'px, 0)');
	                  }
	                  else {
	                      sb.drag.transform('translateY(' + (newPos) + 'px)');
	                  }
	                  sb.drag[0].style.height = newSize + 'px';
	              }
	              if (s.params.scrollbarHide) {
	                  clearTimeout(sb.timeout);
	                  sb.track[0].style.opacity = 1;
	                  sb.timeout = setTimeout(function () {
	                      sb.track[0].style.opacity = 0;
	                      sb.track.transition(400);
	                  }, 1000);
	              }
	          },
	          setTransition: function (duration) {
	              if (!s.params.scrollbar) return;
	              s.scrollbar.drag.transition(duration);
	          }
	      };

	      /*=========================
	        Controller
	        ===========================*/
	      s.controller = {
	          LinearSpline: function (x, y) {
	              this.x = x;
	              this.y = y;
	              this.lastIndex = x.length - 1;
	              // Given an x value (x2), return the expected y2 value:
	              // (x1,y1) is the known point before given value,
	              // (x3,y3) is the known point after given value.
	              var i1, i3;
	              var l = this.x.length;

	              this.interpolate = function (x2) {
	                  if (!x2) return 0;

	                  // Get the indexes of x1 and x3 (the array indexes before and after given x2):
	                  i3 = binarySearch(this.x, x2);
	                  i1 = i3 - 1;

	                  // We have our indexes i1 & i3, so we can calculate already:
	                  // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
	                  return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
	              };

	              var binarySearch = (function() {
	                  var maxIndex, minIndex, guess;
	                  return function(array, val) {
	                      minIndex = -1;
	                      maxIndex = array.length;
	                      while (maxIndex - minIndex > 1)
	                          if (array[guess = maxIndex + minIndex >> 1] <= val) {
	                              minIndex = guess;
	                          } else {
	                              maxIndex = guess;
	                          }
	                      return maxIndex;
	                  };
	              })();
	          },
	          //xxx: for now i will just save one spline function to to
	          getInterpolateFunction: function(c){
	              if(!s.controller.spline) s.controller.spline = s.params.loop ?
	                  new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) :
	                  new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
	          },
	          setTranslate: function (translate, byController) {
	             var controlled = s.params.control;
	             var multiplier, controlledTranslate;
	             function setControlledTranslate(c) {
	                  // this will create an Interpolate function based on the snapGrids
	                  // x is the Grid of the scrolled scroller and y will be the controlled scroller
	                  // it makes sense to create this only once and recall it for the interpolation
	                  // the function does a lot of value caching for performance
	                  translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
	                  if (s.params.controlBy === 'slide') {
	                      s.controller.getInterpolateFunction(c);
	                      // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
	                      // but it did not work out
	                      controlledTranslate = -s.controller.spline.interpolate(-translate);
	                  }

	                  if(!controlledTranslate || s.params.controlBy === 'container'){
	                      multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
	                      controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
	                  }

	                  if (s.params.controlInverse) {
	                      controlledTranslate = c.maxTranslate() - controlledTranslate;
	                  }
	                  c.updateProgress(controlledTranslate);
	                  c.setWrapperTranslate(controlledTranslate, false, s);
	                  c.updateActiveIndex();
	             }
	             if (s.isArray(controlled)) {
	                 for (var i = 0; i < controlled.length; i++) {
	                     if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	                         setControlledTranslate(controlled[i]);
	                     }
	                 }
	             }
	             else if (controlled instanceof Swiper && byController !== controlled) {

	                 setControlledTranslate(controlled);
	             }
	          },
	          setTransition: function (duration, byController) {
	              var controlled = s.params.control;
	              var i;
	              function setControlledTransition(c) {
	                  c.setWrapperTransition(duration, s);
	                  if (duration !== 0) {
	                      c.onTransitionStart();
	                      c.wrapper.transitionEnd(function(){
	                          if (!controlled) return;
	                          if (c.params.loop && s.params.controlBy === 'slide') {
	                              c.fixLoop();
	                          }
	                          c.onTransitionEnd();

	                      });
	                  }
	              }
	              if (s.isArray(controlled)) {
	                  for (i = 0; i < controlled.length; i++) {
	                      if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
	                          setControlledTransition(controlled[i]);
	                      }
	                  }
	              }
	              else if (controlled instanceof Swiper && byController !== controlled) {
	                  setControlledTransition(controlled);
	              }
	          }
	      };

	      /*=========================
	        Hash Navigation
	        ===========================*/
	      s.hashnav = {
	          init: function () {
	              if (!s.params.hashnav) return;
	              s.hashnav.initialized = true;
	              var hash = document.location.hash.replace('#', '');
	              if (!hash) return;
	              var speed = 0;
	              for (var i = 0, length = s.slides.length; i < length; i++) {
	                  var slide = s.slides.eq(i);
	                  var slideHash = slide.attr('data-hash');
	                  if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
	                      var index = slide.index();
	                      s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
	                  }
	              }
	          },
	          setHash: function () {
	              if (!s.hashnav.initialized || !s.params.hashnav) return;
	              document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';
	          }
	      };

	      /*=========================
	        Keyboard Control
	        ===========================*/
	      function handleKeyboard(e) {
	          if (e.originalEvent) e = e.originalEvent; //jquery fix
	          var kc = e.keyCode || e.charCode;
	          // Directions locks
	          if (!s.params.allowSwipeToNext && (isH() && kc === 39 || !isH() && kc === 40)) {
	              return false;
	          }
	          if (!s.params.allowSwipeToPrev && (isH() && kc === 37 || !isH() && kc === 38)) {
	              return false;
	          }
	          if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
	              return;
	          }
	          if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
	              return;
	          }
	          if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
	              var inView = false;
	              //Check that swiper should be inside of visible area of window
	              if (s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0) {
	                  return;
	              }
	              var windowScroll = {
	                  left: window.pageXOffset,
	                  top: window.pageYOffset
	              };
	              var windowWidth = window.innerWidth;
	              var windowHeight = window.innerHeight;
	              var swiperOffset = s.container.offset();
	              if (s.rtl) swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
	              var swiperCoord = [
	                  [swiperOffset.left, swiperOffset.top],
	                  [swiperOffset.left + s.width, swiperOffset.top],
	                  [swiperOffset.left, swiperOffset.top + s.height],
	                  [swiperOffset.left + s.width, swiperOffset.top + s.height]
	              ];
	              for (var i = 0; i < swiperCoord.length; i++) {
	                  var point = swiperCoord[i];
	                  if (
	                      point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&
	                      point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight
	                  ) {
	                      inView = true;
	                  }

	              }
	              if (!inView) return;
	          }
	          if (isH()) {
	              if (kc === 37 || kc === 39) {
	                  if (e.preventDefault) e.preventDefault();
	                  else e.returnValue = false;
	              }
	              if ((kc === 39 && !s.rtl) || (kc === 37 && s.rtl)) s.slideNext();
	              if ((kc === 37 && !s.rtl) || (kc === 39 && s.rtl)) s.slidePrev();
	          }
	          else {
	              if (kc === 38 || kc === 40) {
	                  if (e.preventDefault) e.preventDefault();
	                  else e.returnValue = false;
	              }
	              if (kc === 40) s.slideNext();
	              if (kc === 38) s.slidePrev();
	          }
	      }
	      s.disableKeyboardControl = function () {
	          $(document).off('keydown', handleKeyboard);
	      };
	      s.enableKeyboardControl = function () {
	          $(document).on('keydown', handleKeyboard);
	      };


	      /*=========================
	        Mousewheel Control
	        ===========================*/
	      s.mousewheel = {
	          event: false,
	          lastScrollTime: (new window.Date()).getTime()
	      };
	      if (s.params.mousewheelControl) {
	          try {
	              new window.WheelEvent('wheel');
	              s.mousewheel.event = 'wheel';
	          } catch (e) {}

	          if (!s.mousewheel.event && document.onmousewheel !== undefined) {
	              s.mousewheel.event = 'mousewheel';
	          }
	          if (!s.mousewheel.event) {
	              s.mousewheel.event = 'DOMMouseScroll';
	          }
	      }
	      function handleMousewheel(e) {
	          if (e.originalEvent) e = e.originalEvent; //jquery fix
	          var we = s.mousewheel.event;
	          var delta = 0;
	          //Opera & IE
	          if (e.detail) delta = -e.detail;
	          //WebKits
	          else if (we === 'mousewheel') {
	              if (s.params.mousewheelForceToAxis) {
	                  if (isH()) {
	                      if (Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY)) delta = e.wheelDeltaX;
	                      else return;
	                  }
	                  else {
	                      if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX)) delta = e.wheelDeltaY;
	                      else return;
	                  }
	              }
	              else {
	                  delta = e.wheelDelta;
	              }
	          }
	          //Old FireFox
	          else if (we === 'DOMMouseScroll') delta = -e.detail;
	          //New FireFox
	          else if (we === 'wheel') {
	              if (s.params.mousewheelForceToAxis) {
	                  if (isH()) {
	                      if (Math.abs(e.deltaX) > Math.abs(e.deltaY)) delta = -e.deltaX;
	                      else return;
	                  }
	                  else {
	                      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) delta = -e.deltaY;
	                      else return;
	                  }
	              }
	              else {
	                  delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? - e.deltaX : - e.deltaY;
	              }
	          }

	          if (s.params.mousewheelInvert) delta = -delta;

	          if (!s.params.freeMode) {
	              if ((new window.Date()).getTime() - s.mousewheel.lastScrollTime > 60) {
	                  if (delta < 0) {
	                      if ((!s.isEnd || s.params.loop) && !s.animating) s.slideNext();
	                      else if (s.params.mousewheelReleaseOnEdges) return true;
	                  }
	                  else {
	                      if ((!s.isBeginning || s.params.loop) && !s.animating) s.slidePrev();
	                      else if (s.params.mousewheelReleaseOnEdges) return true;
	                  }
	              }
	              s.mousewheel.lastScrollTime = (new window.Date()).getTime();

	          }
	          else {
	              //Freemode or scrollContainer:

	              var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;

	              if (position > 0) position = 0;
	              if (position < s.maxTranslate()) position = s.maxTranslate();

	              s.setWrapperTransition(0);
	              s.setWrapperTranslate(position);
	              s.updateProgress();
	              s.updateActiveIndex();

	              if (s.params.freeModeSticky) {
	                  clearTimeout(s.mousewheel.timeout);
	                  s.mousewheel.timeout = setTimeout(function () {
	                      s.slideReset();
	                  }, 300);
	              }

	              // Return page scroll on edge positions
	              if (position === 0 || position === s.maxTranslate()) return;
	          }
	          if (s.params.autoplay) s.stopAutoplay();

	          if (e.preventDefault) e.preventDefault();
	          else e.returnValue = false;
	          return false;
	      }
	      s.disableMousewheelControl = function () {
	          if (!s.mousewheel.event) return false;
	          s.container.off(s.mousewheel.event, handleMousewheel);
	          return true;
	      };

	      s.enableMousewheelControl = function () {
	          if (!s.mousewheel.event) return false;
	          s.container.on(s.mousewheel.event, handleMousewheel);
	          return true;
	      };

	      /*=========================
	        Parallax
	        ===========================*/
	      function setParallaxTransform(el, progress) {
	          el = $(el);
	          var p, pX, pY;

	          p = el.attr('data-swiper-parallax') || '0';
	          pX = el.attr('data-swiper-parallax-x');
	          pY = el.attr('data-swiper-parallax-y');
	          if (pX || pY) {
	              pX = pX || '0';
	              pY = pY || '0';
	          }
	          else {
	              if (isH()) {
	                  pX = p;
	                  pY = '0';
	              }
	              else {
	                  pY = p;
	                  pX = '0';
	              }
	          }
	          if ((pX).indexOf('%') >= 0) {
	              pX = parseInt(pX, 10) * progress + '%';
	          }
	          else {
	              pX = pX * progress + 'px' ;
	          }
	          if ((pY).indexOf('%') >= 0) {
	              pY = parseInt(pY, 10) * progress + '%';
	          }
	          else {
	              pY = pY * progress + 'px' ;
	          }
	          el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
	      }
	      s.parallax = {
	          setTranslate: function () {
	              s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
	                  setParallaxTransform(this, s.progress);

	              });
	              s.slides.each(function () {
	                  var slide = $(this);
	                  slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
	                      var progress = Math.min(Math.max(slide[0].progress, -1), 1);
	                      setParallaxTransform(this, progress);
	                  });
	              });
	          },
	          setTransition: function (duration) {
	              if (typeof duration === 'undefined') duration = s.params.speed;
	              s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
	                  var el = $(this);
	                  var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
	                  if (duration === 0) parallaxDuration = 0;
	                  el.transition(parallaxDuration);
	              });
	          }
	      };


	      /*=========================
	        Plugins API. Collect all and init all plugins
	        ===========================*/
	      s._plugins = [];
	      for (var plugin in s.plugins) {
	          var p = s.plugins[plugin](s, s.params[plugin]);
	          if (p) s._plugins.push(p);
	      }
	      // Method to call all plugins event/method
	      s.callPlugins = function (eventName) {
	          for (var i = 0; i < s._plugins.length; i++) {
	              if (eventName in s._plugins[i]) {
	                  s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	              }
	          }
	      };

	      /*=========================
	        Events/Callbacks/Plugins Emitter
	        ===========================*/
	      function normalizeEventName (eventName) {
	          if (eventName.indexOf('on') !== 0) {
	              if (eventName[0] !== eventName[0].toUpperCase()) {
	                  eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
	              }
	              else {
	                  eventName = 'on' + eventName;
	              }
	          }
	          return eventName;
	      }
	      s.emitterEventListeners = {

	      };
	      s.emit = function (eventName) {
	          // Trigger callbacks
	          if (s.params[eventName]) {
	              s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	          }
	          var i;
	          // Trigger events
	          if (s.emitterEventListeners[eventName]) {
	              for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
	                  s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	              }
	          }
	          // Trigger plugins
	          if (s.callPlugins) s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
	      };
	      s.on = function (eventName, handler) {
	          eventName = normalizeEventName(eventName);
	          if (!s.emitterEventListeners[eventName]) s.emitterEventListeners[eventName] = [];
	          s.emitterEventListeners[eventName].push(handler);
	          return s;
	      };
	      s.off = function (eventName, handler) {
	          var i;
	          eventName = normalizeEventName(eventName);
	          if (typeof handler === 'undefined') {
	              // Remove all handlers for such event
	              s.emitterEventListeners[eventName] = [];
	              return s;
	          }
	          if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0) return;
	          for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
	              if(s.emitterEventListeners[eventName][i] === handler) s.emitterEventListeners[eventName].splice(i, 1);
	          }
	          return s;
	      };
	      s.once = function (eventName, handler) {
	          eventName = normalizeEventName(eventName);
	          var _handler = function () {
	              handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
	              s.off(eventName, _handler);
	          };
	          s.on(eventName, _handler);
	          return s;
	      };

	      // Accessibility tools
	      s.a11y = {
	          makeFocusable: function ($el) {
	              $el.attr('tabIndex', '0');
	              return $el;
	          },
	          addRole: function ($el, role) {
	              $el.attr('role', role);
	              return $el;
	          },

	          addLabel: function ($el, label) {
	              $el.attr('aria-label', label);
	              return $el;
	          },

	          disable: function ($el) {
	              $el.attr('aria-disabled', true);
	              return $el;
	          },

	          enable: function ($el) {
	              $el.attr('aria-disabled', false);
	              return $el;
	          },

	          onEnterKey: function (event) {
	              if (event.keyCode !== 13) return;
	              if ($(event.target).is(s.params.nextButton)) {
	                  s.onClickNext(event);
	                  if (s.isEnd) {
	                      s.a11y.notify(s.params.lastSlideMessage);
	                  }
	                  else {
	                      s.a11y.notify(s.params.nextSlideMessage);
	                  }
	              }
	              else if ($(event.target).is(s.params.prevButton)) {
	                  s.onClickPrev(event);
	                  if (s.isBeginning) {
	                      s.a11y.notify(s.params.firstSlideMessage);
	                  }
	                  else {
	                      s.a11y.notify(s.params.prevSlideMessage);
	                  }
	              }
	              if ($(event.target).is('.' + s.params.bulletClass)) {
	                  $(event.target)[0].click();
	              }
	          },

	          liveRegion: $('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),

	          notify: function (message) {
	              var notification = s.a11y.liveRegion;
	              if (notification.length === 0) return;
	              notification.html('');
	              notification.html(message);
	          },
	          init: function () {
	              // Setup accessibility
	              if (s.params.nextButton) {
	                  var nextButton = $(s.params.nextButton);
	                  s.a11y.makeFocusable(nextButton);
	                  s.a11y.addRole(nextButton, 'button');
	                  s.a11y.addLabel(nextButton, s.params.nextSlideMessage);
	              }
	              if (s.params.prevButton) {
	                  var prevButton = $(s.params.prevButton);
	                  s.a11y.makeFocusable(prevButton);
	                  s.a11y.addRole(prevButton, 'button');
	                  s.a11y.addLabel(prevButton, s.params.prevSlideMessage);
	              }

	              $(s.container).append(s.a11y.liveRegion);
	          },
	          initPagination: function () {
	              if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
	                  s.bullets.each(function () {
	                      var bullet = $(this);
	                      s.a11y.makeFocusable(bullet);
	                      s.a11y.addRole(bullet, 'button');
	                      s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
	                  });
	              }
	          },
	          destroy: function () {
	              if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0) s.a11y.liveRegion.remove();
	          }
	      };


	      /*=========================
	        Init/Destroy
	        ===========================*/
	      s.init = function () {
	          if (s.params.loop) s.createLoop();
	          s.updateContainerSize();
	          s.updateSlidesSize();
	          s.updatePagination();
	          if (s.params.scrollbar && s.scrollbar) {
	              s.scrollbar.set();
	          }
	          if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
	              if (!s.params.loop) s.updateProgress();
	              s.effects[s.params.effect].setTranslate();
	          }
	          if (s.params.loop) {
	              s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
	          }
	          else {
	              s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
	              if (s.params.initialSlide === 0) {
	                  if (s.parallax && s.params.parallax) s.parallax.setTranslate();
	                  if (s.lazy && s.params.lazyLoading) {
	                      s.lazy.load();
	                      s.lazy.initialImageLoaded = true;
	                  }
	              }
	          }
	          s.attachEvents();
	          if (s.params.observer && s.support.observer) {
	              s.initObservers();
	          }
	          if (s.params.preloadImages && !s.params.lazyLoading) {
	              s.preloadImages();
	          }
	          if (s.params.autoplay) {
	              s.startAutoplay();
	          }
	          if (s.params.keyboardControl) {
	              if (s.enableKeyboardControl) s.enableKeyboardControl();
	          }
	          if (s.params.mousewheelControl) {
	              if (s.enableMousewheelControl) s.enableMousewheelControl();
	          }
	          if (s.params.hashnav) {
	              if (s.hashnav) s.hashnav.init();
	          }
	          if (s.params.a11y && s.a11y) s.a11y.init();
	          s.emit('onInit', s);
	      };

	      // Cleanup dynamic styles
	      s.cleanupStyles = function () {
	          // Container
	          s.container.removeClass(s.classNames.join(' ')).removeAttr('style');

	          // Wrapper
	          s.wrapper.removeAttr('style');

	          // Slides
	          if (s.slides && s.slides.length) {
	              s.slides
	                  .removeClass([
	                    s.params.slideVisibleClass,
	                    s.params.slideActiveClass,
	                    s.params.slideNextClass,
	                    s.params.slidePrevClass
	                  ].join(' '))
	                  .removeAttr('style')
	                  .removeAttr('data-swiper-column')
	                  .removeAttr('data-swiper-row');
	          }

	          // Pagination/Bullets
	          if (s.paginationContainer && s.paginationContainer.length) {
	              s.paginationContainer.removeClass(s.params.paginationHiddenClass);
	          }
	          if (s.bullets && s.bullets.length) {
	              s.bullets.removeClass(s.params.bulletActiveClass);
	          }

	          // Buttons
	          if (s.params.prevButton) $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
	          if (s.params.nextButton) $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);

	          // Scrollbar
	          if (s.params.scrollbar && s.scrollbar) {
	              if (s.scrollbar.track && s.scrollbar.track.length) s.scrollbar.track.removeAttr('style');
	              if (s.scrollbar.drag && s.scrollbar.drag.length) s.scrollbar.drag.removeAttr('style');
	          }
	      };

	      // Destroy
	      s.destroy = function (deleteInstance, cleanupStyles) {
	          // Detach evebts
	          s.detachEvents();
	          // Stop autoplay
	          s.stopAutoplay();
	          // Destroy loop
	          if (s.params.loop) {
	              s.destroyLoop();
	          }
	          // Cleanup styles
	          if (cleanupStyles) {
	              s.cleanupStyles();
	          }
	          // Disconnect observer
	          s.disconnectObservers();
	          // Disable keyboard/mousewheel
	          if (s.params.keyboardControl) {
	              if (s.disableKeyboardControl) s.disableKeyboardControl();
	          }
	          if (s.params.mousewheelControl) {
	              if (s.disableMousewheelControl) s.disableMousewheelControl();
	          }
	          // Disable a11y
	          if (s.params.a11y && s.a11y) s.a11y.destroy();
	          // Destroy callback
	          s.emit('onDestroy');
	          // Delete instance
	          if (deleteInstance !== false) s = null;
	      };

	      s.init();



	      // Return swiper instance
	      return s;
	  };


	  /*==================================================
	      Prototype
	  ====================================================*/
	  Swiper.prototype = {
	      isSafari: (function () {
	          var ua = navigator.userAgent.toLowerCase();
	          return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
	      })(),
	      isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
	      isArray: function (arr) {
	          return Object.prototype.toString.apply(arr) === '[object Array]';
	      },
	      /*==================================================
	      Browser
	      ====================================================*/
	      browser: {
	          ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
	          ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1),
	      },
	      /*==================================================
	      Devices
	      ====================================================*/
	      device: (function () {
	          var ua = navigator.userAgent;
	          var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	          var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	          var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	          var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	          return {
	              ios: ipad || iphone || ipod,
	              android: android
	          };
	      })(),
	      /*==================================================
	      Feature Detection
	      ====================================================*/
	      support: {
	          touch : (window.Modernizr && Modernizr.touch === true) || (function () {
	              return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
	          })(),

	          transforms3d : (window.Modernizr && Modernizr.csstransforms3d === true) || (function () {
	              var div = document.createElement('div').style;
	              return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
	          })(),

	          flexbox: (function () {
	              var div = document.createElement('div').style;
	              var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
	              for (var i = 0; i < styles.length; i++) {
	                  if (styles[i] in div) return true;
	              }
	          })(),

	          observer: (function () {
	              return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
	          })()
	      },
	      /*==================================================
	      Plugins
	      ====================================================*/
	      plugins: {}
	  };


	  /*===========================
	  Dom7 Library
	  ===========================*/
	  var Dom7 = (function () {
	      var Dom7 = function (arr) {
	          var _this = this, i = 0;
	          // Create array-like object
	          for (i = 0; i < arr.length; i++) {
	              _this[i] = arr[i];
	          }
	          _this.length = arr.length;
	          // Return collection with methods
	          return this;
	      };
	      var $ = function (selector, context) {
	          var arr = [], i = 0;
	          if (selector && !context) {
	              if (selector instanceof Dom7) {
	                  return selector;
	              }
	          }
	          if (selector) {
	              // String
	              if (typeof selector === 'string') {
	                  var els, tempParent, html = selector.trim();
	                  if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
	                      var toCreate = 'div';
	                      if (html.indexOf('<li') === 0) toCreate = 'ul';
	                      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
	                      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
	                      if (html.indexOf('<tbody') === 0) toCreate = 'table';
	                      if (html.indexOf('<option') === 0) toCreate = 'select';
	                      tempParent = document.createElement(toCreate);
	                      tempParent.innerHTML = selector;
	                      for (i = 0; i < tempParent.childNodes.length; i++) {
	                          arr.push(tempParent.childNodes[i]);
	                      }
	                  }
	                  else {
	                      if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
	                          // Pure ID selector
	                          els = [document.getElementById(selector.split('#')[1])];
	                      }
	                      else {
	                          // Other selectors
	                          els = (context || document).querySelectorAll(selector);
	                      }
	                      for (i = 0; i < els.length; i++) {
	                          if (els[i]) arr.push(els[i]);
	                      }
	                  }
	              }
	              // Node/element
	              else if (selector.nodeType || selector === window || selector === document) {
	                  arr.push(selector);
	              }
	              //Array of elements or instance of Dom
	              else if (selector.length > 0 && selector[0].nodeType) {
	                  for (i = 0; i < selector.length; i++) {
	                      arr.push(selector[i]);
	                  }
	              }
	          }
	          return new Dom7(arr);
	      };
	      Dom7.prototype = {
	          // Classes and attriutes
	          addClass: function (className) {
	              if (typeof className === 'undefined') {
	                  return this;
	              }
	              var classes = className.split(' ');
	              for (var i = 0; i < classes.length; i++) {
	                  for (var j = 0; j < this.length; j++) {
	                      this[j].classList.add(classes[i]);
	                  }
	              }
	              return this;
	          },
	          removeClass: function (className) {
	              var classes = className.split(' ');
	              for (var i = 0; i < classes.length; i++) {
	                  for (var j = 0; j < this.length; j++) {
	                      this[j].classList.remove(classes[i]);
	                  }
	              }
	              return this;
	          },
	          hasClass: function (className) {
	              if (!this[0]) return false;
	              else return this[0].classList.contains(className);
	          },
	          toggleClass: function (className) {
	              var classes = className.split(' ');
	              for (var i = 0; i < classes.length; i++) {
	                  for (var j = 0; j < this.length; j++) {
	                      this[j].classList.toggle(classes[i]);
	                  }
	              }
	              return this;
	          },
	          attr: function (attrs, value) {
	              if (arguments.length === 1 && typeof attrs === 'string') {
	                  // Get attr
	                  if (this[0]) return this[0].getAttribute(attrs);
	                  else return undefined;
	              }
	              else {
	                  // Set attrs
	                  for (var i = 0; i < this.length; i++) {
	                      if (arguments.length === 2) {
	                          // String
	                          this[i].setAttribute(attrs, value);
	                      }
	                      else {
	                          // Object
	                          for (var attrName in attrs) {
	                              this[i][attrName] = attrs[attrName];
	                              this[i].setAttribute(attrName, attrs[attrName]);
	                          }
	                      }
	                  }
	                  return this;
	              }
	          },
	          removeAttr: function (attr) {
	              for (var i = 0; i < this.length; i++) {
	                  this[i].removeAttribute(attr);
	              }
	              return this;
	          },
	          data: function (key, value) {
	              if (typeof value === 'undefined') {
	                  // Get value
	                  if (this[0]) {
	                      var dataKey = this[0].getAttribute('data-' + key);
	                      if (dataKey) return dataKey;
	                      else if (this[0].dom7ElementDataStorage && (key in this[0].dom7ElementDataStorage)) return this[0].dom7ElementDataStorage[key];
	                      else return undefined;
	                  }
	                  else return undefined;
	              }
	              else {
	                  // Set value
	                  for (var i = 0; i < this.length; i++) {
	                      var el = this[i];
	                      if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
	                      el.dom7ElementDataStorage[key] = value;
	                  }
	                  return this;
	              }
	          },
	          // Transforms
	          transform : function (transform) {
	              for (var i = 0; i < this.length; i++) {
	                  var elStyle = this[i].style;
	                  elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
	              }
	              return this;
	          },
	          transition: function (duration) {
	              if (typeof duration !== 'string') {
	                  duration = duration + 'ms';
	              }
	              for (var i = 0; i < this.length; i++) {
	                  var elStyle = this[i].style;
	                  elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
	              }
	              return this;
	          },
	          //Events
	          on: function (eventName, targetSelector, listener, capture) {
	              function handleLiveEvent(e) {
	                  var target = e.target;
	                  if ($(target).is(targetSelector)) listener.call(target, e);
	                  else {
	                      var parents = $(target).parents();
	                      for (var k = 0; k < parents.length; k++) {
	                          if ($(parents[k]).is(targetSelector)) listener.call(parents[k], e);
	                      }
	                  }
	              }
	              var events = eventName.split(' ');
	              var i, j;
	              for (i = 0; i < this.length; i++) {
	                  if (typeof targetSelector === 'function' || targetSelector === false) {
	                      // Usual events
	                      if (typeof targetSelector === 'function') {
	                          listener = arguments[1];
	                          capture = arguments[2] || false;
	                      }
	                      for (j = 0; j < events.length; j++) {
	                          this[i].addEventListener(events[j], listener, capture);
	                      }
	                  }
	                  else {
	                      //Live events
	                      for (j = 0; j < events.length; j++) {
	                          if (!this[i].dom7LiveListeners) this[i].dom7LiveListeners = [];
	                          this[i].dom7LiveListeners.push({listener: listener, liveListener: handleLiveEvent});
	                          this[i].addEventListener(events[j], handleLiveEvent, capture);
	                      }
	                  }
	              }

	              return this;
	          },
	          off: function (eventName, targetSelector, listener, capture) {
	              var events = eventName.split(' ');
	              for (var i = 0; i < events.length; i++) {
	                  for (var j = 0; j < this.length; j++) {
	                      if (typeof targetSelector === 'function' || targetSelector === false) {
	                          // Usual events
	                          if (typeof targetSelector === 'function') {
	                              listener = arguments[1];
	                              capture = arguments[2] || false;
	                          }
	                          this[j].removeEventListener(events[i], listener, capture);
	                      }
	                      else {
	                          // Live event
	                          if (this[j].dom7LiveListeners) {
	                              for (var k = 0; k < this[j].dom7LiveListeners.length; k++) {
	                                  if (this[j].dom7LiveListeners[k].listener === listener) {
	                                      this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
	                                  }
	                              }
	                          }
	                      }
	                  }
	              }
	              return this;
	          },
	          once: function (eventName, targetSelector, listener, capture) {
	              var dom = this;
	              if (typeof targetSelector === 'function') {
	                  targetSelector = false;
	                  listener = arguments[1];
	                  capture = arguments[2];
	              }
	              function proxy(e) {
	                  listener(e);
	                  dom.off(eventName, targetSelector, proxy, capture);
	              }
	              dom.on(eventName, targetSelector, proxy, capture);
	          },
	          trigger: function (eventName, eventData) {
	              for (var i = 0; i < this.length; i++) {
	                  var evt;
	                  try {
	                      evt = new window.CustomEvent(eventName, {detail: eventData, bubbles: true, cancelable: true});
	                  }
	                  catch (e) {
	                      evt = document.createEvent('Event');
	                      evt.initEvent(eventName, true, true);
	                      evt.detail = eventData;
	                  }
	                  this[i].dispatchEvent(evt);
	              }
	              return this;
	          },
	          transitionEnd: function (callback) {
	              var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
	                  i, j, dom = this;
	              function fireCallBack(e) {
	                  /*jshint validthis:true */
	                  if (e.target !== this) return;
	                  callback.call(this, e);
	                  for (i = 0; i < events.length; i++) {
	                      dom.off(events[i], fireCallBack);
	                  }
	              }
	              if (callback) {
	                  for (i = 0; i < events.length; i++) {
	                      dom.on(events[i], fireCallBack);
	                  }
	              }
	              return this;
	          },
	          // Sizing/Styles
	          width: function () {
	              if (this[0] === window) {
	                  return window.innerWidth;
	              }
	              else {
	                  if (this.length > 0) {
	                      return parseFloat(this.css('width'));
	                  }
	                  else {
	                      return null;
	                  }
	              }
	          },
	          outerWidth: function (includeMargins) {
	              if (this.length > 0) {
	                  if (includeMargins)
	                      return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));
	                  else
	                      return this[0].offsetWidth;
	              }
	              else return null;
	          },
	          height: function () {
	              if (this[0] === window) {
	                  return window.innerHeight;
	              }
	              else {
	                  if (this.length > 0) {
	                      return parseFloat(this.css('height'));
	                  }
	                  else {
	                      return null;
	                  }
	              }
	          },
	          outerHeight: function (includeMargins) {
	              if (this.length > 0) {
	                  if (includeMargins)
	                      return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));
	                  else
	                      return this[0].offsetHeight;
	              }
	              else return null;
	          },
	          offset: function () {
	              if (this.length > 0) {
	                  var el = this[0];
	                  var box = el.getBoundingClientRect();
	                  var body = document.body;
	                  var clientTop  = el.clientTop  || body.clientTop  || 0;
	                  var clientLeft = el.clientLeft || body.clientLeft || 0;
	                  var scrollTop  = window.pageYOffset || el.scrollTop;
	                  var scrollLeft = window.pageXOffset || el.scrollLeft;
	                  return {
	                      top: box.top  + scrollTop  - clientTop,
	                      left: box.left + scrollLeft - clientLeft
	                  };
	              }
	              else {
	                  return null;
	              }
	          },
	          css: function (props, value) {
	              var i;
	              if (arguments.length === 1) {
	                  if (typeof props === 'string') {
	                      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
	                  }
	                  else {
	                      for (i = 0; i < this.length; i++) {
	                          for (var prop in props) {
	                              this[i].style[prop] = props[prop];
	                          }
	                      }
	                      return this;
	                  }
	              }
	              if (arguments.length === 2 && typeof props === 'string') {
	                  for (i = 0; i < this.length; i++) {
	                      this[i].style[props] = value;
	                  }
	                  return this;
	              }
	              return this;
	          },

	          //Dom manipulation
	          each: function (callback) {
	              for (var i = 0; i < this.length; i++) {
	                  callback.call(this[i], i, this[i]);
	              }
	              return this;
	          },
	          html: function (html) {
	              if (typeof html === 'undefined') {
	                  return this[0] ? this[0].innerHTML : undefined;
	              }
	              else {
	                  for (var i = 0; i < this.length; i++) {
	                      this[i].innerHTML = html;
	                  }
	                  return this;
	              }
	          },
	          is: function (selector) {
	              if (!this[0]) return false;
	              var compareWith, i;
	              if (typeof selector === 'string') {
	                  var el = this[0];
	                  if (el === document) return selector === document;
	                  if (el === window) return selector === window;

	                  if (el.matches) return el.matches(selector);
	                  else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
	                  else if (el.mozMatchesSelector) return el.mozMatchesSelector(selector);
	                  else if (el.msMatchesSelector) return el.msMatchesSelector(selector);
	                  else {
	                      compareWith = $(selector);
	                      for (i = 0; i < compareWith.length; i++) {
	                          if (compareWith[i] === this[0]) return true;
	                      }
	                      return false;
	                  }
	              }
	              else if (selector === document) return this[0] === document;
	              else if (selector === window) return this[0] === window;
	              else {
	                  if (selector.nodeType || selector instanceof Dom7) {
	                      compareWith = selector.nodeType ? [selector] : selector;
	                      for (i = 0; i < compareWith.length; i++) {
	                          if (compareWith[i] === this[0]) return true;
	                      }
	                      return false;
	                  }
	                  return false;
	              }

	          },
	          index: function () {
	              if (this[0]) {
	                  var child = this[0];
	                  var i = 0;
	                  while ((child = child.previousSibling) !== null) {
	                      if (child.nodeType === 1) i++;
	                  }
	                  return i;
	              }
	              else return undefined;
	          },
	          eq: function (index) {
	              if (typeof index === 'undefined') return this;
	              var length = this.length;
	              var returnIndex;
	              if (index > length - 1) {
	                  return new Dom7([]);
	              }
	              if (index < 0) {
	                  returnIndex = length + index;
	                  if (returnIndex < 0) return new Dom7([]);
	                  else return new Dom7([this[returnIndex]]);
	              }
	              return new Dom7([this[index]]);
	          },
	          append: function (newChild) {
	              var i, j;
	              for (i = 0; i < this.length; i++) {
	                  if (typeof newChild === 'string') {
	                      var tempDiv = document.createElement('div');
	                      tempDiv.innerHTML = newChild;
	                      while (tempDiv.firstChild) {
	                          this[i].appendChild(tempDiv.firstChild);
	                      }
	                  }
	                  else if (newChild instanceof Dom7) {
	                      for (j = 0; j < newChild.length; j++) {
	                          this[i].appendChild(newChild[j]);
	                      }
	                  }
	                  else {
	                      this[i].appendChild(newChild);
	                  }
	              }
	              return this;
	          },
	          prepend: function (newChild) {
	              var i, j;
	              for (i = 0; i < this.length; i++) {
	                  if (typeof newChild === 'string') {
	                      var tempDiv = document.createElement('div');
	                      tempDiv.innerHTML = newChild;
	                      for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
	                          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
	                      }
	                      // this[i].insertAdjacentHTML('afterbegin', newChild);
	                  }
	                  else if (newChild instanceof Dom7) {
	                      for (j = 0; j < newChild.length; j++) {
	                          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
	                      }
	                  }
	                  else {
	                      this[i].insertBefore(newChild, this[i].childNodes[0]);
	                  }
	              }
	              return this;
	          },
	          insertBefore: function (selector) {
	              var before = $(selector);
	              for (var i = 0; i < this.length; i++) {
	                  if (before.length === 1) {
	                      before[0].parentNode.insertBefore(this[i], before[0]);
	                  }
	                  else if (before.length > 1) {
	                      for (var j = 0; j < before.length; j++) {
	                          before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
	                      }
	                  }
	              }
	          },
	          insertAfter: function (selector) {
	              var after = $(selector);
	              for (var i = 0; i < this.length; i++) {
	                  if (after.length === 1) {
	                      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
	                  }
	                  else if (after.length > 1) {
	                      for (var j = 0; j < after.length; j++) {
	                          after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
	                      }
	                  }
	              }
	          },
	          next: function (selector) {
	              if (this.length > 0) {
	                  if (selector) {
	                      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) return new Dom7([this[0].nextElementSibling]);
	                      else return new Dom7([]);
	                  }
	                  else {
	                      if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
	                      else return new Dom7([]);
	                  }
	              }
	              else return new Dom7([]);
	          },
	          nextAll: function (selector) {
	              var nextEls = [];
	              var el = this[0];
	              if (!el) return new Dom7([]);
	              while (el.nextElementSibling) {
	                  var next = el.nextElementSibling;
	                  if (selector) {
	                      if($(next).is(selector)) nextEls.push(next);
	                  }
	                  else nextEls.push(next);
	                  el = next;
	              }
	              return new Dom7(nextEls);
	          },
	          prev: function (selector) {
	              if (this.length > 0) {
	                  if (selector) {
	                      if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) return new Dom7([this[0].previousElementSibling]);
	                      else return new Dom7([]);
	                  }
	                  else {
	                      if (this[0].previousElementSibling) return new Dom7([this[0].previousElementSibling]);
	                      else return new Dom7([]);
	                  }
	              }
	              else return new Dom7([]);
	          },
	          prevAll: function (selector) {
	              var prevEls = [];
	              var el = this[0];
	              if (!el) return new Dom7([]);
	              while (el.previousElementSibling) {
	                  var prev = el.previousElementSibling;
	                  if (selector) {
	                      if($(prev).is(selector)) prevEls.push(prev);
	                  }
	                  else prevEls.push(prev);
	                  el = prev;
	              }
	              return new Dom7(prevEls);
	          },
	          parent: function (selector) {
	              var parents = [];
	              for (var i = 0; i < this.length; i++) {
	                  if (selector) {
	                      if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
	                  }
	                  else {
	                      parents.push(this[i].parentNode);
	                  }
	              }
	              return $($.unique(parents));
	          },
	          parents: function (selector) {
	              var parents = [];
	              for (var i = 0; i < this.length; i++) {
	                  var parent = this[i].parentNode;
	                  while (parent) {
	                      if (selector) {
	                          if ($(parent).is(selector)) parents.push(parent);
	                      }
	                      else {
	                          parents.push(parent);
	                      }
	                      parent = parent.parentNode;
	                  }
	              }
	              return $($.unique(parents));
	          },
	          find : function (selector) {
	              var foundElements = [];
	              for (var i = 0; i < this.length; i++) {
	                  var found = this[i].querySelectorAll(selector);
	                  for (var j = 0; j < found.length; j++) {
	                      foundElements.push(found[j]);
	                  }
	              }
	              return new Dom7(foundElements);
	          },
	          children: function (selector) {
	              var children = [];
	              for (var i = 0; i < this.length; i++) {
	                  var childNodes = this[i].childNodes;

	                  for (var j = 0; j < childNodes.length; j++) {
	                      if (!selector) {
	                          if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
	                      }
	                      else {
	                          if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) children.push(childNodes[j]);
	                      }
	                  }
	              }
	              return new Dom7($.unique(children));
	          },
	          remove: function () {
	              for (var i = 0; i < this.length; i++) {
	                  if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
	              }
	              return this;
	          },
	          add: function () {
	              var dom = this;
	              var i, j;
	              for (i = 0; i < arguments.length; i++) {
	                  var toAdd = $(arguments[i]);
	                  for (j = 0; j < toAdd.length; j++) {
	                      dom[dom.length] = toAdd[j];
	                      dom.length++;
	                  }
	              }
	              return dom;
	          }
	      };
	      $.fn = Dom7.prototype;
	      $.unique = function (arr) {
	          var unique = [];
	          for (var i = 0; i < arr.length; i++) {
	              if (unique.indexOf(arr[i]) === -1) unique.push(arr[i]);
	          }
	          return unique;
	      };

	      return $;
	  })();


	  /*===========================
	   Get Dom libraries
	   ===========================*/
	  var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
	  for (var i = 0; i < swiperDomPlugins.length; i++) {
	  	if (window[swiperDomPlugins[i]]) {
	  		addLibraryPlugin(window[swiperDomPlugins[i]]);
	  	}
	  }
	  /*===========================
	  Add .swiper plugin from Dom libraries
	  ===========================*/
	  function addLibraryPlugin(lib) {
	      lib.fn.swiper = function (params) {
	          var firstInstance;
	          lib(this).each(function () {
	              var s = new Swiper(this, params);
	              if (!firstInstance) firstInstance = s;
	          });
	          return firstInstance;
	      };
	  }

	var __extends$19 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Slides = (function (_super) {
	    __extends$19(Slides, _super);
	    function Slides(elementRef, renderer) {
	        var _this = this;
	        _super.call(this, elementRef);
	        this.ionWillChange = new EventEmitter();
	        this.ionDidChange = new EventEmitter();
	        this.ionDrag = new EventEmitter();
	        this.rapidUpdate = debounce(function () {
	            _this.update();
	        }, 10);
	        this.id = ++slidesId;
	        this.slideId = 'slides-' + this.id;
	        renderer.setElementClass(elementRef.nativeElement, this.slideId, true);
	    }
	    /**
	     * @private
	     */
	    Slides.prototype.ngOnInit = function () {
	        var _this = this;
	        if (!this.options) {
	            this.options = {};
	        }
	        if (isPresent$5(this.options.pager)) {
	            this.showPager = isTrueProperty(this.options.pager);
	        }
	        var paginationId = '.' + this.slideId + ' .swiper-pagination';
	        var options = defaults$1({
	            pagination: paginationId
	        }, this.options);
	        options.onTap = function (swiper, e) {
	            _this.onTap(swiper, e);
	            return _this.options.onTap && _this.options.onTap(swiper, e);
	        };
	        options.onClick = function (swiper, e) {
	            _this.onClick(swiper, e);
	            return _this.options.onClick && _this.options.onClick(swiper, e);
	        };
	        options.onDoubleTap = function (swiper, e) {
	            _this.onDoubleTap(swiper, e);
	            return _this.options.onDoubleTap && _this.options.onDoubleTap(swiper, e);
	        };
	        options.onTransitionStart = function (swiper, e) {
	            _this.onTransitionStart(swiper, e);
	            return _this.options.onTransitionStart && _this.options.onTransitionStart(swiper, e);
	        };
	        options.onTransitionEnd = function (swiper, e) {
	            _this.onTransitionEnd(swiper, e);
	            return _this.options.onTransitionEnd && _this.options.onTransitionEnd(swiper, e);
	        };
	        options.onSlideChangeStart = function (swiper) {
	            _this.ionWillChange.emit(swiper);
	            return _this.options.onSlideChangeStart && _this.options.onSlideChangeStart(swiper);
	        };
	        options.onSlideChangeEnd = function (swiper) {
	            _this.ionDidChange.emit(swiper);
	            return _this.options.onSlideChangeEnd && _this.options.onSlideChangeEnd(swiper);
	        };
	        options.onLazyImageLoad = function (swiper, slide, img) {
	            return _this.options.onLazyImageLoad && _this.options.onLazyImageLoad(swiper, slide, img);
	        };
	        options.onLazyImageReady = function (swiper, slide, img) {
	            return _this.options.onLazyImageReady && _this.options.onLazyImageReady(swiper, slide, img);
	        };
	        options.onSliderMove = function (swiper, e) {
	            _this.ionDrag.emit(swiper);
	            return _this.options.onSliderMove && _this.options.onSliderMove(swiper, e);
	        };
	        setTimeout(function () {
	            var swiper = new Swiper(_this.getNativeElement().children[0], options);
	            _this.slider = swiper;
	        });
	        /*
	        * TODO: Finish this
	        if (isTrueProperty(this.zoom)) {
	          this.enableZoom = true;
	          setTimeout(() => {
	            this.initZoom();
	          })
	        }
	        */
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onTap = function (swiper, e) {
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onClick = function (swiper, e) {
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onDoubleTap = function (swiper, e) {
	        this.toggleZoom(swiper, e);
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onLazyImageLoad = function (swiper, slide, img) {
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onLazyImageReady = function (swiper, slide, img) {
	    };
	    /*
	    nextButton(swiper: any, e: any) {
	    }
	    prevButton() {
	    }
	    indexButton() {
	    }
	    */
	    /**
	     * @private
	     */
	    Slides.prototype.initZoom = function () {
	        var _this = this;
	        this.zoomDuration = this.zoomDuration || 230;
	        this.maxScale = this.zoomMax || 3;
	        this.zoomElement = this.getNativeElement().children[0].children[0];
	        this.zoomElement && this.zoomElement.classList.add('ion-scroll-zoom');
	        this.zoomGesture = new Gesture(this.zoomElement);
	        this.zoomGesture.listen();
	        this.scale = 1;
	        this.zoomLastPosX = 0;
	        this.zoomLastPosY = 0;
	        var lastScale, startX, startY, posX = 0, posY = 0, zoomRect;
	        this.viewportWidth = this.getNativeElement().offsetWidth;
	        this.viewportHeight = this.getNativeElement().offsetHeight;
	        this.zoomElement.addEventListener('touchstart', function (e) {
	            _this.onTouchStart(e);
	        });
	        this.zoomElement.addEventListener('touchmove', function (e) {
	            _this.onTouchMove(e);
	        });
	        this.zoomElement.addEventListener('touchend', function (e) {
	            _this.onTouchEnd(e);
	        });
	        this.zoomGesture.on('pinchstart', function (e) {
	            lastScale = _this.scale;
	            console.debug('Last scale', e.scale);
	        });
	        this.zoomGesture.on('pinch', function (e) {
	            _this.scale = Math.max(1, Math.min(lastScale * e.scale, 10));
	            console.debug('Scaling', _this.scale);
	            _this.zoomElement.style[CSS.transform] = 'scale(' + _this.scale + ')';
	            zoomRect = _this.zoomElement.getBoundingClientRect();
	        });
	        this.zoomGesture.on('pinchend', function () {
	            // last_scale = Math.max(1, Math.min(last_scale * e.scale, 10));
	            if (_this.scale > _this.maxScale) {
	                var za = new Animation(_this.zoomElement)
	                    .duration(_this.zoomDuration)
	                    .easing('linear')
	                    .from('scale', _this.scale)
	                    .to('scale', _this.maxScale);
	                za.play();
	                _this.scale = _this.maxScale;
	            }
	        });
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.resetZoom = function () {
	        if (this.zoomElement) {
	            this.zoomElement.parentElement.style[CSS.transform] = '';
	            this.zoomElement.style[CSS.transform] = 'scale(1)';
	        }
	        this.scale = 1;
	        this.zoomLastPosX = 0;
	        this.zoomLastPosY = 0;
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.toggleZoom = function (swiper, e) {
	        console.debug('Try toggle zoom');
	        if (!this.enableZoom) {
	            return;
	        }
	        console.debug('Toggling zoom', e);
	        /*
	        let x = e.pointers[0].clientX;
	        let y = e.pointers[0].clientY;
	    
	        let mx = this.viewportWidth / 2;
	        let my = this.viewportHeight / 2;
	    
	        let tx, ty;
	    
	        if (x > mx) {
	          // Greater than half
	          tx = -x;
	        } else {
	          // Less than or equal to half
	          tx = (this.viewportWidth - x);
	        }
	        if (y > my) {
	          ty = -y;
	        } else {
	          ty = y-my;
	        }
	    
	        console.debug(y);
	        */
	        var zi = new Animation(this.touch.target.children[0])
	            .duration(this.zoomDuration)
	            .easing('linear');
	        var zw = new Animation(this.touch.target.children[0])
	            .duration(this.zoomDuration)
	            .easing('linear');
	        var za = new Animation();
	        za.add(zi);
	        if (this.scale > 1) {
	            // zoom out
	            // zw.fromTo('translateX', posX + 'px', '0px');
	            // zw.fromTo('translateY', posY + 'px', '0px');
	            zi.from('scale', this.scale);
	            zi.to('scale', 1);
	            za.play();
	            // posX = 0;
	            // posY = 0;
	            this.scale = 1;
	        }
	        else {
	            // zoom in
	            // zw.fromTo('translateX', posX + 'px', tx + 'px');
	            // zw.fromTo('translateY', posY + 'px', ty + 'px');
	            zi.from('scale', this.scale);
	            zi.to('scale', this.maxScale);
	            za.play();
	            // posX = tx;
	            // posY = ty;
	            this.scale = this.maxScale;
	        }
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onTransitionStart = function (swiper, e) {
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onTransitionEnd = function (swiper, e) {
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onTouchStart = function (e) {
	        console.debug('Touch start', e);
	        // TODO: Support mice as well
	        var target = dom.closest(e.target, '.slide').children[0].children[0];
	        this.touch = {
	            x: null,
	            y: null,
	            startX: e.touches[0].clientX,
	            startY: e.touches[0].clientY,
	            deltaX: 0,
	            deltaY: 0,
	            lastX: 0,
	            lastY: 0,
	            target: target.parentElement,
	            zoomable: target,
	            zoomableWidth: target.offsetWidth,
	            zoomableHeight: target.offsetHeight
	        };
	        console.debug('Target', this.touch.target);
	        // TODO: android prevent default
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onTouchMove = function (e) {
	        this.touch.deltaX = e.touches[0].clientX - this.touch.startX;
	        this.touch.deltaY = e.touches[0].clientY - this.touch.startY;
	        // TODO: Make sure we need to transform (image is bigger than viewport)
	        var zoomableScaledWidth = this.touch.zoomableWidth * this.scale;
	        var zoomableScaledHeight = this.touch.zoomableHeight * this.scale;
	        var x1 = Math.min((this.viewportWidth / 2) - zoomableScaledWidth / 2, 0);
	        var x2 = -x1;
	        var y1 = Math.min((this.viewportHeight / 2) - zoomableScaledHeight / 2, 0);
	        var y2 = -y1;
	        console.debug('BOUNDS', x1, x2, y1, y2);
	        if (this.scale <= 1) {
	            return;
	        }
	        console.debug('PAN', e);
	        // move image
	        this.touch.x = this.touch.deltaX + this.touch.lastX;
	        this.touch.y = this.touch.deltaY + this.touch.lastY;
	        if (this.touch.x < x1) {
	            console.debug('OUT ON LEFT');
	        }
	        if (this.touch.x > x2) {
	            console.debug('OUT ON RIGHT');
	        }
	        if (this.touch.x > this.viewportWidth) {
	        }
	        else if (-this.touch.x > this.viewportWidth) {
	        }
	        else {
	            console.debug('TRANSFORM', this.touch.x, this.touch.y, this.touch.target);
	            // this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
	            this.touch.target.style[CSS.transform] = 'translateX(' + this.touch.x + 'px) translateY(' + this.touch.y + 'px)';
	            e.preventDefault();
	            e.stopPropagation();
	            return false;
	        }
	    };
	    /**
	     * @private
	     */
	    Slides.prototype.onTouchEnd = function (e) {
	        console.debug('PANEND', e);
	        if (this.scale > 1) {
	            if (Math.abs(this.touch.x) > this.viewportWidth) {
	                // TODO what is posX?
	                var posX = posX > 0 ? this.viewportWidth - 1 : -(this.viewportWidth - 1);
	                console.debug('Setting on posx', this.touch.x);
	            }
	            /*
	            if (posY > this.viewportHeight/2) {
	              let z = new Animation(this.zoomElement.parentElement);
	              z.fromTo('translateY', posY + 'px', Math.min(this.viewportHeight/2 + 30, posY));
	              z.play();
	            } else {
	              let z = new Animation(this.zoomElement.parentElement);
	              z.fromTo('translateY', posY + 'px', Math.max(this.viewportHeight/2 - 30, posY));
	              z.play();
	            }
	            */
	            this.touch.lastX = this.touch.x;
	            this.touch.lastY = this.touch.y;
	        }
	    };
	    /**
	     * @private
	     * Update the underlying slider implementation. Call this if you've added or removed
	     * child slides.
	     */
	    Slides.prototype.update = function () {
	        var _this = this;
	        setTimeout(function () {
	            _this.slider.update();
	            // Don't allow pager to show with > 10 slides
	            if (_this.length() > 10) {
	                _this.showPager = false;
	            }
	        });
	    };
	    /**
	     * Transition to the specified slide.
	     *
	     * @param {number} index  The index number of the slide.
	     * @param {number} speed  Transition duration (in ms). Optional.
	     * @param {boolean} runCallbacks  Whether or not to emit the `ionWillChange`/`ionDidChange` events. Optional. Default true.
	     */
	    Slides.prototype.slideTo = function (index, speed, runCallbacks) {
	        this.slider.slideTo(index, speed, runCallbacks);
	    };
	    /**
	     * Transition to the next slide.
	     *
	     * @param {number} speed  Transition duration (in ms). Optional.
	     * @param {boolean} runCallbacks  Whether or not to emit the `ionWillChange`/`ionDidChange` events. Optional. Default true.
	     */
	    Slides.prototype.slideNext = function (speed, runCallbacks) {
	        this.slider.slideNext(runCallbacks, speed);
	    };
	    /**
	     * Transition to the previous slide.
	     *
	     * @param {number} speed  Transition duration (in ms). Optional.
	     * @param {boolean} runCallbacks  Whether or not to emit the `ionWillChange`/`ionDidChange` events. Optional. Default true.
	     */
	    Slides.prototype.slidePrev = function (speed, runCallbacks) {
	        this.slider.slidePrev(runCallbacks, speed);
	    };
	    /**
	     * Get the index of the active slide.
	     *
	     * @returns {number} The index number of the current slide.
	     */
	    Slides.prototype.getActiveIndex = function () {
	        return this.slider.activeIndex;
	    };
	    /**
	     * Get the index of the previous slide.
	     *
	     * @returns {number} The index number of the previous slide.
	     */
	    Slides.prototype.getPreviousIndex = function () {
	        return this.slider.previousIndex;
	    };
	    /**
	     * Get the total number of slides.
	     *
	     * @returns {number} The total number of slides.
	     */
	    Slides.prototype.length = function () {
	        return this.slider.slides.length;
	    };
	    /**
	     * Get whether or not the current slide is the last slide.
	     *
	     * @returns {boolean} If the slide is the last slide or not.
	     */
	    Slides.prototype.isEnd = function () {
	        return this.slider.isEnd;
	    };
	    /**
	     * Get whether or not the current slide is the first slide.
	     *
	     * @returns {boolean} If the slide is the first slide or not.
	     */
	    Slides.prototype.isBeginning = function () {
	        return this.slider.isBeginning;
	    };
	    /**
	     * Get the `Swiper` instance.
	     *
	     * The Slides component wraps the `Swiper` component built by iDangero.us. See the
	     * [Swiper API Docs](http://idangero.us/swiper/api/) for information on using
	     * the `Swiper` instance directly.
	     *
	     * @returns {Swiper}
	     */
	    Slides.prototype.getSlider = function () {
	        return this.slider;
	    };
	    /** @nocollapse */
	    Slides.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-slides',
	                    template: '<div class="swiper-container">' +
	                        '<div class="swiper-wrapper">' +
	                        '<ng-content></ng-content>' +
	                        '</div>' +
	                        '<div [class.hide]="!showPager" class="swiper-pagination"></div>' +
	                        '</div>',
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Slides.ctorParameters = [
	        { type: ElementRef, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    Slides.propDecorators = {
	        'options': [{ type: Input },],
	        'pager': [{ type: Input },],
	        'zoom': [{ type: Input },],
	        'zoomDuration': [{ type: Input },],
	        'zoomMax': [{ type: Input },],
	        'ionWillChange': [{ type: Output },],
	        'ionDidChange': [{ type: Output },],
	        'ionDrag': [{ type: Output },],
	    };
	    return Slides;
	}(Ion));
	var Slide = (function () {
	    function Slide(elementRef, slides) {
	        this.slides = slides;
	        this.ele = elementRef.nativeElement;
	        this.ele.classList.add('swiper-slide');
	        slides.rapidUpdate();
	    }
	    Slide.prototype.ngOnDestroy = function () {
	        this.slides.rapidUpdate();
	    };
	    /** @nocollapse */
	    Slide.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-slide',
	                    template: '<div class="slide-zoom"><ng-content></ng-content></div>',
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Slide.ctorParameters = [
	        { type: ElementRef, },
	        { type: Slides, decorators: [{ type: Host },] },
	    ];
	    /** @nocollapse */
	    Slide.propDecorators = {
	        'zoom': [{ type: Input },],
	    };
	    return Slide;
	}());
	var SlideLazy = (function () {
	    function SlideLazy() {
	    }
	    SlideLazy.decorators = [
	        { type: Directive, args: [{
	                    selector: 'slide-lazy',
	                    host: {
	                        'class': 'swiper-lazy'
	                    }
	                },] },
	    ];
	    return SlideLazy;
	}());
	var slidesId = -1;

	var __extends$20 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Tab = (function (_super) {
	    __extends$20(Tab, _super);
	    function Tab(parent, app, config, keyboard, elementRef, zone, renderer, compiler, _cd, menuCtrl) {
	        // A Tab is a NavController for its child pages
	        _super.call(this, parent, app, config, keyboard, elementRef, zone, renderer, compiler, menuCtrl);
	        this.parent = parent;
	        this._cd = _cd;
	        this._isEnabled = true;
	        this._isShown = true;
	        this.ionSelect = new EventEmitter();
	        parent.add(this);
	        if (parent.rootNav) {
	            this._sbEnabled = parent.rootNav.isSwipeBackEnabled();
	        }
	        this._panelId = 'tabpanel-' + this.id;
	        this._btnId = 'tab-' + this.id;
	    }
	    Object.defineProperty(Tab.prototype, "enabled", {
	        get: function () {
	            return this._isEnabled;
	        },
	        set: function (val) {
	            this._isEnabled = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Tab.prototype, "show", {
	        get: function () {
	            return this._isShown;
	        },
	        set: function (val) {
	            this._isShown = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Tab.prototype, "swipeBackEnabled", {
	        get: function () {
	            return this._sbEnabled;
	        },
	        set: function (val) {
	            this._sbEnabled = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Tab.prototype, "_vp", {
	        set: function (val) {
	            this.setViewport(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Tab.prototype.ngOnInit = function () {
	        this.tabBadgeStyle = this.tabBadgeStyle ? this.tabBadgeStyle : 'default';
	    };
	    /**
	     * @private
	     */
	    Tab.prototype.load = function (opts, done) {
	        if (!this._loaded && this.root) {
	            this.push(this.root, this.rootParams, opts).then(function () {
	                done(true);
	            });
	            this._loaded = true;
	        }
	        else {
	            done(false);
	        }
	    };
	    /**
	     * @private
	     */
	    Tab.prototype.preload = function (wait) {
	        var _this = this;
	        this._loadTmr = setTimeout(function () {
	            if (!_this._loaded) {
	                console.debug('Tabs, preload', _this.id);
	                _this.load({
	                    animate: false,
	                    preload: true
	                }, function () { });
	            }
	        }, wait);
	    };
	    /**
	     * @private
	     */
	    Tab.prototype.loadPage = function (viewCtrl, viewport, opts, done) {
	        var _this = this;
	        var isTabSubPage = (this.parent.subPages && viewCtrl.index > 0);
	        if (isTabSubPage) {
	            viewport = this.parent.portal;
	        }
	        _super.prototype.loadPage.call(this, viewCtrl, viewport, opts, function () {
	            if (isTabSubPage) {
	                // add the .tab-subpage css class to tabs pages that should act like subpages
	                var pageEleRef = viewCtrl.pageRef();
	                if (pageEleRef) {
	                    _this._renderer.setElementClass(pageEleRef.nativeElement, 'tab-subpage', true);
	                }
	            }
	            done();
	        });
	    };
	    /**
	     * @private
	     */
	    Tab.prototype.setSelected = function (isSelected) {
	        this.isSelected = isSelected;
	        if (isSelected) {
	            // this is the selected tab, detect changes
	            this._cd.reattach();
	        }
	        else {
	            // this tab is not selected, do not detect changes
	            this._cd.detach();
	        }
	    };
	    Object.defineProperty(Tab.prototype, "index", {
	        /**
	         * @private
	         */
	        get: function () {
	            return this.parent.getIndex(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Tab.prototype.ngOnDestroy = function () {
	        clearTimeout(this._loadTmr);
	        _super.prototype.ngOnDestroy.call(this);
	    };
	    /** @nocollapse */
	    Tab.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-tab',
	                    host: {
	                        '[class.show-tab]': 'isSelected',
	                        '[attr.id]': '_panelId',
	                        '[attr.aria-labelledby]': '_btnId',
	                        'role': 'tabpanel'
	                    },
	                    template: '<div #viewport></div><div class="nav-decor"></div>',
	                    encapsulation: ViewEncapsulation.None,
	                    directives: [NgIf]
	                },] },
	    ];
	    /** @nocollapse */
	    Tab.ctorParameters = [
	        { type: Tabs, decorators: [{ type: Inject, args: [forwardRef(function () { return Tabs; }),] },] },
	        { type: App, },
	        { type: Config, },
	        { type: Keyboard, },
	        { type: ElementRef, },
	        { type: NgZone, },
	        { type: Renderer, },
	        { type: ComponentResolver, },
	        { type: ChangeDetectorRef, },
	        { type: MenuController, },
	    ];
	    /** @nocollapse */
	    Tab.propDecorators = {
	        'root': [{ type: Input },],
	        'rootParams': [{ type: Input },],
	        'tabTitle': [{ type: Input },],
	        'tabIcon': [{ type: Input },],
	        'tabBadge': [{ type: Input },],
	        'tabBadgeStyle': [{ type: Input },],
	        'enabled': [{ type: Input },],
	        'show': [{ type: Input },],
	        'swipeBackEnabled': [{ type: Input },],
	        'ionSelect': [{ type: Output },],
	        '_vp': [{ type: ViewChild, args: ['viewport', { read: ViewContainerRef },] },],
	    };
	    return Tab;
	}(NavController));

	var __extends$22 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DRAG_THRESHOLD = 20;
	var MAX_ATTACK_ANGLE = 20;
	var ItemSlidingGesture = (function (_super) {
	    __extends$22(ItemSlidingGesture, _super);
	    function ItemSlidingGesture(list) {
	        _super.call(this, list.getNativeElement(), {
	            direction: 'x',
	            threshold: DRAG_THRESHOLD
	        });
	        this.list = list;
	        this.selectedContainer = null;
	        this.openContainer = null;
	        this.listen();
	    }
	    ItemSlidingGesture.prototype.onTapCallback = function (ev) {
	        if (isFromOptionButtons(ev)) {
	            return;
	        }
	        var didClose = this.closeOpened();
	        if (didClose) {
	            console.debug('tap close sliding item, preventDefault');
	            ev.preventDefault();
	        }
	    };
	    ItemSlidingGesture.prototype.onDragStart = function (ev) {
	        var angle = Math.abs(ev.angle);
	        if (angle > MAX_ATTACK_ANGLE && Math.abs(angle - 180) > MAX_ATTACK_ANGLE) {
	            this.closeOpened();
	            return false;
	        }
	        if (this.selectedContainer) {
	            console.debug('onDragStart, another container is already selected');
	            return false;
	        }
	        var container = getContainer(ev);
	        if (!container) {
	            console.debug('onDragStart, no itemContainerEle');
	            return false;
	        }
	        // Close open container if it is not the selected one.
	        if (container !== this.openContainer) {
	            this.closeOpened();
	        }
	        this.selectedContainer = container;
	        this.openContainer = container;
	        container.startSliding(ev.center.x);
	        return true;
	    };
	    ItemSlidingGesture.prototype.onDrag = function (ev) {
	        if (this.selectedContainer) {
	            this.selectedContainer.moveSliding(ev.center.x);
	            ev.preventDefault();
	        }
	        return;
	    };
	    ItemSlidingGesture.prototype.onDragEnd = function (ev) {
	        var _this = this;
	        if (!this.selectedContainer) {
	            return;
	        }
	        ev.preventDefault();
	        var openAmount = this.selectedContainer.endSliding(ev.velocityX);
	        this.selectedContainer = null;
	        // TODO: I am not sure listening for a tap event is the best idea
	        // we should try mousedown/touchstart
	        if (openAmount === 0) {
	            this.openContainer = null;
	            this.off('tap', this.onTap);
	            this.onTap = null;
	        }
	        else if (!this.onTap) {
	            this.onTap = function (event) { return _this.onTapCallback(event); };
	            this.on('tap', this.onTap);
	        }
	    };
	    ItemSlidingGesture.prototype.closeOpened = function () {
	        if (!this.openContainer) {
	            return false;
	        }
	        this.openContainer.close();
	        this.openContainer = null;
	        this.selectedContainer = null;
	        this.off('tap', this.onTap);
	        this.onTap = null;
	        return true;
	    };
	    ItemSlidingGesture.prototype.unlisten = function () {
	        this.closeOpened();
	        _super.prototype.unlisten.call(this);
	    };
	    return ItemSlidingGesture;
	}(DragGesture));
	function getContainer(ev) {
	    var ele = closest(ev.target, 'ion-item-sliding', true);
	    if (ele) {
	        return ele['$ionComponent'];
	    }
	    return null;
	}
	function isFromOptionButtons(ev) {
	    var button = closest(ev.target, '.button', true);
	    if (!button) {
	        return false;
	    }
	    return !!closest(button, 'ion-item-options', true);
	}

	var __extends$21 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var List = (function (_super) {
	    __extends$21(List, _super);
	    function List(elementRef, _rendered) {
	        _super.call(this, elementRef);
	        this._rendered = _rendered;
	        this._enableSliding = true;
	        this._containsSlidingItems = false;
	    }
	    /**
	     * @private
	     */
	    List.prototype.ngOnDestroy = function () {
	        this._slidingGesture && this._slidingGesture.destroy();
	    };
	    Object.defineProperty(List.prototype, "sliding", {
	        get: function () {
	            return this._enableSliding;
	        },
	        set: function (val) {
	            this._enableSliding = isTrueProperty(val);
	            this._updateSlidingState();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    List.prototype.containsSlidingItem = function (contains) {
	        this._containsSlidingItems = contains;
	        this._updateSlidingState();
	    };
	    List.prototype._updateSlidingState = function () {
	        var shouldSlide = this._enableSliding && this._containsSlidingItems;
	        if (!shouldSlide) {
	            this._slidingGesture && this._slidingGesture.unlisten();
	            this._slidingGesture = null;
	        }
	        else if (!this._slidingGesture) {
	            console.debug('enableSlidingItems');
	            this._slidingGesture = new ItemSlidingGesture(this);
	        }
	    };
	    /**
	     * Close the open sliding item.
	     *
	     * ```ts
	     * import {Component, ViewChild} from '@angular/core';
	     * import {List} from 'ionic-angular';
	     *
	     * @Component({...})
	     * export class MyClass {
	     *   @ViewChild(List) list: List;
	     *
	     *   constructor() { }
	     *
	     *   closeItems() {
	     *     this.list.closeSlidingItems();
	     *   }
	     * }
	     * ```
	     */
	    List.prototype.closeSlidingItems = function () {
	        this._slidingGesture && this._slidingGesture.closeOpened();
	    };
	    /** @nocollapse */
	    List.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-list',
	                },] },
	    ];
	    /** @nocollapse */
	    List.ctorParameters = [
	        { type: ElementRef, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    List.propDecorators = {
	        'sliding': [{ type: Input },],
	    };
	    return List;
	}(Ion));
	var ListHeader = (function () {
	    function ListHeader(_renderer, _elementRef, _id) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._id = _id;
	    }
	    Object.defineProperty(ListHeader.prototype, "id", {
	        get: function () {
	            return this._id;
	        },
	        set: function (val) {
	            this._id = val;
	            this._renderer.setElementAttribute(this._elementRef.nativeElement, 'id', val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    ListHeader.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-list-header'
	                },] },
	    ];
	    /** @nocollapse */
	    ListHeader.ctorParameters = [
	        { type: Renderer, },
	        { type: ElementRef, },
	        { type: undefined, decorators: [{ type: Attribute, args: ['id',] },] },
	    ];
	    return ListHeader;
	}());

	var AUTO_SCROLL_MARGIN = 60;
	var SCROLL_JUMP = 10;
	var ITEM_REORDER_ACTIVE = 'reorder-active';
	/**
	 * @private
	 */
	var ItemReorderGesture = (function () {
	    function ItemReorderGesture(list) {
	        this.list = list;
	        this.selectedItemEle = null;
	        this.events = new UIEventManager(false);
	        var element = this.list.getNativeElement();
	        this.events.pointerEvents(element, this.onDragStart.bind(this), this.onDragMove.bind(this), this.onDragEnd.bind(this));
	    }
	    ItemReorderGesture.prototype.onDragStart = function (ev) {
	        var reorderElement = ev.target;
	        if (reorderElement.nodeName !== 'ION-REORDER') {
	            return false;
	        }
	        var reorderMark = reorderElement['$ionComponent'];
	        if (!reorderMark) {
	            console.error('ion-reorder does not contain $ionComponent');
	            return false;
	        }
	        this.list.reorderPrepare();
	        var item = reorderMark.getReorderNode();
	        if (!item) {
	            console.error('reorder node not found');
	            return false;
	        }
	        ev.preventDefault();
	        // Preparing state
	        this.selectedItemEle = item;
	        this.selectedItemHeight = item.offsetHeight;
	        this.lastYcoord = -100;
	        this.lastToIndex = indexForItem(item);
	        this.windowHeight = window.innerHeight - AUTO_SCROLL_MARGIN;
	        this.lastScrollPosition = this.list.scrollContent(0);
	        this.offset = pointerCoord(ev);
	        this.offset.y += this.lastScrollPosition;
	        item.classList.add(ITEM_REORDER_ACTIVE);
	        this.list.reorderStart();
	        return true;
	    };
	    ItemReorderGesture.prototype.onDragMove = function (ev) {
	        var selectedItem = this.selectedItemEle;
	        if (!selectedItem) {
	            return;
	        }
	        ev.preventDefault();
	        // Get coordinate
	        var coord = pointerCoord(ev);
	        var posY = coord.y;
	        // Scroll if we reach the scroll margins
	        var scrollPosition = this.scroll(posY);
	        // Only perform hit test if we moved at least 30px from previous position
	        if (Math.abs(posY - this.lastYcoord) > 30) {
	            var overItem = this.itemForCoord(coord);
	            if (overItem) {
	                var toIndex = indexForItem(overItem);
	                if (toIndex !== undefined && (toIndex !== this.lastToIndex || this.emptyZone)) {
	                    var fromIndex = indexForItem(this.selectedItemEle);
	                    this.lastToIndex = toIndex;
	                    this.lastYcoord = posY;
	                    this.emptyZone = false;
	                    this.list.reorderMove(fromIndex, toIndex, this.selectedItemHeight);
	                }
	            }
	            else {
	                this.emptyZone = true;
	            }
	        }
	        // Update selected item position
	        var ydiff = Math.round(posY - this.offset.y + scrollPosition);
	        selectedItem.style[CSS.transform] = "translateY(" + ydiff + "px)";
	    };
	    ItemReorderGesture.prototype.onDragEnd = function () {
	        if (!this.selectedItemEle) {
	            return;
	        }
	        var toIndex = this.lastToIndex;
	        var fromIndex = indexForItem(this.selectedItemEle);
	        this.selectedItemEle.classList.remove(ITEM_REORDER_ACTIVE);
	        this.selectedItemEle = null;
	        this.list.reorderEmit(fromIndex, toIndex);
	    };
	    ItemReorderGesture.prototype.itemForCoord = function (coord) {
	        return itemForPosition(this.offset.x - 100, coord.y);
	    };
	    ItemReorderGesture.prototype.scroll = function (posY) {
	        if (posY < AUTO_SCROLL_MARGIN) {
	            this.lastScrollPosition = this.list.scrollContent(-SCROLL_JUMP);
	        }
	        else if (posY > this.windowHeight) {
	            this.lastScrollPosition = this.list.scrollContent(SCROLL_JUMP);
	        }
	        return this.lastScrollPosition;
	    };
	    /**
	     * @private
	     */
	    ItemReorderGesture.prototype.destroy = function () {
	        this.onDragEnd();
	        this.events.unlistenAll();
	        this.events = null;
	        this.list = null;
	    };
	    return ItemReorderGesture;
	}());
	function itemForPosition(x, y) {
	    var element = document.elementFromPoint(x, y);
	    if (!element) {
	        return null;
	    }
	    if (element.nodeName !== 'ION-ITEM' && !element.hasAttribute('ion-item')) {
	        return null;
	    }
	    return findReorderItem(element);
	}

	var ItemReorder = (function () {
	    function ItemReorder(elementRef, _rendered, _zone, _content) {
	        this._rendered = _rendered;
	        this._zone = _zone;
	        this._content = _content;
	        this._enableReorder = false;
	        this._lastToIndex = -1;
	        this.ionItemReorder = new EventEmitter();
	        this._element = elementRef.nativeElement;
	    }
	    /**
	     * @private
	     */
	    ItemReorder.prototype.ngOnDestroy = function () {
	        this._element = null;
	        this._reorderGesture && this._reorderGesture.destroy();
	    };
	    Object.defineProperty(ItemReorder.prototype, "reorder", {
	        get: function () {
	            return this._enableReorder;
	        },
	        set: function (val) {
	            this._enableReorder = isTrueProperty(val);
	            if (!this._enableReorder) {
	                this._reorderGesture && this._reorderGesture.destroy();
	                this._reorderGesture = null;
	            }
	            else if (!this._reorderGesture) {
	                console.debug('enableReorderItems');
	                this._reorderGesture = new ItemReorderGesture(this);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    ItemReorder.prototype.reorderPrepare = function () {
	        var children = this._element.children;
	        var len = children.length;
	        for (var i = 0; i < len; i++) {
	            children[i]['$ionIndex'] = i;
	        }
	    };
	    /**
	     * @private
	     */
	    ItemReorder.prototype.reorderStart = function () {
	        this.setCssClass('reorder-list-active', true);
	    };
	    /**
	     * @private
	     */
	    ItemReorder.prototype.reorderEmit = function (fromIndex, toIndex) {
	        var _this = this;
	        this.reorderReset();
	        if (fromIndex !== toIndex) {
	            this._zone.run(function () {
	                _this.ionItemReorder.emit({
	                    from: fromIndex,
	                    to: toIndex,
	                });
	            });
	        }
	    };
	    /**
	     * @private
	     */
	    ItemReorder.prototype.scrollContent = function (scroll) {
	        var scrollTop = this._content.getScrollTop() + scroll;
	        if (scroll !== 0) {
	            this._content.scrollTo(0, scrollTop, 0);
	        }
	        return scrollTop;
	    };
	    /**
	     * @private
	     */
	    ItemReorder.prototype.reorderReset = function () {
	        var children = this._element.children;
	        var len = children.length;
	        this.setCssClass('reorder-list-active', false);
	        var transform = CSS.transform;
	        for (var i = 0; i < len; i++) {
	            children[i].style[transform] = '';
	        }
	        this._lastToIndex = -1;
	    };
	    /**
	     * @private
	     */
	    ItemReorder.prototype.reorderMove = function (fromIndex, toIndex, itemHeight) {
	        if (this._lastToIndex === -1) {
	            this._lastToIndex = fromIndex;
	        }
	        var lastToIndex = this._lastToIndex;
	        this._lastToIndex = toIndex;
	        // TODO: I think both loops can be merged into a single one
	        // but I had no luck last time I tried
	        /********* DOM READ ********** */
	        var children = this._element.children;
	        /********* DOM WRITE ********* */
	        var transform = CSS.transform;
	        if (toIndex >= lastToIndex) {
	            for (var i = lastToIndex; i <= toIndex; i++) {
	                if (i !== fromIndex) {
	                    children[i].style[transform] = (i > fromIndex)
	                        ? "translateY(" + -itemHeight + "px)" : '';
	                }
	            }
	        }
	        if (toIndex <= lastToIndex) {
	            for (var i = toIndex; i <= lastToIndex; i++) {
	                if (i !== fromIndex) {
	                    children[i].style[transform] = (i < fromIndex)
	                        ? "translateY(" + itemHeight + "px)" : '';
	                }
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    ItemReorder.prototype.setCssClass = function (classname, add) {
	        this._rendered.setElementClass(this._element, classname, add);
	    };
	    /**
	     * @private
	     */
	    ItemReorder.prototype.getNativeElement = function () {
	        return this._element;
	    };
	    /** @nocollapse */
	    ItemReorder.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-list[reorder],ion-item-group[reorder]',
	                    host: {
	                        '[class.reorder-enabled]': '_enableReorder',
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    ItemReorder.ctorParameters = [
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: NgZone, },
	        { type: Content, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    ItemReorder.propDecorators = {
	        'ionItemReorder': [{ type: Output },],
	        'reorder': [{ type: Input },],
	    };
	    return ItemReorder;
	}());
	var Reorder = (function () {
	    function Reorder(item, elementRef) {
	        this.item = item;
	        this.elementRef = elementRef;
	        elementRef.nativeElement['$ionComponent'] = this;
	    }
	    Reorder.prototype.getReorderNode = function () {
	        var node = this.item.getNativeElement();
	        return findReorderItem(node);
	    };
	    /** @nocollapse */
	    Reorder.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-reorder',
	                    template: "<ion-icon name=\"menu\"></ion-icon>"
	                },] },
	    ];
	    /** @nocollapse */
	    Reorder.ctorParameters = [
	        { type: Item, decorators: [{ type: Inject, args: [forwardRef(function () { return Item; }),] },] },
	        { type: ElementRef, },
	    ];
	    return Reorder;
	}());
	/**
	 * @private
	 */
	function findReorderItem(node) {
	    var nested = 0;
	    while (node && nested < 4) {
	        if (indexForItem(node) !== undefined) {
	            return node;
	        }
	        node = node.parentNode;
	        nested++;
	    }
	    return null;
	}
	/**
	 * @private
	 */
	function indexForItem(element) {
	    return element['$ionIndex'];
	}

	var Label = (function () {
	    function Label(_elementRef, _renderer, isFloating, isStacked, isFixed, isInset) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this.type = (isFloating === '' ? 'floating' : (isStacked === '' ? 'stacked' : (isFixed === '' ? 'fixed' : (isInset === '' ? 'inset' : null))));
	    }
	    Object.defineProperty(Label.prototype, "id", {
	        get: function () {
	            return this._id;
	        },
	        set: function (val) {
	            this._id = val;
	            if (val) {
	                this._renderer.setElementAttribute(this._elementRef.nativeElement, 'id', val);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Label.prototype, "text", {
	        /**
	         * @private
	         */
	        get: function () {
	            return this._elementRef.nativeElement.textContent || '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * @param {string} add class name
	     */
	    Label.prototype.addClass = function (className) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, className, true);
	    };
	    /** @nocollapse */
	    Label.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-label'
	                },] },
	    ];
	    /** @nocollapse */
	    Label.ctorParameters = [
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: undefined, decorators: [{ type: Attribute, args: ['floating',] },] },
	        { type: undefined, decorators: [{ type: Attribute, args: ['stacked',] },] },
	        { type: undefined, decorators: [{ type: Attribute, args: ['fixed',] },] },
	        { type: undefined, decorators: [{ type: Attribute, args: ['inset',] },] },
	    ];
	    /** @nocollapse */
	    Label.propDecorators = {
	        'id': [{ type: Input },],
	    };
	    return Label;
	}());

	var Item = (function () {
	    function Item(form, _renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._ids = -1;
	        this._inputs = [];
	        this._viewLabel = true;
	        /**
	         * @private
	         */
	        this.labelId = null;
	        this.id = form.nextId().toString();
	    }
	    /**
	     * @private
	     */
	    Item.prototype.registerInput = function (type) {
	        this._inputs.push(type);
	        return this.id + '-' + (++this._ids);
	    };
	    /**
	     * @private
	     */
	    Item.prototype.ngAfterContentInit = function () {
	        if (this._viewLabel && this._inputs.length) {
	            var labelText = this.getLabelText().trim();
	            this._viewLabel = (labelText.length > 0);
	        }
	        if (this._inputs.length > 1) {
	            this.setCssClass('item-multiple-inputs', true);
	        }
	    };
	    /**
	     * @private
	     */
	    Item.prototype.getLabelText = function () {
	        return this._label ? this._label.text : '';
	    };
	    Object.defineProperty(Item.prototype, "contentLabel", {
	        set: function (label) {
	            if (label) {
	                this._label = label;
	                this.labelId = label.id = ('lbl-' + this.id);
	                if (label.type) {
	                    this.setCssClass('item-label-' + label.type, true);
	                }
	                this._viewLabel = false;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Item.prototype, "viewLabel", {
	        set: function (label) {
	            if (!this._label) {
	                this._label = label;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Item.prototype, "_buttons", {
	        set: function (buttons) {
	            buttons.toArray().forEach(function (button) {
	                // Don't add the item-button class if the user specifies
	                // a different size button
	                if (!button.isItem && !button._size) {
	                    button.addClass('item-button');
	                }
	            });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Item.prototype, "_icons", {
	        set: function (icons) {
	            icons.toArray().forEach(function (icon) {
	                icon.addClass('item-icon');
	            });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Item.prototype.setCssClass = function (cssClass, shouldAdd) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, shouldAdd);
	    };
	    /**
	     * @private
	     */
	    Item.prototype.setCssStyle = function (property, value) {
	        this._renderer.setElementStyle(this._elementRef.nativeElement, property, value);
	    };
	    /**
	     * @private
	     */
	    Item.prototype.getNativeElement = function () {
	        return this._elementRef.nativeElement;
	    };
	    /** @nocollapse */
	    Item.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-list-header,ion-item,[ion-item],ion-item-divider',
	                    template: "\n    <ng-content select=\"[item-left],ion-checkbox:not([item-right])\"></ng-content>\n    <div class=\"item-inner\">\n      <div class=\"input-wrapper\">\n        <ng-content select=\"ion-label\"></ng-content>\n        <ion-label *ngIf=\"_viewLabel\">\n          <ng-content></ng-content>\n        </ion-label>\n        <ng-content select=\"ion-select,ion-input,ion-textarea,ion-datetime,ion-range,[item-content]\"></ng-content>\n      </div>\n      <ng-content select=\"[item-right],ion-radio,ion-toggle\"></ng-content>\n      <ion-reorder></ion-reorder>\n    </div>\n    <ion-button-effect></ion-button-effect>\n  ",
	                    directives: [NgIf, Label, forwardRef(function () { return Reorder; })],
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Item.ctorParameters = [
	        { type: Form, },
	        { type: Renderer, },
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    Item.propDecorators = {
	        'contentLabel': [{ type: ContentChild, args: [Label,] },],
	        'viewLabel': [{ type: ViewChild, args: [Label,] },],
	        '_buttons': [{ type: ContentChildren, args: [Button,] },],
	        '_icons': [{ type: ContentChildren, args: [Icon,] },],
	    };
	    return Item;
	}());
	var ItemContent = (function () {
	    function ItemContent() {
	    }
	    /** @nocollapse */
	    ItemContent.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-item,[ion-item]',
	                    host: {
	                        'class': 'item'
	                    }
	                },] },
	    ];
	    return ItemContent;
	}());

	var SWIPE_MARGIN = 20;
	var ELASTIC_FACTOR = 0.55;
	var ItemOptions = (function () {
	    function ItemOptions(_elementRef, _renderer) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this.ionSwipe = new EventEmitter();
	    }
	    /**
	     * @private
	     */
	    ItemOptions.prototype.setCssStyle = function (property, value) {
	        this._renderer.setElementStyle(this._elementRef.nativeElement, property, value);
	    };
	    /**
	     * @private
	     */
	    ItemOptions.prototype.getSides = function () {
	        if (isPresent$5(this.side) && this.side === 'left') {
	            return 1 /* Left */;
	        }
	        else {
	            return 2 /* Right */;
	        }
	    };
	    /**
	     * @private
	     */
	    ItemOptions.prototype.width = function () {
	        return this._elementRef.nativeElement.offsetWidth;
	    };
	    /** @nocollapse */
	    ItemOptions.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-item-options',
	                },] },
	    ];
	    /** @nocollapse */
	    ItemOptions.ctorParameters = [
	        { type: ElementRef, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    ItemOptions.propDecorators = {
	        'side': [{ type: Input },],
	        'ionSwipe': [{ type: Output },],
	    };
	    return ItemOptions;
	}());
	var ItemSliding = (function () {
	    function ItemSliding(list, _renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._openAmount = 0;
	        this._startX = 0;
	        this._optsWidthRightSide = 0;
	        this._optsWidthLeftSide = 0;
	        this._timer = null;
	        this._optsDirty = true;
	        this._state = 2 /* Disabled */;
	        this.ionDrag = new EventEmitter();
	        list && list.containsSlidingItem(true);
	        _elementRef.nativeElement.$ionComponent = this;
	        this.setCssClass('item-wrapper', true);
	    }
	    Object.defineProperty(ItemSliding.prototype, "_itemOptions", {
	        set: function (itemOptions) {
	            var sides = 0;
	            for (var _i = 0, _a = itemOptions.toArray(); _i < _a.length; _i++) {
	                var item = _a[_i];
	                var side = item.getSides();
	                if (side === 1 /* Left */) {
	                    this._leftOptions = item;
	                }
	                else {
	                    this._rightOptions = item;
	                }
	                sides |= item.getSides();
	            }
	            this._optsDirty = true;
	            this._sides = sides;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    ItemSliding.prototype.getOpenAmount = function () {
	        return this._openAmount;
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.getSlidingPercent = function () {
	        var openAmount = this._openAmount;
	        if (openAmount > 0) {
	            return openAmount / this._optsWidthRightSide;
	        }
	        else if (openAmount < 0) {
	            return openAmount / this._optsWidthLeftSide;
	        }
	        else {
	            return 0;
	        }
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.startSliding = function (startX) {
	        if (this._timer) {
	            clearNativeTimeout(this._timer);
	            this._timer = null;
	        }
	        if (this._openAmount === 0) {
	            this._optsDirty = true;
	            this._setState(4 /* Enabled */);
	        }
	        this._startX = startX + this._openAmount;
	        this.item.setCssStyle(CSS.transition, 'none');
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.moveSliding = function (x) {
	        if (this._optsDirty) {
	            this.calculateOptsWidth();
	            return;
	        }
	        var openAmount = (this._startX - x);
	        switch (this._sides) {
	            case 2 /* Right */:
	                openAmount = Math.max(0, openAmount);
	                break;
	            case 1 /* Left */:
	                openAmount = Math.min(0, openAmount);
	                break;
	            case 3 /* Both */: break;
	            default: return;
	        }
	        if (openAmount > this._optsWidthRightSide) {
	            var optsWidth = this._optsWidthRightSide;
	            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
	        }
	        else if (openAmount < -this._optsWidthLeftSide) {
	            var optsWidth = -this._optsWidthLeftSide;
	            openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
	        }
	        this._setOpenAmount(openAmount, false);
	        return openAmount;
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.endSliding = function (velocity) {
	        var restingPoint = (this._openAmount > 0)
	            ? this._optsWidthRightSide
	            : -this._optsWidthLeftSide;
	        // Check if the drag didn't clear the buttons mid-point
	        // and we aren't moving fast enough to swipe open
	        var isCloseDirection = (this._openAmount > 0) === !(velocity < 0);
	        var isMovingFast = Math.abs(velocity) > 0.3;
	        var isOnCloseZone = Math.abs(this._openAmount) < Math.abs(restingPoint / 2);
	        if (shouldClose(isCloseDirection, isMovingFast, isOnCloseZone)) {
	            restingPoint = 0;
	        }
	        this._setOpenAmount(restingPoint, true);
	        this.fireSwipeEvent();
	        return restingPoint;
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.fireSwipeEvent = function () {
	        if (this._state & 32 /* SwipeRight */) {
	            this._rightOptions.ionSwipe.emit(this);
	        }
	        else if (this._state & 64 /* SwipeLeft */) {
	            this._leftOptions.ionSwipe.emit(this);
	        }
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.calculateOptsWidth = function () {
	        var _this = this;
	        nativeRaf(function () {
	            if (!_this._optsDirty) {
	                return;
	            }
	            _this._optsWidthRightSide = 0;
	            if (_this._rightOptions) {
	                _this._optsWidthRightSide = _this._rightOptions.width();
	            }
	            _this._optsWidthLeftSide = 0;
	            if (_this._leftOptions) {
	                _this._optsWidthLeftSide = _this._leftOptions.width();
	            }
	            _this._optsDirty = false;
	        });
	    };
	    ItemSliding.prototype._setOpenAmount = function (openAmount, isFinal) {
	        var _this = this;
	        if (this._timer) {
	            clearNativeTimeout(this._timer);
	            this._timer = null;
	        }
	        this._openAmount = openAmount;
	        if (isFinal) {
	            this.item.setCssStyle(CSS.transition, '');
	        }
	        else {
	            if (openAmount > 0) {
	                var state = (openAmount >= (this._optsWidthRightSide + SWIPE_MARGIN))
	                    ? 8 /* Right */ | 32 /* SwipeRight */
	                    : 8 /* Right */;
	                this._setState(state);
	            }
	            else if (openAmount < 0) {
	                var state = (openAmount <= (-this._optsWidthLeftSide - SWIPE_MARGIN))
	                    ? 16 /* Left */ | 64 /* SwipeLeft */
	                    : 16 /* Left */;
	                this._setState(state);
	            }
	        }
	        if (openAmount === 0) {
	            this._timer = nativeTimeout(function () {
	                _this._setState(2 /* Disabled */);
	                _this._timer = null;
	            }, 600);
	            this.item.setCssStyle(CSS.transform, '');
	            return;
	        }
	        this.item.setCssStyle(CSS.transform, "translate3d(" + -openAmount + "px,0,0)");
	        this.ionDrag.emit(this);
	    };
	    ItemSliding.prototype._setState = function (state) {
	        if (state === this._state) {
	            return;
	        }
	        this.setCssClass('active-slide', (state !== 2 /* Disabled */));
	        this.setCssClass('active-options-right', !!(state & 8 /* Right */));
	        this.setCssClass('active-options-left', !!(state & 16 /* Left */));
	        this.setCssClass('active-swipe-right', !!(state & 32 /* SwipeRight */));
	        this.setCssClass('active-swipe-left', !!(state & 64 /* SwipeLeft */));
	        this._state = state;
	    };
	    /**
	     * Close the sliding item. Items can also be closed from the [List](../../list/List).
	     *
	     * The sliding item can be closed by grabbing a reference to `ItemSliding`. In the
	     * below example, the template reference variable `slidingItem` is placed on the element
	     * and passed to the `share` method.
	     *
	     * ```html
	     * <ion-list>
	     *   <ion-item-sliding #slidingItem>
	     *     <ion-item>
	     *       Item
	     *     </ion-item>
	     *     <ion-item-options>
	     *       <button (click)="share(slidingItem)">Share</button>
	     *     </ion-item-options>
	     *   </ion-item-sliding>
	     * </ion-list>
	     * ```
	     *
	     * ```ts
	     * import {Component} from '@angular/core';
	     * import {ItemSliding} from 'ionic-angular';
	     *
	     * @Component({...})
	     * export class MyClass {
	     *   constructor() { }
	     *
	     *   share(slidingItem: ItemSliding) {
	     *     slidingItem.close();
	     *   }
	     * }
	     * ```
	     */
	    ItemSliding.prototype.close = function () {
	        this._setOpenAmount(0, true);
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.setCssClass = function (cssClass, shouldAdd) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, shouldAdd);
	    };
	    /**
	     * @private
	     */
	    ItemSliding.prototype.setCssStyle = function (property, value) {
	        this._renderer.setElementStyle(this._elementRef.nativeElement, property, value);
	    };
	    /** @nocollapse */
	    ItemSliding.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-item-sliding',
	                    template: "\n    <ng-content select=\"ion-item,[ion-item]\"></ng-content>\n    <ng-content select=\"ion-item-options\"></ng-content>\n  ",
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None
	                },] },
	    ];
	    /** @nocollapse */
	    ItemSliding.ctorParameters = [
	        { type: List, decorators: [{ type: Optional },] },
	        { type: Renderer, },
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    ItemSliding.propDecorators = {
	        'item': [{ type: ContentChild, args: [Item,] },],
	        'ionDrag': [{ type: Output },],
	        '_itemOptions': [{ type: ContentChildren, args: [ItemOptions,] },],
	    };
	    return ItemSliding;
	}());
	function shouldClose(isCloseDirection, isMovingFast, isOnCloseZone) {
	    // The logic required to know when the sliding item should close (openAmount=0)
	    // depends on three booleans (isCloseDirection, isMovingFast, isOnCloseZone)
	    // and it ended up being too complicated to be written manually without errors
	    // so the truth table is attached below: (0=false, 1=true)
	    // isCloseDirection | isMovingFast | isOnCloseZone || shouldClose
	    //         0        |       0      |       0       ||    0
	    //         0        |       0      |       1       ||    1
	    //         0        |       1      |       0       ||    0
	    //         0        |       1      |       1       ||    0
	    //         1        |       0      |       0       ||    0
	    //         1        |       0      |       1       ||    1
	    //         1        |       1      |       0       ||    1
	    //         1        |       1      |       1       ||    1
	    // The resulting expression was generated by resolving the K-map (Karnaugh map):
	    var shouldClose = (!isMovingFast && isOnCloseZone) || (isCloseDirection && isMovingFast);
	    return shouldClose;
	}

	/**
	 * NO DOM
	 */
	function processRecords(stopAtHeight, records, cells, headerFn, footerFn, data) {
	    var record;
	    var startRecordIndex;
	    var previousCell;
	    var tmpData;
	    var lastRecordIndex = (records.length - 1);
	    if (cells.length) {
	        // we already have cells
	        previousCell = cells[cells.length - 1];
	        if (previousCell.top + previousCell.height > stopAtHeight) {
	            return;
	        }
	        startRecordIndex = (previousCell.record + 1);
	    }
	    else {
	        // no cells have been created yet
	        previousCell = {
	            row: 0,
	            width: 0,
	            height: 0,
	            top: 0,
	            left: 0,
	            tmpl: -1
	        };
	        startRecordIndex = 0;
	    }
	    var processedTotal = 0;
	    for (var recordIndex = startRecordIndex; recordIndex <= lastRecordIndex; recordIndex++) {
	        record = records[recordIndex];
	        if (headerFn) {
	            tmpData = headerFn(record, recordIndex, records);
	            if (tmpData !== null) {
	                // add header data
	                previousCell = addCell(previousCell, recordIndex, TEMPLATE_HEADER, tmpData, data.hdrWidth, data.hdrHeight, data.viewWidth);
	                cells.push(previousCell);
	            }
	        }
	        // add item data
	        previousCell = addCell(previousCell, recordIndex, TEMPLATE_ITEM, null, data.itmWidth, data.itmHeight, data.viewWidth);
	        cells.push(previousCell);
	        if (footerFn) {
	            tmpData = footerFn(record, recordIndex, records);
	            if (tmpData !== null) {
	                // add footer data
	                previousCell = addCell(previousCell, recordIndex, TEMPLATE_FOOTER, tmpData, data.ftrWidth, data.ftrHeight, data.viewWidth);
	                cells.push(previousCell);
	            }
	        }
	        if (previousCell.record === lastRecordIndex) {
	            previousCell.isLast = true;
	        }
	        // should always process at least 3 records
	        processedTotal++;
	        if (previousCell.top + previousCell.height + data.itmHeight > stopAtHeight && processedTotal > 3) {
	            return;
	        }
	    }
	}
	function addCell(previousCell, recordIndex, tmpl, tmplData, cellWidth, cellHeight, viewportWidth) {
	    var newCell;
	    if (previousCell.left + previousCell.width + cellWidth > viewportWidth) {
	        // add a new cell in a new row
	        newCell = {
	            record: recordIndex,
	            tmpl: tmpl,
	            row: (previousCell.row + 1),
	            width: cellWidth,
	            height: cellHeight,
	            top: (previousCell.top + previousCell.height),
	            left: 0,
	            reads: 0,
	        };
	    }
	    else {
	        // add a new cell in the same row
	        newCell = {
	            record: recordIndex,
	            tmpl: tmpl,
	            row: previousCell.row,
	            width: cellWidth,
	            height: cellHeight,
	            top: previousCell.top,
	            left: (previousCell.left + previousCell.width),
	            reads: 0,
	        };
	    }
	    if (tmplData) {
	        newCell.data = tmplData;
	    }
	    return newCell;
	}
	/**
	 * NO DOM
	 */
	function populateNodeData(startCellIndex, endCellIndex, viewportWidth, scrollingDown, cells, records, nodes, viewContainer, itmTmp, hdrTmp, ftrTmp, initialLoad) {
	    var madeChanges = false;
	    var node;
	    var availableNode;
	    var cell;
	    var previousCell;
	    var isAlreadyRendered;
	    var lastRecordIndex = (records.length - 1);
	    var viewInsertIndex = null;
	    var totalNodes = nodes.length;
	    var templateRef;
	    startCellIndex = Math.max(startCellIndex, 0);
	    endCellIndex = Math.min(endCellIndex, cells.length - 1);
	    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {
	        cell = cells[cellIndex];
	        availableNode = null;
	        isAlreadyRendered = false;
	        // find the first one that's available
	        if (!initialLoad) {
	            for (var i = 0; i < totalNodes; i++) {
	                node = nodes[i];
	                if (cell.tmpl !== node.tmpl || i === 0 && cellIndex !== 0) {
	                    // the cell must use the correct template
	                    // first node can only be used by the first cell (css :first-child reasons)
	                    // this node is never available to be reused
	                    continue;
	                }
	                else if (node.isLastRecord) {
	                    // very last record, but could be a header/item/footer
	                    if (cell.record === lastRecordIndex) {
	                        availableNode = nodes[i];
	                        availableNode.hidden = false;
	                        break;
	                    }
	                    // this node is for the last record, but not actually the last
	                    continue;
	                }
	                if (node.cell === cellIndex) {
	                    isAlreadyRendered = true;
	                    break;
	                }
	                if (node.cell < startCellIndex || node.cell > endCellIndex) {
	                    if (!availableNode) {
	                        // havent gotten an available node yet
	                        availableNode = nodes[i];
	                    }
	                    else if (scrollingDown) {
	                        // scrolling down
	                        if (node.cell < availableNode.cell) {
	                            availableNode = nodes[i];
	                        }
	                    }
	                    else {
	                        // scrolling up
	                        if (node.cell > availableNode.cell) {
	                            availableNode = nodes[i];
	                        }
	                    }
	                }
	            }
	            if (isAlreadyRendered) {
	                continue;
	            }
	        }
	        if (!availableNode) {
	            // did not find an available node to put the cell data into
	            // insert a new node before the last record nodes
	            if (viewInsertIndex === null) {
	                viewInsertIndex = -1;
	                for (var j = totalNodes - 1; j >= 0; j--) {
	                    node = nodes[j];
	                    if (node && !node.isLastRecord) {
	                        viewInsertIndex = viewContainer.indexOf(node.view);
	                        break;
	                    }
	                }
	            }
	            // select which templateRef should be used for this cell
	            templateRef = cell.tmpl === TEMPLATE_HEADER ? hdrTmp : cell.tmpl === TEMPLATE_FOOTER ? ftrTmp : itmTmp;
	            if (!templateRef) {
	                console.error("virtual" + (cell.tmpl === TEMPLATE_HEADER ? 'Header' : cell.tmpl === TEMPLATE_FOOTER ? 'Footer' : 'Item') + " template required");
	                continue;
	            }
	            availableNode = {
	                tmpl: cell.tmpl,
	                view: viewContainer.createEmbeddedView(templateRef, new VirtualContext(null, null, null), viewInsertIndex)
	            };
	            totalNodes = nodes.push(availableNode);
	        }
	        // console.debug(`node was cell ${availableNode.cell} but is now ${cellIndex}, was top: ${cell.top}`);
	        // assign who's the new cell index for this node
	        availableNode.cell = cellIndex;
	        // apply the cell's data to this node
	        availableNode.view.context.$implicit = cell.data || records[cell.record];
	        availableNode.view.context.index = cellIndex;
	        availableNode.hasChanges = true;
	        availableNode.lastTransform = null;
	        madeChanges = true;
	    }
	    if (initialLoad) {
	        // add nodes that go at the very end, and only represent the last record
	        var lastNodeTempData = (records[lastRecordIndex] || {});
	        addLastNodes(nodes, viewContainer, TEMPLATE_HEADER, hdrTmp, lastNodeTempData);
	        addLastNodes(nodes, viewContainer, TEMPLATE_ITEM, itmTmp, lastNodeTempData);
	        addLastNodes(nodes, viewContainer, TEMPLATE_FOOTER, ftrTmp, lastNodeTempData);
	    }
	    return madeChanges;
	}
	function addLastNodes(nodes, viewContainer, templateType, templateRef, temporaryData) {
	    if (templateRef) {
	        var node = {
	            tmpl: templateType,
	            view: viewContainer.createEmbeddedView(templateRef),
	            isLastRecord: true,
	            hidden: true,
	        };
	        node.view.context.$implicit = temporaryData;
	        nodes.push(node);
	    }
	}
	/**
	 * DOM READ THEN DOM WRITE
	 */
	function initReadNodes(nodes, cells, data) {
	    if (nodes.length && cells.length) {
	        // first node
	        // ******** DOM READ ****************
	        var firstEle = getElement(nodes[0]);
	        cells[0].top = firstEle.clientTop;
	        cells[0].left = firstEle.clientLeft;
	        cells[0].row = 0;
	        // ******** DOM READ ****************
	        updateDimensions(nodes, cells, data, true);
	        // ******** DOM READS ABOVE / DOM WRITES BELOW ****************
	        for (var i = 0; i < nodes.length; i++) {
	            if (nodes[i].hidden) {
	                // ******** DOM WRITE ****************
	                getElement(nodes[i]).classList.add('virtual-hidden');
	            }
	        }
	    }
	}
	/**
	 * DOM READ
	 */
	function updateDimensions(nodes, cells, data, initialUpdate) {
	    var node;
	    var element;
	    var totalCells = cells.length;
	    var cell;
	    var previousCell;
	    for (var i = 0; i < nodes.length; i++) {
	        node = nodes[i];
	        cell = cells[node.cell];
	        // read element dimensions if they haven't been checked enough times
	        if (cell && cell.reads < REQUIRED_DOM_READS && !node.hidden) {
	            element = getElement(node);
	            // ******** DOM READ ****************
	            readElements(cell, element);
	            if (initialUpdate) {
	                // update estimated dimensions with more accurate dimensions
	                if (cell.tmpl === TEMPLATE_HEADER) {
	                    data.hdrHeight = cell.height;
	                    if (cell.left === 0) {
	                        data.hdrWidth = cell.width;
	                    }
	                }
	                else if (cell.tmpl === TEMPLATE_FOOTER) {
	                    data.ftrHeight = cell.height;
	                    if (cell.left === 0) {
	                        data.ftrWidth = cell.width;
	                    }
	                }
	                else {
	                    data.itmHeight = cell.height;
	                    if (cell.left === 0) {
	                        data.itmWidth = cell.width;
	                    }
	                }
	            }
	            cell.reads++;
	        }
	    }
	    // figure out which cells are currently viewable within the viewport
	    var viewableBottom = (data.scrollTop + data.viewHeight);
	    data.topViewCell = totalCells;
	    data.bottomViewCell = 0;
	    // completely realign position to ensure they're all accurately placed
	    for (var i = 1; i < totalCells; i++) {
	        cell = cells[i];
	        previousCell = cells[i - 1];
	        if (previousCell.left + previousCell.width + cell.width > data.viewWidth) {
	            // new row
	            cell.row++;
	            cell.top = (previousCell.top + previousCell.height);
	            cell.left = 0;
	        }
	        else {
	            // same row
	            cell.row = previousCell.row;
	            cell.top = previousCell.top;
	            cell.left = (previousCell.left + previousCell.width);
	        }
	        // figure out which cells are viewable within the viewport
	        if (cell.top + cell.height > data.scrollTop && i < data.topViewCell) {
	            data.topViewCell = i;
	        }
	        else if (cell.top < viewableBottom && i > data.bottomViewCell) {
	            data.bottomViewCell = i;
	        }
	    }
	}
	/**
	 * DOM READ
	 */
	function readElements(cell, element) {
	    // ******** DOM READ ****************
	    var styles = window.getComputedStyle(element);
	    // ******** DOM READ ****************
	    cell.left = (element.offsetLeft - parseFloat(styles.marginLeft));
	    // ******** DOM READ ****************
	    cell.width = (element.offsetWidth + parseFloat(styles.marginLeft) + parseFloat(styles.marginRight));
	    // ******** DOM READ ****************
	    cell.height = (element.offsetHeight + parseFloat(styles.marginTop) + parseFloat(styles.marginBottom));
	}
	/**
	 * DOM WRITE
	 */
	function writeToNodes(nodes, cells, totalRecords) {
	    var node;
	    var element;
	    var cell;
	    var totalCells = Math.max(totalRecords, cells.length).toString();
	    var transform;
	    for (var i = 0, ilen = nodes.length; i < ilen; i++) {
	        node = nodes[i];
	        if (!node.hidden) {
	            cell = cells[node.cell];
	            transform = "translate3d(" + cell.left + "px," + cell.top + "px,0px)";
	            if (node.lastTransform !== transform) {
	                element = getElement(node);
	                if (element) {
	                    // ******** DOM WRITE ****************
	                    element.style[CSS.transform] = node.lastTransform = transform;
	                    // ******** DOM WRITE ****************
	                    element.classList.add('virtual-position');
	                    if (node.isLastRecord) {
	                        // its the last record, now with data and safe to show
	                        // ******** DOM WRITE ****************
	                        element.classList.remove('virtual-hidden');
	                    }
	                    // https://www.w3.org/TR/wai-aria/states_and_properties#aria-posinset
	                    // ******** DOM WRITE ****************
	                    element.setAttribute('aria-posinset', (node.cell + 1).toString());
	                    // https://www.w3.org/TR/wai-aria/states_and_properties#aria-setsize
	                    // ******** DOM WRITE ****************
	                    element.setAttribute('aria-setsize', totalCells);
	                }
	            }
	        }
	    }
	}
	/**
	 * NO DOM
	 */
	function adjustRendered(cells, data) {
	    // figure out which cells should be rendered
	    var cell;
	    var lastRow = -1;
	    var cellsRenderHeight = 0;
	    var maxRenderHeight = (data.renderHeight - data.itmHeight);
	    var totalCells = cells.length;
	    var viewableRenderedPadding = (data.itmHeight < 90 ? VIEWABLE_RENDERED_PADDING : 0);
	    if (data.scrollDiff > 0) {
	        // scrolling down
	        data.topCell = Math.max(data.topViewCell - viewableRenderedPadding, 0);
	        data.bottomCell = Math.min(data.topCell + 2, totalCells - 1);
	        for (var i = data.topCell; i < totalCells; i++) {
	            cell = cells[i];
	            if (cell.row !== lastRow) {
	                cellsRenderHeight += cell.height;
	                lastRow = cell.row;
	            }
	            if (i > data.bottomCell) {
	                data.bottomCell = i;
	            }
	            if (cellsRenderHeight >= maxRenderHeight) {
	                break;
	            }
	        }
	    }
	    else {
	        // scroll up
	        data.bottomCell = Math.min(data.bottomViewCell + viewableRenderedPadding, totalCells - 1);
	        data.topCell = Math.max(data.bottomCell - 2, 0);
	        for (var i = data.bottomCell; i >= 0; i--) {
	            cell = cells[i];
	            if (cell.row !== lastRow) {
	                cellsRenderHeight += cell.height;
	                lastRow = cell.row;
	            }
	            if (i < data.topCell) {
	                data.topCell = i;
	            }
	            if (cellsRenderHeight >= maxRenderHeight) {
	                break;
	            }
	        }
	    }
	    // console.log(`adjustRendered topCell: ${data.topCell}, bottomCell: ${data.bottomCell}, cellsRenderHeight: ${cellsRenderHeight}, data.renderHeight: ${data.renderHeight}`);
	}
	/**
	 * NO DOM
	 */
	function getVirtualHeight(totalRecords, lastCell) {
	    if (lastCell.record >= totalRecords - 1) {
	        return (lastCell.top + lastCell.height);
	    }
	    var unknownRecords = (totalRecords - lastCell.record - 1);
	    var knownHeight = (lastCell.top + lastCell.height);
	    return Math.ceil(knownHeight + ((knownHeight / (totalRecords - unknownRecords)) * unknownRecords));
	}
	/**
	 * NO DOM
	 */
	function estimateHeight(totalRecords, lastCell, existingHeight, difference) {
	    var newHeight = getVirtualHeight(totalRecords, lastCell);
	    var percentToBottom = (lastCell.record / (totalRecords - 1));
	    var diff = Math.abs(existingHeight - newHeight);
	    if ((diff > (newHeight * difference)) ||
	        (percentToBottom > .995)) {
	        return newHeight;
	    }
	    return existingHeight;
	}
	/**
	 * DOM READ
	 */
	function calcDimensions(data, viewportElement, approxItemWidth, approxItemHeight, appoxHeaderWidth, approxHeaderHeight, approxFooterWidth, approxFooterHeight, bufferRatio) {
	    // get the parent container's viewport height
	    // ******** DOM READ ****************
	    data.viewWidth = viewportElement.offsetWidth;
	    // ******** DOM READ ****************
	    data.viewHeight = viewportElement.offsetHeight;
	    // the height we'd like to render, which is larger than viewable
	    data.renderHeight = (data.viewHeight * bufferRatio);
	    if (data.viewWidth > 0 && data.viewHeight > 0) {
	        data.itmWidth = calcWidth(data.viewWidth, approxItemWidth);
	        data.itmHeight = calcHeight(data.viewHeight, approxItemHeight);
	        data.hdrWidth = calcWidth(data.viewWidth, appoxHeaderWidth);
	        data.hdrHeight = calcHeight(data.viewHeight, approxHeaderHeight);
	        data.ftrWidth = calcWidth(data.viewWidth, approxFooterWidth);
	        data.ftrHeight = calcHeight(data.viewHeight, approxFooterHeight);
	        data.valid = true;
	    }
	}
	/**
	 * NO DOM
	 */
	function calcWidth(viewportWidth, approxWidth) {
	    if (approxWidth.indexOf('%') > 0) {
	        return (viewportWidth * (parseFloat(approxWidth) / 100));
	    }
	    else if (approxWidth.indexOf('px') > 0) {
	        return parseFloat(approxWidth);
	    }
	    throw 'virtual scroll width can only use "%" or "px" units';
	}
	/**
	 * NO DOM
	 */
	function calcHeight(viewportHeight, approxHeight) {
	    if (approxHeight.indexOf('px') > 0) {
	        return parseFloat(approxHeight);
	    }
	    throw 'virtual scroll height must use "px" units';
	}
	/**
	 * NO DOM
	 */
	function getElement(node) {
	    var rootNodes = node.view.rootNodes;
	    for (var i = 0; i < rootNodes.length; i++) {
	        if (rootNodes[i].nodeType === 1) {
	            return rootNodes[i];
	        }
	    }
	    return null;
	}
	var VirtualContext = (function () {
	    function VirtualContext($implicit, index, count) {
	        this.$implicit = $implicit;
	        this.index = index;
	        this.count = count;
	    }
	    Object.defineProperty(VirtualContext.prototype, "first", {
	        get: function () { return this.index === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VirtualContext.prototype, "last", {
	        get: function () { return this.index === this.count - 1; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VirtualContext.prototype, "even", {
	        get: function () { return this.index % 2 === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VirtualContext.prototype, "odd", {
	        get: function () { return !this.even; },
	        enumerable: true,
	        configurable: true
	    });
	    return VirtualContext;
	}());
	var TEMPLATE_ITEM = 0;
	var TEMPLATE_HEADER = 1;
	var TEMPLATE_FOOTER = 2;
	var VIEWABLE_RENDERED_PADDING = 3;
	var REQUIRED_DOM_READS = 2;

	var VirtualHeader = (function () {
	    function VirtualHeader(templateRef) {
	        this.templateRef = templateRef;
	    }
	    /** @nocollapse */
	    VirtualHeader.decorators = [
	        { type: Directive, args: [{ selector: '[virtualHeader]' },] },
	    ];
	    /** @nocollapse */
	    VirtualHeader.ctorParameters = [
	        { type: TemplateRef, },
	    ];
	    return VirtualHeader;
	}());
	var VirtualFooter = (function () {
	    function VirtualFooter(templateRef) {
	        this.templateRef = templateRef;
	    }
	    /** @nocollapse */
	    VirtualFooter.decorators = [
	        { type: Directive, args: [{ selector: '[virtualFooter]' },] },
	    ];
	    /** @nocollapse */
	    VirtualFooter.ctorParameters = [
	        { type: TemplateRef, },
	    ];
	    return VirtualFooter;
	}());
	var VirtualItem = (function () {
	    function VirtualItem(templateRef, viewContainer) {
	        this.templateRef = templateRef;
	        this.viewContainer = viewContainer;
	    }
	    /** @nocollapse */
	    VirtualItem.decorators = [
	        { type: Directive, args: [{ selector: '[virtualItem]' },] },
	    ];
	    /** @nocollapse */
	    VirtualItem.ctorParameters = [
	        { type: TemplateRef, },
	        { type: ViewContainerRef, },
	    ];
	    return VirtualItem;
	}());

	var VirtualScroll = (function () {
	    function VirtualScroll(_iterableDiffers, _elementRef, _renderer, _zone, _cd, _content, _platform, _ctrl, config) {
	        this._iterableDiffers = _iterableDiffers;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._zone = _zone;
	        this._cd = _cd;
	        this._content = _content;
	        this._platform = _platform;
	        this._ctrl = _ctrl;
	        this._records = [];
	        this._cells = [];
	        this._nodes = [];
	        this._vHeight = 0;
	        this._lastCheck = 0;
	        this._data = {
	            scrollTop: 0,
	        };
	        this._queue = null;
	        this.bufferRatio = 2;
	        this.approxItemWidth = '100%';
	        this.approxItemHeight = '40px';
	        this.approxHeaderWidth = '100%';
	        this.approxHeaderHeight = '40px';
	        this.approxFooterWidth = '100%';
	        this.approxFooterHeight = '40px';
	        this._eventAssist = config.getBoolean('virtualScrollEventAssist');
	    }
	    Object.defineProperty(VirtualScroll.prototype, "virtualScroll", {
	        set: function (val) {
	            this._records = val;
	            if (isBlank$5(this._differ) && isPresent$5(val)) {
	                this._differ = this._iterableDiffers.find(val).create(this._cd, this._trackBy);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VirtualScroll.prototype, "headerFn", {
	        set: function (val) {
	            if (isFunction$6(val)) {
	                this._hdrFn = val.bind((this._ctrl && this._ctrl.instance) || this);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VirtualScroll.prototype, "footerFn", {
	        set: function (val) {
	            if (isFunction$6(val)) {
	                this._ftrFn = val.bind((this._ctrl && this._ctrl.instance) || this);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VirtualScroll.prototype, "virtualTrackBy", {
	        set: function (val) {
	            this._trackBy = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    VirtualScroll.prototype.ngDoCheck = function () {
	        if (this._init) {
	            this.update(true);
	        }
	    };
	    /**
	     * @private
	     */
	    VirtualScroll.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        if (!this._init) {
	            if (!this._itmTmp) {
	                throw 'virtualItem required within virtualScroll';
	            }
	            this._init = true;
	            this.update(true);
	            this._platform.onResize(function () {
	                console.debug('VirtualScroll, onResize');
	                _this.update(false);
	            });
	        }
	    };
	    /**
	     * @private
	     * DOM READ THEN DOM WRITE
	     */
	    VirtualScroll.prototype.update = function (checkChanges) {
	        var self = this;
	        if (!self._records || !self._records.length)
	            return;
	        if (checkChanges) {
	            if (isPresent$5(self._differ)) {
	                var changes = self._differ.diff(self._records);
	                if (!isPresent$5(changes))
	                    return;
	            }
	        }
	        console.debug('VirtualScroll, update, records:', self._records.length);
	        // reset everything
	        self._cells.length = 0;
	        self._nodes.length = 0;
	        self._itmTmp.viewContainer.clear();
	        self._elementRef.nativeElement.parentElement.scrollTop = 0;
	        var attempts = 0;
	        function readDimensions(done /* cuz promises add unnecessary overhead here */) {
	            if (self._data.valid) {
	                // good to go, we already have good dimension data
	                done();
	            }
	            else {
	                // ******** DOM READ ****************
	                calcDimensions(self._data, self._elementRef.nativeElement.parentElement, self.approxItemWidth, self.approxItemHeight, self.approxHeaderWidth, self.approxHeaderHeight, self.approxFooterWidth, self.approxFooterHeight, self.bufferRatio);
	                if (self._data.valid) {
	                    // sweet, we got some good dimension data!
	                    done();
	                }
	                else if (attempts < 30) {
	                    // oh no! the DOM doesn't have good data yet!
	                    // let's try again in XXms, and give up eventually if we never get data
	                    attempts++;
	                    nativeRaf(function () {
	                        readDimensions(done);
	                    });
	                }
	            }
	        }
	        // ******** DOM READ ****************
	        readDimensions(function () {
	            processRecords(self._data.renderHeight, self._records, self._cells, self._hdrFn, self._ftrFn, self._data);
	            // ******** DOM WRITE ****************
	            self.renderVirtual();
	            // list for scroll events
	            self.addScrollListener();
	        });
	    };
	    /**
	     * @private
	     * DOM WRITE
	     */
	    VirtualScroll.prototype.renderVirtual = function () {
	        // initialize nodes with the correct cell data
	        this._data.topCell = 0;
	        this._data.bottomCell = (this._cells.length - 1);
	        populateNodeData(0, this._data.bottomCell, this._data.viewWidth, true, this._cells, this._records, this._nodes, this._itmTmp.viewContainer, this._itmTmp.templateRef, this._hdrTmp && this._hdrTmp.templateRef, this._ftrTmp && this._ftrTmp.templateRef, true);
	        // ******** DOM WRITE ****************
	        this._cd.detectChanges();
	        // wait a frame before trying to read and calculate the dimensions
	        nativeRaf(this.postRenderVirtual.bind(this));
	    };
	    /**
	     * @private
	     * DOM READ THEN DOM WRITE
	     */
	    VirtualScroll.prototype.postRenderVirtual = function () {
	        // ******** DOM READ THEN DOM WRITE ****************
	        initReadNodes(this._nodes, this._cells, this._data);
	        // ******** DOM READS ABOVE / DOM WRITES BELOW ****************
	        // ******** DOM WRITE ****************
	        this._renderer.setElementClass(this._elementRef.nativeElement, 'virtual-scroll', true);
	        // ******** DOM WRITE ****************
	        writeToNodes(this._nodes, this._cells, this._records.length);
	        // ******** DOM WRITE ****************
	        this.setVirtualHeight(estimateHeight(this._records.length, this._cells[this._cells.length - 1], this._vHeight, 0.25));
	    };
	    /**
	     * @private
	     */
	    VirtualScroll.prototype.scrollUpdate = function () {
	        clearNativeTimeout(this._tmId);
	        this._tmId = nativeTimeout(this.onScrollEnd.bind(this), SCROLL_END_TIMEOUT_MS);
	        var data = this._data;
	        if (this._queue === QUEUE_CHANGE_DETECTION) {
	            // ******** DOM WRITE ****************
	            this._cd.detectChanges();
	            // ******** DOM WRITE ****************
	            writeToNodes(this._nodes, this._cells, this._records.length);
	            // ******** DOM WRITE ****************
	            this.setVirtualHeight(estimateHeight(this._records.length, this._cells[this._cells.length - 1], this._vHeight, 0.25));
	            this._queue = null;
	        }
	        else {
	            data.scrollDiff = (data.scrollTop - this._lastCheck);
	            if (Math.abs(data.scrollDiff) > SCROLL_DIFFERENCE_MINIMUM) {
	                // don't bother updating if the scrollTop hasn't changed much
	                this._lastCheck = data.scrollTop;
	                if (data.scrollDiff > 0) {
	                    // load data we may not have processed yet
	                    var stopAtHeight = (data.scrollTop + data.renderHeight);
	                    processRecords(stopAtHeight, this._records, this._cells, this._hdrFn, this._ftrFn, data);
	                }
	                // ******** DOM READ ****************
	                updateDimensions(this._nodes, this._cells, data, false);
	                adjustRendered(this._cells, data);
	                var madeChanges = populateNodeData(data.topCell, data.bottomCell, data.viewWidth, data.scrollDiff > 0, this._cells, this._records, this._nodes, this._itmTmp.viewContainer, this._itmTmp.templateRef, this._hdrTmp && this._hdrTmp.templateRef, this._ftrTmp && this._ftrTmp.templateRef, false);
	                if (madeChanges) {
	                    // do not update images while scrolling
	                    this._imgs.forEach(function (img) {
	                        img.enable(false);
	                    });
	                    // queue making updates in the next frame
	                    this._queue = QUEUE_CHANGE_DETECTION;
	                }
	                else {
	                    this._queue = null;
	                }
	            }
	        }
	    };
	    /**
	     * @private
	     * DOM WRITE
	     */
	    VirtualScroll.prototype.onScrollEnd = function () {
	        // scrolling is done, allow images to be updated now
	        this._imgs.forEach(function (img) {
	            img.enable(true);
	        });
	        // ******** DOM READ ****************
	        updateDimensions(this._nodes, this._cells, this._data, false);
	        adjustRendered(this._cells, this._data);
	        // ******** DOM WRITE ****************
	        this._cd.detectChanges();
	        // ******** DOM WRITE ****************
	        this.setVirtualHeight(estimateHeight(this._records.length, this._cells[this._cells.length - 1], this._vHeight, 0.05));
	    };
	    /**
	     * @private
	     * DOM WRITE
	     */
	    VirtualScroll.prototype.setVirtualHeight = function (newVirtualHeight) {
	        if (newVirtualHeight !== this._vHeight) {
	            // ******** DOM WRITE ****************
	            this._renderer.setElementStyle(this._elementRef.nativeElement, 'height', newVirtualHeight > 0 ? newVirtualHeight + 'px' : '');
	            this._vHeight = newVirtualHeight;
	            console.debug('VirtualScroll, height', newVirtualHeight);
	        }
	    };
	    /**
	     * @private
	     * NO DOM
	     */
	    VirtualScroll.prototype.addScrollListener = function () {
	        var self = this;
	        if (!self._unreg) {
	            self._zone.runOutsideAngular(function () {
	                function onScroll() {
	                    // ******** DOM READ ****************
	                    self._data.scrollTop = self._content.getScrollTop();
	                    // ******** DOM READ THEN DOM WRITE ****************
	                    self.scrollUpdate();
	                }
	                if (self._eventAssist) {
	                    // use JS scrolling for iOS UIWebView
	                    // goal is to completely remove this when iOS
	                    // fully supports scroll events
	                    // listen to JS scroll events
	                    self._unreg = self._content.jsScroll(onScroll);
	                }
	                else {
	                    // listen to native scroll events
	                    self._unreg = self._content.addScrollListener(onScroll);
	                }
	            });
	        }
	    };
	    /**
	     * @private
	     * NO DOM
	     */
	    VirtualScroll.prototype.ngOnDestroy = function () {
	        this._unreg && this._unreg();
	        this._unreg = null;
	    };
	    /** @nocollapse */
	    VirtualScroll.decorators = [
	        { type: Directive, args: [{
	                    selector: '[virtualScroll]'
	                },] },
	    ];
	    /** @nocollapse */
	    VirtualScroll.ctorParameters = [
	        { type: IterableDiffers, },
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: NgZone, },
	        { type: ChangeDetectorRef, },
	        { type: Content, },
	        { type: Platform, },
	        { type: ViewController, decorators: [{ type: Optional },] },
	        { type: Config, },
	    ];
	    /** @nocollapse */
	    VirtualScroll.propDecorators = {
	        '_itmTmp': [{ type: ContentChild, args: [VirtualItem,] },],
	        '_hdrTmp': [{ type: ContentChild, args: [VirtualHeader,] },],
	        '_ftrTmp': [{ type: ContentChild, args: [VirtualFooter,] },],
	        '_imgs': [{ type: ContentChildren, args: [Img,] },],
	        'virtualScroll': [{ type: Input },],
	        'bufferRatio': [{ type: Input },],
	        'approxItemWidth': [{ type: Input },],
	        'approxItemHeight': [{ type: Input },],
	        'approxHeaderWidth': [{ type: Input },],
	        'approxHeaderHeight': [{ type: Input },],
	        'approxFooterWidth': [{ type: Input },],
	        'approxFooterHeight': [{ type: Input },],
	        'headerFn': [{ type: Input },],
	        'footerFn': [{ type: Input },],
	        'virtualTrackBy': [{ type: Input },],
	    };
	    return VirtualScroll;
	}());
	var SCROLL_END_TIMEOUT_MS = 140;
	var SCROLL_DIFFERENCE_MINIMUM = 20;
	var QUEUE_CHANGE_DETECTION = 0;

	var ToolbarItem = (function () {
	    function ToolbarItem(elementRef, toolbar, navbar) {
	        toolbar && toolbar.addItemRef(elementRef);
	        navbar && navbar.addItemRef(elementRef);
	        this.inToolbar = !!(toolbar || navbar);
	    }
	    Object.defineProperty(ToolbarItem.prototype, "_buttons", {
	        set: function (buttons) {
	            if (this.inToolbar) {
	                Button.setRoles(buttons, 'bar-button');
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    ToolbarItem.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-buttons,[menuToggle]'
	                },] },
	    ];
	    /** @nocollapse */
	    ToolbarItem.ctorParameters = [
	        { type: ElementRef, },
	        { type: Toolbar, decorators: [{ type: Optional },] },
	        { type: Navbar, decorators: [{ type: Optional }, { type: Inject, args: [forwardRef(function () { return Navbar; }),] },] },
	    ];
	    /** @nocollapse */
	    ToolbarItem.propDecorators = {
	        '_buttons': [{ type: ContentChildren, args: [Button,] },],
	    };
	    return ToolbarItem;
	}());

	var __extends$23 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ToolbarTitle = (function (_super) {
	    __extends$23(ToolbarTitle, _super);
	    function ToolbarTitle(_elementRef, toolbar, navbar) {
	        _super.call(this, _elementRef);
	        this._elementRef = _elementRef;
	        toolbar && toolbar.setTitleCmp(this);
	        navbar && navbar.setTitleCmp(this);
	    }
	    /**
	     * @private
	     */
	    ToolbarTitle.prototype.getTitleText = function () {
	        return this._elementRef.nativeElement.textContent;
	    };
	    /** @nocollapse */
	    ToolbarTitle.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-title',
	                    template: '<div class="toolbar-title">' +
	                        '<ng-content></ng-content>' +
	                        '</div>',
	                    changeDetection: ChangeDetectionStrategy.OnPush,
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    ToolbarTitle.ctorParameters = [
	        { type: ElementRef, },
	        { type: Toolbar, decorators: [{ type: Optional },] },
	        { type: Navbar, decorators: [{ type: Optional }, { type: Inject, args: [forwardRef(function () { return Navbar; }),] },] },
	    ];
	    return ToolbarTitle;
	}(Ion));

	var CHECKBOX_VALUE_ACCESSOR$2 = new Provider(NG_VALUE_ACCESSOR$1, { useExisting: forwardRef(function () { return Checkbox; }), multi: true });
	var Checkbox = (function () {
	    function Checkbox(_form, _item) {
	        this._form = _form;
	        this._item = _item;
	        this._checked = false;
	        this._disabled = false;
	        this.ionChange = new EventEmitter();
	        _form.register(this);
	        if (_item) {
	            this.id = 'chk-' + _item.registerInput('checkbox');
	            this._labelId = 'lbl-' + _item.id;
	            this._item.setCssClass('item-checkbox', true);
	        }
	    }
	    Checkbox.prototype._click = function (ev) {
	        console.debug('checkbox, checked');
	        ev.preventDefault();
	        ev.stopPropagation();
	        this.onChange(!this._checked);
	    };
	    Object.defineProperty(Checkbox.prototype, "checked", {
	        get: function () {
	            return this._checked;
	        },
	        set: function (val) {
	            this._setChecked(isTrueProperty(val));
	            this.onChange(this._checked);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Checkbox.prototype._setChecked = function (isChecked) {
	        if (isChecked !== this._checked) {
	            this._checked = isChecked;
	            if (this._init) {
	                this.ionChange.emit(this);
	            }
	            this._item && this._item.setCssClass('item-checkbox-checked', isChecked);
	        }
	    };
	    /**
	     * @private
	     */
	    Checkbox.prototype.writeValue = function (val) {
	        this._setChecked(isTrueProperty(val));
	    };
	    /**
	     * @private
	     */
	    Checkbox.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this._fn = fn;
	        this.onChange = function (isChecked) {
	            console.debug('checkbox, onChange', isChecked);
	            fn(isChecked);
	            _this._setChecked(isChecked);
	            _this.onTouched();
	        };
	    };
	    /**
	     * @private
	     */
	    Checkbox.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    Object.defineProperty(Checkbox.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this._item && this._item.setCssClass('item-checkbox-disabled', this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Checkbox.prototype.onChange = function (isChecked) {
	        // used when this input does not have an ngModel or formControlName
	        console.debug('checkbox, onChange (no ngModel)', isChecked);
	        this._setChecked(isChecked);
	        this.onTouched();
	    };
	    /**
	     * @private
	     */
	    Checkbox.prototype.onTouched = function () { };
	    /**
	     * @private
	     */
	    Checkbox.prototype.ngAfterContentInit = function () {
	        this._init = true;
	    };
	    /**
	     * @private
	     */
	    Checkbox.prototype.ngOnDestroy = function () {
	        this._form.deregister(this);
	    };
	    /** @nocollapse */
	    Checkbox.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-checkbox',
	                    template: "\n    <div class=\"checkbox-icon\" [class.checkbox-checked]=\"_checked\">\n      <div class=\"checkbox-inner\"></div>\n    </div>\n    <button role=\"checkbox\"\n            type=\"button\"\n            category=\"item-cover\"\n            [id]=\"id\"\n            [attr.aria-checked]=\"_checked\"\n            [attr.aria-labelledby]=\"_labelId\"\n            [attr.aria-disabled]=\"_disabled\"\n            class=\"item-cover\">\n    </button>\n  ",
	                    host: {
	                        '[class.checkbox-disabled]': '_disabled'
	                    },
	                    providers: [CHECKBOX_VALUE_ACCESSOR$2],
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Checkbox.ctorParameters = [
	        { type: Form, },
	        { type: Item, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    Checkbox.propDecorators = {
	        'ionChange': [{ type: Output },],
	        '_click': [{ type: HostListener, args: ['click', ['$event'],] },],
	        'checked': [{ type: Input },],
	        'disabled': [{ type: Input },],
	    };
	    return Checkbox;
	}());

	var Option = (function () {
	    function Option(_elementRef) {
	        this._elementRef = _elementRef;
	        this._checked = false;
	        this._disabled = false;
	        this.ionSelect = new EventEmitter();
	    }
	    Object.defineProperty(Option.prototype, "checked", {
	        get: function () {
	            return this._checked;
	        },
	        set: function (val) {
	            this._checked = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Option.prototype, "value", {
	        get: function () {
	            if (isPresent$5(this._value)) {
	                return this._value;
	            }
	            return this.text;
	        },
	        set: function (val) {
	            this._value = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Option.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Option.prototype, "text", {
	        /**
	         * @private
	         */
	        get: function () {
	            return this._elementRef.nativeElement.textContent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    Option.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-option'
	                },] },
	    ];
	    /** @nocollapse */
	    Option.ctorParameters = [
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    Option.propDecorators = {
	        'ionSelect': [{ type: Output },],
	        'checked': [{ type: Input },],
	        'value': [{ type: Input },],
	        'disabled': [{ type: Input },],
	    };
	    return Option;
	}());

	var SELECT_VALUE_ACCESSOR$2 = new Provider(NG_VALUE_ACCESSOR$1, { useExisting: forwardRef(function () { return Select; }), multi: true });
	var Select = (function () {
	    function Select(_app, _form, _elementRef, _renderer, _item, _nav) {
	        this._app = _app;
	        this._form = _form;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._item = _item;
	        this._nav = _nav;
	        this._disabled = false;
	        this._multi = false;
	        this._values = [];
	        this._texts = [];
	        this._text = '';
	        this._isOpen = false;
	        this.cancelText = 'Cancel';
	        this.okText = 'OK';
	        this.alertOptions = {};
	        this.checked = false;
	        this.interface = '';
	        this.ionChange = new EventEmitter();
	        this.ionCancel = new EventEmitter();
	        this._form.register(this);
	        if (_item) {
	            this.id = 'sel-' + _item.registerInput('select');
	            this._labelId = 'lbl-' + _item.id;
	            this._item.setCssClass('item-select', true);
	        }
	    }
	    Select.prototype._click = function (ev) {
	        if (ev.detail === 0) {
	            // do not continue if the click event came from a form submit
	            return;
	        }
	        ev.preventDefault();
	        ev.stopPropagation();
	        this.open();
	    };
	    Select.prototype._keyup = function () {
	        if (!this._isOpen) {
	            this.open();
	        }
	    };
	    /**
	     * Open the select interface.
	     */
	    Select.prototype.open = function () {
	        var _this = this;
	        if (this._disabled) {
	            return;
	        }
	        console.debug('select, open alert');
	        // the user may have assigned some options specifically for the alert
	        var alertOptions = merge$1({}, this.alertOptions);
	        // make sure their buttons array is removed from the options
	        // and we create a new array for the alert's two buttons
	        alertOptions.buttons = [{
	                text: this.cancelText,
	                role: 'cancel',
	                handler: function () {
	                    _this.ionCancel.emit(null);
	                }
	            }];
	        // if the alertOptions didn't provide an title then use the label's text
	        if (!alertOptions.title && this._item) {
	            alertOptions.title = this._item.getLabelText();
	        }
	        var options = this._options.toArray();
	        if (this.interface === 'action-sheet' && options.length > 6) {
	            console.warn('Interface cannot be "action-sheet" with more than 6 options. Using the "alert" interface.');
	            this.interface = 'alert';
	        }
	        if (this.interface === 'action-sheet' && this._multi) {
	            console.warn('Interface cannot be "action-sheet" with a multi-value select. Using the "alert" interface.');
	            this.interface = 'alert';
	        }
	        var overlay;
	        if (this.interface === 'action-sheet') {
	            alertOptions.buttons = alertOptions.buttons.concat(options.map(function (input) {
	                return {
	                    role: (input.checked ? 'selected' : ''),
	                    text: input.text,
	                    handler: function () {
	                        _this.onChange(input.value);
	                        _this.ionChange.emit(input.value);
	                    }
	                };
	            }));
	            alertOptions.cssClass = 'select-action-sheet';
	            overlay = new ActionSheet(this._app, alertOptions);
	        }
	        else {
	            // default to use the alert interface
	            this.interface = 'alert';
	            // user cannot provide inputs from alertOptions
	            // alert inputs must be created by ionic from ion-options
	            alertOptions.inputs = this._options.map(function (input) {
	                return {
	                    type: (_this._multi ? 'checkbox' : 'radio'),
	                    label: input.text,
	                    value: input.value,
	                    checked: input.checked,
	                    disabled: input.disabled
	                };
	            });
	            // create the alert instance from our built up alertOptions
	            overlay = new Alert(this._app, alertOptions);
	            if (this._multi) {
	                // use checkboxes
	                overlay.setCssClass('select-alert multiple-select-alert');
	            }
	            else {
	                // use radio buttons
	                overlay.setCssClass('select-alert single-select-alert');
	            }
	            overlay.addButton({
	                text: this.okText,
	                handler: function (selectedValues) {
	                    _this.onChange(selectedValues);
	                    _this.ionChange.emit(selectedValues);
	                }
	            });
	        }
	        overlay.present(alertOptions);
	        this._isOpen = true;
	        overlay.onDidDismiss(function () {
	            _this._isOpen = false;
	        });
	    };
	    Object.defineProperty(Select.prototype, "multiple", {
	        get: function () {
	            return this._multi;
	        },
	        set: function (val) {
	            this._multi = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Select.prototype, "text", {
	        /**
	         * @private
	         */
	        get: function () {
	            return (this._multi ? this._texts : this._texts.join());
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Select.prototype, "options", {
	        set: function (val) {
	            this._options = val;
	            if (!this._values.length) {
	                // there are no values set at this point
	                // so check to see who should be checked
	                this._values = val.filter(function (o) { return o.checked; }).map(function (o) { return o.value; });
	            }
	            this._updOpts();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Select.prototype._updOpts = function () {
	        var _this = this;
	        this._texts = [];
	        if (this._options) {
	            this._options.forEach(function (option) {
	                // check this option if the option's value is in the values array
	                option.checked = _this._values.some(function (selectValue) {
	                    return isCheckedProperty(selectValue, option.value);
	                });
	                if (option.checked) {
	                    _this._texts.push(option.text);
	                }
	            });
	        }
	        this._text = this._texts.join(', ');
	    };
	    Object.defineProperty(Select.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this._item && this._item.setCssClass('item-select-disabled', this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Select.prototype.writeValue = function (val) {
	        console.debug('select, writeValue', val);
	        this._values = (Array.isArray(val) ? val : isBlank$5(val) ? [] : [val]);
	        this._updOpts();
	    };
	    /**
	     * @private
	     */
	    Select.prototype.ngAfterContentInit = function () {
	        this._updOpts();
	    };
	    /**
	     * @private
	     */
	    Select.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this._fn = fn;
	        this.onChange = function (val) {
	            console.debug('select, onChange', val);
	            fn(val);
	            _this._values = (Array.isArray(val) ? val : isBlank$5(val) ? [] : [val]);
	            _this._updOpts();
	            _this.onTouched();
	        };
	    };
	    /**
	     * @private
	     */
	    Select.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /**
	     * @private
	     */
	    Select.prototype.onChange = function (val) {
	        // onChange used when there is not an formControlName
	        console.debug('select, onChange w/out formControlName', val);
	        this._values = (Array.isArray(val) ? val : isBlank$5(val) ? [] : [val]);
	        this._updOpts();
	        this.onTouched();
	    };
	    /**
	     * @private
	     */
	    Select.prototype.onTouched = function () { };
	    /**
	     * @private
	     */
	    Select.prototype.ngOnDestroy = function () {
	        this._form.deregister(this);
	    };
	    /** @nocollapse */
	    Select.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-select',
	                    template: "\n    <div *ngIf=\"!_text\" class=\"select-placeholder select-text\">{{placeholder}}</div>\n    <div *ngIf=\"_text\" class=\"select-text\">{{_text}}</div>\n    <div class=\"select-icon\">\n      <div class=\"select-icon-inner\"></div>\n    </div>\n    <button aria-haspopup=\"true\"\n            [id]=\"id\"\n            category=\"item-cover\"\n            [attr.aria-labelledby]=\"_labelId\"\n            [attr.aria-disabled]=\"_disabled\"\n            class=\"item-cover\">\n    </button>\n  ",
	                    directives: [NgIf],
	                    host: {
	                        '[class.select-disabled]': '_disabled'
	                    },
	                    providers: [SELECT_VALUE_ACCESSOR$2],
	                    encapsulation: ViewEncapsulation.None
	                },] },
	    ];
	    /** @nocollapse */
	    Select.ctorParameters = [
	        { type: App, },
	        { type: Form, },
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: Item, decorators: [{ type: Optional },] },
	        { type: NavController, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    Select.propDecorators = {
	        'cancelText': [{ type: Input },],
	        'okText': [{ type: Input },],
	        'placeholder': [{ type: Input },],
	        'alertOptions': [{ type: Input },],
	        'checked': [{ type: Input },],
	        'interface': [{ type: Input },],
	        'ionChange': [{ type: Output },],
	        'ionCancel': [{ type: Output },],
	        '_click': [{ type: HostListener, args: ['click', ['$event'],] },],
	        '_keyup': [{ type: HostListener, args: ['keyup.space',] },],
	        'multiple': [{ type: Input },],
	        'options': [{ type: ContentChildren, args: [Option,] },],
	        'disabled': [{ type: Input },],
	    };
	    return Select;
	}());

	var __extends$25 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PickerColumnCmp = (function () {
	    function PickerColumnCmp(config, elementRef, _sanitizer) {
	        this.elementRef = elementRef;
	        this._sanitizer = _sanitizer;
	        this.y = 0;
	        this.pos = [];
	        this.startY = null;
	        this.receivingEvents = false;
	        this.events = new UIEventManager();
	        this.ionChange = new EventEmitter();
	        this.rotateFactor = config.getNumber('pickerRotateFactor', 0);
	    }
	    PickerColumnCmp.prototype.ngAfterViewInit = function () {
	        var _this = this;
	        // get the scrollable element within the column
	        var colEle = this.colEle.nativeElement;
	        this.colHeight = colEle.clientHeight;
	        // get the height of one option
	        this.optHeight = (colEle.firstElementChild ? colEle.firstElementChild.clientHeight : 0);
	        // set the scroll position for the selected option
	        this.setSelected(this.col.selectedIndex, 0);
	        // Listening for pointer events
	        this.events.pointerEventsRef(this.elementRef, function (ev) { return _this.pointerStart(ev); }, function (ev) { return _this.pointerMove(ev); }, function (ev) { return _this.pointerEnd(ev); });
	    };
	    PickerColumnCmp.prototype.ngOnDestroy = function () {
	        this.events.unlistenAll();
	    };
	    PickerColumnCmp.prototype.pointerStart = function (ev) {
	        console.debug('picker, pointerStart', ev.type, this.startY);
	        // cancel any previous raf's that haven't fired yet
	        cancelRaf(this.rafId);
	        // remember where the pointer started from`
	        this.startY = pointerCoord(ev).y;
	        // reset everything
	        this.receivingEvents = true;
	        this.velocity = 0;
	        this.pos.length = 0;
	        this.pos.push(this.startY, Date.now());
	        var minY = (this.col.options.length - 1);
	        var maxY = 0;
	        for (var i = 0; i < this.col.options.length; i++) {
	            if (!this.col.options[i].disabled) {
	                minY = Math.min(minY, i);
	                maxY = Math.max(maxY, i);
	            }
	        }
	        this.minY = (minY * this.optHeight * -1);
	        this.maxY = (maxY * this.optHeight * -1);
	        return true;
	    };
	    PickerColumnCmp.prototype.pointerMove = function (ev) {
	        ev.preventDefault();
	        ev.stopPropagation();
	        if (this.startY === null) {
	            return;
	        }
	        var currentY = pointerCoord(ev).y;
	        this.pos.push(currentY, Date.now());
	        // update the scroll position relative to pointer start position
	        var y = this.y + (currentY - this.startY);
	        if (y > this.minY) {
	            // scrolling up higher than scroll area
	            y = Math.pow(y, 0.8);
	            this.bounceFrom = y;
	        }
	        else if (y < this.maxY) {
	            // scrolling down below scroll area
	            y += Math.pow(this.maxY - y, 0.9);
	            this.bounceFrom = y;
	        }
	        else {
	            this.bounceFrom = 0;
	        }
	        this.update(y, 0, false, false);
	    };
	    PickerColumnCmp.prototype.pointerEnd = function (ev) {
	        if (!this.receivingEvents) {
	            return;
	        }
	        this.receivingEvents = false;
	        this.velocity = 0;
	        if (this.bounceFrom > 0) {
	            // bounce back up
	            this.update(this.minY, 100, true, true);
	        }
	        else if (this.bounceFrom < 0) {
	            // bounce back down
	            this.update(this.maxY, 100, true, true);
	        }
	        else if (this.startY !== null) {
	            var endY = pointerCoord(ev).y;
	            console.debug('picker, pointerEnd', ev.type, endY);
	            this.pos.push(endY, Date.now());
	            var endPos = (this.pos.length - 1);
	            var startPos = endPos;
	            var timeRange = (Date.now() - 100);
	            // move pointer to position measured 100ms ago
	            for (var i = endPos; i > 0 && this.pos[i] > timeRange; i -= 2) {
	                startPos = i;
	            }
	            if (startPos !== endPos) {
	                // compute relative movement between these two points
	                var timeOffset = (this.pos[endPos] - this.pos[startPos]);
	                var movedTop = (this.pos[startPos - 1] - this.pos[endPos - 1]);
	                // based on XXms compute the movement to apply for each render step
	                this.velocity = ((movedTop / timeOffset) * FRAME_MS$1);
	            }
	            if (Math.abs(endY - this.startY) > 3) {
	                ev.preventDefault();
	                ev.stopPropagation();
	                var y = this.y + (endY - this.startY);
	                this.update(y, 0, true, true);
	            }
	        }
	        this.startY = null;
	        this.decelerate();
	    };
	    PickerColumnCmp.prototype.decelerate = function () {
	        var y = 0;
	        cancelRaf(this.rafId);
	        if (isNaN(this.y) || !this.optHeight) {
	            // fallback in case numbers get outta wack
	            this.update(y, 0, true, true);
	        }
	        else if (Math.abs(this.velocity) > 0) {
	            // still decelerating
	            this.velocity *= DECELERATION_FRICTION$1;
	            // do not let it go slower than a velocity of 1
	            this.velocity = (this.velocity > 0 ? Math.max(this.velocity, 1) : Math.min(this.velocity, -1));
	            y = Math.round(this.y - this.velocity);
	            if (y > this.minY) {
	                // whoops, it's trying to scroll up farther than the options we have!
	                y = this.minY;
	                this.velocity = 0;
	            }
	            else if (y < this.maxY) {
	                // gahh, it's trying to scroll down farther than we can!
	                y = this.maxY;
	                this.velocity = 0;
	            }
	            console.log("decelerate y: " + y + ", velocity: " + this.velocity + ", optHeight: " + this.optHeight);
	            var notLockedIn = (y % this.optHeight !== 0 || Math.abs(this.velocity) > 1);
	            this.update(y, 0, true, !notLockedIn);
	            if (notLockedIn) {
	                // isn't locked in yet, keep decelerating until it is
	                this.rafId = raf(this.decelerate.bind(this));
	            }
	        }
	        else if (this.y % this.optHeight !== 0) {
	            // needs to still get locked into a position so options line up
	            var currentPos = Math.abs(this.y % this.optHeight);
	            // create a velocity in the direction it needs to scroll
	            this.velocity = (currentPos > (this.optHeight / 2) ? 1 : -1);
	            this.decelerate();
	        }
	    };
	    PickerColumnCmp.prototype.optClick = function (ev, index) {
	        if (!this.velocity) {
	            ev.preventDefault();
	            ev.stopPropagation();
	            this.setSelected(index, 150);
	        }
	    };
	    PickerColumnCmp.prototype.setSelected = function (selectedIndex, duration) {
	        // if there is a selected index, then figure out it's y position
	        // if there isn't a selected index, then just use the top y position
	        var y = (selectedIndex > -1) ? ((selectedIndex * this.optHeight) * -1) : 0;
	        cancelRaf(this.rafId);
	        this.velocity = 0;
	        // so what y position we're at
	        this.update(y, duration, true, true);
	    };
	    PickerColumnCmp.prototype.update = function (y, duration, saveY, emitChange) {
	        // ensure we've got a good round number :)
	        y = Math.round(y);
	        this.col.selectedIndex = Math.max(Math.abs(Math.round(y / this.optHeight)), 0);
	        for (var i = 0; i < this.col.options.length; i++) {
	            var opt = this.col.options[i];
	            var optTop = (i * this.optHeight);
	            var optOffset = (optTop + y);
	            var rotateX = (optOffset * this.rotateFactor);
	            var translateX = 0;
	            var translateY = 0;
	            var translateZ = 0;
	            if (this.rotateFactor !== 0) {
	                translateX = 0;
	                translateZ = 90;
	                if (rotateX > 90 || rotateX < -90) {
	                    translateX = -9999;
	                    rotateX = 0;
	                }
	            }
	            else {
	                translateY = optOffset;
	            }
	            opt._trans = this._sanitizer.bypassSecurityTrustStyle("rotateX(" + rotateX + "deg) translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)");
	            opt._dur = (duration > 0 ? duration + 'ms' : '');
	        }
	        if (saveY) {
	            this.y = y;
	        }
	        if (emitChange) {
	            if (this.lastIndex === undefined) {
	                // have not set a last index yet
	                this.lastIndex = this.col.selectedIndex;
	            }
	            else if (this.lastIndex !== this.col.selectedIndex) {
	                // new selected index has changed from the last index
	                // update the lastIndex and emit that it has changed
	                this.lastIndex = this.col.selectedIndex;
	                this.ionChange.emit(this.col.options[this.col.selectedIndex]);
	            }
	        }
	    };
	    PickerColumnCmp.prototype.refresh = function () {
	        var min = this.col.options.length - 1;
	        var max = 0;
	        for (var i = 0; i < this.col.options.length; i++) {
	            if (!this.col.options[i].disabled) {
	                min = Math.min(min, i);
	                max = Math.max(max, i);
	            }
	        }
	        var selectedIndex = clamp(min, this.col.selectedIndex, max);
	        if (selectedIndex !== this.col.selectedIndex) {
	            var y = (selectedIndex * this.optHeight) * -1;
	            this.update(y, 150, true, true);
	        }
	    };
	    /** @nocollapse */
	    PickerColumnCmp.decorators = [
	        { type: Component, args: [{
	                    selector: '.picker-col',
	                    template: "\n    <div *ngIf=\"col.prefix\" class=\"picker-prefix\" [style.width]=\"col.prefixWidth\">{{col.prefix}}</div>\n    <div class=\"picker-opts\" #colEle [style.width]=\"col.optionsWidth\">\n      <button *ngFor=\"let o of col.options; let i=index\" [style.transform]=\"o._trans\" [style.transitionDuration]=\"o._dur\" [class.picker-opt-selected]=\"col.selectedIndex === i\" [class.picker-opt-disabled]=\"o.disabled\" (click)=\"optClick($event, i)\" type=\"button\" category=\"picker-opt\">\n        {{o.text}}\n      </button>\n    </div>\n    <div *ngIf=\"col.suffix\" class=\"picker-suffix\" [style.width]=\"col.suffixWidth\">{{col.suffix}}</div>\n  ",
	                    directives: [NgFor, NgIf],
	                    host: {
	                        '[style.min-width]': 'col.columnWidth',
	                        '[class.picker-opts-left]': 'col.align=="left"',
	                        '[class.picker-opts-right]': 'col.align=="right"',
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    PickerColumnCmp.ctorParameters = [
	        { type: Config, },
	        { type: ElementRef, },
	        { type: DomSanitizationService, },
	    ];
	    /** @nocollapse */
	    PickerColumnCmp.propDecorators = {
	        'colEle': [{ type: ViewChild, args: ['colEle',] },],
	        'col': [{ type: Input },],
	        'ionChange': [{ type: Output },],
	    };
	    return PickerColumnCmp;
	}());
	var PickerCmp = (function () {
	    function PickerCmp(_viewCtrl, _elementRef, _config, params, renderer) {
	        this._viewCtrl = _viewCtrl;
	        this._elementRef = _elementRef;
	        this._config = _config;
	        this.d = params.data;
	        if (this.d.cssClass) {
	            this.d.cssClass.split(' ').forEach(function (cssClass) {
	                renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
	            });
	        }
	        this.id = (++pickerIds);
	        this.lastClick = 0;
	    }
	    PickerCmp.prototype.ionViewLoaded = function () {
	        // normalize the data
	        var data = this.d;
	        data.buttons = data.buttons.map(function (button) {
	            if (isString$5(button)) {
	                return { text: button };
	            }
	            if (button.role) {
	                button.cssRole = "picker-toolbar-" + button.role;
	            }
	            return button;
	        });
	        // clean up dat data
	        data.columns = data.columns.map(function (column) {
	            if (!isPresent$5(column.columnWidth)) {
	                column.columnWidth = (100 / data.columns.length) + '%';
	            }
	            if (!isPresent$5(column.options)) {
	                column.options = [];
	            }
	            column.options = column.options.map(function (inputOpt) {
	                var opt = {
	                    text: '',
	                    value: '',
	                    disabled: inputOpt.disabled,
	                };
	                if (isPresent$5(inputOpt)) {
	                    if (isString$5(inputOpt) || isNumber$5(inputOpt)) {
	                        opt.text = inputOpt.toString();
	                        opt.value = inputOpt;
	                    }
	                    else {
	                        opt.text = isPresent$5(inputOpt.text) ? inputOpt.text : inputOpt.value;
	                        opt.value = isPresent$5(inputOpt.value) ? inputOpt.value : inputOpt.text;
	                    }
	                }
	                return opt;
	            });
	            return column;
	        });
	    };
	    PickerCmp.prototype.refresh = function () {
	        this._cols.forEach(function (column) {
	            column.refresh();
	        });
	    };
	    PickerCmp.prototype._colChange = function (selectedOption) {
	        // one of the columns has changed its selected index
	        var picker = this._viewCtrl;
	        picker.ionChange.emit(this.getSelected());
	    };
	    PickerCmp.prototype._keyUp = function (ev) {
	        if (this.enabled && this._viewCtrl.isLast()) {
	            if (ev.keyCode === Key.ENTER) {
	                if (this.lastClick + 1000 < Date.now()) {
	                    // do not fire this click if there recently was already a click
	                    // this can happen when the button has focus and used the enter
	                    // key to click the button. However, both the click handler and
	                    // this keyup event will fire, so only allow one of them to go.
	                    console.debug('picker, enter button');
	                    var button = this.d.buttons[this.d.buttons.length - 1];
	                    this.btnClick(button);
	                }
	            }
	            else if (ev.keyCode === Key.ESCAPE) {
	                console.debug('picker, escape button');
	                this.bdClick();
	            }
	        }
	    };
	    PickerCmp.prototype.ionViewDidEnter = function () {
	        var activeElement = document.activeElement;
	        if (activeElement) {
	            activeElement.blur();
	        }
	        var focusableEle = this._elementRef.nativeElement.querySelector('button');
	        if (focusableEle) {
	            focusableEle.focus();
	        }
	        this.enabled = true;
	    };
	    PickerCmp.prototype.btnClick = function (button, dismissDelay) {
	        var _this = this;
	        if (!this.enabled) {
	            return;
	        }
	        // keep the time of the most recent button click
	        this.lastClick = Date.now();
	        var shouldDismiss = true;
	        if (button.handler) {
	            // a handler has been provided, execute it
	            // pass the handler the values from the inputs
	            if (button.handler(this.getSelected()) === false) {
	                // if the return value of the handler is false then do not dismiss
	                shouldDismiss = false;
	            }
	        }
	        if (shouldDismiss) {
	            setTimeout(function () {
	                _this.dismiss(button.role);
	            }, dismissDelay || this._config.get('pageTransitionDelay'));
	        }
	    };
	    PickerCmp.prototype.bdClick = function () {
	        if (this.enabled && this.d.enableBackdropDismiss) {
	            this.dismiss('backdrop');
	        }
	    };
	    PickerCmp.prototype.dismiss = function (role) {
	        return this._viewCtrl.dismiss(this.getSelected(), role);
	    };
	    PickerCmp.prototype.getSelected = function () {
	        var selected = {};
	        this.d.columns.forEach(function (col, index) {
	            var selectedColumn = col.options[col.selectedIndex];
	            selected[col.name] = {
	                text: selectedColumn ? selectedColumn.text : null,
	                value: selectedColumn ? selectedColumn.value : null,
	                columnIndex: index,
	            };
	        });
	        return selected;
	    };
	    /** @nocollapse */
	    PickerCmp.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-picker-cmp',
	                    template: "\n    <ion-backdrop (click)=\"bdClick()\"></ion-backdrop>\n    <div class=\"picker-wrapper\">\n      <div class=\"picker-toolbar\">\n        <div *ngFor=\"let b of d.buttons\" class=\"picker-toolbar-button\" [ngClass]=\"b.cssRole\">\n          <button (click)=\"btnClick(b)\" [ngClass]=\"b.cssClass\" class=\"picker-button\" clear>\n            {{b.text}}\n          </button>\n        </div>\n      </div>\n      <div class=\"picker-columns\">\n        <div class=\"picker-above-highlight\"></div>\n        <div *ngFor=\"let c of d.columns\" [col]=\"c\" class=\"picker-col\" (ionChange)=\"_colChange($event)\"></div>\n        <div class=\"picker-below-highlight\"></div>\n      </div>\n    </div>\n  ",
	                    directives: [Backdrop, NgClass, NgFor, PickerColumnCmp],
	                    host: {
	                        'role': 'dialog'
	                    },
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    PickerCmp.ctorParameters = [
	        { type: ViewController, },
	        { type: ElementRef, },
	        { type: Config, },
	        { type: NavParams, },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    PickerCmp.propDecorators = {
	        '_cols': [{ type: ViewChildren, args: [PickerColumnCmp,] },],
	        '_keyUp': [{ type: HostListener, args: ['body:keyup', ['$event'],] },],
	    };
	    return PickerCmp;
	}());
	/**
	 * Animations for pickers
	 */
	var PickerSlideIn = (function (_super) {
	    __extends$25(PickerSlideIn, _super);
	    function PickerSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.picker-wrapper'));
	        backdrop.fromTo('opacity', 0.01, 0.26);
	        wrapper.fromTo('translateY', '100%', '0%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(backdrop).add(wrapper);
	    }
	    return PickerSlideIn;
	}(Transition));
	Transition.register('picker-slide-in', PickerSlideIn);
	var PickerSlideOut = (function (_super) {
	    __extends$25(PickerSlideOut, _super);
	    function PickerSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.picker-wrapper'));
	        backdrop.fromTo('opacity', 0.26, 0);
	        wrapper.fromTo('translateY', '0%', '100%');
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(backdrop).add(wrapper);
	    }
	    return PickerSlideOut;
	}(Transition));
	Transition.register('picker-slide-out', PickerSlideOut);
	var pickerIds = -1;
	var DECELERATION_FRICTION$1 = 0.97;
	var FRAME_MS$1 = (1000 / 60);

	var __extends$24 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var Picker = (function (_super) {
	    __extends$24(Picker, _super);
	    function Picker(app, opts) {
	        if (opts === void 0) { opts = {}; }
	        opts.columns = opts.columns || [];
	        opts.buttons = opts.buttons || [];
	        opts.enableBackdropDismiss = isPresent$5(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
	        _super.call(this, PickerCmp, opts);
	        this._app = app;
	        this.isOverlay = true;
	        this.ionChange = new EventEmitter();
	        // by default, pickers should not fire lifecycle events of other views
	        // for example, when an picker enters, the current active view should
	        // not fire its lifecycle events because it's not conceptually leaving
	        this.fireOtherLifecycles = false;
	    }
	    /**
	    * @private
	    */
	    Picker.prototype.getTransitionName = function (direction) {
	        var key = (direction === 'back' ? 'pickerLeave' : 'pickerEnter');
	        return this._nav && this._nav.config.get(key);
	    };
	    /**
	     * @param {any} button Picker toolbar button
	     */
	    Picker.prototype.addButton = function (button) {
	        this.data.buttons.push(button);
	    };
	    /**
	     * @param {any} button Picker toolbar button
	     */
	    Picker.prototype.addColumn = function (column) {
	        this.data.columns.push(column);
	    };
	    Picker.prototype.getColumns = function () {
	        return this.data.columns;
	    };
	    Picker.prototype.refresh = function () {
	        this.instance.refresh && this.instance.refresh();
	    };
	    /**
	     * @param {string} cssClass CSS class name to add to the picker's outer wrapper.
	     */
	    Picker.prototype.setCssClass = function (cssClass) {
	        this.data.cssClass = cssClass;
	    };
	    /**
	     * Present the picker instance.
	     *
	     * @param {NavOptions} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    Picker.prototype.present = function (navOptions) {
	        if (navOptions === void 0) { navOptions = {}; }
	        return this._app.present(this, navOptions);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please inject PickerController instead
	     */
	    Picker.create = function (opt) {
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('Picker.create(..) has been deprecated. Please inject PickerController instead');
	    };
	    /** @nocollapse */
	    Picker.propDecorators = {
	        'ionChange': [{ type: Output },],
	    };
	    return Picker;
	}(ViewController));
	var PickerController = (function () {
	    function PickerController(_app) {
	        this._app = _app;
	    }
	    /**
	     * Open a picker.
	     */
	    PickerController.prototype.create = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        return new Picker(this._app, opts);
	    };
	    /** @nocollapse */
	    PickerController.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    PickerController.ctorParameters = [
	        { type: App, },
	    ];
	    return PickerController;
	}());

	var DATETIME_VALUE_ACCESSOR = new Provider(NG_VALUE_ACCESSOR$1, { useExisting: forwardRef(function () { return DateTime; }), multi: true });
	var DateTime = (function () {
	    function DateTime(_form, _config, _item, _pickerCtrl) {
	        this._form = _form;
	        this._config = _config;
	        this._item = _item;
	        this._pickerCtrl = _pickerCtrl;
	        this._disabled = false;
	        this._text = '';
	        this._isOpen = false;
	        this._value = {};
	        this._locale = {};
	        this.displayFormat = 'MMM D, YYYY';
	        this.cancelText = 'Cancel';
	        this.doneText = 'Done';
	        this.pickerOptions = {};
	        this.ionChange = new EventEmitter();
	        this.ionCancel = new EventEmitter();
	        this._form.register(this);
	        if (_item) {
	            this.id = 'dt-' + _item.registerInput('datetime');
	            this._labelId = 'lbl-' + _item.id;
	            this._item.setCssClass('item-datetime', true);
	        }
	    }
	    DateTime.prototype._click = function (ev) {
	        if (ev.detail === 0) {
	            // do not continue if the click event came from a form submit
	            return;
	        }
	        ev.preventDefault();
	        ev.stopPropagation();
	        this.open();
	    };
	    DateTime.prototype._keyup = function () {
	        if (!this._isOpen) {
	            this.open();
	        }
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.open = function () {
	        var _this = this;
	        if (this._disabled) {
	            return;
	        }
	        console.debug('datetime, open picker');
	        // the user may have assigned some options specifically for the alert
	        var pickerOptions = merge$1({}, this.pickerOptions);
	        var picker = this._pickerCtrl.create(pickerOptions);
	        pickerOptions.buttons = [
	            {
	                text: this.cancelText,
	                role: 'cancel',
	                handler: function () {
	                    _this.ionCancel.emit(null);
	                }
	            },
	            {
	                text: this.doneText,
	                handler: function (data) {
	                    console.log('datetime, done', data);
	                    _this.onChange(data);
	                    _this.ionChange.emit(data);
	                }
	            }
	        ];
	        this.generate(picker);
	        this.validate(picker);
	        picker.ionChange.subscribe(function () {
	            _this.validate(picker);
	        });
	        picker.present(pickerOptions);
	        this._isOpen = true;
	        picker.onDidDismiss(function () {
	            _this._isOpen = false;
	        });
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.generate = function (picker) {
	        var _this = this;
	        // if a picker format wasn't provided, then fallback
	        // to use the display format
	        var template = this.pickerFormat || this.displayFormat;
	        if (isPresent$5(template)) {
	            // make sure we've got up to date sizing information
	            this.calcMinMax();
	            // does not support selecting by day name
	            // automaticallly remove any day name formats
	            template = template.replace('DDDD', '{~}').replace('DDD', '{~}');
	            if (template.indexOf('D') === -1) {
	                // there is not a day in the template
	                // replace the day name with a numeric one if it exists
	                template = template.replace('{~}', 'D');
	            }
	            // make sure no day name replacer is left in the string
	            template = template.replace(/{~}/g, '');
	            // parse apart the given template into an array of "formats"
	            parseTemplate(template).forEach(function (format) {
	                // loop through each format in the template
	                // create a new picker column to build up with data
	                var key = convertFormatToKey(format);
	                var values;
	                // first see if they have exact values to use for this input
	                if (isPresent$5(_this[key + 'Values'])) {
	                    // user provide exact values for this date part
	                    values = convertToArrayOfNumbers(_this[key + 'Values'], key);
	                }
	                else {
	                    // use the default date part values
	                    values = dateValueRange(format, _this._min, _this._max);
	                }
	                var column = {
	                    name: key,
	                    options: values.map(function (val) {
	                        return {
	                            value: val,
	                            text: renderTextFormat(format, val, null, _this._locale),
	                        };
	                    })
	                };
	                if (column.options.length) {
	                    // cool, we've loaded up the columns with options
	                    // preselect the option for this column
	                    var selected = column.options.find(function (opt) { return opt.value === getValueFromFormat(_this._value, format); });
	                    if (selected) {
	                        // set the select index for this column's options
	                        column.selectedIndex = column.options.indexOf(selected);
	                    }
	                    // add our newly created column to the picker
	                    picker.addColumn(column);
	                }
	            });
	            this.divyColumns(picker);
	        }
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.validate = function (picker) {
	        var i;
	        var today = new Date();
	        var columns = picker.getColumns();
	        // find the columns used
	        var yearCol = columns.find(function (col) { return col.name === 'year'; });
	        var monthCol = columns.find(function (col) { return col.name === 'month'; });
	        var dayCol = columns.find(function (col) { return col.name === 'day'; });
	        var yearOpt;
	        var monthOpt;
	        var dayOpt;
	        // default to assuming today's year
	        var selectedYear = today.getFullYear();
	        if (yearCol) {
	            yearOpt = yearCol.options[yearCol.selectedIndex];
	            if (yearOpt) {
	                // they have a selected year value
	                selectedYear = yearOpt.value;
	            }
	        }
	        // default to assuming this month has 31 days
	        var numDaysInMonth = 31;
	        var selectedMonth;
	        if (monthCol) {
	            monthOpt = monthCol.options[monthCol.selectedIndex];
	            if (monthOpt) {
	                // they have a selected month value
	                selectedMonth = monthOpt.value;
	                // calculate how many days are in this month
	                numDaysInMonth = daysInMonth(selectedMonth, selectedYear);
	            }
	        }
	        // create sort values for the min/max datetimes
	        var minCompareVal = dateDataSortValue(this._min);
	        var maxCompareVal = dateDataSortValue(this._max);
	        if (monthCol) {
	            // enable/disable which months are valid
	            // to show within the min/max date range
	            for (i = 0; i < monthCol.options.length; i++) {
	                monthOpt = monthCol.options[i];
	                // loop through each month and see if it
	                // is within the min/max date range
	                monthOpt.disabled = (dateSortValue(selectedYear, monthOpt.value, 31) < minCompareVal ||
	                    dateSortValue(selectedYear, monthOpt.value, 1) > maxCompareVal);
	            }
	        }
	        if (dayCol) {
	            if (isPresent$5(selectedMonth)) {
	                // enable/disable which days are valid
	                // to show within the min/max date range
	                for (i = 0; i < 31; i++) {
	                    dayOpt = dayCol.options[i];
	                    // loop through each day and see if it
	                    // is within the min/max date range
	                    var compareVal = dateSortValue(selectedYear, selectedMonth, dayOpt.value);
	                    dayOpt.disabled = (compareVal < minCompareVal ||
	                        compareVal > maxCompareVal ||
	                        numDaysInMonth <= i);
	                }
	            }
	            else {
	                // enable/disable which numbers of days to show in this month
	                for (i = 0; i < 31; i++) {
	                    dayCol.options[i].disabled = (numDaysInMonth <= i);
	                }
	            }
	        }
	        picker.refresh();
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.divyColumns = function (picker) {
	        var pickerColumns = picker.getColumns();
	        var columns = [];
	        pickerColumns.forEach(function (col, i) {
	            columns.push(0);
	            col.options.forEach(function (opt) {
	                if (opt.text.length > columns[i]) {
	                    columns[i] = opt.text.length;
	                }
	            });
	        });
	        if (columns.length === 2) {
	            var width = Math.max(columns[0], columns[1]);
	            pickerColumns[0].columnWidth = pickerColumns[1].columnWidth = width * 16 + "px";
	        }
	        else if (columns.length === 3) {
	            var width = Math.max(columns[0], columns[2]);
	            pickerColumns[1].columnWidth = columns[1] * 16 + "px";
	            pickerColumns[0].columnWidth = pickerColumns[2].columnWidth = width * 16 + "px";
	        }
	        else if (columns.length > 3) {
	            columns.forEach(function (col, i) {
	                pickerColumns[i].columnWidth = col * 12 + "px";
	            });
	        }
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.setValue = function (newData) {
	        updateDate(this._value, newData);
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.getValue = function () {
	        return this._value;
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.checkHasValue = function (inputValue) {
	        if (this._item) {
	            this._item.setCssClass('input-has-value', !!(inputValue && inputValue !== ''));
	        }
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.updateText = function () {
	        // create the text of the formatted data
	        this._text = renderDateTime(this.displayFormat, this._value, this._locale);
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.calcMinMax = function () {
	        var todaysYear = new Date().getFullYear();
	        if (isBlank$5(this.min)) {
	            if (isPresent$5(this.yearValues)) {
	                this.min = Math.min.apply(Math, convertToArrayOfNumbers(this.yearValues, 'year'));
	            }
	            else {
	                this.min = (todaysYear - 100).toString();
	            }
	        }
	        if (isBlank$5(this.max)) {
	            if (isPresent$5(this.yearValues)) {
	                this.max = Math.max.apply(Math, convertToArrayOfNumbers(this.yearValues, 'year'));
	            }
	            else {
	                this.max = todaysYear.toString();
	            }
	        }
	        var min = this._min = parseDate(this.min);
	        var max = this._max = parseDate(this.max);
	        min.month = min.month || 1;
	        min.day = min.day || 1;
	        min.hour = min.hour || 0;
	        min.minute = min.minute || 0;
	        min.second = min.second || 0;
	        max.month = max.month || 12;
	        max.day = max.day || 31;
	        max.hour = max.hour || 23;
	        max.minute = max.minute || 59;
	        max.second = max.second || 59;
	    };
	    Object.defineProperty(DateTime.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this._item && this._item.setCssClass('item-datetime-disabled', this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    DateTime.prototype.writeValue = function (val) {
	        console.debug('datetime, writeValue', val);
	        this.setValue(val);
	        this.updateText();
	        this.checkHasValue(val);
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        // first see if locale names were provided in the inputs
	        // then check to see if they're in the config
	        // if neither were provided then it will use default English names
	        ['monthNames', 'monthShortNames', 'dayNames', 'dayShortNames'].forEach(function (type) {
	            _this._locale[type] = convertToArrayOfStrings(isPresent$5(_this[type]) ? _this[type] : _this._config.get(type), type);
	        });
	        // update how the datetime value is displayed as formatted text
	        this.updateText();
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this._fn = fn;
	        this.onChange = function (val) {
	            console.debug('datetime, onChange', val);
	            _this.setValue(val);
	            _this.updateText();
	            _this.checkHasValue(val);
	            // convert DateTimeData value to iso datetime format
	            fn(convertDataToISO(_this._value));
	            _this.onTouched();
	        };
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /**
	     * @private
	     */
	    DateTime.prototype.onChange = function (val) {
	        // onChange used when there is not an formControlName
	        console.debug('datetime, onChange w/out formControlName', val);
	        this.setValue(val);
	        this.updateText();
	        this.onTouched();
	    };
	    /**
	     * @private
	     */
	    DateTime.prototype.onTouched = function () { };
	    /**
	     * @private
	     */
	    DateTime.prototype.ngOnDestroy = function () {
	        this._form.deregister(this);
	    };
	    /** @nocollapse */
	    DateTime.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-datetime',
	                    template: "\n    <div class=\"datetime-text\">{{_text}}</div>\n    <button aria-haspopup=\"true\"\n            type=\"button\"\n            [id]=\"id\"\n            category=\"item-cover\"\n            [attr.aria-labelledby]=\"_labelId\"\n            [attr.aria-disabled]=\"_disabled\"\n            class=\"item-cover\">\n    </button>\n  ",
	                    host: {
	                        '[class.datetime-disabled]': '_disabled'
	                    },
	                    providers: [DATETIME_VALUE_ACCESSOR],
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    DateTime.ctorParameters = [
	        { type: Form, },
	        { type: Config, },
	        { type: Item, decorators: [{ type: Optional },] },
	        { type: PickerController, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    DateTime.propDecorators = {
	        'min': [{ type: Input },],
	        'max': [{ type: Input },],
	        'displayFormat': [{ type: Input },],
	        'pickerFormat': [{ type: Input },],
	        'cancelText': [{ type: Input },],
	        'doneText': [{ type: Input },],
	        'yearValues': [{ type: Input },],
	        'monthValues': [{ type: Input },],
	        'dayValues': [{ type: Input },],
	        'hourValues': [{ type: Input },],
	        'minuteValues': [{ type: Input },],
	        'monthNames': [{ type: Input },],
	        'monthShortNames': [{ type: Input },],
	        'dayNames': [{ type: Input },],
	        'dayShortNames': [{ type: Input },],
	        'pickerOptions': [{ type: Input },],
	        'ionChange': [{ type: Output },],
	        'ionCancel': [{ type: Output },],
	        '_click': [{ type: HostListener, args: ['click', ['$event'],] },],
	        '_keyup': [{ type: HostListener, args: ['keyup.space',] },],
	        'disabled': [{ type: Input },],
	    };
	    return DateTime;
	}());
	/**
	 * @private
	 * Use to convert a string of comma separated numbers or
	 * an array of numbers, and clean up any user input
	 */
	function convertToArrayOfNumbers(input, type) {
	    var values = [];
	    if (isString$5(input)) {
	        // convert the string to an array of strings
	        // auto remove any whitespace and [] characters
	        input = input.replace(/\[|\]|\s/g, '').split(',');
	    }
	    if (isArray$6(input)) {
	        // ensure each value is an actual number in the returned array
	        input.forEach(function (num) {
	            num = parseInt(num, 10);
	            if (!isNaN(num)) {
	                values.push(num);
	            }
	        });
	    }
	    if (!values.length) {
	        console.warn("Invalid \"" + type + "Values\". Must be an array of numbers, or a comma separated string of numbers.");
	    }
	    return values;
	}
	/**
	 * @private
	 * Use to convert a string of comma separated strings or
	 * an array of strings, and clean up any user input
	 */
	function convertToArrayOfStrings(input, type) {
	    if (isPresent$5(input)) {
	        var values = [];
	        if (isString$5(input)) {
	            // convert the string to an array of strings
	            // auto remove any [] characters
	            input = input.replace(/\[|\]/g, '').split(',');
	        }
	        if (isArray$6(input)) {
	            // trim up each string value
	            input.forEach(function (val) {
	                val = val.trim();
	                if (val) {
	                    values.push(val);
	                }
	            });
	        }
	        if (!values.length) {
	            console.warn("Invalid \"" + type + "Names\". Must be an array of strings, or a comma separated string.");
	        }
	        return values;
	    }
	}

	var TOGGLE_VALUE_ACCESSOR = new Provider(NG_VALUE_ACCESSOR$1, { useExisting: forwardRef(function () { return Toggle; }), multi: true });
	var Toggle = (function () {
	    function Toggle(_form, _elementRef, _renderer, _item) {
	        this._form = _form;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._item = _item;
	        this._checked = false;
	        this._disabled = false;
	        this._activated = false;
	        this._msPrv = 0;
	        this._events = new UIEventManager();
	        this.ionChange = new EventEmitter();
	        this._form.register(this);
	        if (_item) {
	            this.id = 'tgl-' + _item.registerInput('toggle');
	            this._labelId = 'lbl-' + _item.id;
	            this._item.setCssClass('item-toggle', true);
	        }
	    }
	    /**
	     * @private
	     */
	    Toggle.prototype.pointerDown = function (ev) {
	        this._startX = pointerCoord(ev).x;
	        this._activated = true;
	        return true;
	    };
	    /**
	     * @private
	     */
	    Toggle.prototype.pointerMove = function (ev) {
	        if (this._startX) {
	            var currentX = pointerCoord(ev).x;
	            console.debug('toggle, pointerMove', ev.type, currentX);
	            if (this._checked) {
	                if (currentX + 15 < this._startX) {
	                    this.onChange(false);
	                    this._startX = currentX;
	                    this._activated = true;
	                }
	            }
	            else if (currentX - 15 > this._startX) {
	                this.onChange(true);
	                this._startX = currentX;
	                this._activated = (currentX < this._startX + 5);
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Toggle.prototype.pointerUp = function (ev) {
	        if (this._startX) {
	            var endX = pointerCoord(ev).x;
	            if (this.checked) {
	                if (this._startX + 4 > endX) {
	                    this.onChange(false);
	                }
	            }
	            else if (this._startX - 4 < endX) {
	                this.onChange(true);
	            }
	            this._activated = false;
	            this._startX = null;
	        }
	    };
	    Object.defineProperty(Toggle.prototype, "checked", {
	        get: function () {
	            return this._checked;
	        },
	        set: function (val) {
	            this._setChecked(isTrueProperty(val));
	            this.onChange(this._checked);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Toggle.prototype._setChecked = function (isChecked) {
	        if (isChecked !== this._checked) {
	            this._checked = isChecked;
	            if (this._init) {
	                this.ionChange.emit(this);
	            }
	            this._item && this._item.setCssClass('item-toggle-checked', isChecked);
	        }
	    };
	    /**
	     * @private
	     */
	    Toggle.prototype.writeValue = function (val) {
	        this._setChecked(isTrueProperty(val));
	    };
	    /**
	     * @private
	     */
	    Toggle.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this._fn = fn;
	        this.onChange = function (isChecked) {
	            console.debug('toggle, onChange', isChecked);
	            fn(isChecked);
	            _this._setChecked(isChecked);
	            _this.onTouched();
	        };
	    };
	    /**
	     * @private
	     */
	    Toggle.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    Object.defineProperty(Toggle.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this._item && this._item.setCssClass('item-toggle-disabled', this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Toggle.prototype.onChange = function (isChecked) {
	        // used when this input does not have an ngModel or formControlName
	        console.debug('toggle, onChange (no ngModel)', isChecked);
	        this._setChecked(isChecked);
	        this.onTouched();
	    };
	    /**
	     * @private
	     */
	    Toggle.prototype.onTouched = function () { };
	    /**
	     * @private
	     */
	    Toggle.prototype.ngAfterContentInit = function () {
	        var _this = this;
	        this._init = true;
	        this._events.pointerEventsRef(this._elementRef, function (ev) { return _this.pointerDown(ev); }, function (ev) { return _this.pointerMove(ev); }, function (ev) { return _this.pointerUp(ev); });
	    };
	    /**
	     * @private
	     */
	    Toggle.prototype.ngOnDestroy = function () {
	        this._form.deregister(this);
	        this._events.unlistenAll();
	    };
	    /** @nocollapse */
	    Toggle.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-toggle',
	                    template: "\n    <div class=\"toggle-icon\" [class.toggle-checked]=\"_checked\" [class.toggle-activated]=\"_activated\">\n      <div class=\"toggle-inner\"></div>\n    </div>\n    <button role=\"checkbox\"\n            type=\"button\"\n            category=\"item-cover\"\n            [id]=\"id\"\n            [attr.aria-checked]=\"_checked\"\n            [attr.aria-labelledby]=\"_labelId\"\n            [attr.aria-disabled]=\"_disabled\"\n            class=\"item-cover\">\n    </button>\n  ",
	                    host: {
	                        '[class.toggle-disabled]': '_disabled'
	                    },
	                    providers: [TOGGLE_VALUE_ACCESSOR],
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Toggle.ctorParameters = [
	        { type: Form, },
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: Item, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    Toggle.propDecorators = {
	        'ionChange': [{ type: Output },],
	        'checked': [{ type: Input },],
	        'disabled': [{ type: Input },],
	    };
	    return Toggle;
	}());

	var NativeInput = (function () {
	    function NativeInput(_elementRef, _renderer, config, ngControl) {
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this.ngControl = ngControl;
	        this.focusChange = new EventEmitter();
	        this.valueChange = new EventEmitter();
	        this._clone = config.getBoolean('inputCloning', false);
	        this._blurring = config.getBoolean('inputBlurring', false);
	    }
	    NativeInput.prototype._change = function (ev) {
	        this.valueChange.emit(ev.target.value);
	    };
	    NativeInput.prototype._focus = function () {
	        var self = this;
	        self.focusChange.emit(true);
	        function docTouchEnd(ev) {
	            var tapped = ev.target;
	            if (tapped && self.element()) {
	                if (tapped.tagName !== 'INPUT' && tapped.tagName !== 'TEXTAREA' && !tapped.classList.contains('input-cover')) {
	                    self.element().blur();
	                }
	            }
	        }
	        if (self._blurring) {
	            // automatically blur input if:
	            // 1) this input has focus
	            // 2) the newly tapped document element is not an input
	            console.debug('input blurring enabled');
	            document.addEventListener('touchend', docTouchEnd, true);
	            self._unrefBlur = function () {
	                console.debug('input blurring disabled');
	                document.removeEventListener('touchend', docTouchEnd, true);
	            };
	        }
	    };
	    NativeInput.prototype._blur = function () {
	        this.focusChange.emit(false);
	        this.hideFocus(false);
	        this._unrefBlur && this._unrefBlur();
	        this._unrefBlur = null;
	    };
	    NativeInput.prototype.labelledBy = function (val) {
	        this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-labelledby', val);
	    };
	    NativeInput.prototype.isDisabled = function (val) {
	        this._renderer.setElementAttribute(this._elementRef.nativeElement, 'disabled', val ? '' : null);
	    };
	    NativeInput.prototype.setFocus = function () {
	        // let's set focus to the element
	        // but only if it does not already have focus
	        if (document.activeElement !== this.element()) {
	            this.element().focus();
	        }
	    };
	    NativeInput.prototype.beginFocus = function (shouldFocus, inputRelativeY) {
	        if (this._relocated !== shouldFocus) {
	            var focusedInputEle = this.element();
	            if (shouldFocus) {
	                // we should focus into this element
	                if (this._clone) {
	                    // this platform needs the input to be cloned
	                    // this allows for the actual input to receive the focus from
	                    // the user's touch event, but before it receives focus, it
	                    // moves the actual input to a location that will not screw
	                    // up the app's layout, and does not allow the native browser
	                    // to attempt to scroll the input into place (messing up headers/footers)
	                    // the cloned input fills the area of where native input should be
	                    // while the native input fakes out the browser by relocating itself
	                    // before it receives the actual focus event
	                    var clonedInputEle = cloneInput(focusedInputEle, 'cloned-focus');
	                    focusedInputEle.parentNode.insertBefore(clonedInputEle, focusedInputEle);
	                    // move the native input to a location safe to receive focus
	                    // according to the browser, the native input receives focus in an
	                    // area which doesn't require the browser to scroll the input into place
	                    focusedInputEle.style[CSS.transform] = "translate3d(-9999px," + inputRelativeY + "px,0)";
	                    focusedInputEle.style.opacity = '0';
	                }
	                // let's now set focus to the actual native element
	                // at this point it is safe to assume the browser will not attempt
	                // to scroll the input into view itself (screwing up headers/footers)
	                this.setFocus();
	                if (this._clone) {
	                    focusedInputEle.classList.add('cloned-active');
	                }
	            }
	            else {
	                // should remove the focus
	                if (this._clone) {
	                    // should remove the cloned node
	                    focusedInputEle.classList.remove('cloned-active');
	                    focusedInputEle.style[CSS.transform] = '';
	                    focusedInputEle.style.opacity = '';
	                    removeClone(focusedInputEle, 'cloned-focus');
	                }
	            }
	            this._relocated = shouldFocus;
	        }
	    };
	    NativeInput.prototype.hideFocus = function (shouldHideFocus) {
	        var focusedInputEle = this.element();
	        console.debug("native input hideFocus, shouldHideFocus: " + shouldHideFocus + ", input value: " + focusedInputEle.value);
	        if (shouldHideFocus) {
	            var clonedInputEle = cloneInput(focusedInputEle, 'cloned-move');
	            focusedInputEle.classList.add('cloned-active');
	            focusedInputEle.parentNode.insertBefore(clonedInputEle, focusedInputEle);
	        }
	        else {
	            focusedInputEle.classList.remove('cloned-active');
	            removeClone(focusedInputEle, 'cloned-move');
	        }
	    };
	    NativeInput.prototype.hasFocus = function () {
	        return hasFocus(this.element());
	    };
	    NativeInput.prototype.getValue = function () {
	        return this.element().value;
	    };
	    NativeInput.prototype.setCssClass = function (cssClass, shouldAdd) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, shouldAdd);
	    };
	    NativeInput.prototype.element = function () {
	        return this._elementRef.nativeElement;
	    };
	    NativeInput.prototype.ngOnDestroy = function () {
	        this._unrefBlur && this._unrefBlur();
	    };
	    /** @nocollapse */
	    NativeInput.decorators = [
	        { type: Directive, args: [{
	                    selector: '.text-input'
	                },] },
	    ];
	    /** @nocollapse */
	    NativeInput.ctorParameters = [
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: Config, },
	        { type: NgControl$1, },
	    ];
	    /** @nocollapse */
	    NativeInput.propDecorators = {
	        'focusChange': [{ type: Output },],
	        'valueChange': [{ type: Output },],
	        '_change': [{ type: HostListener, args: ['input', ['$event'],] },],
	        '_focus': [{ type: HostListener, args: ['focus',] },],
	        '_blur': [{ type: HostListener, args: ['blur',] },],
	    };
	    return NativeInput;
	}());
	function cloneInput(focusedInputEle, addCssClass) {
	    var clonedInputEle = focusedInputEle.cloneNode(true);
	    clonedInputEle.classList.add('cloned-input');
	    clonedInputEle.classList.add(addCssClass);
	    clonedInputEle.setAttribute('aria-hidden', true);
	    clonedInputEle.removeAttribute('aria-labelledby');
	    clonedInputEle.tabIndex = -1;
	    clonedInputEle.style.width = (focusedInputEle.offsetWidth + 10) + 'px';
	    clonedInputEle.style.height = focusedInputEle.offsetHeight + 'px';
	    clonedInputEle.value = focusedInputEle.value;
	    return clonedInputEle;
	}
	function removeClone(focusedInputEle, queryCssClass) {
	    var clonedInputEle = focusedInputEle.parentElement.querySelector('.' + queryCssClass);
	    if (clonedInputEle) {
	        clonedInputEle.parentNode.removeChild(clonedInputEle);
	    }
	}
	var NextInput = (function () {
	    function NextInput() {
	        this.focused = new EventEmitter();
	    }
	    NextInput.prototype.receivedFocus = function () {
	        console.debug('native-input, next-input received focus');
	        this.focused.emit(true);
	    };
	    /** @nocollapse */
	    NextInput.decorators = [
	        { type: Directive, args: [{
	                    selector: '[next-input]'
	                },] },
	    ];
	    /** @nocollapse */
	    NextInput.propDecorators = {
	        'focused': [{ type: Output },],
	        'receivedFocus': [{ type: HostListener, args: ['focus',] },],
	    };
	    return NextInput;
	}());

	var InputBase = (function () {
	    function InputBase(config, _form, _item, _app, _platform, _elementRef, _scrollView, _nav, ngControl) {
	        this._form = _form;
	        this._item = _item;
	        this._app = _app;
	        this._platform = _platform;
	        this._elementRef = _elementRef;
	        this._scrollView = _scrollView;
	        this._nav = _nav;
	        this._disabled = false;
	        this._type = 'text';
	        this._value = '';
	        this.placeholder = '';
	        this.blur = new EventEmitter();
	        this.focus = new EventEmitter();
	        this._useAssist = config.getBoolean('scrollAssist', false);
	        this._usePadding = config.getBoolean('scrollPadding', this._useAssist);
	        this._keyboardHeight = config.getNumber('keyboardHeight');
	        this._autoFocusAssist = config.get('autoFocusAssist', 'delay');
	        this._autoComplete = config.get('autocomplete', 'off');
	        this._autoCorrect = config.get('autocorrect', 'off');
	        if (ngControl) {
	            ngControl.valueAccessor = this;
	            this.inputControl = ngControl;
	        }
	        _form.register(this);
	    }
	    InputBase.prototype.ngOnInit = function () {
	        if (this._item) {
	            this._item.setCssClass('item-input', true);
	            this._item.registerInput(this._type);
	        }
	        var clearInput = this.clearInput;
	        if (typeof clearInput === 'string') {
	            this.clearInput = (clearInput === '' || clearInput === 'true');
	        }
	    };
	    InputBase.prototype.ngAfterContentInit = function () {
	        var self = this;
	        self._scrollMove = function (ev) {
	            // scroll move event listener this instance can reuse
	            if (!(self._nav && self._nav.isTransitioning())) {
	                self.deregScrollMove();
	                if (self.hasFocus()) {
	                    self._native.hideFocus(true);
	                    self._scrollView.onScrollEnd(function () {
	                        self._native.hideFocus(false);
	                        if (self.hasFocus()) {
	                            // if it still has focus then keep listening
	                            self.regScrollMove();
	                        }
	                    });
	                }
	            }
	        };
	        this.setItemInputControlCss();
	    };
	    InputBase.prototype.ngAfterContentChecked = function () {
	        this.setItemInputControlCss();
	    };
	    InputBase.prototype.setItemInputControlCss = function () {
	        var item = this._item;
	        var nativeInput = this._native;
	        var inputControl = this.inputControl;
	        // Set the control classes on the item
	        if (item && inputControl) {
	            this.setControlCss(item, inputControl);
	        }
	        // Set the control classes on the native input
	        if (nativeInput && inputControl) {
	            this.setControlCss(nativeInput, inputControl);
	        }
	    };
	    InputBase.prototype.setControlCss = function (element, control) {
	        element.setCssClass('ng-untouched', control.untouched);
	        element.setCssClass('ng-touched', control.touched);
	        element.setCssClass('ng-pristine', control.pristine);
	        element.setCssClass('ng-dirty', control.dirty);
	        element.setCssClass('ng-valid', control.valid);
	        element.setCssClass('ng-invalid', !control.valid);
	    };
	    InputBase.prototype.ngOnDestroy = function () {
	        this._form.deregister(this);
	    };
	    Object.defineProperty(InputBase.prototype, "value", {
	        get: function () {
	            return this._value;
	        },
	        set: function (val) {
	            this._value = val;
	            this.checkHasValue(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InputBase.prototype, "type", {
	        get: function () {
	            return this._type;
	        },
	        set: function (val) {
	            this._type = 'text';
	            if (val) {
	                val = val.toLowerCase();
	                if (/password|email|number|search|tel|url|date|month|time|week/.test(val)) {
	                    this._type = val;
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InputBase.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this._item && this._item.setCssClass('item-input-disabled', this._disabled);
	            this._native && this._native.isDisabled(this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InputBase.prototype, "_nativeInput", {
	        set: function (nativeInput) {
	            var _this = this;
	            this._native = nativeInput;
	            if (this._item && this._item.labelId !== null) {
	                nativeInput.labelledBy(this._item.labelId);
	            }
	            nativeInput.valueChange.subscribe(function (inputValue) {
	                _this.onChange(inputValue);
	            });
	            this.focusChange(this.hasFocus());
	            nativeInput.focusChange.subscribe(function (textInputHasFocus) {
	                _this.focusChange(textInputHasFocus);
	                _this.checkHasValue(nativeInput.getValue());
	                if (!textInputHasFocus) {
	                    _this.onTouched(textInputHasFocus);
	                }
	            });
	            this.checkHasValue(nativeInput.getValue());
	            this.disabled = this._disabled;
	            var ionInputEle = this._elementRef.nativeElement;
	            var nativeInputEle = nativeInput.element();
	            // copy ion-input attributes to the native input element
	            copyInputAttributes(ionInputEle, nativeInputEle);
	            if (ionInputEle.hasAttribute('autofocus')) {
	                // the ion-input element has the autofocus attributes
	                ionInputEle.removeAttribute('autofocus');
	                if (this._autoFocusAssist === 'immediate') {
	                    // config says to immediate focus on the input
	                    // works best on android devices
	                    nativeInputEle.focus();
	                }
	                else if (this._autoFocusAssist === 'delay') {
	                    // config says to chill out a bit and focus on the input after transitions
	                    // works best on desktop
	                    setTimeout(function () {
	                        nativeInputEle.focus();
	                    }, 650);
	                }
	            }
	            // by default set autocomplete="off" unless specified by the input
	            if (ionInputEle.hasAttribute('autocomplete')) {
	                this._autoComplete = ionInputEle.getAttribute('autocomplete');
	            }
	            nativeInputEle.setAttribute('autocomplete', this._autoComplete);
	            // by default set autocorrect="off" unless specified by the input
	            if (ionInputEle.hasAttribute('autocorrect')) {
	                this._autoCorrect = ionInputEle.getAttribute('autocorrect');
	            }
	            nativeInputEle.setAttribute('autocorrect', this._autoCorrect);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InputBase.prototype, "_nextInput", {
	        set: function (nextInput) {
	            var _this = this;
	            if (nextInput) {
	                nextInput.focused.subscribe(function () {
	                    _this._form.tabFocus(_this);
	                });
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * Angular2 Forms API method called by the model (Control) on change to update
	     * the checked value.
	     * https://github.com/angular/angular/blob/master/modules/angular2/src/forms/directives/shared.ts#L34
	     */
	    InputBase.prototype.writeValue = function (val) {
	        this._value = val;
	        this.checkHasValue(val);
	    };
	    /**
	     * @private
	     */
	    InputBase.prototype.onChange = function (val) {
	        this.checkHasValue(val);
	    };
	    /**
	     * @private
	     */
	    InputBase.prototype.onTouched = function (val) { };
	    /**
	     * @private
	     */
	    InputBase.prototype.hasFocus = function () {
	        // check if an input has focus or not
	        return this._native.hasFocus();
	    };
	    /**
	     * @private
	     */
	    InputBase.prototype.checkHasValue = function (inputValue) {
	        if (this._item) {
	            this._item.setCssClass('input-has-value', !!(inputValue && inputValue !== ''));
	        }
	    };
	    /**
	     * @private
	     */
	    InputBase.prototype.focusChange = function (inputHasFocus) {
	        if (this._item) {
	            this._item.setCssClass('input-has-focus', inputHasFocus);
	        }
	        if (!inputHasFocus) {
	            this.deregScrollMove();
	        }
	    };
	    InputBase.prototype.pointerStart = function (ev) {
	        // input cover touchstart
	        console.debug('scroll assist pointerStart', ev.type);
	        if (ev.type === 'touchstart') {
	            this._isTouch = true;
	        }
	        if ((this._isTouch || (!this._isTouch && ev.type === 'mousedown')) && this._app.isEnabled()) {
	            // remember where the touchstart/mousedown started
	            this._coord = pointerCoord(ev);
	        }
	    };
	    InputBase.prototype.pointerEnd = function (ev) {
	        // input cover touchend/mouseup
	        console.debug('scroll assist pointerEnd', ev.type);
	        if ((this._isTouch && ev.type === 'mouseup') || !this._app.isEnabled()) {
	            // the app is actively doing something right now
	            // don't try to scroll in the input
	            ev.preventDefault();
	            ev.stopPropagation();
	        }
	        else if (this._coord) {
	            // get where the touchend/mouseup ended
	            var endCoord = pointerCoord(ev);
	            // focus this input if the pointer hasn't moved XX pixels
	            // and the input doesn't already have focus
	            if (!hasPointerMoved(8, this._coord, endCoord) && !this.hasFocus()) {
	                ev.preventDefault();
	                ev.stopPropagation();
	                // begin the input focus process
	                console.debug('initFocus', ev.type);
	                this.initFocus();
	            }
	        }
	        this._coord = null;
	    };
	    /**
	     * @private
	     */
	    InputBase.prototype.initFocus = function () {
	        var _this = this;
	        // begin the process of setting focus to the inner input element
	        var scrollView = this._scrollView;
	        if (scrollView) {
	            // this input is inside of a scroll view
	            // find out if text input should be manually scrolled into view
	            // get container of this input, probably an ion-item a few nodes up
	            var ele = this._elementRef.nativeElement;
	            ele = closest(ele, 'ion-item,[ion-item]') || ele;
	            var scrollData = InputBase.getScrollData(ele.offsetTop, ele.offsetHeight, scrollView.getContentDimensions(), this._keyboardHeight, this._platform.height());
	            if (scrollData.scrollAmount > -3 && scrollData.scrollAmount < 3) {
	                // the text input is in a safe position that doesn't
	                // require it to be scrolled into view, just set focus now
	                this.setFocus();
	                this.regScrollMove();
	                return;
	            }
	            if (this._usePadding) {
	                // add padding to the bottom of the scroll view (if needed)
	                scrollView.addScrollPadding(scrollData.scrollPadding);
	            }
	            // manually scroll the text input to the top
	            // do not allow any clicks while it's scrolling
	            var scrollDuration = getScrollAssistDuration(scrollData.scrollAmount);
	            this._app.setEnabled(false, scrollDuration);
	            this._nav && this._nav.setTransitioning(true, scrollDuration);
	            // temporarily move the focus to the focus holder so the browser
	            // doesn't freak out while it's trying to get the input in place
	            // at this point the native text input still does not have focus
	            this._native.beginFocus(true, scrollData.inputSafeY);
	            // scroll the input into place
	            scrollView.scrollTo(0, scrollData.scrollTo, scrollDuration).then(function () {
	                // the scroll view is in the correct position now
	                // give the native text input focus
	                _this._native.beginFocus(false, 0);
	                // ensure this is the focused input
	                _this.setFocus();
	                // all good, allow clicks again
	                _this._app.setEnabled(true);
	                _this._nav && _this._nav.setTransitioning(false);
	                _this.regScrollMove();
	                if (_this._usePadding) {
	                    _this._scrollView.clearScrollPaddingFocusOut();
	                }
	            });
	        }
	        else {
	            // not inside of a scroll view, just focus it
	            this.setFocus();
	            this.regScrollMove();
	        }
	    };
	    /**
	     * @private
	     */
	    InputBase.prototype.setFocus = function () {
	        // immediately set focus
	        this._form.setAsFocused(this);
	        // set focus on the actual input element
	        console.debug("input-base, setFocus " + this._native.element().value);
	        this._native.setFocus();
	        // ensure the body hasn't scrolled down
	        document.body.scrollTop = 0;
	    };
	    /**
	     * @private
	     * Angular2 Forms API method called by the view (formControlName) to register the
	     * onChange event handler that updates the model (Control).
	     * @param {Function} fn  the onChange event handler.
	     */
	    InputBase.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	    /**
	     * @private
	     * Angular2 Forms API method called by the view (formControlName) to register
	     * the onTouched event handler that marks model (Control) as touched.
	     * @param {Function} fn  onTouched event handler.
	     */
	    InputBase.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /**
	     * @private
	     */
	    InputBase.prototype.regScrollMove = function () {
	        var _this = this;
	        // register scroll move listener
	        if (this._useAssist && this._scrollView) {
	            setTimeout(function () {
	                _this.deregScrollMove();
	                _this._deregScroll = _this._scrollView.addScrollListener(_this._scrollMove);
	            }, 80);
	        }
	    };
	    /**
	     * @private
	     */
	    InputBase.prototype.deregScrollMove = function () {
	        // deregister the scroll move listener
	        this._deregScroll && this._deregScroll();
	    };
	    InputBase.prototype.focusNext = function () {
	        this._form.tabFocus(this);
	    };
	    /**
	     * @private
	     */
	    InputBase.getScrollData = function (inputOffsetTop, inputOffsetHeight, scrollViewDimensions, keyboardHeight, plaformHeight) {
	        // compute input's Y values relative to the body
	        var inputTop = (inputOffsetTop + scrollViewDimensions.contentTop - scrollViewDimensions.scrollTop);
	        var inputBottom = (inputTop + inputOffsetHeight);
	        // compute the safe area which is the viewable content area when the soft keyboard is up
	        var safeAreaTop = scrollViewDimensions.contentTop;
	        var safeAreaHeight = plaformHeight - keyboardHeight - safeAreaTop;
	        safeAreaHeight /= 2;
	        var safeAreaBottom = safeAreaTop + safeAreaHeight;
	        var inputTopWithinSafeArea = (inputTop >= safeAreaTop && inputTop <= safeAreaBottom);
	        var inputTopAboveSafeArea = (inputTop < safeAreaTop);
	        var inputTopBelowSafeArea = (inputTop > safeAreaBottom);
	        var inputBottomWithinSafeArea = (inputBottom >= safeAreaTop && inputBottom <= safeAreaBottom);
	        var inputBottomBelowSafeArea = (inputBottom > safeAreaBottom);
	        /*
	        Text Input Scroll To Scenarios
	        ---------------------------------------
	        1) Input top within safe area, bottom within safe area
	        2) Input top within safe area, bottom below safe area, room to scroll
	        3) Input top above safe area, bottom within safe area, room to scroll
	        4) Input top below safe area, no room to scroll, input smaller than safe area
	        5) Input top within safe area, bottom below safe area, no room to scroll, input smaller than safe area
	        6) Input top within safe area, bottom below safe area, no room to scroll, input larger than safe area
	        7) Input top below safe area, no room to scroll, input larger than safe area
	        */
	        var scrollData = {
	            scrollAmount: 0,
	            scrollTo: 0,
	            scrollPadding: 0,
	            inputSafeY: 0
	        };
	        if (inputTopWithinSafeArea && inputBottomWithinSafeArea) {
	            // Input top within safe area, bottom within safe area
	            // no need to scroll to a position, it's good as-is
	            return scrollData;
	        }
	        // looks like we'll have to do some auto-scrolling
	        if (inputTopBelowSafeArea || inputBottomBelowSafeArea) {
	            // Input top and bottom below safe area
	            // auto scroll the input up so at least the top of it shows
	            if (safeAreaHeight > inputOffsetHeight) {
	                // safe area height is taller than the input height, so we
	                // can bring it up the input just enough to show the input bottom
	                scrollData.scrollAmount = Math.round(safeAreaBottom - inputBottom);
	            }
	            else {
	                // safe area height is smaller than the input height, so we can
	                // only scroll it up so the input top is at the top of the safe area
	                // however the input bottom will be below the safe area
	                scrollData.scrollAmount = Math.round(safeAreaTop - inputTop);
	            }
	            scrollData.inputSafeY = -(inputTop - safeAreaTop) + 4;
	        }
	        else if (inputTopAboveSafeArea) {
	            // Input top above safe area
	            // auto scroll the input down so at least the top of it shows
	            scrollData.scrollAmount = Math.round(safeAreaTop - inputTop);
	            scrollData.inputSafeY = (safeAreaTop - inputTop) + 4;
	        }
	        // figure out where it should scroll to for the best position to the input
	        scrollData.scrollTo = (scrollViewDimensions.scrollTop - scrollData.scrollAmount);
	        if (scrollData.scrollAmount < 0) {
	            // when auto-scrolling up, there also needs to be enough
	            // content padding at the bottom of the scroll view
	            // manually add it if there isn't enough scrollable area
	            // figure out how many scrollable area is left to scroll up
	            var availablePadding = (scrollViewDimensions.scrollHeight - scrollViewDimensions.scrollTop) - scrollViewDimensions.contentHeight;
	            var paddingSpace = availablePadding + scrollData.scrollAmount;
	            if (paddingSpace < 0) {
	                // there's not enough scrollable area at the bottom, so manually add more
	                scrollData.scrollPadding = (scrollViewDimensions.contentHeight - safeAreaHeight);
	            }
	        }
	        // if (!window.safeAreaEle) {
	        //   window.safeAreaEle = document.createElement('div');
	        //   window.safeAreaEle.style.position = 'absolute';
	        //   window.safeAreaEle.style.background = 'rgba(0, 128, 0, 0.7)';
	        //   window.safeAreaEle.style.padding = '2px 5px';
	        //   window.safeAreaEle.style.textShadow = '1px 1px white';
	        //   window.safeAreaEle.style.left = '0px';
	        //   window.safeAreaEle.style.right = '0px';
	        //   window.safeAreaEle.style.fontWeight = 'bold';
	        //   window.safeAreaEle.style.pointerEvents = 'none';
	        //   document.body.appendChild(window.safeAreaEle);
	        // }
	        // window.safeAreaEle.style.top = safeAreaTop + 'px';
	        // window.safeAreaEle.style.height = safeAreaHeight + 'px';
	        // window.safeAreaEle.innerHTML = `
	        //   <div>scrollTo: ${scrollData.scrollTo}</div>
	        //   <div>scrollAmount: ${scrollData.scrollAmount}</div>
	        //   <div>scrollPadding: ${scrollData.scrollPadding}</div>
	        //   <div>inputSafeY: ${scrollData.inputSafeY}</div>
	        //   <div>scrollHeight: ${scrollViewDimensions.scrollHeight}</div>
	        //   <div>scrollTop: ${scrollViewDimensions.scrollTop}</div>
	        //   <div>contentHeight: ${scrollViewDimensions.contentHeight}</div>
	        // `;
	        return scrollData;
	    };
	    /** @nocollapse */
	    InputBase.propDecorators = {
	        'clearInput': [{ type: Input },],
	        'placeholder': [{ type: Input },],
	        '_native': [{ type: ViewChild, args: [NativeInput,] },],
	        'blur': [{ type: Output },],
	        'focus': [{ type: Output },],
	        'value': [{ type: Input },],
	        'type': [{ type: Input },],
	        'disabled': [{ type: Input },],
	        '_nativeInput': [{ type: ViewChild, args: [NativeInput,] },],
	        '_nextInput': [{ type: ViewChild, args: [NextInput,] },],
	    };
	    return InputBase;
	}());
	var SCROLL_ASSIST_SPEED = 0.3;
	function getScrollAssistDuration(distanceToScroll) {
	    distanceToScroll = Math.abs(distanceToScroll);
	    var duration = distanceToScroll / SCROLL_ASSIST_SPEED;
	    return Math.min(400, Math.max(150, duration));
	}

	var __extends$26 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextInput = (function (_super) {
	    __extends$26(TextInput, _super);
	    function TextInput(config, form, item, app, platform, elementRef, scrollView, nav, ngControl) {
	        _super.call(this, config, form, item, app, platform, elementRef, scrollView, nav, ngControl);
	    }
	    /**
	     * @private
	     */
	    TextInput.prototype.inputBlurred = function (ev) {
	        this.blur.emit(ev);
	    };
	    /**
	     * @private
	     */
	    TextInput.prototype.inputFocused = function (ev) {
	        this.focus.emit(ev);
	    };
	    /**
	     * @private
	     */
	    TextInput.prototype.clearTextInput = function () {
	        console.debug('Should clear input');
	        this._value = '';
	        this.onChange(this._value);
	        this.writeValue(this._value);
	    };
	    /** @nocollapse */
	    TextInput.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-input',
	                    template: "\n    <input [type]=\"type\" [(ngModel)]=\"_value\" (blur)=\"inputBlurred($event)\" (focus)=\"inputFocused($event)\" [placeholder]=\"placeholder\" class=\"text-input\">\n    <input [type]=\"type\" aria-hidden=\"true\" next-input *ngIf=\"_useAssist\">\n    <button clear [hidden]=\"!clearInput\" type=\"button\" class=\"text-input-clear-icon\" (click)=\"clearTextInput()\" (mousedown)=\"clearTextInput()\"></button>\n    <div (touchstart)=\"pointerStart($event)\" (touchend)=\"pointerEnd($event)\" (mousedown)=\"pointerStart($event)\" (mouseup)=\"pointerEnd($event)\" class=\"input-cover\" tappable *ngIf=\"_useAssist\"></div>\n  ",
	                    directives: [NativeInput, NextInput, NgIf, NgModel$1],
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    TextInput.ctorParameters = [
	        { type: Config, },
	        { type: Form, },
	        { type: Item, decorators: [{ type: Optional },] },
	        { type: App, },
	        { type: Platform, },
	        { type: ElementRef, },
	        { type: Content, decorators: [{ type: Optional },] },
	        { type: NavController, decorators: [{ type: Optional },] },
	        { type: NgControl$1, decorators: [{ type: Optional },] },
	    ];
	    return TextInput;
	}(InputBase));
	var TextArea = (function (_super) {
	    __extends$26(TextArea, _super);
	    function TextArea(config, form, item, app, platform, elementRef, scrollView, nav, ngControl) {
	        _super.call(this, config, form, item, app, platform, elementRef, scrollView, nav, ngControl);
	    }
	    /**
	     * @private
	     */
	    TextArea.prototype.ngOnInit = function () {
	        _super.prototype.ngOnInit.call(this);
	        if (this._item) {
	            this._item.setCssClass('item-textarea', true);
	        }
	    };
	    /**
	     * @private
	     */
	    TextArea.prototype.inputBlurred = function (ev) {
	        this.blur.emit(ev);
	    };
	    /**
	     * @private
	     */
	    TextArea.prototype.inputFocused = function (ev) {
	        this.focus.emit(ev);
	    };
	    /** @nocollapse */
	    TextArea.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-textarea',
	                    template: '<textarea [(ngModel)]="_value" (blur)="inputBlurred($event)" (focus)="inputFocused($event)" [placeholder]="placeholder" class="text-input"></textarea>' +
	                        '<input type="text" aria-hidden="true" next-input *ngIf="_useAssist">' +
	                        '<div (touchstart)="pointerStart($event)" (touchend)="pointerEnd($event)" (mousedown)="pointerStart($event)" (mouseup)="pointerEnd($event)" class="input-cover" tappable *ngIf="_useAssist"></div>',
	                    directives: [NativeInput, NextInput, NgIf, NgModel$1],
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    TextArea.ctorParameters = [
	        { type: Config, },
	        { type: Form, },
	        { type: Item, decorators: [{ type: Optional },] },
	        { type: App, },
	        { type: Platform, },
	        { type: ElementRef, },
	        { type: Content, decorators: [{ type: Optional },] },
	        { type: NavController, decorators: [{ type: Optional },] },
	        { type: NgControl$1, decorators: [{ type: Optional },] },
	    ];
	    return TextArea;
	}(InputBase));

	var SegmentButton = (function () {
	    function SegmentButton(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._disabled = false;
	        this.ionSelect = new EventEmitter();
	    }
	    Object.defineProperty(SegmentButton.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this.setCssClass('segment-button-disabled', this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    SegmentButton.prototype.setCssClass = function (cssClass, shouldAdd) {
	        this._renderer.setElementClass(this._elementRef.nativeElement, cssClass, shouldAdd);
	    };
	    SegmentButton.prototype.onClick = function () {
	        console.debug('SegmentButton, select', this.value);
	        this.ionSelect.emit(this);
	    };
	    /**
	     * @private
	     */
	    SegmentButton.prototype.ngOnInit = function () {
	        if (!isPresent$5(this.value)) {
	            console.warn('<ion-segment-button> requires a "value" attribute');
	        }
	    };
	    Object.defineProperty(SegmentButton.prototype, "isActive", {
	        /**
	         * @private
	         */
	        set: function (isActive) {
	            this._renderer.setElementClass(this._elementRef.nativeElement, 'segment-activated', isActive);
	            this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-pressed', isActive);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    SegmentButton.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-segment-button',
	                    template: "\n    <ng-content></ng-content>\n    <ion-button-effect></ion-button-effect>\n  ",
	                    host: {
	                        'tappable': '',
	                        'class': 'segment-button',
	                        'role': 'button'
	                    },
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    SegmentButton.ctorParameters = [
	        { type: Renderer, },
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    SegmentButton.propDecorators = {
	        'value': [{ type: Input },],
	        'ionSelect': [{ type: Output },],
	        'disabled': [{ type: Input },],
	        'onClick': [{ type: HostListener, args: ['click',] },],
	    };
	    return SegmentButton;
	}());
	var Segment = (function () {
	    function Segment(ngControl) {
	        this._disabled = false;
	        this.ionChange = new EventEmitter();
	        /**
	         * @private
	         */
	        this.onChange = function (_) { };
	        /**
	         * @private
	         */
	        this.onTouched = function (_) { };
	        if (ngControl) {
	            ngControl.valueAccessor = this;
	        }
	    }
	    Object.defineProperty(Segment.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            if (this._buttons) {
	                var buttons = this._buttons.toArray();
	                for (var _i = 0, buttons_1 = buttons; _i < buttons_1.length; _i++) {
	                    var button = buttons_1[_i];
	                    button.setCssClass('segment-button-disabled', this._disabled);
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * Write a new value to the element.
	     */
	    Segment.prototype.writeValue = function (value) {
	        this.value = isPresent$5(value) ? value : '';
	        if (this._buttons) {
	            var buttons = this._buttons.toArray();
	            for (var _i = 0, buttons_2 = buttons; _i < buttons_2.length; _i++) {
	                var button = buttons_2[_i];
	                button.isActive = (button.value === this.value);
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Segment.prototype.ngAfterViewInit = function () {
	        var _this = this;
	        var buttons = this._buttons.toArray();
	        for (var _i = 0, buttons_3 = buttons; _i < buttons_3.length; _i++) {
	            var button = buttons_3[_i];
	            button.ionSelect.subscribe(function (selectedButton) {
	                _this.writeValue(selectedButton.value);
	                _this.onChange(selectedButton.value);
	                _this.ionChange.emit(selectedButton);
	            });
	            if (isPresent$5(this.value)) {
	                button.isActive = (button.value === this.value);
	            }
	            if (isTrueProperty(this._disabled)) {
	                button.setCssClass('segment-button-disabled', this._disabled);
	            }
	        }
	    };
	    /**
	     * @private
	     * Set the function to be called when the control receives a change event.
	     */
	    Segment.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	    /**
	     * @private
	     * Set the function to be called when the control receives a touch event.
	     */
	    Segment.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /** @nocollapse */
	    Segment.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-segment'
	                },] },
	    ];
	    /** @nocollapse */
	    Segment.ctorParameters = [
	        { type: NgControl$1, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    Segment.propDecorators = {
	        'ionChange': [{ type: Output },],
	        '_buttons': [{ type: ContentChildren, args: [SegmentButton,] },],
	        'disabled': [{ type: Input },],
	    };
	    return Segment;
	}());

	var RADIO_VALUE_ACCESSOR$2 = new Provider(NG_VALUE_ACCESSOR$1, { useExisting: forwardRef(function () { return RadioGroup; }), multi: true });
	var RadioGroup = (function () {
	    function RadioGroup(_renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this._btns = [];
	        this._ids = -1;
	        this._init = false;
	        this.ionChange = new EventEmitter();
	        this.id = ++radioGroupIds;
	    }
	    /**
	     * @private
	     */
	    RadioGroup.prototype.ngAfterContentInit = function () {
	        var activeButton = this._btns.find(function (b) { return b.checked; });
	        if (activeButton) {
	            this._setActive(activeButton);
	        }
	    };
	    /**
	     * @private
	     */
	    RadioGroup.prototype.writeValue = function (val) {
	        console.debug('radio group, writeValue', val);
	        this.value = val;
	        if (this._init) {
	            this._update();
	            this.onTouched();
	            this.ionChange.emit(val);
	        }
	        this._init = true;
	    };
	    /**
	     * @private
	     */
	    RadioGroup.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this._fn = fn;
	        this.onChange = function (val) {
	            // onChange used when there's an formControlName
	            console.debug('radio group, onChange', val);
	            fn(val);
	            _this.value = val;
	            _this._update();
	            _this.onTouched();
	            _this.ionChange.emit(val);
	        };
	    };
	    /**
	     * @private
	     */
	    RadioGroup.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    /**
	     * @private
	     */
	    RadioGroup.prototype._update = function () {
	        var _this = this;
	        // loop through each of the radiobuttons
	        var hasChecked = false;
	        this._btns.forEach(function (radioButton) {
	            // check this radiobutton if its value is
	            // the same as the radiogroups value
	            radioButton.checked = isCheckedProperty(_this.value, radioButton.value) && !hasChecked;
	            if (radioButton.checked) {
	                // if this button is checked, then set it as
	                // the radiogroup's active descendant
	                _this._setActive(radioButton);
	                hasChecked = true;
	            }
	        });
	    };
	    RadioGroup.prototype._setActive = function (radioButton) {
	        this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-activedescendant', radioButton.id);
	    };
	    /**
	     * @private
	     */
	    RadioGroup.prototype.add = function (button) {
	        var _this = this;
	        this._btns.push(button);
	        // listen for radiobutton select events
	        button.ionSelect.subscribe(function (val) {
	            // this radiobutton has been selected
	            _this.onChange(val);
	        });
	        return this.id + '-' + (++this._ids);
	    };
	    /**
	     * @private
	     */
	    RadioGroup.prototype.remove = function (button) {
	        var index = this._btns.indexOf(button);
	        if (index > -1) {
	            if (button.value === this.value) {
	                this.value = null;
	            }
	            this._btns.splice(index, 1);
	        }
	    };
	    Object.defineProperty(RadioGroup.prototype, "_header", {
	        set: function (header) {
	            if (header) {
	                if (!header.id) {
	                    header.id = 'rg-hdr-' + this.id;
	                }
	                this._renderer.setElementAttribute(this._elementRef.nativeElement, 'aria-describedby', header.id);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    RadioGroup.prototype.onChange = function (val) {
	        // onChange used when there is not an formControlName
	        console.debug('radio group, onChange w/out formControlName', val);
	        this.value = val;
	        this._update();
	        this.onTouched();
	        this.ionChange.emit(val);
	    };
	    /**
	     * @private
	     */
	    RadioGroup.prototype.onTouched = function () { };
	    /** @nocollapse */
	    RadioGroup.decorators = [
	        { type: Directive, args: [{
	                    selector: '[radio-group]',
	                    host: {
	                        '[attr.aria-activedescendant]': 'activeId',
	                        'role': 'radiogroup'
	                    },
	                    providers: [RADIO_VALUE_ACCESSOR$2]
	                },] },
	    ];
	    /** @nocollapse */
	    RadioGroup.ctorParameters = [
	        { type: Renderer, },
	        { type: ElementRef, },
	    ];
	    /** @nocollapse */
	    RadioGroup.propDecorators = {
	        'ionChange': [{ type: Output },],
	        '_header': [{ type: ContentChild, args: [ListHeader,] },],
	    };
	    return RadioGroup;
	}());
	var radioGroupIds = -1;

	var RadioButton = (function () {
	    function RadioButton(_form, _item, _group) {
	        this._form = _form;
	        this._item = _item;
	        this._group = _group;
	        this._checked = false;
	        this._disabled = false;
	        this._value = null;
	        this.ionSelect = new EventEmitter();
	        _form.register(this);
	        if (_group) {
	            // register with the radiogroup
	            this.id = 'rb-' + _group.add(this);
	        }
	        if (_item) {
	            // register the input inside of the item
	            // reset to the item's id instead of the radiogroup id
	            this.id = 'rb-' + _item.registerInput('radio');
	            this._labelId = 'lbl-' + _item.id;
	            this._item.setCssClass('item-radio', true);
	        }
	    }
	    Object.defineProperty(RadioButton.prototype, "value", {
	        get: function () {
	            // if the value is not defined then use it's unique id
	            return isBlank$5(this._value) ? this.id : this._value;
	        },
	        set: function (val) {
	            this._value = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RadioButton.prototype, "checked", {
	        get: function () {
	            return this._checked;
	        },
	        set: function (isChecked) {
	            this._checked = isTrueProperty(isChecked);
	            if (this._item) {
	                this._item.setCssClass('item-radio-checked', this._checked);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RadioButton.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this._item && this._item.setCssClass('item-radio-disabled', this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RadioButton.prototype._click = function (ev) {
	        console.debug('radio, select', this.id);
	        ev.preventDefault();
	        ev.stopPropagation();
	        this.checked = true;
	        this.ionSelect.emit(this.value);
	    };
	    /**
	     * @private
	     */
	    RadioButton.prototype.ngOnInit = function () {
	        if (this._group && isPresent$5(this._group.value)) {
	            this.checked = isCheckedProperty(this._group.value, this.value);
	        }
	    };
	    /**
	     * @private
	     */
	    RadioButton.prototype.ngOnDestroy = function () {
	        this._form.deregister(this);
	        this._group && this._group.remove(this);
	    };
	    /** @nocollapse */
	    RadioButton.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-radio',
	                    template: "\n    <div class=\"radio-icon\" [class.radio-checked]=\"_checked\">\n      <div class=\"radio-inner\"></div>\n    </div>\n    <button role=\"radio\"\n            type=\"button\"\n            category=\"item-cover\"\n            [id]=\"id\"\n            [attr.aria-checked]=\"_checked\"\n            [attr.aria-labelledby]=\"_labelId\"\n            [attr.aria-disabled]=\"_disabled\"\n            class=\"item-cover\">\n    </button>\n  ",
	                    host: {
	                        '[class.radio-disabled]': '_disabled'
	                    },
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    RadioButton.ctorParameters = [
	        { type: Form, },
	        { type: Item, decorators: [{ type: Optional },] },
	        { type: RadioGroup, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    RadioButton.propDecorators = {
	        'ionSelect': [{ type: Output },],
	        'value': [{ type: Input },],
	        'checked': [{ type: Input },],
	        'disabled': [{ type: Input },],
	        '_click': [{ type: HostListener, args: ['click', ['$event'],] },],
	    };
	    return RadioButton;
	}());

	var Debouncer = (function () {
	    function Debouncer(wait) {
	        this.wait = wait;
	        this.timer = null;
	    }
	    Debouncer.prototype.debounce = function (callback) {
	        this.callback = callback;
	        this.schedule();
	    };
	    Debouncer.prototype.schedule = function () {
	        if (this.timer) {
	            clearTimeout(this.timer);
	            this.timer = null;
	        }
	        if (this.wait <= 0) {
	            this.callback();
	        }
	        else {
	            this.timer = setTimeout(this.callback, this.wait);
	        }
	    };
	    return Debouncer;
	}());

	var RANGE_VALUE_ACCESSOR = new Provider(NG_VALUE_ACCESSOR$1, { useExisting: forwardRef(function () { return Range; }), multi: true });
	var RangeKnob = (function () {
	    function RangeKnob(range) {
	        this.range = range;
	    }
	    Object.defineProperty(RangeKnob.prototype, "ratio", {
	        get: function () {
	            return this._ratio;
	        },
	        set: function (ratio) {
	            this._ratio = clamp(0, ratio, 1);
	            this._val = this.range.ratioToValue(this._ratio);
	            if (this.range.snaps) {
	                this._ratio = this.range.valueToRatio(this._val);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RangeKnob.prototype, "value", {
	        get: function () {
	            return this._val;
	        },
	        set: function (val) {
	            if (isString$5(val)) {
	                val = Math.round(val);
	            }
	            if (isNumber$5(val) && !isNaN(val)) {
	                this._ratio = this.range.valueToRatio(val);
	                this._val = this.range.ratioToValue(this._ratio);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RangeKnob.prototype.position = function () {
	        this._x = this._ratio * 100 + "%";
	    };
	    RangeKnob.prototype.ngOnInit = function () {
	        if (isPresent$5(this.range.value)) {
	            // we already have a value
	            if (this.range.dualKnobs) {
	                // we have a value and there are two knobs
	                if (this.upper) {
	                    // this is the upper knob
	                    this.value = this.range.value.upper;
	                }
	                else {
	                    // this is the lower knob
	                    this.value = this.range.value.lower;
	                }
	            }
	            else {
	                // we have a value and there is only one knob
	                this.value = this.range.value;
	            }
	        }
	        else {
	            // we do not have a value so set defaults
	            this.ratio = ((this.range.dualKnobs && this.upper) ? 1 : 0);
	        }
	        this.position();
	    };
	    /** @nocollapse */
	    RangeKnob.decorators = [
	        { type: Component, args: [{
	                    selector: '.range-knob-handle',
	                    template: "\n    <div class=\"range-pin\" *ngIf=\"range.pin\">{{_val}}</div>\n    <div class=\"range-knob\"></div>\n  ",
	                    host: {
	                        '[class.range-knob-pressed]': 'pressed',
	                        '[class.range-knob-min]': '_val===range.min',
	                        '[class.range-knob-max]': '_val===range.max',
	                        '[style.left]': '_x',
	                        '[style.top]': '_y',
	                        '[style.transform]': '_trns',
	                        '[attr.aria-valuenow]': '_val',
	                        '[attr.aria-valuemin]': 'range.min',
	                        '[attr.aria-valuemax]': 'range.max',
	                        'role': 'slider',
	                        'tabindex': '0'
	                    },
	                    directives: [NgIf]
	                },] },
	    ];
	    /** @nocollapse */
	    RangeKnob.ctorParameters = [
	        { type: Range, decorators: [{ type: Inject, args: [forwardRef(function () { return Range; }),] },] },
	    ];
	    /** @nocollapse */
	    RangeKnob.propDecorators = {
	        'upper': [{ type: Input },],
	    };
	    return RangeKnob;
	}());
	var Range = (function () {
	    function Range(_form, _item, _renderer) {
	        this._form = _form;
	        this._item = _item;
	        this._renderer = _renderer;
	        this._dual = false;
	        this._disabled = false;
	        this._start = null;
	        this._min = 0;
	        this._max = 100;
	        this._step = 1;
	        this._snaps = false;
	        this._debouncer = new Debouncer(0);
	        this._events = new UIEventManager();
	        this.ionChange = new EventEmitter();
	        _form.register(this);
	        if (_item) {
	            this.id = 'rng-' + _item.registerInput('range');
	            this._labelId = 'lbl-' + _item.id;
	            _item.setCssClass('item-range', true);
	        }
	    }
	    Object.defineProperty(Range.prototype, "min", {
	        get: function () {
	            return this._min;
	        },
	        set: function (val) {
	            val = Math.round(val);
	            if (!isNaN(val)) {
	                this._min = val;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "max", {
	        get: function () {
	            return this._max;
	        },
	        set: function (val) {
	            val = Math.round(val);
	            if (!isNaN(val)) {
	                this._max = val;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "step", {
	        get: function () {
	            return this._step;
	        },
	        set: function (val) {
	            val = Math.round(val);
	            if (!isNaN(val) && val > 0) {
	                this._step = val;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "snaps", {
	        get: function () {
	            return this._snaps;
	        },
	        set: function (val) {
	            this._snaps = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "pin", {
	        get: function () {
	            return this._pin;
	        },
	        set: function (val) {
	            this._pin = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "debounce", {
	        get: function () {
	            return this._debouncer.wait;
	        },
	        set: function (val) {
	            this._debouncer.wait = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "dualKnobs", {
	        get: function () {
	            return this._dual;
	        },
	        set: function (val) {
	            this._dual = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Range.prototype.ngAfterViewInit = function () {
	        var barL = '';
	        var barR = '';
	        var firstRatio = this._knobs.first.ratio;
	        if (this._dual) {
	            var lastRatio = this._knobs.last.ratio;
	            barL = (Math.min(firstRatio, lastRatio) * 100) + "%";
	            barR = (100 - (Math.max(firstRatio, lastRatio) * 100)) + "%";
	        }
	        else {
	            barR = (100 - (firstRatio * 100)) + "%";
	        }
	        this._renderer.setElementStyle(this._bar.nativeElement, 'left', barL);
	        this._renderer.setElementStyle(this._bar.nativeElement, 'right', barR);
	        // add touchstart/mousedown listeners
	        this._events.pointerEventsRef(this._slider, this.pointerDown.bind(this), this.pointerMove.bind(this), this.pointerUp.bind(this));
	        this.createTicks();
	    };
	    /**
	     * @private
	     */
	    Range.prototype.pointerDown = function (ev) {
	        // TODO: we could stop listening for events instead of checking this._disabled.
	        // since there are a lot of events involved, this solution is
	        // enough for the moment
	        if (this._disabled) {
	            return false;
	        }
	        console.debug("range, " + ev.type);
	        // prevent default so scrolling does not happen
	        ev.preventDefault();
	        ev.stopPropagation();
	        // get the start coordinates
	        this._start = pointerCoord(ev);
	        // get the full dimensions of the slider element
	        var rect = this._rect = this._slider.nativeElement.getBoundingClientRect();
	        // figure out the offset
	        // the start of the pointer could actually
	        // have been left or right of the slider bar
	        if (this._start.x < rect.left) {
	            rect.xOffset = (this._start.x - rect.left);
	        }
	        else if (this._start.x > rect.right) {
	            rect.xOffset = (this._start.x - rect.right);
	        }
	        else {
	            rect.xOffset = 0;
	        }
	        // figure out which knob we're interacting with
	        this.setActiveKnob(this._start, rect);
	        // update the ratio for the active knob
	        this.updateKnob(this._start, rect);
	        // update the active knob's position
	        this._active.position();
	        this._pressed = this._active.pressed = true;
	        return true;
	    };
	    /**
	     * @private
	     */
	    Range.prototype.pointerMove = function (ev) {
	        console.debug("range, " + ev.type);
	        // prevent default so scrolling does not happen
	        ev.preventDefault();
	        ev.stopPropagation();
	        if (this._start !== null && this._active !== null) {
	            // only use pointer move if it's a valid pointer
	            // and we already have start coordinates
	            // update the ratio for the active knob
	            this.updateKnob(pointerCoord(ev), this._rect);
	            // update the active knob's position
	            this._active.position();
	            this._pressed = this._active.pressed = true;
	        }
	    };
	    /**
	     * @private
	     */
	    Range.prototype.pointerUp = function (ev) {
	        console.debug("range, " + ev.type);
	        // prevent default so scrolling does not happen
	        ev.preventDefault();
	        ev.stopPropagation();
	        // update the ratio for the active knob
	        this.updateKnob(pointerCoord(ev), this._rect);
	        // update the active knob's position
	        this._active.position();
	        // clear the start coordinates and active knob
	        this._start = this._active = null;
	        this._pressed = this._knobs.first.pressed = this._knobs.last.pressed = false;
	    };
	    /**
	     * @private
	     */
	    Range.prototype.setActiveKnob = function (current, rect) {
	        // figure out which knob is the closest one to the pointer
	        var ratio = (current.x - rect.left) / (rect.width);
	        if (this._dual && Math.abs(ratio - this._knobs.first.ratio) > Math.abs(ratio - this._knobs.last.ratio)) {
	            this._active = this._knobs.last;
	        }
	        else {
	            this._active = this._knobs.first;
	        }
	    };
	    /**
	     * @private
	     */
	    Range.prototype.updateKnob = function (current, rect) {
	        var _this = this;
	        // figure out where the pointer is currently at
	        // update the knob being interacted with
	        if (this._active) {
	            var oldVal = this._active.value;
	            this._active.ratio = (current.x - rect.left) / (rect.width);
	            var newVal = this._active.value;
	            if (oldVal !== newVal) {
	                // value has been updated
	                if (this._dual) {
	                    this.value = {
	                        lower: Math.min(this._knobs.first.value, this._knobs.last.value),
	                        upper: Math.max(this._knobs.first.value, this._knobs.last.value),
	                    };
	                }
	                else {
	                    this.value = newVal;
	                }
	                this._debouncer.debounce(function () {
	                    _this.onChange(_this.value);
	                    _this.ionChange.emit(_this);
	                });
	            }
	            this.updateBar();
	        }
	    };
	    /**
	     * @private
	     */
	    Range.prototype.updateBar = function () {
	        var firstRatio = this._knobs.first.ratio;
	        if (this._dual) {
	            var lastRatio = this._knobs.last.ratio;
	            this._barL = (Math.min(firstRatio, lastRatio) * 100) + "%";
	            this._barR = (100 - (Math.max(firstRatio, lastRatio) * 100)) + "%";
	        }
	        else {
	            this._barL = '';
	            this._barR = (100 - (firstRatio * 100)) + "%";
	        }
	        this.updateTicks();
	    };
	    /**
	     * @private
	     */
	    Range.prototype.createTicks = function () {
	        var _this = this;
	        if (this._snaps) {
	            raf(function () {
	                // TODO: Fix to not use RAF
	                _this._ticks = [];
	                for (var value = _this._min; value <= _this._max; value += _this._step) {
	                    var ratio = _this.valueToRatio(value);
	                    _this._ticks.push({
	                        ratio: ratio,
	                        left: ratio * 100 + "%",
	                    });
	                }
	                _this.updateTicks();
	            });
	        }
	    };
	    /**
	     * @private
	     */
	    Range.prototype.updateTicks = function () {
	        if (this._snaps) {
	            var ratio_1 = this.ratio;
	            if (this._dual) {
	                var upperRatio_1 = this.ratioUpper;
	                this._ticks.forEach(function (t) {
	                    t.active = (t.ratio >= ratio_1 && t.ratio <= upperRatio_1);
	                });
	            }
	            else {
	                this._ticks.forEach(function (t) {
	                    t.active = (t.ratio <= ratio_1);
	                });
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Range.prototype.ratioToValue = function (ratio) {
	        ratio = Math.round(((this._max - this._min) * ratio) + this._min);
	        return Math.round(ratio / this._step) * this._step;
	    };
	    /**
	     * @private
	     */
	    Range.prototype.valueToRatio = function (value) {
	        value = Math.round(clamp(this._min, value, this._max) / this._step) * this._step;
	        return (value - this._min) / (this._max - this._min);
	    };
	    /**
	     * @private
	     */
	    Range.prototype.writeValue = function (val) {
	        if (isPresent$5(val)) {
	            var knobs = this._knobs;
	            this.value = val;
	            if (this._knobs) {
	                if (this._dual) {
	                    knobs.first.value = val.lower;
	                    knobs.last.value = val.upper;
	                    knobs.last.position();
	                }
	                else {
	                    knobs.first.value = val;
	                }
	                knobs.first.position();
	                this.updateBar();
	            }
	        }
	    };
	    /**
	     * @private
	     */
	    Range.prototype.registerOnChange = function (fn) {
	        var _this = this;
	        this._fn = fn;
	        this.onChange = function (val) {
	            fn(val);
	            _this.onTouched();
	        };
	    };
	    /**
	     * @private
	     */
	    Range.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    Object.defineProperty(Range.prototype, "disabled", {
	        get: function () {
	            return this._disabled;
	        },
	        set: function (val) {
	            this._disabled = isTrueProperty(val);
	            this._item && this._item.setCssClass('item-range-disabled', this._disabled);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "ratio", {
	        /**
	         * Returns the ratio of the knob's is current location, which is a number between `0` and `1`.
	         * If two knobs are used, this property represents the lower value.
	         */
	        get: function () {
	            if (this._dual) {
	                return Math.min(this._knobs.first.ratio, this._knobs.last.ratio);
	            }
	            return this._knobs.first.ratio;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Range.prototype, "ratioUpper", {
	        /**
	         * Returns the ratio of the upper value's is current location, which is a number between `0` and `1`.
	         * If there is only one knob, then this will return `null`.
	         */
	        get: function () {
	            if (this._dual) {
	                return Math.max(this._knobs.first.ratio, this._knobs.last.ratio);
	            }
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Range.prototype.onChange = function (val) {
	        // used when this input does not have an ngModel or formControlName
	        this.onTouched();
	    };
	    /**
	     * @private
	     */
	    Range.prototype.onTouched = function () { };
	    /**
	     * @private
	     */
	    Range.prototype.ngOnDestroy = function () {
	        this._form.deregister(this);
	        this._events.unlistenAll();
	    };
	    /** @nocollapse */
	    Range.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-range',
	                    template: "\n    <ng-content select=\"[range-left]\"></ng-content>\n    <div class=\"range-slider\" #slider>\n      <div class=\"range-tick\" *ngFor=\"let t of _ticks\" [style.left]=\"t.left\" [class.range-tick-active]=\"t.active\"></div>\n      <div class=\"range-bar\"></div>\n      <div class=\"range-bar range-bar-active\" [style.left]=\"_barL\" [style.right]=\"_barR\" #bar></div>\n      <div class=\"range-knob-handle\"></div>\n      <div class=\"range-knob-handle\" [upper]=\"true\" *ngIf=\"_dual\"></div>\n    </div>\n    <ng-content select=\"[range-right]\"></ng-content>\n  ",
	                    directives: [NgFor, NgIf, RangeKnob],
	                    host: {
	                        '[class.range-disabled]': '_disabled',
	                        '[class.range-pressed]': '_pressed',
	                        '[class.range-has-pin]': '_pin'
	                    },
	                    providers: [RANGE_VALUE_ACCESSOR],
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Range.ctorParameters = [
	        { type: Form, },
	        { type: Item, decorators: [{ type: Optional },] },
	        { type: Renderer, },
	    ];
	    /** @nocollapse */
	    Range.propDecorators = {
	        '_bar': [{ type: ViewChild, args: ['bar',] },],
	        '_slider': [{ type: ViewChild, args: ['slider',] },],
	        '_knobs': [{ type: ViewChildren, args: [RangeKnob,] },],
	        'min': [{ type: Input },],
	        'max': [{ type: Input },],
	        'step': [{ type: Input },],
	        'snaps': [{ type: Input },],
	        'pin': [{ type: Input },],
	        'debounce': [{ type: Input },],
	        'dualKnobs': [{ type: Input },],
	        'ionChange': [{ type: Output },],
	        'disabled': [{ type: Input },],
	    };
	    return Range;
	}());

	var Searchbar = (function () {
	    function Searchbar(_elementRef, _config, ngControl) {
	        this._elementRef = _elementRef;
	        this._config = _config;
	        this._value = '';
	        this._shouldBlur = true;
	        this._isActive = false;
	        this._debouncer = new Debouncer(250);
	        this.cancelButtonText = 'Cancel';
	        this.showCancelButton = false;
	        this.placeholder = 'Search';
	        this.type = 'search';
	        this.ionInput = new EventEmitter();
	        this.ionBlur = new EventEmitter();
	        this.ionFocus = new EventEmitter();
	        this.ionCancel = new EventEmitter();
	        this.ionClear = new EventEmitter();
	        /**
	         * @private
	         */
	        this.onChange = function (_) { };
	        /**
	         * @private
	         */
	        this.onTouched = function () { };
	        // If the user passed a ngControl we need to set the valueAccessor
	        if (ngControl) {
	            ngControl.valueAccessor = this;
	        }
	    }
	    Object.defineProperty(Searchbar.prototype, "debounce", {
	        get: function () {
	            return this._debouncer.wait;
	        },
	        set: function (val) {
	            this._debouncer.wait = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Searchbar.prototype, "searchbarInput", {
	        set: function (searchbarInput) {
	            this._searchbarInput = searchbarInput;
	            var inputEle = searchbarInput.nativeElement;
	            // By defalt set autocomplete="off" unless specified by the input
	            var autoComplete = (this.autocomplete === '' || this.autocomplete === 'on') ? 'on' : this._config.get('autocomplete', 'off');
	            inputEle.setAttribute('autocomplete', autoComplete);
	            // by default set autocorrect="off" unless specified by the input
	            var autoCorrect = (this.autocorrect === '' || this.autocorrect === 'on') ? 'on' : this._config.get('autocorrect', 'off');
	            inputEle.setAttribute('autocorrect', autoCorrect);
	            // by default set spellcheck="false" unless specified by the input
	            var spellCheck = (this.spellcheck === '' || this.spellcheck === 'true' || this.spellcheck === true) ? true : this._config.getBoolean('spellcheck', false);
	            inputEle.setAttribute('spellcheck', spellCheck);
	            // by default set type="search" unless specified by the input
	            inputEle.setAttribute('type', this.type);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Searchbar.prototype, "value", {
	        get: function () {
	            return this._value;
	        },
	        set: function (val) {
	            this._value = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * On Initialization check for attributes
	     */
	    Searchbar.prototype.ngOnInit = function () {
	        var showCancelButton = this.showCancelButton;
	        if (typeof showCancelButton === 'string') {
	            this.showCancelButton = (showCancelButton === '' || showCancelButton === 'true');
	        }
	    };
	    /**
	     * @private
	     * After View Initialization position the elements
	     */
	    Searchbar.prototype.ngAfterViewInit = function () {
	        this.positionElements();
	    };
	    /**
	     * @private
	     * Positions the input search icon, placeholder, and the cancel button
	     * based on the input value and if it is focused. (ios only)
	     */
	    Searchbar.prototype.positionElements = function () {
	        if (this._config.get('mode') !== 'ios')
	            return;
	        // Position the input placeholder & search icon
	        if (this._searchbarInput && this._searchbarIcon) {
	            this.positionInputPlaceholder(this._searchbarInput.nativeElement, this._searchbarIcon.nativeElement);
	        }
	        // Position the cancel button
	        if (this._cancelButton && this._cancelButton.nativeElement) {
	            this.positionCancelButton(this._cancelButton.nativeElement);
	        }
	    };
	    /**
	     * @private
	     * Calculates the amount of padding/margin left for the elements
	     * in order to center them based on the placeholder width
	     */
	    Searchbar.prototype.positionInputPlaceholder = function (inputEle, iconEle) {
	        if (this.shouldAlignLeft()) {
	            inputEle.removeAttribute('style');
	            iconEle.removeAttribute('style');
	        }
	        else {
	            // Create a dummy span to get the placeholder width
	            var tempSpan = document.createElement('span');
	            tempSpan.innerHTML = this.placeholder;
	            document.body.appendChild(tempSpan);
	            // Get the width of the span then remove it
	            var textWidth = tempSpan.offsetWidth;
	            tempSpan.remove();
	            // Set the input padding left
	            var inputLeft = 'calc(50% - ' + (textWidth / 2) + 'px)';
	            inputEle.style.paddingLeft = inputLeft;
	            // Set the icon margin left
	            var iconLeft = 'calc(50% - ' + ((textWidth / 2) + 30) + 'px)';
	            iconEle.style.marginLeft = iconLeft;
	        }
	    };
	    /**
	     * @private
	     * Show the iOS Cancel button on focus, hide it offscreen otherwise
	     */
	    Searchbar.prototype.positionCancelButton = function (cancelButtonEle) {
	        if (cancelButtonEle.offsetWidth > 0) {
	            if (this._sbHasFocus) {
	                cancelButtonEle.style.marginRight = '0';
	            }
	            else {
	                cancelButtonEle.style.marginRight = -cancelButtonEle.offsetWidth + 'px';
	            }
	        }
	    };
	    /**
	     * @private
	     * Align the input placeholder left on focus or if a value exists
	     */
	    Searchbar.prototype.shouldAlignLeft = function () {
	        return ((this._value && this._value.toString().trim() !== '') || this._sbHasFocus === true);
	    };
	    /**
	     * @private
	     * Update the Searchbar input value when the input changes
	     */
	    Searchbar.prototype.inputChanged = function (ev) {
	        var _this = this;
	        var value = ev.target.value;
	        this._debouncer.debounce(function () {
	            _this._value = value;
	            _this.onChange(_this._value);
	            _this.ionInput.emit(ev);
	        });
	    };
	    /**
	     * @private
	     * Sets the Searchbar to focused and active on input focus.
	     */
	    Searchbar.prototype.inputFocused = function (ev) {
	        this.ionFocus.emit(ev);
	        this._sbHasFocus = true;
	        this._isActive = true;
	        this.positionElements();
	    };
	    /**
	     * @private
	     * Sets the Searchbar to not focused and checks if it should align left
	     * based on whether there is a value in the searchbar or not.
	     */
	    Searchbar.prototype.inputBlurred = function (ev) {
	        // _shouldBlur determines if it should blur
	        // if we are clearing the input we still want to stay focused in the input
	        if (this._shouldBlur === false) {
	            this._searchbarInput.nativeElement.focus();
	            this._shouldBlur = true;
	            return;
	        }
	        this.ionBlur.emit(ev);
	        this._sbHasFocus = false;
	        this.positionElements();
	    };
	    /**
	     * @private
	     * Clears the input field and triggers the control change.
	     */
	    Searchbar.prototype.clearInput = function (ev) {
	        this.ionClear.emit(ev);
	        if (isPresent$5(this._value) && this._value !== '') {
	            this._value = '';
	            this.onChange(this._value);
	            this.ionInput.emit(ev);
	        }
	        this._shouldBlur = false;
	    };
	    /**
	     * @private
	     * Clears the input field and tells the input to blur since
	     * the clearInput function doesn't want the input to blur
	     * then calls the custom cancel function if the user passed one in.
	     */
	    Searchbar.prototype.cancelSearchbar = function (ev) {
	        this.ionCancel.emit(ev);
	        this.clearInput(ev);
	        this._shouldBlur = true;
	        this._isActive = false;
	    };
	    /**
	     * @private
	     * Write a new value to the element.
	     */
	    Searchbar.prototype.writeValue = function (val) {
	        this._value = val;
	        this.positionElements();
	    };
	    /**
	     * @private
	     * Set the function to be called when the control receives a change event.
	     */
	    Searchbar.prototype.registerOnChange = function (fn) {
	        this.onChange = fn;
	    };
	    /**
	     * @private
	     * Set the function to be called when the control receives a touch event.
	     */
	    Searchbar.prototype.registerOnTouched = function (fn) {
	        this.onTouched = fn;
	    };
	    /** @nocollapse */
	    Searchbar.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-searchbar',
	                    template: '<div class="searchbar-input-container">' +
	                        '<button (click)="cancelSearchbar($event)" (mousedown)="cancelSearchbar($event)" clear dark class="searchbar-md-cancel">' +
	                        '<ion-icon name="arrow-back"></ion-icon>' +
	                        '</button>' +
	                        '<div #searchbarIcon class="searchbar-search-icon"></div>' +
	                        '<input #searchbarInput [(ngModel)]="_value" [attr.placeholder]="placeholder" (input)="inputChanged($event)" (blur)="inputBlurred($event)" (focus)="inputFocused($event)" class="searchbar-input">' +
	                        '<button clear class="searchbar-clear-icon" (click)="clearInput($event)" (mousedown)="clearInput($event)"></button>' +
	                        '</div>' +
	                        '<button #cancelButton [tabindex]="_isActive ? 1 : -1" clear (click)="cancelSearchbar($event)" (mousedown)="cancelSearchbar($event)" class="searchbar-ios-cancel">{{cancelButtonText}}</button>',
	                    directives: [Icon, NgModel$1],
	                    host: {
	                        '[class.searchbar-has-value]': '_value',
	                        '[class.searchbar-active]': '_isActive',
	                        '[class.searchbar-show-cancel]': 'showCancelButton',
	                        '[class.searchbar-left-aligned]': 'shouldAlignLeft()'
	                    },
	                    encapsulation: ViewEncapsulation.None
	                },] },
	    ];
	    /** @nocollapse */
	    Searchbar.ctorParameters = [
	        { type: ElementRef, },
	        { type: Config, },
	        { type: NgControl$1, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    Searchbar.propDecorators = {
	        'cancelButtonText': [{ type: Input },],
	        'showCancelButton': [{ type: Input },],
	        'debounce': [{ type: Input },],
	        'placeholder': [{ type: Input },],
	        'autocomplete': [{ type: Input },],
	        'autocorrect': [{ type: Input },],
	        'spellcheck': [{ type: Input },],
	        'type': [{ type: Input },],
	        'ionInput': [{ type: Output },],
	        'ionBlur': [{ type: Output },],
	        'ionFocus': [{ type: Output },],
	        'ionCancel': [{ type: Output },],
	        'ionClear': [{ type: Output },],
	        '_sbHasFocus': [{ type: HostBinding, args: ['class.searchbar-has-focus',] },],
	        'searchbarInput': [{ type: ViewChild, args: ['searchbarInput',] },],
	        '_searchbarIcon': [{ type: ViewChild, args: ['searchbarIcon',] },],
	        '_cancelButton': [{ type: ViewChild, args: ['cancelButton', { read: ElementRef },] },],
	        'value': [{ type: Input },],
	    };
	    return Searchbar;
	}());

	var __extends$27 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Nav = (function (_super) {
	    __extends$27(Nav, _super);
	    function Nav(viewCtrl, parent, app, config, keyboard, elementRef, zone, renderer, compiler, menuCtrl) {
	        _super.call(this, parent, app, config, keyboard, elementRef, zone, renderer, compiler, menuCtrl);
	        this._hasInit = false;
	        if (viewCtrl) {
	            // an ion-nav can also act as an ion-page within a parent ion-nav
	            // this would happen when an ion-nav nests a child ion-nav.
	            viewCtrl.setContent(this);
	            viewCtrl.setContentRef(elementRef);
	        }
	        if (parent) {
	            // this Nav has a parent Nav
	            parent.registerChildNav(this);
	        }
	        else if (app) {
	            // this is the root navcontroller for the entire app
	            this._app.setRootNav(this);
	        }
	    }
	    Object.defineProperty(Nav.prototype, "_vp", {
	        set: function (val) {
	            this.setViewport(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     */
	    Nav.prototype.ngAfterViewInit = function () {
	        this._hasInit = true;
	        if (this._root) {
	            if (typeof this._root !== 'function') {
	                throw 'The [root] property in <ion-nav> must be given a reference to a component class from within the constructor.';
	            }
	            this.push(this._root);
	        }
	    };
	    Object.defineProperty(Nav.prototype, "root", {
	        get: function () {
	            return this._root;
	        },
	        set: function (page) {
	            this._root = page;
	            if (this._hasInit) {
	                this.setRoot(page);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Nav.prototype, "swipeBackEnabled", {
	        get: function () {
	            return this._sbEnabled;
	        },
	        set: function (val) {
	            this._sbEnabled = isTrueProperty(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @nocollapse */
	    Nav.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-nav',
	                    template: "\n    <div #viewport nav-viewport></div>\n    <div class=\"nav-decor\"></div>\n  ",
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    Nav.ctorParameters = [
	        { type: ViewController, decorators: [{ type: Optional },] },
	        { type: NavController, decorators: [{ type: Optional },] },
	        { type: App, },
	        { type: Config, },
	        { type: Keyboard, },
	        { type: ElementRef, },
	        { type: NgZone, },
	        { type: Renderer, },
	        { type: ComponentResolver, },
	        { type: MenuController, },
	    ];
	    /** @nocollapse */
	    Nav.propDecorators = {
	        '_vp': [{ type: ViewChild, args: ['viewport', { read: ViewContainerRef },] },],
	        'root': [{ type: Input },],
	        'swipeBackEnabled': [{ type: Input },],
	    };
	    return Nav;
	}(NavController));

	var NavPop = (function () {
	    function NavPop(_nav) {
	        this._nav = _nav;
	        if (!_nav) {
	            console.error('nav-pop must be within a NavController');
	        }
	    }
	    /**
	     * @private
	     */
	    NavPop.prototype.onClick = function () {
	        this._nav && this._nav.pop();
	    };
	    /** @nocollapse */
	    NavPop.decorators = [
	        { type: Directive, args: [{
	                    selector: '[nav-pop]',
	                    host: {
	                        '(click)': 'onClick()',
	                        'role': 'link'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    NavPop.ctorParameters = [
	        { type: NavController, decorators: [{ type: Optional },] },
	    ];
	    return NavPop;
	}());

	var NavPush = (function () {
	    function NavPush(_nav) {
	        this._nav = _nav;
	        if (!_nav) {
	            console.error('nav-push must be within a NavController');
	        }
	    }
	    /**
	     * @private
	     */
	    NavPush.prototype.onClick = function () {
	        var destination, params;
	        if (this.navPush instanceof Array) {
	            if (this.navPush.length > 2) {
	                throw 'Too many [navPush] arguments, expects [View, { params }]';
	            }
	            destination = this.navPush[0];
	            params = this.navPush[1] || this.navParams;
	        }
	        else {
	            destination = this.navPush;
	            params = this.navParams;
	        }
	        this._nav && this._nav.push(destination, params);
	    };
	    /** @nocollapse */
	    NavPush.decorators = [
	        { type: Directive, args: [{
	                    selector: '[navPush]',
	                    host: {
	                        '(click)': 'onClick()',
	                        'role': 'link'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    NavPush.ctorParameters = [
	        { type: NavController, decorators: [{ type: Optional },] },
	    ];
	    /** @nocollapse */
	    NavPush.propDecorators = {
	        'navPush': [{ type: Input },],
	        'navParams': [{ type: Input },],
	    };
	    return NavPush;
	}());

	var NavRouter = (function () {
	    function NavRouter() {
	    }
	    /** @nocollapse */
	    NavRouter.decorators = [
	        { type: Directive, args: [{
	                    selector: 'ion-nav'
	                },] },
	    ];
	    return NavRouter;
	}());

	var __extends$28 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var DisplayWhen = (function () {
	    function DisplayWhen(conditions, platform, ngZone) {
	        var _this = this;
	        this.isMatch = false;
	        this.platform = platform;
	        if (!conditions)
	            return;
	        this.conditions = conditions.split(',');
	        // check if its one of the matching platforms first
	        // a platform does not change during the life of an app
	        for (var i = 0; i < this.conditions.length; i++) {
	            if (this.conditions[i] && platform.is(this.conditions[i])) {
	                this.isMatch = true;
	                return;
	            }
	        }
	        if (this.orientation()) {
	            // add window resize listener
	            platform.onResize(function () {
	                ngZone.run(function () {
	                    _this.orientation();
	                });
	            });
	            return;
	        }
	    }
	    DisplayWhen.prototype.orientation = function () {
	        for (var i = 0; i < this.conditions.length; i++) {
	            if (this.conditions[i] === 'portrait') {
	                this.isMatch = this.platform.isPortrait();
	                return true;
	            }
	            if (this.conditions[i] === 'landscape') {
	                this.isMatch = this.platform.isLandscape();
	                return true;
	            }
	        }
	    };
	    return DisplayWhen;
	}());
	var ShowWhen = (function (_super) {
	    __extends$28(ShowWhen, _super);
	    function ShowWhen(showWhen, platform, ngZone) {
	        _super.call(this, showWhen, platform, ngZone);
	    }
	    /** @nocollapse */
	    ShowWhen.decorators = [
	        { type: Directive, args: [{
	                    selector: '[showWhen]',
	                    host: {
	                        '[class.hidden-show-when]': '!isMatch'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    ShowWhen.ctorParameters = [
	        { type: undefined, decorators: [{ type: Attribute, args: ['showWhen',] },] },
	        { type: Platform, },
	        { type: NgZone, },
	    ];
	    return ShowWhen;
	}(DisplayWhen));
	var HideWhen = (function (_super) {
	    __extends$28(HideWhen, _super);
	    function HideWhen(hideWhen, platform, ngZone) {
	        _super.call(this, hideWhen, platform, ngZone);
	    }
	    /** @nocollapse */
	    HideWhen.decorators = [
	        { type: Directive, args: [{
	                    selector: '[hideWhen]',
	                    host: {
	                        '[class.hidden-hide-when]': 'isMatch'
	                    }
	                },] },
	    ];
	    /** @nocollapse */
	    HideWhen.ctorParameters = [
	        { type: undefined, decorators: [{ type: Attribute, args: ['hideWhen',] },] },
	        { type: Platform, },
	        { type: NgZone, },
	    ];
	    return HideWhen;
	}(DisplayWhen));

	/**
	 * @private
	 * @name IONIC_DIRECTIVES
	 * @description
	 * The core Ionic directives as well as Angular's `CORE_DIRECTIVES` and `FORM_DIRECTIVES` are
	 * available automatically when you bootstrap your app with the `ionicBootstrap`. This means
	 * if you are using custom components you do not need to import `IONIC_DIRECTIVES` as they
	 * are part of the app's default directives.
	 *
	 *
	 * #### Angular
	 * - CORE_DIRECTIVES
	 * - FORM_DIRECTIVES
	 *
	 * #### Ionic
	 * - Menu
	 * - MenuToggle
	 * - MenuClose
	 * - Badge
	 * - Button
	 * - Content
	 * - Scroll
	 * - InfiniteScroll
	 * - InfiniteScrollContent
	 * - Refresher
	 * - RefresherContent
	 * - Img
	 * - List
	 * - ListHeader
	 * - Item
	 * - ItemContent
	 * - ItemSliding
	 * - VirtualScroll
	 * - VirtualItem
	 * - VirtualHeader
	 * - VirtualFooter
	 * - Slides
	 * - Slide
	 * - SlideLazy
	 * - Tabs
	 * - Tab
	 * - Header
	 * - Footer
	 * - Toolbar
	 * - ToolbarTitle
	 * - ToolbarItem
	 * - Icon
	 * - Spinner
	 * - Searchbar
	 * - Segment
	 * - SegmentButton
	 * - Checkbox
	 * - RadioGroup
	 * - RadioButton
	 * - Select
	 * - Option
	 * - DateTime
	 * - Toggle
	 * - TextArea
	 * - TextInput
	 * - Label
	 * - Nav
	 * - NavbarTemplate
	 * - Navbar
	 * - NavPush
	 * - NavPop
	 * - NavRouter
	 * - IdRef
	 * - ShowWhen
	 * - HideWhen
	 */
	var IONIC_DIRECTIVES = [
	    // Angular
	    CORE_DIRECTIVES,
	    REACTIVE_FORM_DIRECTIVES,
	    // Content
	    Menu,
	    MenuToggle,
	    MenuClose,
	    Backdrop,
	    Badge,
	    Button,
	    Content,
	    Scroll,
	    InfiniteScroll,
	    InfiniteScrollContent,
	    Refresher,
	    RefresherContent,
	    Img,
	    // Lists
	    List,
	    ListHeader,
	    Item,
	    ItemContent,
	    ItemSliding,
	    ItemOptions,
	    ItemReorder,
	    VirtualScroll,
	    VirtualItem,
	    VirtualHeader,
	    VirtualFooter,
	    // Slides
	    Slides,
	    Slide,
	    SlideLazy,
	    // Tabs
	    Tabs,
	    Tab,
	    // Toolbar
	    Header,
	    Footer,
	    Toolbar,
	    ToolbarTitle,
	    ToolbarItem,
	    // Media
	    Icon,
	    Spinner,
	    // Forms
	    Searchbar,
	    Segment,
	    SegmentButton,
	    Checkbox,
	    RadioGroup,
	    RadioButton,
	    Range,
	    Select,
	    Option,
	    DateTime,
	    Toggle,
	    TextArea,
	    TextInput,
	    Label,
	    // Nav
	    Nav,
	    NavbarTemplate,
	    Navbar,
	    NavPush,
	    NavPop,
	    NavRouter,
	    ShowWhen,
	    HideWhen
	];

	var __extends$30 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var LoadingCmp = (function () {
	    function LoadingCmp(_viewCtrl, _config, _elementRef, params, renderer) {
	        this._viewCtrl = _viewCtrl;
	        this._config = _config;
	        this._elementRef = _elementRef;
	        this.d = params.data;
	        if (this.d.cssClass) {
	            renderer.setElementClass(_elementRef.nativeElement, this.d.cssClass, true);
	        }
	        this.id = (++loadingIds);
	    }
	    LoadingCmp.prototype.ngOnInit = function () {
	        // If no spinner was passed in loading options we need to fall back
	        // to the loadingSpinner in the app's config, then the mode spinner
	        if (isUndefined(this.d.spinner)) {
	            this.d.spinner = this._config.get('loadingSpinner', this._config.get('spinner', 'ios'));
	        }
	        // If the user passed hide to the spinner we don't want to show it
	        this.showSpinner = isDefined(this.d.spinner) && this.d.spinner !== 'hide';
	    };
	    LoadingCmp.prototype.ionViewDidEnter = function () {
	        var _this = this;
	        var activeElement = document.activeElement;
	        if (document.activeElement) {
	            activeElement.blur();
	        }
	        // If there is a duration, dismiss after that amount of time
	        this.d.duration ? setTimeout(function () { return _this.dismiss('backdrop'); }, this.d.duration) : null;
	    };
	    LoadingCmp.prototype.dismiss = function (role) {
	        return this._viewCtrl.dismiss(null, role);
	    };
	    /** @nocollapse */
	    LoadingCmp.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-loading',
	                    template: "\n    <ion-backdrop [class.hide-backdrop]=\"!d.showBackdrop\"></ion-backdrop>\n    <div class=\"loading-wrapper\">\n      <div *ngIf=\"showSpinner\" class=\"loading-spinner\">\n        <ion-spinner [name]=\"d.spinner\"></ion-spinner>\n      </div>\n      <div *ngIf=\"d.content\" [innerHTML]=\"d.content\" class=\"loading-content\"></div>\n    </div>\n  ",
	                    directives: [Backdrop, NgIf, Spinner],
	                    host: {
	                        'role': 'dialog'
	                    },
	                    encapsulation: ViewEncapsulation.None,
	                },] },
	    ];
	    /** @nocollapse */
	    LoadingCmp.ctorParameters = [
	        { type: ViewController, },
	        { type: Config, },
	        { type: ElementRef, },
	        { type: NavParams, },
	        { type: Renderer, },
	    ];
	    return LoadingCmp;
	}());
	/**
	 * Animations for loading
	 */
	var LoadingPopIn = (function (_super) {
	    __extends$30(LoadingPopIn, _super);
	    function LoadingPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.loading-wrapper'));
	        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
	        backdrop.fromTo('opacity', 0.01, 0.3);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return LoadingPopIn;
	}(Transition));
	Transition.register('loading-pop-in', LoadingPopIn);
	var LoadingPopOut = (function (_super) {
	    __extends$30(LoadingPopOut, _super);
	    function LoadingPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.loading-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
	        backdrop.fromTo('opacity', 0.3, 0);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return LoadingPopOut;
	}(Transition));
	Transition.register('loading-pop-out', LoadingPopOut);
	var LoadingMdPopIn = (function (_super) {
	    __extends$30(LoadingMdPopIn, _super);
	    function LoadingMdPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.loading-wrapper'));
	        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.1, 1);
	        backdrop.fromTo('opacity', 0.01, 0.5);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return LoadingMdPopIn;
	}(Transition));
	Transition.register('loading-md-pop-in', LoadingMdPopIn);
	var LoadingMdPopOut = (function (_super) {
	    __extends$30(LoadingMdPopOut, _super);
	    function LoadingMdPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.loading-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 0.9);
	        backdrop.fromTo('opacity', 0.5, 0);
	        this
	            .easing('ease-in-out')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return LoadingMdPopOut;
	}(Transition));
	Transition.register('loading-md-pop-out', LoadingMdPopOut);
	var LoadingWpPopIn = (function (_super) {
	    __extends$30(LoadingWpPopIn, _super);
	    function LoadingWpPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.loading-wrapper'));
	        wrapper.fromTo('opacity', 0.01, 1).fromTo('scale', 1.3, 1);
	        backdrop.fromTo('opacity', 0.01, 0.16);
	        this
	            .easing('cubic-bezier(0,0 0.05,1)')
	            .duration(200)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return LoadingWpPopIn;
	}(Transition));
	Transition.register('loading-wp-pop-in', LoadingWpPopIn);
	var LoadingWpPopOut = (function (_super) {
	    __extends$30(LoadingWpPopOut, _super);
	    function LoadingWpPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.loading-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0).fromTo('scale', 1, 1.3);
	        backdrop.fromTo('opacity', 0.16, 0);
	        this
	            .easing('ease-out')
	            .duration(150)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return LoadingWpPopOut;
	}(Transition));
	Transition.register('loading-wp-pop-out', LoadingWpPopOut);
	var loadingIds = -1;

	var __extends$29 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var Loading = (function (_super) {
	    __extends$29(Loading, _super);
	    function Loading(app, opts) {
	        if (opts === void 0) { opts = {}; }
	        opts.showBackdrop = isPresent$5(opts.showBackdrop) ? !!opts.showBackdrop : true;
	        opts.dismissOnPageChange = isPresent$5(opts.dismissOnPageChange) ? !!opts.dismissOnPageChange : false;
	        _super.call(this, LoadingCmp, opts);
	        this._app = app;
	        this.isOverlay = true;
	        // by default, loading indicators should not fire lifecycle events of other views
	        // for example, when an loading indicators enters, the current active view should
	        // not fire its lifecycle events because it's not conceptually leaving
	        this.fireOtherLifecycles = false;
	    }
	    /**
	     * @private
	     */
	    Loading.prototype.getTransitionName = function (direction) {
	        var key = (direction === 'back' ? 'loadingLeave' : 'loadingEnter');
	        return this._nav && this._nav.config.get(key);
	    };
	    /**
	     * Present the loading instance.
	     *
	     * @param {NavOptions} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    Loading.prototype.present = function (navOptions) {
	        if (navOptions === void 0) { navOptions = {}; }
	        return this._app.present(this, navOptions);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please inject LoadingController instead
	     */
	    Loading.create = function (opt) {
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('Loading.create(..) has been deprecated. Please inject LoadingController instead');
	    };
	    return Loading;
	}(ViewController));
	var LoadingController = (function () {
	    function LoadingController(_app) {
	        this._app = _app;
	    }
	    /**
	     * Create a loading indicator. See below for options.
	     * @param {LoadingOptions} opts Loading options
	     */
	    LoadingController.prototype.create = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        return new Loading(this._app, opts);
	    };
	    /** @nocollapse */
	    LoadingController.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    LoadingController.ctorParameters = [
	        { type: App, },
	    ];
	    return LoadingController;
	}());

	var __extends$33 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var PageTransition = (function (_super) {
	    __extends$33(PageTransition, _super);
	    function PageTransition(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        this.enteringPage = new Animation(this.enteringView.pageRef());
	        this.enteringPage.before.addClass('show-page');
	        this.add(this.enteringPage);
	        this.before.addDomReadFn(this.readDimensions.bind(this));
	        this.before.addDomWriteFn(this.writeDimensions.bind(this));
	    }
	    /**
	     * DOM READ
	     */
	    PageTransition.prototype.readDimensions = function () {
	        var content = this.enteringView.getContent();
	        if (content && content instanceof Content) {
	            content.readDimensions();
	        }
	    };
	    /**
	     * DOM WRITE
	     */
	    PageTransition.prototype.writeDimensions = function () {
	        var content = this.enteringView.getContent();
	        if (content && content instanceof Content) {
	            content.writeDimensions();
	        }
	    };
	    PageTransition.prototype.destroy = function () {
	        _super.prototype.destroy.call(this);
	        this.enteringView = this.enteringPage = null;
	    };
	    return PageTransition;
	}(Transition));

	var __extends$32 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ModalCmp = (function () {
	    function ModalCmp(_compiler, _renderer, _navParams, _viewCtrl) {
	        this._compiler = _compiler;
	        this._renderer = _renderer;
	        this._navParams = _navParams;
	        this._viewCtrl = _viewCtrl;
	        this.d = _navParams.data.opts;
	    }
	    ModalCmp.prototype.loadComponent = function (done) {
	        var _this = this;
	        var componentType = this._navParams.data.componentType;
	        addSelector(componentType, 'ion-page');
	        this._compiler.resolveComponent(componentType).then(function (componentFactory) {
	            var componentRef = _this.viewport.createComponent(componentFactory, _this.viewport.length, _this.viewport.parentInjector);
	            _this._renderer.setElementClass(componentRef.location.nativeElement, 'show-page', true);
	            // auto-add page css className created from component JS class name
	            var cssClassName = pascalCaseToDashCase(componentType.name);
	            _this._renderer.setElementClass(componentRef.location.nativeElement, cssClassName, true);
	            _this._viewCtrl.setInstance(componentRef.instance);
	            _this.enabled = true;
	            done();
	        });
	    };
	    ModalCmp.prototype.ngAfterViewInit = function () {
	        // intentionally kept empty
	    };
	    ModalCmp.prototype.dismiss = function (role) {
	        return this._viewCtrl.dismiss(null, role);
	    };
	    ModalCmp.prototype.bdClick = function () {
	        if (this.enabled && this.d.enableBackdropDismiss) {
	            this.dismiss('backdrop');
	        }
	    };
	    ModalCmp.prototype._keyUp = function (ev) {
	        if (this.enabled && this._viewCtrl.isLast() && ev.keyCode === Key.ESCAPE) {
	            this.bdClick();
	        }
	    };
	    /** @nocollapse */
	    ModalCmp.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-modal',
	                    template: "\n    <ion-backdrop disableScroll=\"false\" (click)=\"bdClick($event)\"></ion-backdrop>\n    <div class=\"modal-wrapper\">\n      <div #viewport nav-viewport></div>\n    </div>\n  ",
	                    directives: [Backdrop]
	                },] },
	    ];
	    /** @nocollapse */
	    ModalCmp.ctorParameters = [
	        { type: ComponentResolver, },
	        { type: Renderer, },
	        { type: NavParams, },
	        { type: ViewController, },
	    ];
	    /** @nocollapse */
	    ModalCmp.propDecorators = {
	        'viewport': [{ type: ViewChild, args: ['viewport', { read: ViewContainerRef },] },],
	        '_keyUp': [{ type: HostListener, args: ['body:keyup', ['$event'],] },],
	    };
	    return ModalCmp;
	}());
	/**
	 * Animations for modals
	 */
	var ModalSlideIn = (function (_super) {
	    __extends$32(ModalSlideIn, _super);
	    function ModalSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdropEle = ele.querySelector('ion-backdrop');
	        var backdrop = new Animation(backdropEle);
	        var wrapper = new Animation(ele.querySelector('.modal-wrapper'));
	        backdrop.fromTo('opacity', 0.01, 0.4);
	        wrapper.fromTo('translateY', '100%', '0%');
	        this
	            .element(enteringView.pageRef())
	            .easing('cubic-bezier(0.36,0.66,0.04,1)')
	            .duration(400)
	            .add(backdrop)
	            .add(wrapper);
	        if (enteringView.hasNavbar()) {
	            // entering page has a navbar
	            var enteringNavBar = new Animation(enteringView.navbarRef());
	            enteringNavBar.before.addClass('show-navbar');
	            this.add(enteringNavBar);
	        }
	    }
	    return ModalSlideIn;
	}(PageTransition));
	PageTransition.register('modal-slide-in', ModalSlideIn);
	var ModalSlideOut = (function (_super) {
	    __extends$32(ModalSlideOut, _super);
	    function ModalSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapperEle = ele.querySelector('.modal-wrapper');
	        var wrapperEleRect = wrapperEle.getBoundingClientRect();
	        var wrapper = new Animation(wrapperEle);
	        // height of the screen - top of the container tells us how much to scoot it down
	        // so it's off-screen
	        var screenDimensions = windowDimensions();
	        wrapper.fromTo('translateY', '0px', (screenDimensions.height - wrapperEleRect.top) + "px");
	        backdrop.fromTo('opacity', 0.4, 0.0);
	        this
	            .element(leavingView.pageRef())
	            .easing('ease-out')
	            .duration(250)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return ModalSlideOut;
	}(PageTransition));
	PageTransition.register('modal-slide-out', ModalSlideOut);
	var ModalMDSlideIn = (function (_super) {
	    __extends$32(ModalMDSlideIn, _super);
	    function ModalMDSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.modal-wrapper'));
	        backdrop.fromTo('opacity', 0.01, 0.4);
	        wrapper.fromTo('translateY', '40px', '0px');
	        wrapper.fromTo('opacity', 0.01, 1);
	        var DURATION = 280;
	        var EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
	        this.element(enteringView.pageRef()).easing(EASING).duration(DURATION)
	            .add(backdrop)
	            .add(wrapper);
	        if (enteringView.hasNavbar()) {
	            // entering page has a navbar
	            var enteringNavBar = new Animation(enteringView.navbarRef());
	            enteringNavBar.before.addClass('show-navbar');
	            this.add(enteringNavBar);
	        }
	    }
	    return ModalMDSlideIn;
	}(PageTransition));
	PageTransition.register('modal-md-slide-in', ModalMDSlideIn);
	var ModalMDSlideOut = (function (_super) {
	    __extends$32(ModalMDSlideOut, _super);
	    function ModalMDSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.modal-wrapper'));
	        backdrop.fromTo('opacity', 0.4, 0.0);
	        wrapper.fromTo('translateY', '0px', '40px');
	        wrapper.fromTo('opacity', 0.99, 0);
	        this
	            .element(leavingView.pageRef())
	            .duration(200)
	            .easing('cubic-bezier(0.47,0,0.745,0.715)')
	            .add(wrapper)
	            .add(backdrop);
	    }
	    return ModalMDSlideOut;
	}(PageTransition));
	PageTransition.register('modal-md-slide-out', ModalMDSlideOut);

	var __extends$31 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var Modal = (function (_super) {
	    __extends$31(Modal, _super);
	    function Modal(app, componentType, data, opts) {
	        if (data === void 0) { data = {}; }
	        if (opts === void 0) { opts = {}; }
	        data.componentType = componentType;
	        opts.showBackdrop = isPresent$5(opts.showBackdrop) ? !!opts.showBackdrop : true;
	        opts.enableBackdropDismiss = isPresent$5(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
	        data.opts = opts;
	        _super.call(this, ModalCmp, data);
	        this._app = app;
	        this.isOverlay = true;
	    }
	    /**
	     * @private
	     */
	    Modal.prototype.getTransitionName = function (direction) {
	        var key = (direction === 'back' ? 'modalLeave' : 'modalEnter');
	        return this._nav && this._nav.config.get(key);
	    };
	    /**
	     * @private
	     * Override the load method and load our child component
	     */
	    Modal.prototype.loaded = function (done) {
	        var _this = this;
	        // grab the instance, and proxy the ngAfterViewInit method
	        var originalNgAfterViewInit = this.instance.ngAfterViewInit;
	        this.instance.ngAfterViewInit = function () {
	            if (originalNgAfterViewInit) {
	                originalNgAfterViewInit();
	            }
	            _this.instance.loadComponent(done);
	        };
	    };
	    /**
	     * Present the action sheet instance.
	     *
	     * @param {NavOptions} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    Modal.prototype.present = function (navOptions) {
	        if (navOptions === void 0) { navOptions = {}; }
	        return this._app.present(this, navOptions);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please inject ModalController instead
	     */
	    Modal.create = function (cmp, opt) {
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('Modal.create(..) has been deprecated. Please inject ModalController instead');
	    };
	    return Modal;
	}(ViewController));
	var ModalController = (function () {
	    function ModalController(_app) {
	        this._app = _app;
	    }
	    /**
	     * Create a modal to display. See below for options.
	     *
	     * @param {object} componentType The Modal view
	     * @param {object} data Any data to pass to the Modal view
	     * @param {object} opts Modal options
	     */
	    ModalController.prototype.create = function (componentType, data, opts) {
	        if (data === void 0) { data = {}; }
	        if (opts === void 0) { opts = {}; }
	        return new Modal(this._app, componentType, data, opts);
	    };
	    /** @nocollapse */
	    ModalController.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    ModalController.ctorParameters = [
	        { type: App, },
	    ];
	    return ModalController;
	}());

	var __extends$35 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PopoverCmp = (function () {
	    function PopoverCmp(_compiler, _elementRef, _renderer, _config, _navParams, _viewCtrl) {
	        this._compiler = _compiler;
	        this._elementRef = _elementRef;
	        this._renderer = _renderer;
	        this._config = _config;
	        this._navParams = _navParams;
	        this._viewCtrl = _viewCtrl;
	        this.d = _navParams.data.opts;
	        if (this.d.cssClass) {
	            _renderer.setElementClass(_elementRef.nativeElement, this.d.cssClass, true);
	        }
	        this.id = (++popoverIds);
	    }
	    PopoverCmp.prototype.ionViewWillEnter = function () {
	        var _this = this;
	        addSelector(this._navParams.data.componentType, 'ion-popover-inner');
	        this._compiler.resolveComponent(this._navParams.data.componentType).then(function (componentFactory) {
	            var componentRef = _this.viewport.createComponent(componentFactory, _this.viewport.length, _this.viewport.parentInjector);
	            _this._viewCtrl.setInstance(componentRef.instance);
	            // manually fire ionViewWillEnter() since PopoverCmp's ionViewWillEnter already happened
	            _this._viewCtrl.fireWillEnter();
	        });
	    };
	    PopoverCmp.prototype.ngAfterViewInit = function () {
	        var activeElement = document.activeElement;
	        if (document.activeElement) {
	            activeElement.blur();
	        }
	        this.enabled = true;
	    };
	    PopoverCmp.prototype.dismiss = function (role) {
	        return this._viewCtrl.dismiss(null, role);
	    };
	    PopoverCmp.prototype.bdTouch = function (ev) {
	        ev.preventDefault();
	        ev.stopPropagation();
	    };
	    PopoverCmp.prototype.bdClick = function () {
	        if (this.enabled && this.d.enableBackdropDismiss) {
	            this.dismiss('backdrop');
	        }
	    };
	    PopoverCmp.prototype._keyUp = function (ev) {
	        if (this.enabled && ev.keyCode === Key.ESCAPE && this._viewCtrl.isLast()) {
	            this.bdClick();
	        }
	    };
	    /** @nocollapse */
	    PopoverCmp.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-popover',
	                    template: "\n    <ion-backdrop (click)=\"bdClick($event)\" [class.hide-backdrop]=\"!d.showBackdrop\"></ion-backdrop>\n    <div class=\"popover-wrapper\">\n      <div class=\"popover-arrow\"></div>\n      <div class=\"popover-content\">\n        <div class=\"popover-viewport\">\n          <div #viewport nav-viewport></div>\n        </div>\n      </div>\n    </div>\n  ",
	                    directives: [Backdrop]
	                },] },
	    ];
	    /** @nocollapse */
	    PopoverCmp.ctorParameters = [
	        { type: ComponentResolver, },
	        { type: ElementRef, },
	        { type: Renderer, },
	        { type: Config, },
	        { type: NavParams, },
	        { type: ViewController, },
	    ];
	    /** @nocollapse */
	    PopoverCmp.propDecorators = {
	        'viewport': [{ type: ViewChild, args: ['viewport', { read: ViewContainerRef },] },],
	        '_keyUp': [{ type: HostListener, args: ['body:keyup', ['$event'],] },],
	    };
	    return PopoverCmp;
	}());
	/**
	 * Animations for popover
	 */
	var PopoverTransition = (function (_super) {
	    __extends$35(PopoverTransition, _super);
	    function PopoverTransition(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	    }
	    PopoverTransition.prototype.mdPositionView = function (nativeEle, ev) {
	        var originY = 'top';
	        var originX = 'left';
	        var popoverWrapperEle = nativeEle.querySelector('.popover-wrapper');
	        // Popover content width and height
	        var popoverEle = nativeEle.querySelector('.popover-content');
	        var popoverDim = popoverEle.getBoundingClientRect();
	        var popoverWidth = popoverDim.width;
	        var popoverHeight = popoverDim.height;
	        // Window body width and height
	        var bodyWidth = window.innerWidth;
	        var bodyHeight = window.innerHeight;
	        // If ev was passed, use that for target element
	        var targetDim = ev && ev.target && ev.target.getBoundingClientRect();
	        var targetTop = (targetDim && 'top' in targetDim) ? targetDim.top : (bodyHeight / 2) - (popoverHeight / 2);
	        var targetLeft = (targetDim && 'left' in targetDim) ? targetDim.left : (bodyWidth / 2) - (popoverWidth / 2);
	        var targetWidth = targetDim && targetDim.width || 0;
	        var targetHeight = targetDim && targetDim.height || 0;
	        var popoverCSS = {
	            top: targetTop,
	            left: targetLeft
	        };
	        // If the popover left is less than the padding it is off screen
	        // to the left so adjust it, else if the width of the popover
	        // exceeds the body width it is off screen to the right so adjust
	        if (popoverCSS.left < POPOVER_MD_BODY_PADDING) {
	            popoverCSS.left = POPOVER_MD_BODY_PADDING;
	        }
	        else if (popoverWidth + POPOVER_MD_BODY_PADDING + popoverCSS.left > bodyWidth) {
	            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_MD_BODY_PADDING;
	            originX = 'right';
	        }
	        // If the popover when popped down stretches past bottom of screen,
	        // make it pop up if there's room above
	        if (targetTop + targetHeight + popoverHeight > bodyHeight && targetTop - popoverHeight > 0) {
	            popoverCSS.top = targetTop - popoverHeight;
	            nativeEle.className = nativeEle.className + ' popover-bottom';
	            originY = 'bottom';
	        }
	        else if (targetTop + targetHeight + popoverHeight > bodyHeight) {
	            popoverEle.style.bottom = POPOVER_MD_BODY_PADDING + 'px';
	        }
	        popoverEle.style.top = popoverCSS.top + 'px';
	        popoverEle.style.left = popoverCSS.left + 'px';
	        popoverEle.style[CSS.transformOrigin] = originY + ' ' + originX;
	        // Since the transition starts before styling is done we
	        // want to wait for the styles to apply before showing the wrapper
	        popoverWrapperEle.style.opacity = '1';
	    };
	    PopoverTransition.prototype.iosPositionView = function (nativeEle, ev) {
	        var originY = 'top';
	        var originX = 'left';
	        var popoverWrapperEle = nativeEle.querySelector('.popover-wrapper');
	        // Popover content width and height
	        var popoverEle = nativeEle.querySelector('.popover-content');
	        var popoverDim = popoverEle.getBoundingClientRect();
	        var popoverWidth = popoverDim.width;
	        var popoverHeight = popoverDim.height;
	        // Window body width and height
	        var bodyWidth = window.innerWidth;
	        var bodyHeight = window.innerHeight;
	        // If ev was passed, use that for target element
	        var targetDim = ev && ev.target && ev.target.getBoundingClientRect();
	        var targetTop = (targetDim && 'top' in targetDim) ? targetDim.top : (bodyHeight / 2) - (popoverHeight / 2);
	        var targetLeft = (targetDim && 'left' in targetDim) ? targetDim.left : (bodyWidth / 2);
	        var targetWidth = targetDim && targetDim.width || 0;
	        var targetHeight = targetDim && targetDim.height || 0;
	        // The arrow that shows above the popover on iOS
	        var arrowEle = nativeEle.querySelector('.popover-arrow');
	        var arrowDim = arrowEle.getBoundingClientRect();
	        var arrowWidth = arrowDim.width;
	        var arrowHeight = arrowDim.height;
	        // If no ev was passed, hide the arrow
	        if (!targetDim) {
	            arrowEle.style.display = 'none';
	        }
	        var arrowCSS = {
	            top: targetTop + targetHeight,
	            left: targetLeft + (targetWidth / 2) - (arrowWidth / 2)
	        };
	        var popoverCSS = {
	            top: targetTop + targetHeight + (arrowHeight - 1),
	            left: targetLeft + (targetWidth / 2) - (popoverWidth / 2)
	        };
	        // If the popover left is less than the padding it is off screen
	        // to the left so adjust it, else if the width of the popover
	        // exceeds the body width it is off screen to the right so adjust
	        if (popoverCSS.left < POPOVER_IOS_BODY_PADDING) {
	            popoverCSS.left = POPOVER_IOS_BODY_PADDING;
	        }
	        else if (popoverWidth + POPOVER_IOS_BODY_PADDING + popoverCSS.left > bodyWidth) {
	            popoverCSS.left = bodyWidth - popoverWidth - POPOVER_IOS_BODY_PADDING;
	            originX = 'right';
	        }
	        // If the popover when popped down stretches past bottom of screen,
	        // make it pop up if there's room above
	        if (targetTop + targetHeight + popoverHeight > bodyHeight && targetTop - popoverHeight > 0) {
	            arrowCSS.top = targetTop - (arrowHeight + 1);
	            popoverCSS.top = targetTop - popoverHeight - (arrowHeight - 1);
	            nativeEle.className = nativeEle.className + ' popover-bottom';
	            originY = 'bottom';
	        }
	        else if (targetTop + targetHeight + popoverHeight > bodyHeight) {
	            popoverEle.style.bottom = POPOVER_IOS_BODY_PADDING + '%';
	        }
	        arrowEle.style.top = arrowCSS.top + 'px';
	        arrowEle.style.left = arrowCSS.left + 'px';
	        popoverEle.style.top = popoverCSS.top + 'px';
	        popoverEle.style.left = popoverCSS.left + 'px';
	        popoverEle.style[CSS.transformOrigin] = originY + ' ' + originX;
	        // Since the transition starts before styling is done we
	        // want to wait for the styles to apply before showing the wrapper
	        popoverWrapperEle.style.opacity = '1';
	    };
	    return PopoverTransition;
	}(PageTransition));
	var PopoverPopIn = (function (_super) {
	    __extends$35(PopoverPopIn, _super);
	    function PopoverPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        this.opts = opts;
	        var ele = enteringView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.popover-wrapper'));
	        wrapper.fromTo('opacity', 0.01, 1);
	        backdrop.fromTo('opacity', 0.01, 0.08);
	        this
	            .easing('ease')
	            .duration(100)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    PopoverPopIn.prototype.play = function () {
	        var _this = this;
	        nativeRaf(function () {
	            _this.iosPositionView(_this.enteringView.pageRef().nativeElement, _this.opts.ev);
	            _super.prototype.play.call(_this);
	        });
	    };
	    return PopoverPopIn;
	}(PopoverTransition));
	PageTransition.register('popover-pop-in', PopoverPopIn);
	var PopoverPopOut = (function (_super) {
	    __extends$35(PopoverPopOut, _super);
	    function PopoverPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        this.opts = opts;
	        var ele = leavingView.pageRef().nativeElement;
	        var backdrop = new Animation(ele.querySelector('ion-backdrop'));
	        var wrapper = new Animation(ele.querySelector('.popover-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0);
	        backdrop.fromTo('opacity', 0.08, 0);
	        this
	            .easing('ease')
	            .duration(500)
	            .add(backdrop)
	            .add(wrapper);
	    }
	    return PopoverPopOut;
	}(PopoverTransition));
	PageTransition.register('popover-pop-out', PopoverPopOut);
	var PopoverMdPopIn = (function (_super) {
	    __extends$35(PopoverMdPopIn, _super);
	    function PopoverMdPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        this.opts = opts;
	        var ele = enteringView.pageRef().nativeElement;
	        var content = new Animation(ele.querySelector('.popover-content'));
	        var viewport = new Animation(ele.querySelector('.popover-viewport'));
	        content.fromTo('scale', 0.001, 1);
	        viewport.fromTo('opacity', 0.01, 1);
	        this
	            .easing('cubic-bezier(0.36,0.66,0.04,1)')
	            .duration(300)
	            .add(content)
	            .add(viewport);
	    }
	    PopoverMdPopIn.prototype.play = function () {
	        var _this = this;
	        nativeRaf(function () {
	            _this.mdPositionView(_this.enteringView.pageRef().nativeElement, _this.opts.ev);
	            _super.prototype.play.call(_this);
	        });
	    };
	    return PopoverMdPopIn;
	}(PopoverTransition));
	PageTransition.register('popover-md-pop-in', PopoverMdPopIn);
	var PopoverMdPopOut = (function (_super) {
	    __extends$35(PopoverMdPopOut, _super);
	    function PopoverMdPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        this.opts = opts;
	        var ele = leavingView.pageRef().nativeElement;
	        var wrapper = new Animation(ele.querySelector('.popover-wrapper'));
	        wrapper.fromTo('opacity', 0.99, 0);
	        this
	            .easing('ease')
	            .duration(500)
	            .fromTo('opacity', 0.01, 1)
	            .add(wrapper);
	    }
	    return PopoverMdPopOut;
	}(PopoverTransition));
	PageTransition.register('popover-md-pop-out', PopoverMdPopOut);
	var popoverIds = -1;
	var POPOVER_IOS_BODY_PADDING = 2;
	var POPOVER_MD_BODY_PADDING = 12;

	var __extends$34 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var Popover = (function (_super) {
	    __extends$34(Popover, _super);
	    function Popover(app, componentType, data, opts) {
	        if (data === void 0) { data = {}; }
	        if (opts === void 0) { opts = {}; }
	        opts.showBackdrop = isPresent$5(opts.showBackdrop) ? !!opts.showBackdrop : true;
	        opts.enableBackdropDismiss = isPresent$5(opts.enableBackdropDismiss) ? !!opts.enableBackdropDismiss : true;
	        data.componentType = componentType;
	        data.opts = opts;
	        _super.call(this, PopoverCmp, data);
	        this._app = app;
	        this.isOverlay = true;
	        // by default, popovers should not fire lifecycle events of other views
	        // for example, when a popover enters, the current active view should
	        // not fire its lifecycle events because it's not conceptually leaving
	        this.fireOtherLifecycles = false;
	    }
	    /**
	     * @private
	     */
	    Popover.prototype.getTransitionName = function (direction) {
	        var key = (direction === 'back' ? 'popoverLeave' : 'popoverEnter');
	        return this._nav && this._nav.config.get(key);
	    };
	    /**
	     * Present the popover instance.
	     *
	     * @param {NavOptions} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    Popover.prototype.present = function (navOptions) {
	        if (navOptions === void 0) { navOptions = {}; }
	        return this._app.present(this, navOptions);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please inject PopoverController instead
	     */
	    Popover.create = function (componentType, data, opts) {
	        if (data === void 0) { data = {}; }
	        if (opts === void 0) { opts = {}; }
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('Popover.create(..) has been deprecated. Please inject PopoverController instead');
	    };
	    return Popover;
	}(ViewController));
	var PopoverController = (function () {
	    function PopoverController(_app) {
	        this._app = _app;
	    }
	    /**
	     * Present a popover. See below for options
	     * @param {object} componentType The Popover
	     * @param {object} data Any data to pass to the Popover view
	     * @param {PopoverOptions} opts Popover options
	     */
	    PopoverController.prototype.create = function (componentType, data, opts) {
	        if (data === void 0) { data = {}; }
	        if (opts === void 0) { opts = {}; }
	        return new Popover(this._app, componentType, data, opts);
	    };
	    /** @nocollapse */
	    PopoverController.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    PopoverController.ctorParameters = [
	        { type: App, },
	    ];
	    return PopoverController;
	}());

	var Activator = (function () {
	    function Activator(app, config) {
	        this.app = app;
	        this._queue = [];
	        this._active = [];
	        this._css = config.get('activatedClass') || 'activated';
	    }
	    Activator.prototype.downAction = function (ev, activatableEle, startCoord) {
	        // the user just pressed down
	        var self = this;
	        if (self.disableActivated(ev)) {
	            return;
	        }
	        // queue to have this element activated
	        self._queue.push(activatableEle);
	        rafFrames(2, function () {
	            var activatableEle;
	            for (var i = 0; i < self._queue.length; i++) {
	                activatableEle = self._queue[i];
	                if (activatableEle && activatableEle.parentNode) {
	                    self._active.push(activatableEle);
	                    activatableEle.classList.add(self._css);
	                }
	            }
	            self._queue = [];
	        });
	    };
	    Activator.prototype.upAction = function (ev, activatableEle, startCoord) {
	        var _this = this;
	        // the user was pressing down, then just let up
	        rafFrames(CLEAR_STATE_DEFERS, function () {
	            _this.clearState();
	        });
	    };
	    Activator.prototype.clearState = function () {
	        var _this = this;
	        // all states should return to normal
	        if (!this.app.isEnabled()) {
	            // the app is actively disabled, so don't bother deactivating anything.
	            // this makes it easier on the GPU so it doesn't have to redraw any
	            // buttons during a transition. This will retry in XX milliseconds.
	            nativeTimeout(function () {
	                _this.clearState();
	            }, 600);
	        }
	        else {
	            // not actively transitioning, good to deactivate any elements
	            this.deactivate();
	        }
	    };
	    Activator.prototype.deactivate = function () {
	        // remove the active class from all active elements
	        var self = this;
	        self._queue = [];
	        rafFrames(2, function () {
	            for (var i = 0; i < self._active.length; i++) {
	                self._active[i].classList.remove(self._css);
	            }
	            self._active = [];
	        });
	    };
	    Activator.prototype.disableActivated = function (ev) {
	        if (ev.defaultPrevented)
	            return true;
	        var targetEle = ev.target;
	        for (var x = 0; x < 4; x++) {
	            if (!targetEle)
	                break;
	            if (targetEle.hasAttribute('disable-activated'))
	                return true;
	            targetEle = targetEle.parentElement;
	        }
	        return false;
	    };
	    return Activator;
	}());
	var CLEAR_STATE_DEFERS = 5;

	var __extends$36 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var RippleActivator = (function (_super) {
	    __extends$36(RippleActivator, _super);
	    function RippleActivator(app, config) {
	        _super.call(this, app, config);
	    }
	    RippleActivator.prototype.downAction = function (ev, activatableEle, startCoord) {
	        var self = this;
	        if (self.disableActivated(ev)) {
	            return;
	        }
	        // queue to have this element activated
	        self._queue.push(activatableEle);
	        nativeRaf(function () {
	            for (var i = 0; i < self._queue.length; i++) {
	                var queuedEle = self._queue[i];
	                if (queuedEle && queuedEle.parentNode) {
	                    self._active.push(queuedEle);
	                    // DOM WRITE
	                    queuedEle.classList.add(self._css);
	                    var j = queuedEle.childElementCount;
	                    while (j--) {
	                        var rippleEle = queuedEle.children[j];
	                        if (rippleEle.tagName === 'ION-BUTTON-EFFECT') {
	                            // DOM WRITE
	                            rippleEle.style.left = '-9999px';
	                            rippleEle.style.opacity = '';
	                            rippleEle.style[CSS.transform] = 'scale(0.001) translateZ(0px)';
	                            rippleEle.style[CSS.transition] = '';
	                            // DOM READ
	                            var clientRect = activatableEle.getBoundingClientRect();
	                            rippleEle.$top = clientRect.top;
	                            rippleEle.$left = clientRect.left;
	                            rippleEle.$width = clientRect.width;
	                            rippleEle.$height = clientRect.height;
	                            break;
	                        }
	                    }
	                }
	            }
	            self._queue = [];
	        });
	    };
	    RippleActivator.prototype.upAction = function (ev, activatableEle, startCoord) {
	        var self = this;
	        if (!hasPointerMoved(6, startCoord, pointerCoord(ev))) {
	            var i = activatableEle.childElementCount;
	            while (i--) {
	                var rippleEle = activatableEle.children[i];
	                if (rippleEle.tagName === 'ION-BUTTON-EFFECT') {
	                    var clientPointerX = (startCoord.x - rippleEle.$left);
	                    var clientPointerY = (startCoord.y - rippleEle.$top);
	                    var x = Math.max(Math.abs(rippleEle.$width - clientPointerX), clientPointerX) * 2;
	                    var y = Math.max(Math.abs(rippleEle.$height - clientPointerY), clientPointerY) * 2;
	                    var diameter = Math.min(Math.max(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), 64), 240);
	                    if (activatableEle.hasAttribute('ion-item')) {
	                        diameter = Math.min(diameter, 140);
	                    }
	                    var radius = Math.sqrt(rippleEle.$width + rippleEle.$height);
	                    var scaleTransitionDuration = Math.max(1600 * Math.sqrt(radius / TOUCH_DOWN_ACCEL) + 0.5, 260);
	                    var opacityTransitionDuration = scaleTransitionDuration * 0.7;
	                    var opacityTransitionDelay = scaleTransitionDuration - opacityTransitionDuration;
	                    // DOM WRITE
	                    rippleEle.style.width = rippleEle.style.height = diameter + 'px';
	                    rippleEle.style.marginTop = rippleEle.style.marginLeft = -(diameter / 2) + 'px';
	                    rippleEle.style.left = clientPointerX + 'px';
	                    rippleEle.style.top = clientPointerY + 'px';
	                    rippleEle.style.opacity = '0';
	                    rippleEle.style[CSS.transform] = 'scale(1) translateZ(0px)';
	                    rippleEle.style[CSS.transition] = 'transform ' +
	                        scaleTransitionDuration +
	                        'ms,opacity ' +
	                        opacityTransitionDuration +
	                        'ms ' +
	                        opacityTransitionDelay + 'ms';
	                }
	            }
	        }
	        _super.prototype.upAction.call(this, ev, activatableEle, startCoord);
	    };
	    RippleActivator.prototype.deactivate = function () {
	        // remove the active class from all active elements
	        var self = this;
	        self._queue = [];
	        rafFrames(2, function () {
	            for (var i = 0; i < self._active.length; i++) {
	                self._active[i].classList.remove(self._css);
	            }
	            self._active = [];
	        });
	    };
	    return RippleActivator;
	}(Activator));
	var TOUCH_DOWN_ACCEL = 300;

	var TapClick = (function () {
	    function TapClick(config, app, zone) {
	        this.app = app;
	        this.lastTouch = 0;
	        this.disableClick = 0;
	        this.lastActivated = 0;
	        var self = this;
	        if (config.get('activator') === 'ripple') {
	            self.activator = new RippleActivator(app, config);
	        }
	        else if (config.get('activator') === 'highlight') {
	            self.activator = new Activator(app, config);
	        }
	        self.usePolyfill = (config.get('tapPolyfill') === true);
	        zone.runOutsideAngular(function () {
	            addListener('click', self.click.bind(self), true);
	            addListener('touchstart', self.touchStart.bind(self));
	            addListener('touchend', self.touchEnd.bind(self));
	            addListener('touchcancel', self.pointerCancel.bind(self));
	            addListener('mousedown', self.mouseDown.bind(self), true);
	            addListener('mouseup', self.mouseUp.bind(self), true);
	        });
	        self.pointerMove = function (ev) {
	            if (hasPointerMoved(POINTER_MOVE_UNTIL_CANCEL, self.startCoord, pointerCoord(ev))) {
	                self.pointerCancel(ev);
	            }
	        };
	    }
	    TapClick.prototype.touchStart = function (ev) {
	        this.lastTouch = Date.now();
	        this.pointerStart(ev);
	    };
	    TapClick.prototype.touchEnd = function (ev) {
	        this.lastTouch = Date.now();
	        if (this.usePolyfill && this.startCoord && this.app.isEnabled()) {
	            // only dispatch mouse click events from a touchend event
	            // when tapPolyfill config is true, and the startCoordand endCoord
	            // are not too far off from each other
	            var endCoord = pointerCoord(ev);
	            if (!hasPointerMoved(POINTER_TOLERANCE, this.startCoord, endCoord)) {
	                // prevent native mouse click events for XX amount of time
	                this.disableClick = this.lastTouch + DISABLE_NATIVE_CLICK_AMOUNT;
	                if (this.app.isScrolling()) {
	                    // do not fire off a click event while the app was scrolling
	                    console.debug('click from touch prevented by scrolling ' + Date.now());
	                }
	                else {
	                    // dispatch a mouse click event
	                    console.debug('create click from touch ' + Date.now());
	                    var clickEvent = document.createEvent('MouseEvents');
	                    clickEvent.initMouseEvent('click', true, true, window, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
	                    clickEvent.isIonicTap = true;
	                    ev.target.dispatchEvent(clickEvent);
	                }
	            }
	        }
	        this.pointerEnd(ev);
	    };
	    TapClick.prototype.mouseDown = function (ev) {
	        if (this.isDisabledNativeClick()) {
	            console.debug('mouseDown prevent ' + ev.target.tagName + ' ' + Date.now());
	            // does not prevent default on purpose
	            // so native blur events from inputs can happen
	            ev.stopPropagation();
	        }
	        else if (this.lastTouch + DISABLE_NATIVE_CLICK_AMOUNT < Date.now()) {
	            this.pointerStart(ev);
	        }
	    };
	    TapClick.prototype.mouseUp = function (ev) {
	        if (this.isDisabledNativeClick()) {
	            console.debug('mouseUp prevent ' + ev.target.tagName + ' ' + Date.now());
	            ev.preventDefault();
	            ev.stopPropagation();
	        }
	        if (this.lastTouch + DISABLE_NATIVE_CLICK_AMOUNT < Date.now()) {
	            this.pointerEnd(ev);
	        }
	    };
	    TapClick.prototype.pointerStart = function (ev) {
	        var activatableEle = getActivatableTarget(ev.target);
	        if (activatableEle) {
	            this.startCoord = pointerCoord(ev);
	            var now = Date.now();
	            if (this.lastActivated + 150 < now && !this.app.isScrolling()) {
	                this.activator && this.activator.downAction(ev, activatableEle, this.startCoord);
	                this.lastActivated = now;
	            }
	            this.moveListeners(true);
	        }
	        else {
	            this.startCoord = null;
	        }
	    };
	    TapClick.prototype.pointerEnd = function (ev) {
	        if (this.startCoord && this.activator) {
	            var activatableEle = getActivatableTarget(ev.target);
	            if (activatableEle) {
	                this.activator.upAction(ev, activatableEle, this.startCoord);
	            }
	        }
	        this.moveListeners(false);
	    };
	    TapClick.prototype.pointerCancel = function (ev) {
	        console.debug('pointerCancel from ' + ev.type + ' ' + Date.now());
	        this.activator && this.activator.clearState();
	        this.moveListeners(false);
	    };
	    TapClick.prototype.moveListeners = function (shouldAdd) {
	        removeListener(this.usePolyfill ? 'touchmove' : 'mousemove', this.pointerMove);
	        if (shouldAdd) {
	            addListener(this.usePolyfill ? 'touchmove' : 'mousemove', this.pointerMove);
	        }
	    };
	    TapClick.prototype.click = function (ev) {
	        var preventReason = null;
	        if (!this.app.isEnabled()) {
	            preventReason = 'appDisabled';
	        }
	        else if (!ev.isIonicTap && this.isDisabledNativeClick()) {
	            preventReason = 'nativeClick';
	        }
	        if (preventReason !== null) {
	            console.debug('click prevent ' + preventReason + ' ' + Date.now());
	            ev.preventDefault();
	            ev.stopPropagation();
	        }
	    };
	    TapClick.prototype.isDisabledNativeClick = function () {
	        return this.disableClick > Date.now();
	    };
	    /** @nocollapse */
	    TapClick.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    TapClick.ctorParameters = [
	        { type: Config, },
	        { type: App, },
	        { type: NgZone, },
	    ];
	    return TapClick;
	}());
	function getActivatableTarget(ele) {
	    var targetEle = ele;
	    for (var x = 0; x < 4; x++) {
	        if (!targetEle)
	            break;
	        if (isActivatable(targetEle))
	            return targetEle;
	        targetEle = targetEle.parentElement;
	    }
	    return null;
	}
	/**
	 * @private
	 */
	var isActivatable = function (ele) {
	    if (ACTIVATABLE_ELEMENTS.test(ele.tagName)) {
	        return true;
	    }
	    var attributes = ele.attributes;
	    for (var i = 0, l = attributes.length; i < l; i++) {
	        if (ACTIVATABLE_ATTRIBUTES.test(attributes[i].name)) {
	            return true;
	        }
	    }
	    return false;
	};
	function addListener(type, listener, useCapture) {
	    document.addEventListener(type, listener, useCapture);
	}
	function removeListener(type, listener) {
	    document.removeEventListener(type, listener);
	}
	var ACTIVATABLE_ELEMENTS = /^(A|BUTTON)$/;
	var ACTIVATABLE_ATTRIBUTES = /tappable|button/i;
	var POINTER_TOLERANCE = 4;
	var POINTER_MOVE_UNTIL_CANCEL = 10;
	var DISABLE_NATIVE_CLICK_AMOUNT = 2500;

	var __extends$38 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ToastCmp = (function () {
	    function ToastCmp(_nav, _viewCtrl, _config, _elementRef, params, renderer) {
	        this._nav = _nav;
	        this._viewCtrl = _viewCtrl;
	        this._config = _config;
	        this._elementRef = _elementRef;
	        this.dismissTimeout = undefined;
	        this.d = params.data;
	        if (this.d.cssClass) {
	            renderer.setElementClass(_elementRef.nativeElement, this.d.cssClass, true);
	        }
	        this.id = (++toastIds);
	        if (this.d.message) {
	            this.hdrId = 'toast-hdr-' + this.id;
	        }
	    }
	    ToastCmp.prototype.ngAfterViewInit = function () {
	        var _this = this;
	        // if there's a `duration` set, automatically dismiss.
	        if (this.d.duration) {
	            this.dismissTimeout =
	                setTimeout(function () {
	                    _this.dismiss('backdrop');
	                }, this.d.duration);
	        }
	        this.enabled = true;
	    };
	    ToastCmp.prototype.ionViewDidEnter = function () {
	        var activeElement = document.activeElement;
	        if (activeElement) {
	            activeElement.blur();
	        }
	        var focusableEle = this._elementRef.nativeElement.querySelector('button');
	        if (focusableEle) {
	            focusableEle.focus();
	        }
	    };
	    ToastCmp.prototype.cbClick = function () {
	        if (this.enabled) {
	            this.dismiss('close');
	        }
	    };
	    ToastCmp.prototype.dismiss = function (role) {
	        clearTimeout(this.dismissTimeout);
	        this.dismissTimeout = undefined;
	        return this._viewCtrl.dismiss(null, role);
	    };
	    /** @nocollapse */
	    ToastCmp.decorators = [
	        { type: Component, args: [{
	                    selector: 'ion-toast',
	                    template: "\n    <div class=\"toast-wrapper\"\n      [class.toast-bottom]=\"d.position === 'bottom'\"\n      [class.toast-middle]=\"d.position === 'middle'\"\n      [class.toast-top]=\"d.position === 'top'\">\n      <div class=\"toast-container\">\n        <div class=\"toast-message\" id=\"{{hdrId}}\" *ngIf=\"d.message\">{{d.message}}</div>\n        <button clear class=\"toast-button\" *ngIf=\"d.showCloseButton\" (click)=\"cbClick()\">\n          {{ d.closeButtonText || 'Close' }}\n         </button>\n      </div>\n    </div>\n  ",
	                    directives: [NgIf],
	                    host: {
	                        'role': 'dialog',
	                        '[attr.aria-labelledby]': 'hdrId',
	                        '[attr.aria-describedby]': 'descId',
	                    },
	                },] },
	    ];
	    /** @nocollapse */
	    ToastCmp.ctorParameters = [
	        { type: NavController, },
	        { type: ViewController, },
	        { type: Config, },
	        { type: ElementRef, },
	        { type: NavParams, },
	        { type: Renderer, },
	    ];
	    return ToastCmp;
	}());
	var ToastSlideIn = (function (_super) {
	    __extends$38(ToastSlideIn, _super);
	    function ToastSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        // DOM READS
	        var ele = enteringView.pageRef().nativeElement;
	        var wrapperEle = ele.querySelector('.toast-wrapper');
	        var wrapper = new Animation(wrapperEle);
	        if (enteringView.data && enteringView.data.position === TOAST_POSITION_TOP$1) {
	            // top
	            // by default, it is -100% hidden (above the screen)
	            // so move from that to 10px below top: 0px;
	            wrapper.fromTo('translateY', '-100%', 10 + "px");
	        }
	        else if (enteringView.data && enteringView.data.position === TOAST_POSITION_MIDDLE$1) {
	            // Middle
	            // just center it and fade it in
	            var topPosition = Math.floor(ele.clientHeight / 2 - wrapperEle.clientHeight / 2);
	            // DOM WRITE
	            wrapperEle.style.top = topPosition + "px";
	            wrapper.fromTo('opacity', 0.01, 1);
	        }
	        else {
	            // bottom
	            // by default, it is 100% hidden (below the screen),
	            // so move from that to 10 px above bottom: 0px
	            wrapper.fromTo('translateY', '100%', (0 - 10) + "px");
	        }
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(wrapper);
	    }
	    return ToastSlideIn;
	}(Transition));
	var ToastSlideOut = (function (_super) {
	    __extends$38(ToastSlideOut, _super);
	    function ToastSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var wrapperEle = ele.querySelector('.toast-wrapper');
	        var wrapper = new Animation(wrapperEle);
	        if (leavingView.data && leavingView.data.position === TOAST_POSITION_TOP$1) {
	            // top
	            // reverse arguments from enter transition
	            wrapper.fromTo('translateY', 10 + "px", '-100%');
	        }
	        else if (leavingView.data && leavingView.data.position === TOAST_POSITION_MIDDLE$1) {
	            // Middle
	            // just fade it out
	            wrapper.fromTo('opacity', 0.99, 0);
	        }
	        else {
	            // bottom
	            // reverse arguments from enter transition
	            wrapper.fromTo('translateY', (0 - 10) + "px", '100%');
	        }
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(300).add(wrapper);
	    }
	    return ToastSlideOut;
	}(Transition));
	var ToastMdSlideIn = (function (_super) {
	    __extends$38(ToastMdSlideIn, _super);
	    function ToastMdSlideIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        // DOM reads
	        var ele = enteringView.pageRef().nativeElement;
	        var wrapperEle = ele.querySelector('.toast-wrapper');
	        var wrapper = new Animation(wrapperEle);
	        if (enteringView.data && enteringView.data.position === TOAST_POSITION_TOP$1) {
	            // top
	            // by default, it is -100% hidden (above the screen)
	            // so move from that to top: 0px;
	            wrapper.fromTo('translateY', '-100%', "0%");
	        }
	        else if (enteringView.data && enteringView.data.position === TOAST_POSITION_MIDDLE$1) {
	            // Middle
	            // just center it and fade it in
	            var topPosition = Math.floor(ele.clientHeight / 2 - wrapperEle.clientHeight / 2);
	            // DOM WRITE
	            wrapperEle.style.top = topPosition + "px";
	            wrapper.fromTo('opacity', 0.01, 1);
	        }
	        else {
	            // bottom
	            // by default, it is 100% hidden (below the screen),
	            // so move from that to bottom: 0px
	            wrapper.fromTo('translateY', '100%', "0%");
	        }
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(400).add(wrapper);
	    }
	    return ToastMdSlideIn;
	}(Transition));
	var ToastMdSlideOut = (function (_super) {
	    __extends$38(ToastMdSlideOut, _super);
	    function ToastMdSlideOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = leavingView.pageRef().nativeElement;
	        var wrapperEle = ele.querySelector('.toast-wrapper');
	        var wrapper = new Animation(wrapperEle);
	        if (leavingView.data && leavingView.data.position === TOAST_POSITION_TOP$1) {
	            // top
	            // reverse arguments from enter transition
	            wrapper.fromTo('translateY', 0 + "%", '-100%');
	        }
	        else if (leavingView.data && leavingView.data.position === TOAST_POSITION_MIDDLE$1) {
	            // Middle
	            // just fade it out
	            wrapper.fromTo('opacity', 0.99, 0);
	        }
	        else {
	            // bottom
	            // reverse arguments from enter transition
	            wrapper.fromTo('translateY', 0 + "%", '100%');
	        }
	        this.easing('cubic-bezier(.36,.66,.04,1)').duration(450).add(wrapper);
	    }
	    return ToastMdSlideOut;
	}(Transition));
	var ToastWpPopIn = (function (_super) {
	    __extends$38(ToastWpPopIn, _super);
	    function ToastWpPopIn(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        var ele = enteringView.pageRef().nativeElement;
	        var wrapperEle = ele.querySelector('.toast-wrapper');
	        var wrapper = new Animation(wrapperEle);
	        if (enteringView.data && enteringView.data.position === TOAST_POSITION_TOP$1) {
	            // top
	            wrapper.fromTo('opacity', 0.01, 1);
	            wrapper.fromTo('scale', 1.3, 1);
	        }
	        else if (enteringView.data && enteringView.data.position === TOAST_POSITION_MIDDLE$1) {
	            // Middle
	            // just center it and fade it in
	            var topPosition = Math.floor(ele.clientHeight / 2 - wrapperEle.clientHeight / 2);
	            // DOM WRITE
	            wrapperEle.style.top = topPosition + "px";
	            wrapper.fromTo('opacity', 0.01, 1);
	            wrapper.fromTo('scale', 1.3, 1);
	        }
	        else {
	            // bottom
	            wrapper.fromTo('opacity', 0.01, 1);
	            wrapper.fromTo('scale', 1.3, 1);
	        }
	        this.easing('cubic-bezier(0,0 0.05,1)').duration(200).add(wrapper);
	    }
	    return ToastWpPopIn;
	}(Transition));
	var ToastWpPopOut = (function (_super) {
	    __extends$38(ToastWpPopOut, _super);
	    function ToastWpPopOut(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        // DOM reads
	        var ele = leavingView.pageRef().nativeElement;
	        var wrapperEle = ele.querySelector('.toast-wrapper');
	        var wrapper = new Animation(wrapperEle);
	        if (leavingView.data && leavingView.data.position === TOAST_POSITION_TOP$1) {
	            // top
	            // reverse arguments from enter transition
	            wrapper.fromTo('opacity', 0.99, 0);
	            wrapper.fromTo('scale', 1, 1.3);
	        }
	        else if (leavingView.data && leavingView.data.position === TOAST_POSITION_MIDDLE$1) {
	            // Middle
	            // just fade it out
	            wrapper.fromTo('opacity', 0.99, 0);
	            wrapper.fromTo('scale', 1, 1.3);
	        }
	        else {
	            // bottom
	            // reverse arguments from enter transition
	            wrapper.fromTo('opacity', 0.99, 0);
	            wrapper.fromTo('scale', 1, 1.3);
	        }
	        // DOM writes
	        var EASE = 'ease-out';
	        var DURATION = 150;
	        this.easing(EASE).duration(DURATION).add(wrapper);
	    }
	    return ToastWpPopOut;
	}(Transition));
	Transition.register('toast-slide-in', ToastSlideIn);
	Transition.register('toast-slide-out', ToastSlideOut);
	Transition.register('toast-md-slide-in', ToastMdSlideIn);
	Transition.register('toast-md-slide-out', ToastMdSlideOut);
	Transition.register('toast-wp-slide-out', ToastWpPopOut);
	Transition.register('toast-wp-slide-in', ToastWpPopIn);
	var toastIds = -1;
	var TOAST_POSITION_TOP$1 = 'top';
	var TOAST_POSITION_MIDDLE$1 = 'middle';

	var __extends$37 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 */
	var Toast = (function (_super) {
	    __extends$37(Toast, _super);
	    function Toast(app, opts) {
	        if (opts === void 0) { opts = {}; }
	        opts.dismissOnPageChange = isPresent$5(opts.dismissOnPageChange) ? !!opts.dismissOnPageChange : false;
	        _super.call(this, ToastCmp, opts);
	        this._app = app;
	        // set the position to the bottom if not provided
	        if (!opts.position || !this.isValidPosition(opts.position)) {
	            opts.position = TOAST_POSITION_BOTTOM;
	        }
	        this.isOverlay = true;
	        // by default, toasts should not fire lifecycle events of other views
	        // for example, when an toast enters, the current active view should
	        // not fire its lifecycle events because it's not conceptually leaving
	        this.fireOtherLifecycles = false;
	    }
	    /**
	    * @private
	    */
	    Toast.prototype.getTransitionName = function (direction) {
	        var key = 'toast' + (direction === 'back' ? 'Leave' : 'Enter');
	        return this._nav && this._nav.config.get(key);
	    };
	    /**
	    * @private
	    */
	    Toast.prototype.isValidPosition = function (position) {
	        return position === TOAST_POSITION_TOP || position === TOAST_POSITION_MIDDLE || position === TOAST_POSITION_BOTTOM;
	    };
	    /**
	     * @param {string} message  Toast message content
	     */
	    Toast.prototype.setMessage = function (message) {
	        this.data.message = message;
	    };
	    /**
	     * Present the toast instance.
	     *
	     * @param {NavOptions} [opts={}] Nav options to go with this transition.
	     * @returns {Promise} Returns a promise which is resolved when the transition has completed.
	     */
	    Toast.prototype.present = function (navOptions) {
	        if (navOptions === void 0) { navOptions = {}; }
	        return this._app.present(this, navOptions);
	    };
	    /**
	     * @private
	     * DEPRECATED: Please inject ToastController instead
	     */
	    Toast.create = function (opt) {
	        // deprecated warning: added beta.11 2016-06-27
	        console.warn('Toast.create(..) has been deprecated. Please inject ToastController instead');
	    };
	    return Toast;
	}(ViewController));
	var ToastController = (function () {
	    function ToastController(_app) {
	        this._app = _app;
	    }
	    /**
	     * Create a new toast component. See options below
	     * @param {ToastOptions} opts Toast options. See the above table for available options.
	     */
	    ToastController.prototype.create = function (opts) {
	        if (opts === void 0) { opts = {}; }
	        return new Toast(this._app, opts);
	    };
	    /** @nocollapse */
	    ToastController.decorators = [
	        { type: Injectable },
	    ];
	    /** @nocollapse */
	    ToastController.ctorParameters = [
	        { type: App, },
	    ];
	    return ToastController;
	}());
	var TOAST_POSITION_TOP = 'top';
	var TOAST_POSITION_MIDDLE = 'middle';
	var TOAST_POSITION_BOTTOM = 'bottom';

	/**
	 * @private
	 * Provide multi-language and i18n support in your app. Translate works by
	 * mapping full strings to language translated ones. That means that you don't
	 * need to provide strings for your default language, just new languages.
	 *
	 * Note: The Angular team will be building an
	 * [Localization/Internationalization](https://docs.google.com/document/d/1mwyOFsAD-bPoXTk3Hthq0CAcGXCUw-BtTJMR4nGTY-0/view#heading=h.ixg45w3363q)
	 * provider, so this Translation provider may not be further developed.
	 *
	 * @usage
	 * ```js
	 * Translate.translations({
	 *   'de': {
	 *     'Welcome to MyApp': 'Willkommen auf'
	 *   }
	 * })
	 *
	 * Changing the default language:
	 *
	 * Translate.setLanguage('de');
	 * ```
	 *
	 * Usage in a template:
	 *
	 * ```js
	 * <span>{{ 'Welcome to MyApp' | translate }}
	 * ```
	 */
	var Translate = (function () {
	    function Translate() {
	        this._transMap = {};
	        this._language = {};
	    }
	    Translate.prototype.translations = function (lang, map) {
	        this._transMap[lang] = map;
	    };
	    Translate.prototype.setLanguage = function (lang) {
	        this._language = lang;
	    };
	    Translate.prototype.getTranslations = function (lang) {
	        return this._transMap[lang];
	    };
	    Translate.prototype.translate = function (key, lang) {
	        // If the language isn't specified and we have no overridden one, return the string passed.
	        if (!lang && !this._language) {
	            return key;
	        }
	        var setLanguage = lang || this._language;
	        var map = this.getTranslations(setLanguage);
	        if (!map) {
	            console.warn('I18N: No translation for key', key, 'using language', setLanguage);
	            return '';
	        }
	        return this._getTranslation(map, key);
	    };
	    Translate.prototype._getTranslation = function (map, key) {
	        return map && map[key] || '';
	    };
	    return Translate;
	}());

	/**
	 * @private
	 */
	function ionicProviders(customProviders, config) {
	    // create an instance of Config
	    if (!(config instanceof Config)) {
	        config = new Config(config);
	    }
	    // enable production mode if config set to true
	    if (config.getBoolean('prodMode')) {
	        enableProdMode();
	    }
	    // create an instance of Platform
	    var platform = new Platform();
	    // initialize platform
	    platform.setUrl(window.location.href);
	    platform.setUserAgent(window.navigator.userAgent);
	    platform.setNavigatorPlatform(window.navigator.platform);
	    platform.load();
	    config.setPlatform(platform);
	    var events = new Events();
	    var featureDetect = new FeatureDetect();
	    setupDom(window, document, config, platform, featureDetect);
	    bindEvents(window, document, platform, events);
	    var providers = [
	        ActionSheetController,
	        AlertController,
	        App,
	        provide(Config, { useValue: config }),
	        disableDeprecatedForms(),
	        provide(Events, { useValue: events }),
	        provide(FeatureDetect, { useValue: featureDetect }),
	        Form,
	        HTTP_PROVIDERS,
	        Keyboard,
	        LoadingController,
	        MenuController,
	        ModalController,
	        PickerController,
	        PopoverController,
	        provide(Platform, { useValue: platform }),
	        provide(PLATFORM_DIRECTIVES, { useValue: IONIC_DIRECTIVES, multi: true }),
	        provideForms(),
	        TapClick,
	        ToastController,
	        Translate,
	    ];
	    if (isPresent$5(customProviders)) {
	        providers.push(customProviders);
	    }
	    return providers;
	}
	function setupDom(window, document, config, platform, featureDetect) {
	    var bodyEle = document.body;
	    var mode = config.get('mode');
	    // if dynamic mode links have been added the fire up the correct one
	    var modeLinkAttr = mode + '-href';
	    var linkEle = document.head.querySelector('link[' + modeLinkAttr + ']');
	    if (linkEle) {
	        var href = linkEle.getAttribute(modeLinkAttr);
	        linkEle.removeAttribute(modeLinkAttr);
	        linkEle.href = href;
	    }
	    // set the mode class name
	    // ios/md/wp
	    bodyEle.classList.add(mode);
	    // language and direction
	    platform.setDir(document.documentElement.dir, false);
	    platform.setLang(document.documentElement.lang, false);
	    var versions = platform.versions();
	    platform.platforms().forEach(function (platformName) {
	        // platform-ios
	        var platformClass = 'platform-' + platformName;
	        bodyEle.classList.add(platformClass);
	        var platformVersion = versions[platformName];
	        if (platformVersion) {
	            // platform-ios9
	            platformClass += platformVersion.major;
	            bodyEle.classList.add(platformClass);
	            // platform-ios9_3
	            bodyEle.classList.add(platformClass + '_' + platformVersion.minor);
	        }
	    });
	    // touch devices should not use :hover CSS pseudo
	    // enable :hover CSS when the "hoverCSS" setting is not false
	    if (config.getBoolean('hoverCSS', true)) {
	        bodyEle.classList.add('enable-hover');
	    }
	    // run feature detection tests
	    featureDetect.run(window, document);
	}
	/**
	 * Bind some global events and publish on the 'app' channel
	 */
	function bindEvents(window, document, platform, events) {
	    window.addEventListener('online', function (ev) {
	        events.publish('app:online', ev);
	    }, false);
	    window.addEventListener('offline', function (ev) {
	        events.publish('app:offline', ev);
	    }, false);
	    window.addEventListener('orientationchange', function (ev) {
	        events.publish('app:rotated', ev);
	    });
	    // When that status taps, we respond
	    window.addEventListener('statusTap', function (ev) {
	        // TODO: Make this more better
	        var el = document.elementFromPoint(platform.width() / 2, platform.height() / 2);
	        if (!el) {
	            return;
	        }
	        var content = closest(el, 'scroll-content');
	        if (content) {
	            var scroll = new ScrollView(content);
	            scroll.scrollTo(0, 0, 300);
	        }
	    });
	    // start listening for resizes XXms after the app starts
	    nativeTimeout(function () {
	        window.addEventListener('resize', function () {
	            platform.windowResize();
	        });
	    }, 2000);
	}

	var _reflect = Reflect;
	/**
	 * @private
	 */
	function addSelector(type, selector) {
	    if (type) {
	        var annotations = _reflect.getMetadata('annotations', type);
	        if (annotations && !annotations[0].selector) {
	            annotations[0].selector = selector;
	            _reflect.defineMetadata('annotations', annotations, type);
	        }
	    }
	}

	var __extends$39 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @private
	 * Menu Type
	 * Base class which is extended by the various types. Each
	 * type will provide their own animations for open and close
	 * and registers itself with Menu.
	 */
	var MenuType = (function () {
	    function MenuType() {
	        this.ani = new Animation();
	    }
	    MenuType.prototype.setOpen = function (shouldOpen, done) {
	        this.ani
	            .onFinish(done, true)
	            .reverse(!shouldOpen)
	            .play();
	    };
	    MenuType.prototype.setProgressStart = function (isOpen) {
	        this.isOpening = !isOpen;
	        // the cloned animation should not use an easing curve during seek
	        this.ani
	            .reverse(isOpen)
	            .progressStart();
	    };
	    MenuType.prototype.setProgessStep = function (stepValue) {
	        // adjust progress value depending if it opening or closing
	        this.ani.progressStep(stepValue);
	    };
	    MenuType.prototype.setProgressEnd = function (shouldComplete, currentStepValue, done) {
	        var _this = this;
	        var isOpen = (this.isOpening && shouldComplete);
	        if (!this.isOpening && !shouldComplete) {
	            isOpen = true;
	        }
	        this.ani.onFinish(function () {
	            _this.isOpening = false;
	            done(isOpen);
	        }, true);
	        this.ani.progressEnd(shouldComplete, currentStepValue);
	    };
	    MenuType.prototype.destroy = function () {
	        this.ani && this.ani.destroy();
	    };
	    return MenuType;
	}());
	/**
	 * @private
	 * Menu Reveal Type
	 * The content slides over to reveal the menu underneath.
	 * The menu itself, which is under the content, does not move.
	 */
	var MenuRevealType = (function (_super) {
	    __extends$39(MenuRevealType, _super);
	    function MenuRevealType(menu, platform) {
	        _super.call(this);
	        var openedX = (menu.width() * (menu.side === 'right' ? -1 : 1)) + 'px';
	        this.ani
	            .easing('ease')
	            .duration(250);
	        var contentOpen = new Animation(menu.getContentElement());
	        contentOpen.fromTo('translateX', '0px', openedX);
	        this.ani.add(contentOpen);
	    }
	    return MenuRevealType;
	}(MenuType));
	MenuController.registerType('reveal', MenuRevealType);
	/**
	 * @private
	 * Menu Push Type
	 * The content slides over to reveal the menu underneath.
	 * The menu itself also slides over to reveal its bad self.
	 */
	var MenuPushType = (function (_super) {
	    __extends$39(MenuPushType, _super);
	    function MenuPushType(menu, platform) {
	        _super.call(this);
	        this.ani
	            .easing('ease')
	            .duration(250);
	        var contentOpenedX, menuClosedX, menuOpenedX;
	        if (menu.side === 'right') {
	            // right side
	            contentOpenedX = -menu.width() + 'px';
	            menuClosedX = menu.width() + 'px';
	            menuOpenedX = '0px';
	        }
	        else {
	            contentOpenedX = menu.width() + 'px';
	            menuOpenedX = '0px';
	            menuClosedX = -menu.width() + 'px';
	        }
	        var menuAni = new Animation(menu.getMenuElement());
	        menuAni.fromTo('translateX', menuClosedX, menuOpenedX);
	        this.ani.add(menuAni);
	        var contentApi = new Animation(menu.getContentElement());
	        contentApi.fromTo('translateX', '0px', contentOpenedX);
	        this.ani.add(contentApi);
	    }
	    return MenuPushType;
	}(MenuType));
	MenuController.registerType('push', MenuPushType);
	/**
	 * @private
	 * Menu Overlay Type
	 * The menu slides over the content. The content
	 * itself, which is under the menu, does not move.
	 */
	var MenuOverlayType = (function (_super) {
	    __extends$39(MenuOverlayType, _super);
	    function MenuOverlayType(menu, platform) {
	        _super.call(this);
	        this.ani
	            .easing('ease')
	            .duration(250);
	        var closedX, openedX;
	        if (menu.side === 'right') {
	            // right side
	            closedX = 8 + menu.width() + 'px';
	            openedX = '0px';
	        }
	        else {
	            // left side
	            closedX = -(8 + menu.width()) + 'px';
	            openedX = '0px';
	        }
	        var menuAni = new Animation(menu.getMenuElement());
	        menuAni.fromTo('translateX', closedX, openedX);
	        this.ani.add(menuAni);
	        var backdropApi = new Animation(menu.getBackdropElement());
	        backdropApi.fromTo('opacity', 0.01, 0.35);
	        this.ani.add(backdropApi);
	    }
	    return MenuOverlayType;
	}(MenuType));
	MenuController.registerType('overlay', MenuOverlayType);

	/**
	 * @private
	*/
	var StorageEngine = (function () {
	    function StorageEngine(options) {
	        if (options === void 0) { options = {}; }
	    }
	    StorageEngine.prototype.get = function (key) {
	        throw Error('get() not implemented for this storage engine');
	    };
	    StorageEngine.prototype.set = function (key, value) {
	        throw Error('set() not implemented for this storage engine');
	    };
	    StorageEngine.prototype.remove = function (key) {
	        throw Error('remove() not implemented for this storage engine');
	    };
	    StorageEngine.prototype.query = function (query, params) {
	        throw Error('query() not implemented for this storage engine');
	    };
	    StorageEngine.prototype.clear = function () {
	        throw Error('clear() not implemented for this storage engine');
	    };
	    return StorageEngine;
	}());

	var __extends$40 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * @name LocalStorage
	 * @description
	 * The LocalStorage storage engine uses the browser's local storage system for
	 * storing key/value pairs.
	 *
	 * Note: LocalStorage should ONLY be used for temporary data that you can afford to lose.
	 * Given disk space constraints on a mobile device, local storage might be "cleaned up"
	 * by the operating system (iOS).
	 *
	 * For guaranteed, long-term storage, use the SqlStorage engine which stores data in a file.
	 *
	 * @usage
	 * ```ts
	 * import {Component} from '@angular/core';
	 * import {Storage, LocalStorage} from 'ionic-angular';
	 * @Component({
	 *   template: `<ion-content></ion-content>`
	 * });
	 * export class MyClass{
	 *  constructor(){
	 *    this.local = new Storage(LocalStorage);
	 *    this.local.set('didTutorial', 'true');
	 *  }
	 *}
	 *```
	 * @demo /docs/v2/demos/local-storage/
	 * @see {@link /docs/v2/platform/storage/ Storage Platform Docs}
	 */
	var LocalStorage = (function (_super) {
	    __extends$40(LocalStorage, _super);
	    function LocalStorage(options) {
	        if (options === void 0) { options = {}; }
	        _super.call(this);
	    }
	    /**
	     * Get the value of a key in LocalStorage
	     * @param {string} key the key you want to lookup in LocalStorage
	     * @returns {Promise} Returns a promise which is resolved when the value has been retrieved
	     */
	    LocalStorage.prototype.get = function (key) {
	        return new Promise(function (resolve, reject) {
	            try {
	                var value = window.localStorage.getItem(key);
	                resolve(value);
	            }
	            catch (e) {
	                reject(e);
	            }
	        });
	    };
	    /**
	     * Set a key value pair and save it to LocalStorage
	     * @param {string} key the key you want to save to LocalStorage
	     * @param {string} value the value of the key you're saving
	     * @returns {Promise} Returns a promise which is resolved when the key value pair have been set
	     */
	    LocalStorage.prototype.set = function (key, value) {
	        return new Promise(function (resolve, reject) {
	            try {
	                window.localStorage.setItem(key, value);
	                resolve();
	            }
	            catch (e) {
	                reject(e);
	            }
	        });
	    };
	    /**
	     * Remove a key from LocalStorage
	     * @param {string} key the key you want to remove from LocalStorage
	     * @returns {Promise} Returns a promise which is resolved when the key has been removed
	     */
	    LocalStorage.prototype.remove = function (key) {
	        return new Promise(function (resolve, reject) {
	            try {
	                window.localStorage.removeItem(key);
	                resolve();
	            }
	            catch (e) {
	                reject(e);
	            }
	        });
	    };
	    /**
	     * Clear data stored in LocalStorage
	     * @returns {Promise} Returns a promise which is resolved when the data have been cleared
	     */
	    LocalStorage.prototype.clear = function () {
	        return new Promise(function (resolve, reject) {
	            try {
	                window.localStorage.clear();
	                resolve();
	            }
	            catch (e) {
	                reject(e);
	            }
	        });
	    };
	    return LocalStorage;
	}(StorageEngine));

	var __extends$41 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DB_NAME = '__ionicstorage';
	var win$2 = window;
	/**
	 * SqlStorage uses SQLite or WebSQL (development only!) to store data in a
	 * persistent SQL store on the filesystem.
	 *
	 * This is the preferred storage engine, as data will be stored in appropriate
	 * app storage, unlike Local Storage which is treated differently by the OS.
	 *
	 * For convenience, the engine supports key/value storage for simple get/set and blob
	 * storage. The full SQL engine is exposed underneath through the `query` method.
	 *
	 * @usage
	 ```js
	 * let storage = new Storage(SqlStorage, options);
	 * storage.set('name', 'Max');
	 * storage.get('name').then((name) => {
	 * });
	 *
	 * // Sql storage also exposes the full engine underneath
	 * storage.query('insert into projects(name, data) values("Cool Project", "blah")');
	 * storage.query('select * from projects').then((resp) => {})
	 * ```
	 *
	 * The `SqlStorage` service supports these options:
	 * {
	 *   name: the name of the database (__ionicstorage by default)
	 *   backupFlag: // where to store the file, default is BACKUP_LOCAL which DOES NOT store to iCloud. Other options: BACKUP_LIBRARY, BACKUP_DOCUMENTS
	 *   existingDatabase: whether to load this as an existing database (default is false)
	 * }
	 *
	 */
	var SqlStorage = (function (_super) {
	    __extends$41(SqlStorage, _super);
	    function SqlStorage(options) {
	        if (options === void 0) { options = {}; }
	        _super.call(this);
	        var dbOptions = defaults$1(options, {
	            name: DB_NAME,
	            backupFlag: SqlStorage.BACKUP_LOCAL,
	            existingDatabase: false
	        });
	        if (win$2.sqlitePlugin) {
	            var location_1 = this._getBackupLocation(dbOptions.backupFlag);
	            this._db = win$2.sqlitePlugin.openDatabase(assign({
	                name: dbOptions.name,
	                location: location_1,
	                createFromLocation: dbOptions.existingDatabase ? 1 : 0
	            }, dbOptions));
	        }
	        else {
	            console.warn('Storage: SQLite plugin not installed, falling back to WebSQL. Make sure to install cordova-sqlite-storage in production!');
	            this._db = win$2.openDatabase(dbOptions.name, '1.0', 'database', 5 * 1024 * 1024);
	        }
	        this._tryInit();
	    }
	    SqlStorage.prototype._getBackupLocation = function (dbFlag) {
	        switch (dbFlag) {
	            case SqlStorage.BACKUP_LOCAL:
	                return 2;
	            case SqlStorage.BACKUP_LIBRARY:
	                return 1;
	            case SqlStorage.BACKUP_DOCUMENTS:
	                return 0;
	            default:
	                throw Error('Invalid backup flag: ' + dbFlag);
	        }
	    };
	    // Initialize the DB with our required tables
	    SqlStorage.prototype._tryInit = function () {
	        this.query('CREATE TABLE IF NOT EXISTS kv (key text primary key, value text)').catch(function (err) {
	            console.error('Storage: Unable to create initial storage tables', err.tx, err.err);
	        });
	    };
	    /**
	     * Perform an arbitrary SQL operation on the database. Use this method
	     * to have full control over the underlying database through SQL operations
	     * like SELECT, INSERT, and UPDATE.
	     *
	     * @param {string} query the query to run
	     * @param {array} params the additional params to use for query placeholders
	     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
	     */
	    SqlStorage.prototype.query = function (query, params) {
	        var _this = this;
	        if (params === void 0) { params = []; }
	        return new Promise(function (resolve, reject) {
	            try {
	                _this._db.transaction(function (tx) {
	                    tx.executeSql(query, params, function (tx, res) { return resolve({ tx: tx, res: res }); }, function (tx, err) { return reject({ tx: tx, err: err }); });
	                }, function (err) { return reject({ err: err }); });
	            }
	            catch (err) {
	                reject({ err: err });
	            }
	        });
	    };
	    /**
	     * Get the value in the database identified by the given key.
	     * @param {string} key the key
	     * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
	     */
	    SqlStorage.prototype.get = function (key) {
	        return this.query('select key, value from kv where key = ? limit 1', [key]).then(function (data) {
	            if (data.res.rows.length > 0) {
	                return data.res.rows.item(0).value;
	            }
	        });
	    };
	    /**
	    * Set the value in the database for the given key. Existing values will be overwritten.
	    * @param {string} key the key
	    * @param {string} value The value (as a string)
	    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
	    */
	    SqlStorage.prototype.set = function (key, value) {
	        return this.query('insert or replace into kv(key, value) values (?, ?)', [key, value]);
	    };
	    /**
	    * Remove the value in the database for the given key.
	    * @param {string} key the key
	    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
	    */
	    SqlStorage.prototype.remove = function (key) {
	        return this.query('delete from kv where key = ?', [key]);
	    };
	    /**
	    * Clear all keys/values of your database.
	    * @return {Promise} that resolves or rejects with an object of the form { tx: Transaction, res: Result (or err)}
	    */
	    SqlStorage.prototype.clear = function () {
	        return this.query('delete from kv');
	    };
	    SqlStorage.BACKUP_LOCAL = 2;
	    SqlStorage.BACKUP_LIBRARY = 1;
	    SqlStorage.BACKUP_DOCUMENTS = 0;
	    return SqlStorage;
	}(StorageEngine));

	// iOS Mode Settings
	Config.setModeConfig('ios', {
	    activator: 'highlight',
	    actionSheetEnter: 'action-sheet-slide-in',
	    actionSheetLeave: 'action-sheet-slide-out',
	    alertEnter: 'alert-pop-in',
	    alertLeave: 'alert-pop-out',
	    backButtonText: 'Back',
	    backButtonIcon: 'ios-arrow-back',
	    iconMode: 'ios',
	    loadingEnter: 'loading-pop-in',
	    loadingLeave: 'loading-pop-out',
	    menuType: 'reveal',
	    modalEnter: 'modal-slide-in',
	    modalLeave: 'modal-slide-out',
	    pageTransition: 'ios-transition',
	    pageTransitionDelay: 16,
	    pickerEnter: 'picker-slide-in',
	    pickerLeave: 'picker-slide-out',
	    pickerRotateFactor: -0.46,
	    popoverEnter: 'popover-pop-in',
	    popoverLeave: 'popover-pop-out',
	    spinner: 'ios',
	    tabbarHighlight: false,
	    tabbarPlacement: 'bottom',
	    tabSubPages: false,
	    toastEnter: 'toast-slide-in',
	    toastLeave: 'toast-slide-out',
	});
	// Material Design Mode Settings
	Config.setModeConfig('md', {
	    activator: 'ripple',
	    actionSheetEnter: 'action-sheet-md-slide-in',
	    actionSheetLeave: 'action-sheet-md-slide-out',
	    alertEnter: 'alert-md-pop-in',
	    alertLeave: 'alert-md-pop-out',
	    backButtonText: '',
	    backButtonIcon: 'md-arrow-back',
	    iconMode: 'md',
	    loadingEnter: 'loading-md-pop-in',
	    loadingLeave: 'loading-md-pop-out',
	    menuType: 'overlay',
	    modalEnter: 'modal-md-slide-in',
	    modalLeave: 'modal-md-slide-out',
	    pageTransition: 'md-transition',
	    pageTransitionDelay: 64,
	    pickerEnter: 'picker-slide-in',
	    pickerLeave: 'picker-slide-out',
	    pickerRotateFactor: 0,
	    popoverEnter: 'popover-md-pop-in',
	    popoverLeave: 'popover-md-pop-out',
	    spinner: 'crescent',
	    tabbarHighlight: true,
	    tabbarPlacement: 'top',
	    tabSubPages: true,
	    toastEnter: 'toast-md-slide-in',
	    toastLeave: 'toast-md-slide-out',
	});
	// Windows Mode Settings
	Config.setModeConfig('wp', {
	    activator: 'highlight',
	    actionSheetEnter: 'action-sheet-wp-slide-in',
	    actionSheetLeave: 'action-sheet-wp-slide-out',
	    alertEnter: 'alert-wp-pop-in',
	    alertLeave: 'alert-wp-pop-out',
	    backButtonText: '',
	    backButtonIcon: 'ios-arrow-back',
	    iconMode: 'ios',
	    loadingEnter: 'loading-wp-pop-in',
	    loadingLeave: 'loading-wp-pop-out',
	    menuType: 'overlay',
	    modalEnter: 'modal-md-slide-in',
	    modalLeave: 'modal-md-slide-out',
	    pageTransition: 'wp-transition',
	    pageTransitionDelay: 96,
	    pickerEnter: 'picker-slide-in',
	    pickerLeave: 'picker-slide-out',
	    pickerRotateFactor: 0,
	    popoverEnter: 'popover-md-pop-in',
	    popoverLeave: 'popover-md-pop-out',
	    spinner: 'circles',
	    tabbarPlacement: 'top',
	    tabSubPages: true,
	    toastEnter: 'toast-wp-slide-in',
	    toastLeave: 'toast-wp-slide-out',
	});

	var win$3 = window;
	var doc$1 = document;
	Platform.register({
	    name: 'core',
	    settings: {
	        mode: 'md',
	        keyboardHeight: 290
	    }
	});
	Platform.setDefault('core');
	Platform.register({
	    name: 'mobile'
	});
	Platform.register({
	    name: 'phablet',
	    isMatch: function (p) {
	        var smallest = Math.min(p.width(), p.height());
	        var largest = Math.max(p.width(), p.height());
	        return (smallest > 390 && smallest < 520) &&
	            (largest > 620 && largest < 800);
	    }
	});
	Platform.register({
	    name: 'tablet',
	    isMatch: function (p) {
	        var smallest = Math.min(p.width(), p.height());
	        var largest = Math.max(p.width(), p.height());
	        return (smallest > 460 && smallest < 820) &&
	            (largest > 780 && largest < 1400);
	    }
	});
	Platform.register({
	    name: 'android',
	    superset: 'mobile',
	    subsets: [
	        'phablet',
	        'tablet'
	    ],
	    settings: {
	        activator: function (p) {
	            // md mode defaults to use ripple activator
	            // however, under-powered devices shouldn't use ripple
	            // if this a linux device, and is using Android Chrome v36 (Android 5.0)
	            // or above then use ripple, otherwise do not use a ripple effect
	            if (p.testNavigatorPlatform('linux')) {
	                var chromeVersion = p.matchUserAgentVersion(/Chrome\/(\d+).(\d+)?/);
	                if (chromeVersion) {
	                    // linux android device using modern android chrome browser gets ripple
	                    return (parseInt(chromeVersion.major, 10) < 36 ? 'none' : 'ripple');
	                }
	                // linux android device not using chrome browser checks just android's version
	                if (p.version().major < 5) {
	                    return 'none';
	                }
	            }
	            // fallback to always use ripple
	            return 'ripple';
	        },
	        autoFocusAssist: 'immediate',
	        hoverCSS: false,
	        keyboardHeight: 300,
	        mode: 'md',
	    },
	    isMatch: function (p) {
	        return p.isPlatformMatch('android', ['android', 'silk'], ['windows phone']);
	    },
	    versionParser: function (p) {
	        return p.matchUserAgentVersion(/Android (\d+).(\d+)?/);
	    }
	});
	Platform.register({
	    name: 'ios',
	    superset: 'mobile',
	    subsets: [
	        'ipad',
	        'iphone'
	    ],
	    settings: {
	        autoFocusAssist: 'delay',
	        hoverCSS: false,
	        inputBlurring: isIOSDevice,
	        inputCloning: isIOSDevice,
	        keyboardHeight: 300,
	        mode: 'ios',
	        scrollAssist: isIOSDevice,
	        statusbarPadding: !!(win$3.cordova),
	        swipeBackEnabled: isIOSDevice,
	        swipeBackThreshold: 40,
	        tapPolyfill: isIOSDevice,
	        virtualScrollEventAssist: !(win$3.indexedDB)
	    },
	    isMatch: function (p) {
	        return p.isPlatformMatch('ios', ['iphone', 'ipad', 'ipod'], ['windows phone']);
	    },
	    versionParser: function (p) {
	        return p.matchUserAgentVersion(/OS (\d+)_(\d+)?/);
	    }
	});
	Platform.register({
	    name: 'ipad',
	    superset: 'tablet',
	    settings: {
	        keyboardHeight: 500,
	    },
	    isMatch: function (p) {
	        return p.isPlatformMatch('ipad');
	    }
	});
	Platform.register({
	    name: 'iphone',
	    subsets: [
	        'phablet'
	    ],
	    isMatch: function (p) {
	        return p.isPlatformMatch('iphone');
	    }
	});
	Platform.register({
	    name: 'windows',
	    superset: 'mobile',
	    subsets: [
	        'phablet',
	        'tablet'
	    ],
	    settings: {
	        mode: 'wp',
	        autoFocusAssist: 'immediate',
	        hoverCSS: false
	    },
	    isMatch: function (p) {
	        return p.isPlatformMatch('windows', ['windows phone']);
	    },
	    versionParser: function (p) {
	        return p.matchUserAgentVersion(/Windows Phone (\d+).(\d+)?/);
	    }
	});
	Platform.register({
	    name: 'cordova',
	    isEngine: true,
	    initialize: function (p) {
	        // prepare a custom "ready" for cordova "deviceready"
	        p.prepareReady = function () {
	            // 1) ionic bootstrapped
	            windowLoad(function () {
	                // 2) window onload triggered or completed
	                doc$1.addEventListener('deviceready', function () {
	                    // 3) cordova deviceready event triggered
	                    // add cordova listeners to emit platform events
	                    doc$1.addEventListener('backbutton', function (ev) {
	                        p.zone.run(function () {
	                            p.backButton.emit(ev);
	                        });
	                    });
	                    doc$1.addEventListener('pause', function (ev) {
	                        p.zone.run(function () {
	                            p.pause.emit(ev);
	                        });
	                    });
	                    doc$1.addEventListener('resume', function (ev) {
	                        p.zone.run(function () {
	                            p.resume.emit(ev);
	                        });
	                    });
	                    // cordova has its own exitApp method
	                    p.exitApp = function () {
	                        win$3.navigator.app.exitApp();
	                    };
	                    // cordova has fully loaded and we've added listeners
	                    p.triggerReady('cordova');
	                });
	            });
	        };
	    },
	    isMatch: function () {
	        return !!(win$3.cordova || win$3.PhoneGap || win$3.phonegap);
	    }
	});
	function isIOSDevice(p) {
	    // shortcut function to be reused internally
	    // checks navigator.platform to see if it's an actual iOS device
	    // this does not use the user-agent string because it is often spoofed
	    // an actual iPad will return true, a chrome dev tools iPad will return false
	    return p.testNavigatorPlatform('iphone|ipad|ipod');
	}

	var __extends$42 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SlideIn = (function (_super) {
	    __extends$42(SlideIn, _super);
	    function SlideIn(element) {
	        _super.call(this, element);
	        this
	            .easing('cubic-bezier(0.1,0.7,0.1,1)')
	            .duration(400)
	            .fromTo('translateY', '100%', '0%');
	    }
	    return SlideIn;
	}(Animation));
	Animation.register('slide-in', SlideIn);
	var SlideOut = (function (_super) {
	    __extends$42(SlideOut, _super);
	    function SlideOut(element) {
	        _super.call(this, element);
	        this
	            .easing('ease-out')
	            .duration(250)
	            .fromTo('translateY', '0%', '100%');
	    }
	    return SlideOut;
	}(Animation));
	Animation.register('slide-out', SlideOut);
	var FadeIn = (function (_super) {
	    __extends$42(FadeIn, _super);
	    function FadeIn(element) {
	        _super.call(this, element);
	        this
	            .easing('ease-in')
	            .duration(400)
	            .fromTo('opacity', 0.001, 1, true);
	    }
	    return FadeIn;
	}(Animation));
	Animation.register('fade-in', FadeIn);
	var FadeOut = (function (_super) {
	    __extends$42(FadeOut, _super);
	    function FadeOut(element) {
	        _super.call(this, element);
	        this
	            .easing('ease-out')
	            .duration(250)
	            .fromTo('opacity', 0.999, 0);
	    }
	    return FadeOut;
	}(Animation));
	Animation.register('fade-out', FadeOut);

	var __extends$43 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DURATION = 500;
	var EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
	var OPACITY = 'opacity';
	var TRANSLATEX = 'translateX';
	var OFF_RIGHT = '99.5%';
	var OFF_LEFT = '-33%';
	var CENTER = '0%';
	var OFF_OPACITY = 0.8;
	var SHOW_BACK_BTN_CSS = 'show-back-button';
	var IOSTransition = (function (_super) {
	    __extends$43(IOSTransition, _super);
	    function IOSTransition(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        this.duration(opts.duration || DURATION);
	        this.easing(opts.easing || EASING);
	        // what direction is the transition going
	        var backDirection = (opts.direction === 'back');
	        // do they have navbars?
	        var enteringHasNavbar = enteringView.hasNavbar();
	        var leavingHasNavbar = leavingView && leavingView.hasNavbar();
	        // entering content
	        var enteringContent = new Animation(enteringView.contentRef());
	        enteringContent.element(enteringView.toolbarRefs());
	        this.add(enteringContent);
	        if (backDirection) {
	            // entering content, back direction
	            enteringContent
	                .fromTo(TRANSLATEX, OFF_LEFT, CENTER, true)
	                .fromTo(OPACITY, OFF_OPACITY, 1, true);
	        }
	        else {
	            // entering content, forward direction
	            enteringContent
	                .before.clearStyles([OPACITY])
	                .fromTo(TRANSLATEX, OFF_RIGHT, CENTER, true);
	        }
	        if (enteringHasNavbar) {
	            // entering page has a navbar
	            var enteringNavBar = new Animation(enteringView.navbarRef());
	            enteringNavBar.before.addClass('show-navbar');
	            this.add(enteringNavBar);
	            var enteringTitle = new Animation(enteringView.titleRef());
	            var enteringNavbarItems = new Animation(enteringView.navbarItemRefs());
	            var enteringNavbarBg = new Animation(enteringView.navbarBgRef());
	            var enteringBackButton = new Animation(enteringView.backBtnRef());
	            enteringNavBar
	                .add(enteringTitle)
	                .add(enteringNavbarItems)
	                .add(enteringNavbarBg)
	                .add(enteringBackButton);
	            enteringTitle.fromTo(OPACITY, 0.01, 1, true);
	            enteringNavbarItems.fromTo(OPACITY, 0.01, 1, true);
	            // set properties depending on direction
	            if (backDirection) {
	                // entering navbar, back direction
	                enteringTitle.fromTo(TRANSLATEX, OFF_LEFT, CENTER, true);
	                if (enteringView.enableBack()) {
	                    // back direction, entering page has a back button
	                    enteringBackButton
	                        .before.addClass(SHOW_BACK_BTN_CSS)
	                        .fromTo(OPACITY, 0.01, 1, true);
	                }
	            }
	            else {
	                // entering navbar, forward direction
	                enteringTitle.fromTo(TRANSLATEX, OFF_RIGHT, CENTER, true);
	                if (leavingHasNavbar) {
	                    // entering navbar, forward direction, and there's a leaving navbar
	                    // should just fade in, no sliding
	                    enteringNavbarBg
	                        .before.clearStyles([TRANSLATEX])
	                        .fromTo(OPACITY, 0.01, 1, true);
	                }
	                else {
	                    // entering navbar, forward direction, and there's no leaving navbar
	                    // should just slide in, no fading in
	                    enteringNavbarBg
	                        .before.clearStyles([OPACITY])
	                        .fromTo(TRANSLATEX, OFF_RIGHT, CENTER, true);
	                }
	                if (enteringView.enableBack()) {
	                    // forward direction, entering page has a back button
	                    enteringBackButton
	                        .before.addClass(SHOW_BACK_BTN_CSS)
	                        .fromTo(OPACITY, 0.01, 1, true);
	                    var enteringBackBtnText = new Animation(enteringView.backBtnTextRef());
	                    enteringBackBtnText.fromTo(TRANSLATEX, '100px', '0px');
	                    enteringNavBar.add(enteringBackBtnText);
	                }
	                else {
	                    enteringBackButton.before.removeClass(SHOW_BACK_BTN_CSS);
	                }
	            }
	        }
	        // setup leaving view
	        if (leavingView) {
	            // leaving content
	            var leavingContent = new Animation(leavingView.contentRef());
	            leavingContent.element(leavingView.toolbarRefs());
	            this.add(leavingContent);
	            if (backDirection) {
	                // leaving content, back direction
	                leavingContent
	                    .before.clearStyles([OPACITY])
	                    .fromTo(TRANSLATEX, CENTER, '100%');
	            }
	            else {
	                // leaving content, forward direction
	                leavingContent
	                    .fromTo(TRANSLATEX, CENTER, OFF_LEFT)
	                    .fromTo(OPACITY, 1, OFF_OPACITY);
	            }
	            if (leavingHasNavbar) {
	                // leaving page has a navbar
	                var leavingNavBar = new Animation(leavingView.navbarRef());
	                var leavingBackButton = new Animation(leavingView.backBtnRef());
	                var leavingTitle = new Animation(leavingView.titleRef());
	                var leavingNavbarItems = new Animation(leavingView.navbarItemRefs());
	                var leavingNavbarBg = new Animation(leavingView.navbarBgRef());
	                leavingNavBar
	                    .add(leavingBackButton)
	                    .add(leavingTitle)
	                    .add(leavingNavbarItems)
	                    .add(leavingNavbarBg);
	                this.add(leavingNavBar);
	                // fade out leaving navbar items
	                leavingBackButton.fromTo(OPACITY, 0.99, 0);
	                leavingTitle.fromTo(OPACITY, 0.99, 0);
	                leavingNavbarItems.fromTo(OPACITY, 0.99, 0);
	                if (backDirection) {
	                    // leaving navbar, back direction
	                    leavingTitle.fromTo(TRANSLATEX, CENTER, '100%');
	                    if (enteringHasNavbar) {
	                        // leaving navbar, back direction, and there's an entering navbar
	                        // should just fade out, no sliding
	                        leavingNavbarBg
	                            .before.clearStyles([TRANSLATEX])
	                            .fromTo('opacity', 0.99, 0);
	                    }
	                    else {
	                        // leaving navbar, back direction, and there's no entering navbar
	                        // should just slide out, no fading out
	                        leavingNavbarBg
	                            .before.clearStyles([OPACITY])
	                            .fromTo(TRANSLATEX, CENTER, '100%');
	                    }
	                    var leavingBackBtnText = new Animation(leavingView.backBtnTextRef());
	                    leavingBackBtnText.fromTo(TRANSLATEX, CENTER, (300) + 'px');
	                    leavingNavBar.add(leavingBackBtnText);
	                }
	                else {
	                    // leaving navbar, forward direction
	                    leavingTitle.fromTo(TRANSLATEX, CENTER, OFF_LEFT);
	                }
	            }
	        }
	    }
	    return IOSTransition;
	}(PageTransition));
	PageTransition.register('ios-transition', IOSTransition);

	var __extends$44 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TRANSLATEY = 'translateY';
	var OFF_BOTTOM = '40px';
	var CENTER$1 = '0px';
	var SHOW_BACK_BTN_CSS$1 = 'show-back-button';
	var MDTransition = (function (_super) {
	    __extends$44(MDTransition, _super);
	    function MDTransition(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        // what direction is the transition going
	        var backDirection = (opts.direction === 'back');
	        // do they have navbars?
	        var enteringHasNavbar = enteringView.hasNavbar();
	        var leavingHasNavbar = leavingView && leavingView.hasNavbar();
	        if (backDirection) {
	            this.duration(opts.duration || 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
	            this.enteringPage.before.clearStyles([TRANSLATEY]);
	        }
	        else {
	            this.duration(opts.duration || 280).easing('cubic-bezier(0.36,0.66,0.04,1)');
	            this.enteringPage
	                .fromTo(TRANSLATEY, OFF_BOTTOM, CENTER$1, true)
	                .fromTo('opacity', 0.01, 1, true);
	        }
	        if (enteringHasNavbar) {
	            var enteringNavBar = new Animation(enteringView.navbarRef());
	            enteringNavBar.before.addClass('show-navbar');
	            this.add(enteringNavBar);
	            var enteringBackButton = new Animation(enteringView.backBtnRef());
	            this.add(enteringBackButton);
	            if (enteringView.enableBack()) {
	                enteringBackButton.before.addClass(SHOW_BACK_BTN_CSS$1);
	            }
	            else {
	                enteringBackButton.before.removeClass(SHOW_BACK_BTN_CSS$1);
	            }
	        }
	        // setup leaving view
	        if (leavingView && backDirection) {
	            // leaving content
	            this.duration(opts.duration || 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
	            var leavingPage = new Animation(leavingView.pageRef());
	            this.add(leavingPage.fromTo(TRANSLATEY, CENTER$1, OFF_BOTTOM).fromTo('opacity', 0.99, 0));
	        }
	    }
	    return MDTransition;
	}(PageTransition));
	PageTransition.register('md-transition', MDTransition);

	var __extends$45 = (undefined && undefined.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SHOW_BACK_BTN_CSS$2 = 'show-back-button';
	var SCALE_SMALL = .95;
	var WPTransition = (function (_super) {
	    __extends$45(WPTransition, _super);
	    function WPTransition(enteringView, leavingView, opts) {
	        _super.call(this, enteringView, leavingView, opts);
	        // what direction is the transition going
	        var backDirection = (opts.direction === 'back');
	        // do they have navbars?
	        var enteringHasNavbar = enteringView.hasNavbar();
	        var leavingHasNavbar = leavingView && leavingView.hasNavbar();
	        if (backDirection) {
	            this.duration(opts.duration || 120).easing('cubic-bezier(0.47,0,0.745,0.715)');
	            this.enteringPage.before.clearStyles(['scale']);
	        }
	        else {
	            this.duration(opts.duration || 280).easing('cubic-bezier(0,0 0.05,1)');
	            this.enteringPage
	                .fromTo('scale', SCALE_SMALL, 1, true)
	                .fromTo('opacity', 0.01, 1, true);
	        }
	        if (enteringHasNavbar) {
	            var enteringNavBar = new Animation(enteringView.navbarRef());
	            enteringNavBar.before.addClass('show-navbar');
	            this.add(enteringNavBar);
	            var enteringBackButton = new Animation(enteringView.backBtnRef());
	            this.add(enteringBackButton);
	            if (enteringView.enableBack()) {
	                enteringBackButton.before.addClass(SHOW_BACK_BTN_CSS$2);
	            }
	            else {
	                enteringBackButton.before.removeClass(SHOW_BACK_BTN_CSS$2);
	            }
	        }
	        // setup leaving view
	        if (leavingView && backDirection) {
	            // leaving content
	            this.duration(opts.duration || 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
	            var leavingPage = new Animation(leavingView.pageRef());
	            this.add(leavingPage.fromTo('scale', 1, SCALE_SMALL).fromTo('opacity', 0.99, 0));
	        }
	    }
	    return WPTransition;
	}(PageTransition));
	PageTransition.register('wp-transition', WPTransition);

	var _scope_check$1 = wtfCreateScope('AppView#check(ascii id)');
	/**
	 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	 *
	 */
	var AppView$2 = function () {
	    function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
	        classCallCheck(this, AppView);

	        this.clazz = clazz;
	        this.componentType = componentType;
	        this.type = type;
	        this.viewUtils = viewUtils;
	        this.parentInjector = parentInjector;
	        this.declarationAppElement = declarationAppElement;
	        this.cdMode = cdMode;
	        this.contentChildren = [];
	        this.viewChildren = [];
	        this.viewContainerElement = null;
	        this.numberOfChecks = 0;
	        this.activeAnimationPlayers = new ActiveAnimationPlayersMap();
	        this.ref = new ViewRef_(this);
	        if (type === ViewType.COMPONENT || type === ViewType.HOST) {
	            this.renderer = viewUtils.renderComponent(componentType);
	        } else {
	            this.renderer = declarationAppElement.parentView.renderer;
	        }
	    }

	    createClass(AppView, [{
	        key: 'cancelActiveAnimation',
	        value: function cancelActiveAnimation(element, animationName) {
	            var removeAllAnimations = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	            if (removeAllAnimations) {
	                this.activeAnimationPlayers.findAllPlayersByElement(element).forEach(function (player) {
	                    return player.destroy();
	                });
	            } else {
	                var player = this.activeAnimationPlayers.find(element, animationName);
	                if (isPresent(player)) {
	                    player.destroy();
	                }
	            }
	        }
	    }, {
	        key: 'registerAndStartAnimation',
	        value: function registerAndStartAnimation(element, animationName, player) {
	            var _this = this;

	            this.activeAnimationPlayers.set(element, animationName, player);
	            player.onDone(function () {
	                _this.activeAnimationPlayers.remove(element, animationName);
	            });
	            player.play();
	        }
	    }, {
	        key: 'create',
	        value: function create(context, givenProjectableNodes, rootSelectorOrNode) {
	            this.context = context;
	            var projectableNodes;
	            switch (this.type) {
	                case ViewType.COMPONENT:
	                    projectableNodes = ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
	                    break;
	                case ViewType.EMBEDDED:
	                    projectableNodes = this.declarationAppElement.parentView.projectableNodes;
	                    break;
	                case ViewType.HOST:
	                    // Note: Don't ensure the slot count for the projectableNodes as we store
	                    // them only for the contained component view (which will later check the slot count...)
	                    projectableNodes = givenProjectableNodes;
	                    break;
	            }
	            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
	            this.projectableNodes = projectableNodes;
	            return this.createInternal(rootSelectorOrNode);
	        }
	        /**
	         * Overwritten by implementations.
	         * Returns the AppElement for the host element for ViewType.HOST.
	         */

	    }, {
	        key: 'createInternal',
	        value: function createInternal(rootSelectorOrNode) {
	            return null;
	        }
	    }, {
	        key: 'init',
	        value: function init(rootNodesOrAppElements, allNodes, disposables, subscriptions) {
	            this.rootNodesOrAppElements = rootNodesOrAppElements;
	            this.allNodes = allNodes;
	            this.disposables = disposables;
	            this.subscriptions = subscriptions;
	            if (this.type === ViewType.COMPONENT) {
	                // Note: the render nodes have been attached to their host element
	                // in the ViewFactory already.
	                this.declarationAppElement.parentView.viewChildren.push(this);
	                this.dirtyParentQueriesInternal();
	            }
	        }
	    }, {
	        key: 'selectOrCreateHostElement',
	        value: function selectOrCreateHostElement(elementName, rootSelectorOrNode, debugInfo) {
	            var hostElement;
	            if (isPresent(rootSelectorOrNode)) {
	                hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
	            } else {
	                hostElement = this.renderer.createElement(null, elementName, debugInfo);
	            }
	            return hostElement;
	        }
	    }, {
	        key: 'injectorGet',
	        value: function injectorGet(token, nodeIndex, notFoundResult) {
	            return this.injectorGetInternal(token, nodeIndex, notFoundResult);
	        }
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'injectorGetInternal',
	        value: function injectorGetInternal(token, nodeIndex, notFoundResult) {
	            return notFoundResult;
	        }
	    }, {
	        key: 'injector',
	        value: function injector(nodeIndex) {
	            if (isPresent(nodeIndex)) {
	                return new ElementInjector(this, nodeIndex);
	            } else {
	                return this.parentInjector;
	            }
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            if (this._hasExternalHostElement) {
	                this.renderer.detachView(this.flatRootNodes);
	            } else if (isPresent(this.viewContainerElement)) {
	                this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
	            }
	            this._destroyRecurse();
	        }
	    }, {
	        key: '_destroyRecurse',
	        value: function _destroyRecurse() {
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                return;
	            }
	            var children = this.contentChildren;
	            for (var i = 0; i < children.length; i++) {
	                children[i]._destroyRecurse();
	            }
	            children = this.viewChildren;
	            for (var i = 0; i < children.length; i++) {
	                children[i]._destroyRecurse();
	            }
	            this.destroyLocal();
	            this.cdMode = ChangeDetectorStatus.Destroyed;
	        }
	    }, {
	        key: 'destroyLocal',
	        value: function destroyLocal() {
	            var _this2 = this;

	            var hostElement = this.type === ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
	            for (var i = 0; i < this.disposables.length; i++) {
	                this.disposables[i]();
	            }
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                ObservableWrapper.dispose(this.subscriptions[i]);
	            }
	            this.destroyInternal();
	            this.dirtyParentQueriesInternal();
	            if (this.activeAnimationPlayers.length == 0) {
	                this.renderer.destroyView(hostElement, this.allNodes);
	            } else {
	                var player = new AnimationGroupPlayer(this.activeAnimationPlayers.getAllPlayers());
	                player.onDone(function () {
	                    _this2.renderer.destroyView(hostElement, _this2.allNodes);
	                });
	            }
	        }
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'destroyInternal',
	        value: function destroyInternal() {}
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'detachInternal',
	        value: function detachInternal() {}
	    }, {
	        key: 'detach',
	        value: function detach() {
	            var _this3 = this;

	            this.detachInternal();
	            if (this.activeAnimationPlayers.length == 0) {
	                this.renderer.detachView(this.flatRootNodes);
	            } else {
	                var player = new AnimationGroupPlayer(this.activeAnimationPlayers.getAllPlayers());
	                player.onDone(function () {
	                    _this3.renderer.detachView(_this3.flatRootNodes);
	                });
	            }
	        }
	    }, {
	        key: 'dirtyParentQueriesInternal',

	        /**
	         * Overwritten by implementations
	         */
	        value: function dirtyParentQueriesInternal() {}
	    }, {
	        key: 'detectChanges',
	        value: function detectChanges(throwOnChange) {
	            var s = _scope_check$1(this.clazz);
	            if (this.cdMode === ChangeDetectorStatus.Checked || this.cdMode === ChangeDetectorStatus.Errored) return;
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                this.throwDestroyedError('detectChanges');
	            }
	            this.detectChangesInternal(throwOnChange);
	            if (this.cdMode === ChangeDetectorStatus.CheckOnce) this.cdMode = ChangeDetectorStatus.Checked;
	            this.numberOfChecks++;
	            wtfLeave(s);
	        }
	        /**
	         * Overwritten by implementations
	         */

	    }, {
	        key: 'detectChangesInternal',
	        value: function detectChangesInternal(throwOnChange) {
	            this.detectContentChildrenChanges(throwOnChange);
	            this.detectViewChildrenChanges(throwOnChange);
	        }
	    }, {
	        key: 'detectContentChildrenChanges',
	        value: function detectContentChildrenChanges(throwOnChange) {
	            for (var i = 0; i < this.contentChildren.length; ++i) {
	                var child = this.contentChildren[i];
	                if (child.cdMode === ChangeDetectorStatus.Detached) continue;
	                child.detectChanges(throwOnChange);
	            }
	        }
	    }, {
	        key: 'detectViewChildrenChanges',
	        value: function detectViewChildrenChanges(throwOnChange) {
	            for (var i = 0; i < this.viewChildren.length; ++i) {
	                var child = this.viewChildren[i];
	                if (child.cdMode === ChangeDetectorStatus.Detached) continue;
	                child.detectChanges(throwOnChange);
	            }
	        }
	    }, {
	        key: 'addToContentChildren',
	        value: function addToContentChildren(renderAppElement) {
	            renderAppElement.parentView.contentChildren.push(this);
	            this.viewContainerElement = renderAppElement;
	            this.dirtyParentQueriesInternal();
	        }
	    }, {
	        key: 'removeFromContentChildren',
	        value: function removeFromContentChildren(renderAppElement) {
	            ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
	            this.dirtyParentQueriesInternal();
	            this.viewContainerElement = null;
	        }
	    }, {
	        key: 'markAsCheckOnce',
	        value: function markAsCheckOnce() {
	            this.cdMode = ChangeDetectorStatus.CheckOnce;
	        }
	    }, {
	        key: 'markPathToRootAsCheckOnce',
	        value: function markPathToRootAsCheckOnce() {
	            var c = this;
	            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
	                if (c.cdMode === ChangeDetectorStatus.Checked) {
	                    c.cdMode = ChangeDetectorStatus.CheckOnce;
	                }
	                var parentEl = c.type === ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
	                c = isPresent(parentEl) ? parentEl.parentView : null;
	            }
	        }
	    }, {
	        key: 'eventHandler',
	        value: function eventHandler(cb) {
	            return cb;
	        }
	    }, {
	        key: 'throwDestroyedError',
	        value: function throwDestroyedError(details) {
	            throw new ViewDestroyedException(details);
	        }
	    }, {
	        key: 'destroyed',
	        get: function get() {
	            return this.cdMode === ChangeDetectorStatus.Destroyed;
	        }
	    }, {
	        key: 'changeDetectorRef',
	        get: function get() {
	            return this.ref;
	        }
	    }, {
	        key: 'parent',
	        get: function get() {
	            return isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
	        }
	    }, {
	        key: 'flatRootNodes',
	        get: function get() {
	            return flattenNestedViewRenderNodes(this.rootNodesOrAppElements);
	        }
	    }, {
	        key: 'lastRootNode',
	        get: function get() {
	            var lastNode = this.rootNodesOrAppElements.length > 0 ? this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] : null;
	            return _findLastRenderNode$1(lastNode);
	        }
	    }]);
	    return AppView;
	}();
	var DebugAppView$2 = function (_AppView) {
	    inherits(DebugAppView, _AppView);

	    function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
	        classCallCheck(this, DebugAppView);

	        var _this4 = possibleConstructorReturn(this, Object.getPrototypeOf(DebugAppView).call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode));

	        _this4.staticNodeDebugInfos = staticNodeDebugInfos;
	        _this4._currentDebugContext = null;
	        return _this4;
	    }

	    createClass(DebugAppView, [{
	        key: 'create',
	        value: function create(context, givenProjectableNodes, rootSelectorOrNode) {
	            this._resetDebug();
	            try {
	                return get(Object.getPrototypeOf(DebugAppView.prototype), 'create', this).call(this, context, givenProjectableNodes, rootSelectorOrNode);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'injectorGet',
	        value: function injectorGet(token, nodeIndex, notFoundResult) {
	            this._resetDebug();
	            try {
	                return get(Object.getPrototypeOf(DebugAppView.prototype), 'injectorGet', this).call(this, token, nodeIndex, notFoundResult);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'detach',
	        value: function detach() {
	            this._resetDebug();
	            try {
	                get(Object.getPrototypeOf(DebugAppView.prototype), 'detach', this).call(this);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'destroyLocal',
	        value: function destroyLocal() {
	            this._resetDebug();
	            try {
	                get(Object.getPrototypeOf(DebugAppView.prototype), 'destroyLocal', this).call(this);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: 'detectChanges',
	        value: function detectChanges(throwOnChange) {
	            this._resetDebug();
	            try {
	                get(Object.getPrototypeOf(DebugAppView.prototype), 'detectChanges', this).call(this, throwOnChange);
	            } catch (e) {
	                this._rethrowWithContext(e, e.stack);
	                throw e;
	            }
	        }
	    }, {
	        key: '_resetDebug',
	        value: function _resetDebug() {
	            this._currentDebugContext = null;
	        }
	    }, {
	        key: 'debug',
	        value: function debug(nodeIndex, rowNum, colNum) {
	            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
	        }
	    }, {
	        key: '_rethrowWithContext',
	        value: function _rethrowWithContext(e, stack) {
	            if (!(e instanceof ViewWrappedException)) {
	                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedException)) {
	                    this.cdMode = ChangeDetectorStatus.Errored;
	                }
	                if (isPresent(this._currentDebugContext)) {
	                    throw new ViewWrappedException(e, stack, this._currentDebugContext);
	                }
	            }
	        }
	    }, {
	        key: 'eventHandler',
	        value: function eventHandler(cb) {
	            var _this5 = this;

	            var superHandler = get(Object.getPrototypeOf(DebugAppView.prototype), 'eventHandler', this).call(this, cb);
	            return function (event /** TODO #9100 */) {
	                _this5._resetDebug();
	                try {
	                    return superHandler(event);
	                } catch (e) {
	                    _this5._rethrowWithContext(e, e.stack);
	                    throw e;
	                }
	            };
	        }
	    }]);
	    return DebugAppView;
	}(AppView$2);
	function _findLastRenderNode$1(node) {
	    var lastNode;
	    if (node instanceof AppElement) {
	        var appEl = node;
	        lastNode = appEl.nativeElement;
	        if (isPresent(appEl.nestedViews)) {
	            // Note: Views might have no root nodes at all!
	            for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
	                var nestedView = appEl.nestedViews[i];
	                if (nestedView.rootNodesOrAppElements.length > 0) {
	                    lastNode = _findLastRenderNode$1(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
	                }
	            }
	        }
	    } else {
	        lastNode = node;
	    }
	    return lastNode;
	}

	function __extends$46(d, b) {
	    for (var p in b) {
	        if (b.hasOwnProperty(p)) d[p] = b[p];
	    }function __() {
	        this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	function __decorate(decorators, target, key, desc) {
	    var c = arguments.length,
	        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	        d;
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    }return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	function __metadata(k, v) {
	    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	}

	var HomePage = function () {
	    function HomePage(navController) {
	        this.navController = navController;
	    }
	    HomePage = __decorate([Component({
	        template: "\n  <ion-navbar *navbar>\n    <ion-title>Home</ion-title>\n  </ion-navbar>\n\n  <ion-content padding class=\"home\">\n    <h2>Welcome to Ionic!</h2>\n    <p>\n      This starter project comes with simple tabs-based layout for apps\n      that are going to primarily use a Tabbed UI.\n    </p>\n    <p>\n      Take a look at the <code>app/</code> directory to add or change tabs,\n      update any existing page or create new pages.\n    </p>\n  </ion-content>\n  "
	    }), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object])], HomePage);
	    return HomePage;
	    var _a;
	}();

	var AboutPage = function () {
	    function AboutPage(navController) {
	        this.navController = navController;
	    }
	    AboutPage = __decorate([Component({
	        template: "\n  <ion-navbar *navbar>\n    <ion-title>\n      About\n    </ion-title>\n  </ion-navbar>\n\n  <ion-content padding class=\"about\">\n  </ion-content>\n  "
	    }), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object])], AboutPage);
	    return AboutPage;
	    var _a;
	}();

	var ContactPage = function () {
	    function ContactPage(navController) {
	        this.navController = navController;
	    }
	    ContactPage = __decorate([Component({
	        template: "\n  <ion-navbar *navbar>\n    <ion-title>\n      Contact\n    </ion-title>\n  </ion-navbar>\n\n  <ion-content>\n    <ion-list>\n      <ion-list-header>Follow us on Twitter</ion-list-header>\n      <ion-item>\n        <ion-icon name=\"ionic\" item-left></ion-icon>\n        @ionicframework\n      </ion-item>\n    </ion-list>\n  </ion-content>\n  "
	    }), __metadata('design:paramtypes', [typeof (_a = typeof NavController !== 'undefined' && NavController) === 'function' && _a || Object])], ContactPage);
	    return ContactPage;
	    var _a;
	}();

	var TabsPage = function () {
	    function TabsPage() {
	        this.tab1Root = HomePage;
	        this.tab2Root = AboutPage;
	        this.tab3Root = ContactPage;
	    }
	    TabsPage = __decorate([Component({
	        selector: 'io-tabs',
	        template: "\n  <ion-tabs>\n    <ion-tab [root]=\"tab1Root\" tabTitle=\"Home\" tabIcon=\"home\"></ion-tab>\n    <ion-tab [root]=\"tab2Root\" tabTitle=\"About\" tabIcon=\"information-circle\"></ion-tab>\n    <ion-tab [root]=\"tab3Root\" tabTitle=\"Contact\" tabIcon=\"contacts\"></ion-tab>\n  </ion-tabs>\n  "
	    }), __metadata('design:paramtypes', [])], TabsPage);
	    return TabsPage;
	}();

	var App$1 = function () {
	    function App(platform) {
	        this.platform = platform;
	        this.rootPage = TabsPage;
	        platform.ready().then(function () {});
	    }
	    App = __decorate([Component({
	        selector: 'ion-app',
	        template: "\n    <ion-content>\n    What up\n    </ion-content>\n  ",
	        directives: [Content],
	        providers: [Platform]
	    }), __metadata('design:paramtypes', [typeof (_a = typeof Platform !== 'undefined' && Platform) === 'function' && _a || Object])], App);
	    return App;
	    var _a;
	}();

	/**
	 * An AppElement is created for elements that have a ViewContainerRef,
	 * a nested component or a <template> element to keep data around
	 * that is needed for later instantiations.
	 */
	var AppElement$2 = function () {
	    function AppElement(index, parentIndex, parentView, nativeElement) {
	        classCallCheck(this, AppElement);

	        this.index = index;
	        this.parentIndex = parentIndex;
	        this.parentView = parentView;
	        this.nativeElement = nativeElement;
	        this.nestedViews = null;
	        this.componentView = null;
	    }

	    createClass(AppElement, [{
	        key: 'initComponent',
	        value: function initComponent(component, componentConstructorViewQueries, view) {
	            this.component = component;
	            this.componentConstructorViewQueries = componentConstructorViewQueries;
	            this.componentView = view;
	        }
	    }, {
	        key: 'mapNestedViews',
	        value: function mapNestedViews(nestedViewClass, callback) {
	            var result = [];
	            if (isPresent(this.nestedViews)) {
	                this.nestedViews.forEach(function (nestedView) {
	                    if (nestedView.clazz === nestedViewClass) {
	                        result.push(callback(nestedView));
	                    }
	                });
	            }
	            return result;
	        }
	    }, {
	        key: 'attachView',
	        value: function attachView(view, viewIndex) {
	            if (view.type === ViewType.COMPONENT) {
	                throw new BaseException('Component views can\'t be moved!');
	            }
	            var nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            ListWrapper.insert(nestedViews, viewIndex, view);
	            var refRenderNode;
	            if (viewIndex > 0) {
	                var prevView = nestedViews[viewIndex - 1];
	                refRenderNode = prevView.lastRootNode;
	            } else {
	                refRenderNode = this.nativeElement;
	            }
	            if (isPresent(refRenderNode)) {
	                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
	            }
	            view.addToContentChildren(this);
	        }
	    }, {
	        key: 'detachView',
	        value: function detachView(viewIndex) {
	            var view = ListWrapper.removeAt(this.nestedViews, viewIndex);
	            if (view.type === ViewType.COMPONENT) {
	                throw new BaseException('Component views can\'t be moved!');
	            }
	            view.detach();
	            view.removeFromContentChildren(this);
	            return view;
	        }
	    }, {
	        key: 'elementRef',
	        get: function get() {
	            return new ElementRef(this.nativeElement);
	        }
	    }, {
	        key: 'vcRef',
	        get: function get() {
	            return new ViewContainerRef_(this);
	        }
	    }, {
	        key: 'parentInjector',
	        get: function get() {
	            return this.parentView.injector(this.parentIndex);
	        }
	    }, {
	        key: 'injector',
	        get: function get() {
	            return this.parentView.injector(this.index);
	        }
	    }]);
	    return AppElement;
	}();

	var ViewUtils$2 = function () {
	    function ViewUtils(_renderer, _appId, sanitizer) {
	        classCallCheck(this, ViewUtils);

	        this._renderer = _renderer;
	        this._appId = _appId;
	        this._nextCompTypeId = 0;
	        this.sanitizer = sanitizer;
	    }
	    /**
	     * Used by the generated code
	     */


	    createClass(ViewUtils, [{
	        key: 'createRenderComponentType',
	        value: function createRenderComponentType(templateUrl, slotCount, encapsulation, styles) {
	            return new RenderComponentType(this._appId + '-' + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles);
	        }
	        /** @internal */

	    }, {
	        key: 'renderComponent',
	        value: function renderComponent(renderComponentType) {
	            return this._renderer.renderComponent(renderComponentType);
	        }
	    }]);
	    return ViewUtils;
	}();
	/** @nocollapse */
	ViewUtils$2.decorators = [{ type: Injectable }];
	/** @nocollapse */
	ViewUtils$2.ctorParameters = [{ type: RootRenderer }, { type: undefined, decorators: [{ type: Inject, args: [APP_ID] }] }, { type: SanitizationService }];
	function flattenNestedViewRenderNodes$2(nodes) {
	    return _flattenNestedViewRenderNodes$1(nodes, []);
	}
	function _flattenNestedViewRenderNodes$1(nodes, renderNodes) {
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node instanceof AppElement) {
	            var appEl = node;
	            renderNodes.push(appEl.nativeElement);
	            if (isPresent(appEl.nestedViews)) {
	                for (var k = 0; k < appEl.nestedViews.length; k++) {
	                    _flattenNestedViewRenderNodes$1(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
	                }
	            }
	        } else {
	            renderNodes.push(node);
	        }
	    }
	    return renderNodes;
	}
	function checkBinding$2(throwOnChange, oldValue, newValue) {
	    if (throwOnChange) {
	        if (!devModeEqual(oldValue, newValue)) {
	            throw new ExpressionChangedAfterItHasBeenCheckedException(oldValue, newValue, null);
	        }
	        return false;
	    } else {
	        return !looseIdentical(oldValue, newValue);
	    }
	}

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	var ViewType$2;
	(function (ViewType) {
	    // A view that contains the host element with bound component directive.
	    // Contains a COMPONENT view
	    ViewType[ViewType["HOST"] = 0] = "HOST";
	    // The view of the component
	    // Can contain 0 to n EMBEDDED views
	    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
	    // A view that is embedded into another View via a <template> element
	    // inside of a COMPONENT view
	    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
	})(ViewType$2 || (ViewType$2 = {}));

	/**
	 * Structural diffing for `Object`s and `Map`s.
	 */
	var keyValDiff$1 =
	/*@ts2dart_const*/[new DefaultKeyValueDifferFactory()];
	/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */
	var iterableDiff$1 =
	/*@ts2dart_const*/[new DefaultIterableDifferFactory()];
	var defaultIterableDiffers$1 = new IterableDiffers(iterableDiff$1);
	var defaultKeyValueDiffers$1 = new KeyValueDiffers(keyValDiff$1);

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * Defines template and style encapsulation options available for Component's {@link View}.
	 *
	 * See {@link ViewMetadata#encapsulation}.
	 * @stable
	 */
	var ViewEncapsulation$1;
	(function (ViewEncapsulation) {
	  /**
	   * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
	   * Element and pre-processing the style rules provided via
	   * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
	   * attribute to all selectors.
	   *
	   * This is the default option.
	   */
	  ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
	  /**
	   * Use the native encapsulation mechanism of the renderer.
	   *
	   * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
	   * creating a ShadowRoot for Component's Host Element.
	   */
	  ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
	  /**
	   * Don't provide any template or style encapsulation.
	   */
	  ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
	})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));

	/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
	/**
	 * A wrapper around a native element inside of a View.
	 *
	 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
	 * element.
	 *
	 * @security Permitting direct access to the DOM can make your application more vulnerable to
	 * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
	 * [Security Guide](http://g.co/ng/security).
	 *
	 * @stable
	 */
	// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
	// i.e. users have to ask for what they need. With that, we can build better analysis tools
	// and could do better codegen in the future.
	var ElementRef$1 = function ElementRef(nativeElement) {
	  classCallCheck(this, ElementRef);

	  this.nativeElement = nativeElement;
	};

	/**
	 * An injectable service for executing work inside or outside of the Angular zone.
	 *
	 * The most common use of this service is to optimize performance when starting a work consisting of
	 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
	 * can reenter the Angular zone via {@link #run}.
	 *
	 * <!-- TODO: add/fix links to:
	 *   - docs explaining zones and the use of zones in Angular and change-detection
	 *   - link to runOutsideAngular/run (throughout this file!)
	 *   -->
	 *
	 * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
	 * ```
	 * import {Component, View, NgZone} from '@angular/core';
	 * import {NgIf} from '@angular/common';
	 *
	 * @Component({
	 *   selector: 'ng-zone-demo'.
	 *   template: `
	 *     <h2>Demo: NgZone</h2>
	 *
	 *     <p>Progress: {{progress}}%</p>
	 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	 *
	 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	 *   `,
	 *   directives: [NgIf]
	 * })
	 * export class NgZoneDemo {
	 *   progress: number = 0;
	 *   label: string;
	 *
	 *   constructor(private _ngZone: NgZone) {}
	 *
	 *   // Loop inside the Angular zone
	 *   // so the UI DOES refresh after each setTimeout cycle
	 *   processWithinAngularZone() {
	 *     this.label = 'inside';
	 *     this.progress = 0;
	 *     this._increaseProgress(() => console.log('Inside Done!'));
	 *   }
	 *
	 *   // Loop outside of the Angular zone
	 *   // so the UI DOES NOT refresh after each setTimeout cycle
	 *   processOutsideOfAngularZone() {
	 *     this.label = 'outside';
	 *     this.progress = 0;
	 *     this._ngZone.runOutsideAngular(() => {
	 *       this._increaseProgress(() => {
	 *       // reenter the Angular zone and display done
	 *       this._ngZone.run(() => {console.log('Outside Done!') });
	 *     }}));
	 *   }
	 *
	 *
	 *   _increaseProgress(doneCallback: () => void) {
	 *     this.progress += 1;
	 *     console.log(`Current progress: ${this.progress}%`);
	 *
	 *     if (this.progress < 100) {
	 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	 *     } else {
	 *       doneCallback();
	 *     }
	 *   }
	 * }
	 * ```
	 * @experimental
	 */
	var NgZone$1 = function () {
	    function NgZone(_ref) {
	        var _this = this;

	        var _ref$enableLongStackT = _ref.enableLongStackTrace;
	        var enableLongStackTrace = _ref$enableLongStackT === undefined ? false : _ref$enableLongStackT;
	        classCallCheck(this, NgZone);

	        this._hasPendingMicrotasks = false;
	        this._hasPendingMacrotasks = false;
	        /** @internal */
	        this._isStable = true;
	        /** @internal */
	        this._nesting = 0;
	        /** @internal */
	        this._onUnstable = new EventEmitter(false);
	        /** @internal */
	        this._onMicrotaskEmpty = new EventEmitter(false);
	        /** @internal */
	        this._onStable = new EventEmitter(false);
	        /** @internal */
	        this._onErrorEvents = new EventEmitter(false);
	        this._zoneImpl = new NgZoneImpl({
	            trace: enableLongStackTrace,
	            onEnter: function onEnter() {
	                // console.log('ZONE.enter', this._nesting, this._isStable);
	                _this._nesting++;
	                if (_this._isStable) {
	                    _this._isStable = false;
	                    _this._onUnstable.emit(null);
	                }
	            },
	            onLeave: function onLeave() {
	                _this._nesting--;
	                // console.log('ZONE.leave', this._nesting, this._isStable);
	                _this._checkStable();
	            },
	            setMicrotask: function setMicrotask(hasMicrotasks) {
	                _this._hasPendingMicrotasks = hasMicrotasks;
	                _this._checkStable();
	            },
	            setMacrotask: function setMacrotask(hasMacrotasks) {
	                _this._hasPendingMacrotasks = hasMacrotasks;
	            },
	            onError: function onError(error) {
	                return _this._onErrorEvents.emit(error);
	            }
	        });
	    }

	    createClass(NgZone, [{
	        key: '_checkStable',
	        value: function _checkStable() {
	            var _this2 = this;

	            if (this._nesting == 0) {
	                if (!this._hasPendingMicrotasks && !this._isStable) {
	                    try {
	                        // console.log('ZONE.microtaskEmpty');
	                        this._nesting++;
	                        this._onMicrotaskEmpty.emit(null);
	                    } finally {
	                        this._nesting--;
	                        if (!this._hasPendingMicrotasks) {
	                            try {
	                                // console.log('ZONE.stable', this._nesting, this._isStable);
	                                this.runOutsideAngular(function () {
	                                    return _this2._onStable.emit(null);
	                                });
	                            } finally {
	                                this._isStable = true;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'run',

	        /**
	         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * within the Angular zone.
	         *
	         * If a synchronous error happens it will be rethrown and not reported via `onError`.
	         */
	        value: function run(fn) {
	            return this._zoneImpl.runInner(fn);
	        }
	        /**
	         * Same as #run, except that synchronous errors are caught and forwarded
	         * via `onError` and not rethrown.
	         */

	    }, {
	        key: 'runGuarded',
	        value: function runGuarded(fn) {
	            return this._zoneImpl.runInnerGuarded(fn);
	        }
	        /**
	         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * outside of the Angular zone.
	         *
	         * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
	         */

	    }, {
	        key: 'runOutsideAngular',
	        value: function runOutsideAngular(fn) {
	            return this._zoneImpl.runOuter(fn);
	        }
	    }, {
	        key: 'onUnstable',

	        /**
	         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	         */
	        get: function get() {
	            return this._onUnstable;
	        }
	        /**
	         * Notifies when there is no more microtasks enqueue in the current VM Turn.
	         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	         * For this reason this event can fire multiple times per VM Turn.
	         */

	    }, {
	        key: 'onMicrotaskEmpty',
	        get: function get() {
	            return this._onMicrotaskEmpty;
	        }
	        /**
	         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	         * implies we are about to relinquish VM turn.
	         * This event gets called just once.
	         */

	    }, {
	        key: 'onStable',
	        get: function get() {
	            return this._onStable;
	        }
	        /**
	         * Notify that an error has been delivered.
	         */

	    }, {
	        key: 'onError',
	        get: function get() {
	            return this._onErrorEvents;
	        }
	        /**
	         * Whether there are no outstanding microtasks or microtasks.
	         */

	    }, {
	        key: 'isStable',
	        get: function get() {
	            return this._isStable;
	        }
	        /**
	         * Whether there are any outstanding microtasks.
	         */

	    }, {
	        key: 'hasPendingMicrotasks',
	        get: function get() {
	            return this._hasPendingMicrotasks;
	        }
	        /**
	         * Whether there are any outstanding microtasks.
	         */

	    }, {
	        key: 'hasPendingMacrotasks',
	        get: function get() {
	            return this._hasPendingMacrotasks;
	        }
	    }], [{
	        key: 'isInAngularZone',
	        value: function isInAngularZone() {
	            return NgZoneImpl.isInAngularZone();
	        }
	    }, {
	        key: 'assertInAngularZone',
	        value: function assertInAngularZone() {
	            if (!NgZoneImpl.isInAngularZone()) {
	                throw new BaseException('Expected to be in Angular Zone, but it is not!');
	            }
	        }
	    }, {
	        key: 'assertNotInAngularZone',
	        value: function assertNotInAngularZone() {
	            if (NgZoneImpl.isInAngularZone()) {
	                throw new BaseException('Expected to not be in Angular Zone, but it is!');
	            }
	        }
	    }]);
	    return NgZone;
	}();

	/**
	 * Represents an instance of a Component created via a {@link ComponentFactory}.
	 *
	 * `ComponentRef` provides access to the Component Instance as well other objects related to this
	 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
	 * method.
	 * @stable
	 */
	var ComponentRef$1 = function () {
	  function ComponentRef() {
	    classCallCheck(this, ComponentRef);
	  }

	  createClass(ComponentRef, [{
	    key: 'location',

	    /**
	     * Location of the Host Element of this Component Instance.
	     */
	    get: function get() {
	      return unimplemented();
	    }
	    /**
	     * The injector on which the component instance exists.
	     */

	  }, {
	    key: 'injector',
	    get: function get() {
	      return unimplemented();
	    }
	    /**
	     * The instance of the Component.
	     */

	  }, {
	    key: 'instance',
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'hostView',

	    /**
	     * The {@link ViewRef} of the Host View of this Component instance.
	     */
	    get: function get() {
	      return unimplemented();
	    }
	  }, {
	    key: 'changeDetectorRef',

	    /**
	     * The {@link ChangeDetectorRef} of the Component instance.
	     */
	    get: function get() {
	      return unimplemented();
	    }
	    /**
	     * The component type.
	     */

	  }, {
	    key: 'componentType',
	    get: function get() {
	      return unimplemented();
	    }
	  }]);
	  return ComponentRef;
	}();
	var ComponentRef_$1 = function (_ComponentRef) {
	  inherits(ComponentRef_, _ComponentRef);

	  function ComponentRef_(_hostElement, _componentType) {
	    classCallCheck(this, ComponentRef_);

	    var _this = possibleConstructorReturn(this, Object.getPrototypeOf(ComponentRef_).call(this));

	    _this._hostElement = _hostElement;
	    _this._componentType = _componentType;
	    return _this;
	  }

	  createClass(ComponentRef_, [{
	    key: 'destroy',
	    value: function destroy() {
	      this._hostElement.parentView.destroy();
	    }
	  }, {
	    key: 'onDestroy',
	    value: function onDestroy(callback) {
	      this.hostView.onDestroy(callback);
	    }
	  }, {
	    key: 'location',
	    get: function get() {
	      return this._hostElement.elementRef;
	    }
	  }, {
	    key: 'injector',
	    get: function get() {
	      return this._hostElement.injector;
	    }
	  }, {
	    key: 'instance',
	    get: function get() {
	      return this._hostElement.component;
	    }
	  }, {
	    key: 'hostView',
	    get: function get() {
	      return this._hostElement.parentView.ref;
	    }
	  }, {
	    key: 'changeDetectorRef',
	    get: function get() {
	      return this._hostElement.parentView.ref;
	    }
	  }, {
	    key: 'componentType',
	    get: function get() {
	      return this._componentType;
	    }
	  }]);
	  return ComponentRef_;
	}(ComponentRef$1);
	/**
	 * @experimental
	 * @ts2dart_const
	 */
	var EMPTY_CONTEXT$2 = new Object();
	/**
	 * @stable
	 */
	var ComponentFactory$1 = function () {
	  function ComponentFactory(selector, _viewFactory, _componentType) {
	    classCallCheck(this, ComponentFactory);

	    this.selector = selector;
	    this._viewFactory = _viewFactory;
	    this._componentType = _componentType;
	  }

	  createClass(ComponentFactory, [{
	    key: 'create',

	    /**
	     * Creates a new component.
	     */
	    value: function create(injector) {
	      var projectableNodes = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	      var rootSelectorOrNode = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

	      var vu = injector.get(ViewUtils);
	      if (isBlank(projectableNodes)) {
	        projectableNodes = [];
	      }
	      // Note: Host views don't need a declarationAppElement!
	      var hostView = this._viewFactory(vu, injector, null);
	      var hostElement = hostView.create(EMPTY_CONTEXT$2, projectableNodes, rootSelectorOrNode);
	      return new ComponentRef_$1(hostElement, this._componentType);
	    }
	  }, {
	    key: 'componentType',
	    get: function get() {
	      return this._componentType;
	    }
	  }]);
	  return ComponentFactory;
	}();

	var styles_Content = [];
	var renderType_Content = null;
	var _View_Content0 = (function (_super) {
	    __extends$46(_View_Content0, _super);
	    function _View_Content0(viewUtils, parentInjector, declarationEl) {
	        _super.call(this, _View_Content0, renderType_Content, ViewType$2.COMPONENT, viewUtils, parentInjector, declarationEl, ChangeDetectorStatus.CheckAlways);
	    }
	    _View_Content0.prototype.createInternal = function (rootSelector) {
	        var parentRenderNode = this.renderer.createViewRoot(this.declarationAppElement.nativeElement);
	        this._el_0 = this.renderer.createElement(parentRenderNode, 'scroll-content', null);
	        this.renderer.projectNodes(this._el_0, flattenNestedViewRenderNodes$2(this.projectableNodes[0]));
	        this.renderer.projectNodes(parentRenderNode, flattenNestedViewRenderNodes$2(this.projectableNodes[1]));
	        this.renderer.projectNodes(parentRenderNode, flattenNestedViewRenderNodes$2(this.projectableNodes[2]));
	        this.init([], [this._el_0], [], []);
	        return null;
	    };
	    return _View_Content0;
	}(AppView$2));
	function viewFactory_Content0(viewUtils, parentInjector, declarationEl) {
	    if ((renderType_Content === null)) {
	        (renderType_Content = viewUtils.createRenderComponentType('/Users/joshthomas/Workspace/tree-shake-ionic2/node_modules/ionic-angular/components/content/content.d.ts class Content - inline template', 3, ViewEncapsulation$1.None, styles_Content));
	    }
	    return new _View_Content0(viewUtils, parentInjector, declarationEl);
	}
	var renderType_Content_Host = null;
	var _View_Content_Host0 = (function (_super) {
	    __extends$46(_View_Content_Host0, _super);
	    function _View_Content_Host0(viewUtils, parentInjector, declarationEl) {
	        _super.call(this, _View_Content_Host0, renderType_Content_Host, ViewType$2.HOST, viewUtils, parentInjector, declarationEl, ChangeDetectorStatus.CheckAlways);
	    }
	    _View_Content_Host0.prototype.createInternal = function (rootSelector) {
	        this._el_0 = this.selectOrCreateHostElement('ion-content', rootSelector, null);
	        this._appEl_0 = new AppElement$2(0, null, this, this._el_0);
	        var compView_0 = viewFactory_Content0(this.viewUtils, this.injector(0), this._appEl_0);
	        this._Content_0_4 = new Content(new ElementRef$1(this._el_0), this.parentInjector.get(Config), this.parentInjector.get(App), this.parentInjector.get(Keyboard), this.parentInjector.get(NgZone$1), this.parentInjector.get(ViewController, null), this.parentInjector.get(Tabs, null));
	        this._appEl_0.initComponent(this._Content_0_4, [], compView_0);
	        compView_0.create(this._Content_0_4, this.projectableNodes, null);
	        this._expr_0 = uninitialized;
	        this.init([].concat([this._el_0]), [this._el_0], [], []);
	        return this._appEl_0;
	    };
	    _View_Content_Host0.prototype.injectorGetInternal = function (token, requestNodeIndex, notFoundResult) {
	        if (((token === Content) && (0 === requestNodeIndex))) {
	            return this._Content_0_4;
	        }
	        return notFoundResult;
	    };
	    _View_Content_Host0.prototype.detectChangesInternal = function (throwOnChange) {
	        if (((this.numberOfChecks === 0) && !throwOnChange)) {
	            this._Content_0_4.ngOnInit();
	        }
	        this.detectContentChildrenChanges(throwOnChange);
	        var currVal_0 = this._Content_0_4._sbPadding;
	        if (checkBinding$2(throwOnChange, this._expr_0, currVal_0)) {
	            this.renderer.setElementClass(this._el_0, 'statusbar-padding', currVal_0);
	            this._expr_0 = currVal_0;
	        }
	        this.detectViewChildrenChanges(throwOnChange);
	    };
	    _View_Content_Host0.prototype.destroyInternal = function () {
	        this._Content_0_4.ngOnDestroy();
	    };
	    return _View_Content_Host0;
	}(AppView$2));
	function viewFactory_Content_Host0(viewUtils, parentInjector, declarationEl) {
	    if ((renderType_Content_Host === null)) {
	        (renderType_Content_Host = viewUtils.createRenderComponentType('', 0, null, []));
	    }
	    return new _View_Content_Host0(viewUtils, parentInjector, declarationEl);
	}
	var ContentNgFactory = new ComponentFactory$1('ion-content', viewFactory_Content_Host0, Content);

	var styles_App = [];
	var renderType_App = null;
	var _View_App0 = function (_super) {
	    __extends$46(_View_App0, _super);
	    function _View_App0(viewUtils, parentInjector, declarationEl) {
	        _super.call(this, _View_App0, renderType_App, ViewType$2.COMPONENT, viewUtils, parentInjector, declarationEl, ChangeDetectorStatus.CheckAlways);
	    }
	    _View_App0.prototype.createInternal = function (rootSelector) {
	        var parentRenderNode = this.renderer.createViewRoot(this.declarationAppElement.nativeElement);
	        this._text_0 = this.renderer.createText(parentRenderNode, '\n    ', null);
	        this._el_1 = this.renderer.createElement(parentRenderNode, 'ion-content', null);
	        this._appEl_1 = new AppElement$2(1, null, this, this._el_1);
	        var compView_1 = viewFactory_Content0(this.viewUtils, this.injector(1), this._appEl_1);
	        this._Content_1_4 = new Content(new ElementRef$1(this._el_1), this.parentInjector.get(Config), this.parentInjector.get(App), this.parentInjector.get(Keyboard), this.parentInjector.get(NgZone$1), this.parentInjector.get(ViewController, null), this.parentInjector.get(Tabs, null));
	        this._appEl_1.initComponent(this._Content_1_4, [], compView_1);
	        this._text_2 = this.renderer.createText(null, '\n    What up\n    ', null);
	        compView_1.create(this._Content_1_4, [[].concat([this._text_2]), [], []], null);
	        this._text_3 = this.renderer.createText(parentRenderNode, '\n  ', null);
	        this._expr_0 = uninitialized;
	        this.init([], [this._text_0, this._el_1, this._text_2, this._text_3], [], []);
	        return null;
	    };
	    _View_App0.prototype.injectorGetInternal = function (token, requestNodeIndex, notFoundResult) {
	        if (token === Content && 1 <= requestNodeIndex && requestNodeIndex <= 2) {
	            return this._Content_1_4;
	        }
	        return notFoundResult;
	    };
	    _View_App0.prototype.detectChangesInternal = function (throwOnChange) {
	        if (this.numberOfChecks === 0 && !throwOnChange) {
	            this._Content_1_4.ngOnInit();
	        }
	        this.detectContentChildrenChanges(throwOnChange);
	        var currVal_0 = this._Content_1_4._sbPadding;
	        if (checkBinding$2(throwOnChange, this._expr_0, currVal_0)) {
	            this.renderer.setElementClass(this._el_1, 'statusbar-padding', currVal_0);
	            this._expr_0 = currVal_0;
	        }
	        this.detectViewChildrenChanges(throwOnChange);
	    };
	    _View_App0.prototype.destroyInternal = function () {
	        this._Content_1_4.ngOnDestroy();
	    };
	    return _View_App0;
	}(AppView$2);
	function viewFactory_App0(viewUtils, parentInjector, declarationEl) {
	    if (renderType_App === null) {
	        renderType_App = viewUtils.createRenderComponentType('/Users/joshthomas/Workspace/tree-shake-ionic2/src/app/app.ts class App - inline template', 0, ViewEncapsulation$1.None, styles_App);
	    }
	    return new _View_App0(viewUtils, parentInjector, declarationEl);
	}
	var renderType_App_Host = null;
	var _View_App_Host0 = function (_super) {
	    __extends$46(_View_App_Host0, _super);
	    function _View_App_Host0(viewUtils, parentInjector, declarationEl) {
	        _super.call(this, _View_App_Host0, renderType_App_Host, ViewType$2.HOST, viewUtils, parentInjector, declarationEl, ChangeDetectorStatus.CheckAlways);
	    }
	    _View_App_Host0.prototype.createInternal = function (rootSelector) {
	        this._el_0 = this.selectOrCreateHostElement('ion-app', rootSelector, null);
	        this._appEl_0 = new AppElement$2(0, null, this, this._el_0);
	        var compView_0 = viewFactory_App0(this.viewUtils, this.injector(0), this._appEl_0);
	        this._Platform_0_4 = new Platform();
	        this._App_0_5 = new App$1(this._Platform_0_4);
	        this._appEl_0.initComponent(this._App_0_5, [], compView_0);
	        compView_0.create(this._App_0_5, this.projectableNodes, null);
	        this.init([].concat([this._el_0]), [this._el_0], [], []);
	        return this._appEl_0;
	    };
	    _View_App_Host0.prototype.injectorGetInternal = function (token, requestNodeIndex, notFoundResult) {
	        if (token === Platform && 0 === requestNodeIndex) {
	            return this._Platform_0_4;
	        }
	        if (token === App$1 && 0 === requestNodeIndex) {
	            return this._App_0_5;
	        }
	        return notFoundResult;
	    };
	    return _View_App_Host0;
	}(AppView$2);
	function viewFactory_App_Host0(viewUtils, parentInjector, declarationEl) {
	    if (renderType_App_Host === null) {
	        renderType_App_Host = viewUtils.createRenderComponentType('', 0, null, []);
	    }
	    return new _View_App_Host0(viewUtils, parentInjector, declarationEl);
	}
	var AppNgFactory = new ComponentFactory$1('ion-app', viewFactory_App_Host0, App$1);

	var providers = ionicProviders();
	var appInjector = ReflectiveInjector.resolveAndCreate([BROWSER_APP_PROVIDERS, []], browserPlatform().injector);
	var ngComponentRef = coreBootstrap(AppNgFactory, appInjector);

}());
//# sourceMappingURL=bundle.es5.js.map